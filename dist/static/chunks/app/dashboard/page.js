/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["app/dashboard/page"],{

/***/ "(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22C%3A%5C%5CUsers%5C%5CUSUARIO%5C%5CDesktop%5C%5Ctransactions-app-manager%5C%5Csrc%5C%5Capp%5C%5Cdashboard%5C%5Cpage.tsx%22%2C%22ids%22%3A%5B%5D%7D&server=false!":
/*!***************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22C%3A%5C%5CUsers%5C%5CUSUARIO%5C%5CDesktop%5C%5Ctransactions-app-manager%5C%5Csrc%5C%5Capp%5C%5Cdashboard%5C%5Cpage.tsx%22%2C%22ids%22%3A%5B%5D%7D&server=false! ***!
  \***************************************************************************************************************************************************************************************************************************************************************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("Promise.resolve(/*! import() eager */).then(__webpack_require__.bind(__webpack_require__, /*! ./src/app/dashboard/page.tsx */ \"(app-pages-browser)/./src/app/dashboard/page.tsx\"));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL25leHQtZmxpZ2h0LWNsaWVudC1lbnRyeS1sb2FkZXIuanM/bW9kdWxlcz0lN0IlMjJyZXF1ZXN0JTIyJTNBJTIyQyUzQSU1QyU1Q1VzZXJzJTVDJTVDVVNVQVJJTyU1QyU1Q0Rlc2t0b3AlNUMlNUN0cmFuc2FjdGlvbnMtYXBwLW1hbmFnZXIlNUMlNUNzcmMlNUMlNUNhcHAlNUMlNUNkYXNoYm9hcmQlNUMlNUNwYWdlLnRzeCUyMiUyQyUyMmlkcyUyMiUzQSU1QiU1RCU3RCZzZXJ2ZXI9ZmFsc2UhIiwibWFwcGluZ3MiOiJBQUFBLGtMQUF5SCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvPzBiYzMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0KC8qIHdlYnBhY2tNb2RlOiBcImVhZ2VyXCIgKi8gXCJDOlxcXFxVc2Vyc1xcXFxVU1VBUklPXFxcXERlc2t0b3BcXFxcdHJhbnNhY3Rpb25zLWFwcC1tYW5hZ2VyXFxcXHNyY1xcXFxhcHBcXFxcZGFzaGJvYXJkXFxcXHBhZ2UudHN4XCIpO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22C%3A%5C%5CUsers%5C%5CUSUARIO%5C%5CDesktop%5C%5Ctransactions-app-manager%5C%5Csrc%5C%5Capp%5C%5Cdashboard%5C%5Cpage.tsx%22%2C%22ids%22%3A%5B%5D%7D&server=false!\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/buffer/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/next/dist/compiled/buffer/index.js ***!
  \*********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("var __dirname = \"/\";\n(function(){var e={675:function(e,r){\"use strict\";r.byteLength=byteLength;r.toByteArray=toByteArray;r.fromByteArray=fromByteArray;var t=[];var f=[];var n=typeof Uint8Array!==\"undefined\"?Uint8Array:Array;var i=\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";for(var o=0,u=i.length;o<u;++o){t[o]=i[o];f[i.charCodeAt(o)]=o}f[\"-\".charCodeAt(0)]=62;f[\"_\".charCodeAt(0)]=63;function getLens(e){var r=e.length;if(r%4>0){throw new Error(\"Invalid string. Length must be a multiple of 4\")}var t=e.indexOf(\"=\");if(t===-1)t=r;var f=t===r?0:4-t%4;return[t,f]}function byteLength(e){var r=getLens(e);var t=r[0];var f=r[1];return(t+f)*3/4-f}function _byteLength(e,r,t){return(r+t)*3/4-t}function toByteArray(e){var r;var t=getLens(e);var i=t[0];var o=t[1];var u=new n(_byteLength(e,i,o));var a=0;var s=o>0?i-4:i;var h;for(h=0;h<s;h+=4){r=f[e.charCodeAt(h)]<<18|f[e.charCodeAt(h+1)]<<12|f[e.charCodeAt(h+2)]<<6|f[e.charCodeAt(h+3)];u[a++]=r>>16&255;u[a++]=r>>8&255;u[a++]=r&255}if(o===2){r=f[e.charCodeAt(h)]<<2|f[e.charCodeAt(h+1)]>>4;u[a++]=r&255}if(o===1){r=f[e.charCodeAt(h)]<<10|f[e.charCodeAt(h+1)]<<4|f[e.charCodeAt(h+2)]>>2;u[a++]=r>>8&255;u[a++]=r&255}return u}function tripletToBase64(e){return t[e>>18&63]+t[e>>12&63]+t[e>>6&63]+t[e&63]}function encodeChunk(e,r,t){var f;var n=[];for(var i=r;i<t;i+=3){f=(e[i]<<16&16711680)+(e[i+1]<<8&65280)+(e[i+2]&255);n.push(tripletToBase64(f))}return n.join(\"\")}function fromByteArray(e){var r;var f=e.length;var n=f%3;var i=[];var o=16383;for(var u=0,a=f-n;u<a;u+=o){i.push(encodeChunk(e,u,u+o>a?a:u+o))}if(n===1){r=e[f-1];i.push(t[r>>2]+t[r<<4&63]+\"==\")}else if(n===2){r=(e[f-2]<<8)+e[f-1];i.push(t[r>>10]+t[r>>4&63]+t[r<<2&63]+\"=\")}return i.join(\"\")}},72:function(e,r,t){\"use strict\";\n/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <https://feross.org>\n * @license  MIT\n */var f=t(675);var n=t(783);var i=typeof Symbol===\"function\"&&typeof Symbol.for===\"function\"?Symbol.for(\"nodejs.util.inspect.custom\"):null;r.Buffer=Buffer;r.SlowBuffer=SlowBuffer;r.INSPECT_MAX_BYTES=50;var o=2147483647;r.kMaxLength=o;Buffer.TYPED_ARRAY_SUPPORT=typedArraySupport();if(!Buffer.TYPED_ARRAY_SUPPORT&&typeof console!==\"undefined\"&&typeof console.error===\"function\"){console.error(\"This browser lacks typed array (Uint8Array) support which is required by \"+\"`buffer` v5.x. Use `buffer` v4.x if you require old browser support.\")}function typedArraySupport(){try{var e=new Uint8Array(1);var r={foo:function(){return 42}};Object.setPrototypeOf(r,Uint8Array.prototype);Object.setPrototypeOf(e,r);return e.foo()===42}catch(e){return false}}Object.defineProperty(Buffer.prototype,\"parent\",{enumerable:true,get:function(){if(!Buffer.isBuffer(this))return undefined;return this.buffer}});Object.defineProperty(Buffer.prototype,\"offset\",{enumerable:true,get:function(){if(!Buffer.isBuffer(this))return undefined;return this.byteOffset}});function createBuffer(e){if(e>o){throw new RangeError('The value \"'+e+'\" is invalid for option \"size\"')}var r=new Uint8Array(e);Object.setPrototypeOf(r,Buffer.prototype);return r}function Buffer(e,r,t){if(typeof e===\"number\"){if(typeof r===\"string\"){throw new TypeError('The \"string\" argument must be of type string. Received type number')}return allocUnsafe(e)}return from(e,r,t)}Buffer.poolSize=8192;function from(e,r,t){if(typeof e===\"string\"){return fromString(e,r)}if(ArrayBuffer.isView(e)){return fromArrayLike(e)}if(e==null){throw new TypeError(\"The first argument must be one of type string, Buffer, ArrayBuffer, Array, \"+\"or Array-like Object. Received type \"+typeof e)}if(isInstance(e,ArrayBuffer)||e&&isInstance(e.buffer,ArrayBuffer)){return fromArrayBuffer(e,r,t)}if(typeof SharedArrayBuffer!==\"undefined\"&&(isInstance(e,SharedArrayBuffer)||e&&isInstance(e.buffer,SharedArrayBuffer))){return fromArrayBuffer(e,r,t)}if(typeof e===\"number\"){throw new TypeError('The \"value\" argument must not be of type number. Received type number')}var f=e.valueOf&&e.valueOf();if(f!=null&&f!==e){return Buffer.from(f,r,t)}var n=fromObject(e);if(n)return n;if(typeof Symbol!==\"undefined\"&&Symbol.toPrimitive!=null&&typeof e[Symbol.toPrimitive]===\"function\"){return Buffer.from(e[Symbol.toPrimitive](\"string\"),r,t)}throw new TypeError(\"The first argument must be one of type string, Buffer, ArrayBuffer, Array, \"+\"or Array-like Object. Received type \"+typeof e)}Buffer.from=function(e,r,t){return from(e,r,t)};Object.setPrototypeOf(Buffer.prototype,Uint8Array.prototype);Object.setPrototypeOf(Buffer,Uint8Array);function assertSize(e){if(typeof e!==\"number\"){throw new TypeError('\"size\" argument must be of type number')}else if(e<0){throw new RangeError('The value \"'+e+'\" is invalid for option \"size\"')}}function alloc(e,r,t){assertSize(e);if(e<=0){return createBuffer(e)}if(r!==undefined){return typeof t===\"string\"?createBuffer(e).fill(r,t):createBuffer(e).fill(r)}return createBuffer(e)}Buffer.alloc=function(e,r,t){return alloc(e,r,t)};function allocUnsafe(e){assertSize(e);return createBuffer(e<0?0:checked(e)|0)}Buffer.allocUnsafe=function(e){return allocUnsafe(e)};Buffer.allocUnsafeSlow=function(e){return allocUnsafe(e)};function fromString(e,r){if(typeof r!==\"string\"||r===\"\"){r=\"utf8\"}if(!Buffer.isEncoding(r)){throw new TypeError(\"Unknown encoding: \"+r)}var t=byteLength(e,r)|0;var f=createBuffer(t);var n=f.write(e,r);if(n!==t){f=f.slice(0,n)}return f}function fromArrayLike(e){var r=e.length<0?0:checked(e.length)|0;var t=createBuffer(r);for(var f=0;f<r;f+=1){t[f]=e[f]&255}return t}function fromArrayBuffer(e,r,t){if(r<0||e.byteLength<r){throw new RangeError('\"offset\" is outside of buffer bounds')}if(e.byteLength<r+(t||0)){throw new RangeError('\"length\" is outside of buffer bounds')}var f;if(r===undefined&&t===undefined){f=new Uint8Array(e)}else if(t===undefined){f=new Uint8Array(e,r)}else{f=new Uint8Array(e,r,t)}Object.setPrototypeOf(f,Buffer.prototype);return f}function fromObject(e){if(Buffer.isBuffer(e)){var r=checked(e.length)|0;var t=createBuffer(r);if(t.length===0){return t}e.copy(t,0,0,r);return t}if(e.length!==undefined){if(typeof e.length!==\"number\"||numberIsNaN(e.length)){return createBuffer(0)}return fromArrayLike(e)}if(e.type===\"Buffer\"&&Array.isArray(e.data)){return fromArrayLike(e.data)}}function checked(e){if(e>=o){throw new RangeError(\"Attempt to allocate Buffer larger than maximum \"+\"size: 0x\"+o.toString(16)+\" bytes\")}return e|0}function SlowBuffer(e){if(+e!=e){e=0}return Buffer.alloc(+e)}Buffer.isBuffer=function isBuffer(e){return e!=null&&e._isBuffer===true&&e!==Buffer.prototype};Buffer.compare=function compare(e,r){if(isInstance(e,Uint8Array))e=Buffer.from(e,e.offset,e.byteLength);if(isInstance(r,Uint8Array))r=Buffer.from(r,r.offset,r.byteLength);if(!Buffer.isBuffer(e)||!Buffer.isBuffer(r)){throw new TypeError('The \"buf1\", \"buf2\" arguments must be one of type Buffer or Uint8Array')}if(e===r)return 0;var t=e.length;var f=r.length;for(var n=0,i=Math.min(t,f);n<i;++n){if(e[n]!==r[n]){t=e[n];f=r[n];break}}if(t<f)return-1;if(f<t)return 1;return 0};Buffer.isEncoding=function isEncoding(e){switch(String(e).toLowerCase()){case\"hex\":case\"utf8\":case\"utf-8\":case\"ascii\":case\"latin1\":case\"binary\":case\"base64\":case\"ucs2\":case\"ucs-2\":case\"utf16le\":case\"utf-16le\":return true;default:return false}};Buffer.concat=function concat(e,r){if(!Array.isArray(e)){throw new TypeError('\"list\" argument must be an Array of Buffers')}if(e.length===0){return Buffer.alloc(0)}var t;if(r===undefined){r=0;for(t=0;t<e.length;++t){r+=e[t].length}}var f=Buffer.allocUnsafe(r);var n=0;for(t=0;t<e.length;++t){var i=e[t];if(isInstance(i,Uint8Array)){i=Buffer.from(i)}if(!Buffer.isBuffer(i)){throw new TypeError('\"list\" argument must be an Array of Buffers')}i.copy(f,n);n+=i.length}return f};function byteLength(e,r){if(Buffer.isBuffer(e)){return e.length}if(ArrayBuffer.isView(e)||isInstance(e,ArrayBuffer)){return e.byteLength}if(typeof e!==\"string\"){throw new TypeError('The \"string\" argument must be one of type string, Buffer, or ArrayBuffer. '+\"Received type \"+typeof e)}var t=e.length;var f=arguments.length>2&&arguments[2]===true;if(!f&&t===0)return 0;var n=false;for(;;){switch(r){case\"ascii\":case\"latin1\":case\"binary\":return t;case\"utf8\":case\"utf-8\":return utf8ToBytes(e).length;case\"ucs2\":case\"ucs-2\":case\"utf16le\":case\"utf-16le\":return t*2;case\"hex\":return t>>>1;case\"base64\":return base64ToBytes(e).length;default:if(n){return f?-1:utf8ToBytes(e).length}r=(\"\"+r).toLowerCase();n=true}}}Buffer.byteLength=byteLength;function slowToString(e,r,t){var f=false;if(r===undefined||r<0){r=0}if(r>this.length){return\"\"}if(t===undefined||t>this.length){t=this.length}if(t<=0){return\"\"}t>>>=0;r>>>=0;if(t<=r){return\"\"}if(!e)e=\"utf8\";while(true){switch(e){case\"hex\":return hexSlice(this,r,t);case\"utf8\":case\"utf-8\":return utf8Slice(this,r,t);case\"ascii\":return asciiSlice(this,r,t);case\"latin1\":case\"binary\":return latin1Slice(this,r,t);case\"base64\":return base64Slice(this,r,t);case\"ucs2\":case\"ucs-2\":case\"utf16le\":case\"utf-16le\":return utf16leSlice(this,r,t);default:if(f)throw new TypeError(\"Unknown encoding: \"+e);e=(e+\"\").toLowerCase();f=true}}}Buffer.prototype._isBuffer=true;function swap(e,r,t){var f=e[r];e[r]=e[t];e[t]=f}Buffer.prototype.swap16=function swap16(){var e=this.length;if(e%2!==0){throw new RangeError(\"Buffer size must be a multiple of 16-bits\")}for(var r=0;r<e;r+=2){swap(this,r,r+1)}return this};Buffer.prototype.swap32=function swap32(){var e=this.length;if(e%4!==0){throw new RangeError(\"Buffer size must be a multiple of 32-bits\")}for(var r=0;r<e;r+=4){swap(this,r,r+3);swap(this,r+1,r+2)}return this};Buffer.prototype.swap64=function swap64(){var e=this.length;if(e%8!==0){throw new RangeError(\"Buffer size must be a multiple of 64-bits\")}for(var r=0;r<e;r+=8){swap(this,r,r+7);swap(this,r+1,r+6);swap(this,r+2,r+5);swap(this,r+3,r+4)}return this};Buffer.prototype.toString=function toString(){var e=this.length;if(e===0)return\"\";if(arguments.length===0)return utf8Slice(this,0,e);return slowToString.apply(this,arguments)};Buffer.prototype.toLocaleString=Buffer.prototype.toString;Buffer.prototype.equals=function equals(e){if(!Buffer.isBuffer(e))throw new TypeError(\"Argument must be a Buffer\");if(this===e)return true;return Buffer.compare(this,e)===0};Buffer.prototype.inspect=function inspect(){var e=\"\";var t=r.INSPECT_MAX_BYTES;e=this.toString(\"hex\",0,t).replace(/(.{2})/g,\"$1 \").trim();if(this.length>t)e+=\" ... \";return\"<Buffer \"+e+\">\"};if(i){Buffer.prototype[i]=Buffer.prototype.inspect}Buffer.prototype.compare=function compare(e,r,t,f,n){if(isInstance(e,Uint8Array)){e=Buffer.from(e,e.offset,e.byteLength)}if(!Buffer.isBuffer(e)){throw new TypeError('The \"target\" argument must be one of type Buffer or Uint8Array. '+\"Received type \"+typeof e)}if(r===undefined){r=0}if(t===undefined){t=e?e.length:0}if(f===undefined){f=0}if(n===undefined){n=this.length}if(r<0||t>e.length||f<0||n>this.length){throw new RangeError(\"out of range index\")}if(f>=n&&r>=t){return 0}if(f>=n){return-1}if(r>=t){return 1}r>>>=0;t>>>=0;f>>>=0;n>>>=0;if(this===e)return 0;var i=n-f;var o=t-r;var u=Math.min(i,o);var a=this.slice(f,n);var s=e.slice(r,t);for(var h=0;h<u;++h){if(a[h]!==s[h]){i=a[h];o=s[h];break}}if(i<o)return-1;if(o<i)return 1;return 0};function bidirectionalIndexOf(e,r,t,f,n){if(e.length===0)return-1;if(typeof t===\"string\"){f=t;t=0}else if(t>2147483647){t=2147483647}else if(t<-2147483648){t=-2147483648}t=+t;if(numberIsNaN(t)){t=n?0:e.length-1}if(t<0)t=e.length+t;if(t>=e.length){if(n)return-1;else t=e.length-1}else if(t<0){if(n)t=0;else return-1}if(typeof r===\"string\"){r=Buffer.from(r,f)}if(Buffer.isBuffer(r)){if(r.length===0){return-1}return arrayIndexOf(e,r,t,f,n)}else if(typeof r===\"number\"){r=r&255;if(typeof Uint8Array.prototype.indexOf===\"function\"){if(n){return Uint8Array.prototype.indexOf.call(e,r,t)}else{return Uint8Array.prototype.lastIndexOf.call(e,r,t)}}return arrayIndexOf(e,[r],t,f,n)}throw new TypeError(\"val must be string, number or Buffer\")}function arrayIndexOf(e,r,t,f,n){var i=1;var o=e.length;var u=r.length;if(f!==undefined){f=String(f).toLowerCase();if(f===\"ucs2\"||f===\"ucs-2\"||f===\"utf16le\"||f===\"utf-16le\"){if(e.length<2||r.length<2){return-1}i=2;o/=2;u/=2;t/=2}}function read(e,r){if(i===1){return e[r]}else{return e.readUInt16BE(r*i)}}var a;if(n){var s=-1;for(a=t;a<o;a++){if(read(e,a)===read(r,s===-1?0:a-s)){if(s===-1)s=a;if(a-s+1===u)return s*i}else{if(s!==-1)a-=a-s;s=-1}}}else{if(t+u>o)t=o-u;for(a=t;a>=0;a--){var h=true;for(var c=0;c<u;c++){if(read(e,a+c)!==read(r,c)){h=false;break}}if(h)return a}}return-1}Buffer.prototype.includes=function includes(e,r,t){return this.indexOf(e,r,t)!==-1};Buffer.prototype.indexOf=function indexOf(e,r,t){return bidirectionalIndexOf(this,e,r,t,true)};Buffer.prototype.lastIndexOf=function lastIndexOf(e,r,t){return bidirectionalIndexOf(this,e,r,t,false)};function hexWrite(e,r,t,f){t=Number(t)||0;var n=e.length-t;if(!f){f=n}else{f=Number(f);if(f>n){f=n}}var i=r.length;if(f>i/2){f=i/2}for(var o=0;o<f;++o){var u=parseInt(r.substr(o*2,2),16);if(numberIsNaN(u))return o;e[t+o]=u}return o}function utf8Write(e,r,t,f){return blitBuffer(utf8ToBytes(r,e.length-t),e,t,f)}function asciiWrite(e,r,t,f){return blitBuffer(asciiToBytes(r),e,t,f)}function latin1Write(e,r,t,f){return asciiWrite(e,r,t,f)}function base64Write(e,r,t,f){return blitBuffer(base64ToBytes(r),e,t,f)}function ucs2Write(e,r,t,f){return blitBuffer(utf16leToBytes(r,e.length-t),e,t,f)}Buffer.prototype.write=function write(e,r,t,f){if(r===undefined){f=\"utf8\";t=this.length;r=0}else if(t===undefined&&typeof r===\"string\"){f=r;t=this.length;r=0}else if(isFinite(r)){r=r>>>0;if(isFinite(t)){t=t>>>0;if(f===undefined)f=\"utf8\"}else{f=t;t=undefined}}else{throw new Error(\"Buffer.write(string, encoding, offset[, length]) is no longer supported\")}var n=this.length-r;if(t===undefined||t>n)t=n;if(e.length>0&&(t<0||r<0)||r>this.length){throw new RangeError(\"Attempt to write outside buffer bounds\")}if(!f)f=\"utf8\";var i=false;for(;;){switch(f){case\"hex\":return hexWrite(this,e,r,t);case\"utf8\":case\"utf-8\":return utf8Write(this,e,r,t);case\"ascii\":return asciiWrite(this,e,r,t);case\"latin1\":case\"binary\":return latin1Write(this,e,r,t);case\"base64\":return base64Write(this,e,r,t);case\"ucs2\":case\"ucs-2\":case\"utf16le\":case\"utf-16le\":return ucs2Write(this,e,r,t);default:if(i)throw new TypeError(\"Unknown encoding: \"+f);f=(\"\"+f).toLowerCase();i=true}}};Buffer.prototype.toJSON=function toJSON(){return{type:\"Buffer\",data:Array.prototype.slice.call(this._arr||this,0)}};function base64Slice(e,r,t){if(r===0&&t===e.length){return f.fromByteArray(e)}else{return f.fromByteArray(e.slice(r,t))}}function utf8Slice(e,r,t){t=Math.min(e.length,t);var f=[];var n=r;while(n<t){var i=e[n];var o=null;var u=i>239?4:i>223?3:i>191?2:1;if(n+u<=t){var a,s,h,c;switch(u){case 1:if(i<128){o=i}break;case 2:a=e[n+1];if((a&192)===128){c=(i&31)<<6|a&63;if(c>127){o=c}}break;case 3:a=e[n+1];s=e[n+2];if((a&192)===128&&(s&192)===128){c=(i&15)<<12|(a&63)<<6|s&63;if(c>2047&&(c<55296||c>57343)){o=c}}break;case 4:a=e[n+1];s=e[n+2];h=e[n+3];if((a&192)===128&&(s&192)===128&&(h&192)===128){c=(i&15)<<18|(a&63)<<12|(s&63)<<6|h&63;if(c>65535&&c<1114112){o=c}}}}if(o===null){o=65533;u=1}else if(o>65535){o-=65536;f.push(o>>>10&1023|55296);o=56320|o&1023}f.push(o);n+=u}return decodeCodePointsArray(f)}var u=4096;function decodeCodePointsArray(e){var r=e.length;if(r<=u){return String.fromCharCode.apply(String,e)}var t=\"\";var f=0;while(f<r){t+=String.fromCharCode.apply(String,e.slice(f,f+=u))}return t}function asciiSlice(e,r,t){var f=\"\";t=Math.min(e.length,t);for(var n=r;n<t;++n){f+=String.fromCharCode(e[n]&127)}return f}function latin1Slice(e,r,t){var f=\"\";t=Math.min(e.length,t);for(var n=r;n<t;++n){f+=String.fromCharCode(e[n])}return f}function hexSlice(e,r,t){var f=e.length;if(!r||r<0)r=0;if(!t||t<0||t>f)t=f;var n=\"\";for(var i=r;i<t;++i){n+=s[e[i]]}return n}function utf16leSlice(e,r,t){var f=e.slice(r,t);var n=\"\";for(var i=0;i<f.length;i+=2){n+=String.fromCharCode(f[i]+f[i+1]*256)}return n}Buffer.prototype.slice=function slice(e,r){var t=this.length;e=~~e;r=r===undefined?t:~~r;if(e<0){e+=t;if(e<0)e=0}else if(e>t){e=t}if(r<0){r+=t;if(r<0)r=0}else if(r>t){r=t}if(r<e)r=e;var f=this.subarray(e,r);Object.setPrototypeOf(f,Buffer.prototype);return f};function checkOffset(e,r,t){if(e%1!==0||e<0)throw new RangeError(\"offset is not uint\");if(e+r>t)throw new RangeError(\"Trying to access beyond buffer length\")}Buffer.prototype.readUIntLE=function readUIntLE(e,r,t){e=e>>>0;r=r>>>0;if(!t)checkOffset(e,r,this.length);var f=this[e];var n=1;var i=0;while(++i<r&&(n*=256)){f+=this[e+i]*n}return f};Buffer.prototype.readUIntBE=function readUIntBE(e,r,t){e=e>>>0;r=r>>>0;if(!t){checkOffset(e,r,this.length)}var f=this[e+--r];var n=1;while(r>0&&(n*=256)){f+=this[e+--r]*n}return f};Buffer.prototype.readUInt8=function readUInt8(e,r){e=e>>>0;if(!r)checkOffset(e,1,this.length);return this[e]};Buffer.prototype.readUInt16LE=function readUInt16LE(e,r){e=e>>>0;if(!r)checkOffset(e,2,this.length);return this[e]|this[e+1]<<8};Buffer.prototype.readUInt16BE=function readUInt16BE(e,r){e=e>>>0;if(!r)checkOffset(e,2,this.length);return this[e]<<8|this[e+1]};Buffer.prototype.readUInt32LE=function readUInt32LE(e,r){e=e>>>0;if(!r)checkOffset(e,4,this.length);return(this[e]|this[e+1]<<8|this[e+2]<<16)+this[e+3]*16777216};Buffer.prototype.readUInt32BE=function readUInt32BE(e,r){e=e>>>0;if(!r)checkOffset(e,4,this.length);return this[e]*16777216+(this[e+1]<<16|this[e+2]<<8|this[e+3])};Buffer.prototype.readIntLE=function readIntLE(e,r,t){e=e>>>0;r=r>>>0;if(!t)checkOffset(e,r,this.length);var f=this[e];var n=1;var i=0;while(++i<r&&(n*=256)){f+=this[e+i]*n}n*=128;if(f>=n)f-=Math.pow(2,8*r);return f};Buffer.prototype.readIntBE=function readIntBE(e,r,t){e=e>>>0;r=r>>>0;if(!t)checkOffset(e,r,this.length);var f=r;var n=1;var i=this[e+--f];while(f>0&&(n*=256)){i+=this[e+--f]*n}n*=128;if(i>=n)i-=Math.pow(2,8*r);return i};Buffer.prototype.readInt8=function readInt8(e,r){e=e>>>0;if(!r)checkOffset(e,1,this.length);if(!(this[e]&128))return this[e];return(255-this[e]+1)*-1};Buffer.prototype.readInt16LE=function readInt16LE(e,r){e=e>>>0;if(!r)checkOffset(e,2,this.length);var t=this[e]|this[e+1]<<8;return t&32768?t|4294901760:t};Buffer.prototype.readInt16BE=function readInt16BE(e,r){e=e>>>0;if(!r)checkOffset(e,2,this.length);var t=this[e+1]|this[e]<<8;return t&32768?t|4294901760:t};Buffer.prototype.readInt32LE=function readInt32LE(e,r){e=e>>>0;if(!r)checkOffset(e,4,this.length);return this[e]|this[e+1]<<8|this[e+2]<<16|this[e+3]<<24};Buffer.prototype.readInt32BE=function readInt32BE(e,r){e=e>>>0;if(!r)checkOffset(e,4,this.length);return this[e]<<24|this[e+1]<<16|this[e+2]<<8|this[e+3]};Buffer.prototype.readFloatLE=function readFloatLE(e,r){e=e>>>0;if(!r)checkOffset(e,4,this.length);return n.read(this,e,true,23,4)};Buffer.prototype.readFloatBE=function readFloatBE(e,r){e=e>>>0;if(!r)checkOffset(e,4,this.length);return n.read(this,e,false,23,4)};Buffer.prototype.readDoubleLE=function readDoubleLE(e,r){e=e>>>0;if(!r)checkOffset(e,8,this.length);return n.read(this,e,true,52,8)};Buffer.prototype.readDoubleBE=function readDoubleBE(e,r){e=e>>>0;if(!r)checkOffset(e,8,this.length);return n.read(this,e,false,52,8)};function checkInt(e,r,t,f,n,i){if(!Buffer.isBuffer(e))throw new TypeError('\"buffer\" argument must be a Buffer instance');if(r>n||r<i)throw new RangeError('\"value\" argument is out of bounds');if(t+f>e.length)throw new RangeError(\"Index out of range\")}Buffer.prototype.writeUIntLE=function writeUIntLE(e,r,t,f){e=+e;r=r>>>0;t=t>>>0;if(!f){var n=Math.pow(2,8*t)-1;checkInt(this,e,r,t,n,0)}var i=1;var o=0;this[r]=e&255;while(++o<t&&(i*=256)){this[r+o]=e/i&255}return r+t};Buffer.prototype.writeUIntBE=function writeUIntBE(e,r,t,f){e=+e;r=r>>>0;t=t>>>0;if(!f){var n=Math.pow(2,8*t)-1;checkInt(this,e,r,t,n,0)}var i=t-1;var o=1;this[r+i]=e&255;while(--i>=0&&(o*=256)){this[r+i]=e/o&255}return r+t};Buffer.prototype.writeUInt8=function writeUInt8(e,r,t){e=+e;r=r>>>0;if(!t)checkInt(this,e,r,1,255,0);this[r]=e&255;return r+1};Buffer.prototype.writeUInt16LE=function writeUInt16LE(e,r,t){e=+e;r=r>>>0;if(!t)checkInt(this,e,r,2,65535,0);this[r]=e&255;this[r+1]=e>>>8;return r+2};Buffer.prototype.writeUInt16BE=function writeUInt16BE(e,r,t){e=+e;r=r>>>0;if(!t)checkInt(this,e,r,2,65535,0);this[r]=e>>>8;this[r+1]=e&255;return r+2};Buffer.prototype.writeUInt32LE=function writeUInt32LE(e,r,t){e=+e;r=r>>>0;if(!t)checkInt(this,e,r,4,4294967295,0);this[r+3]=e>>>24;this[r+2]=e>>>16;this[r+1]=e>>>8;this[r]=e&255;return r+4};Buffer.prototype.writeUInt32BE=function writeUInt32BE(e,r,t){e=+e;r=r>>>0;if(!t)checkInt(this,e,r,4,4294967295,0);this[r]=e>>>24;this[r+1]=e>>>16;this[r+2]=e>>>8;this[r+3]=e&255;return r+4};Buffer.prototype.writeIntLE=function writeIntLE(e,r,t,f){e=+e;r=r>>>0;if(!f){var n=Math.pow(2,8*t-1);checkInt(this,e,r,t,n-1,-n)}var i=0;var o=1;var u=0;this[r]=e&255;while(++i<t&&(o*=256)){if(e<0&&u===0&&this[r+i-1]!==0){u=1}this[r+i]=(e/o>>0)-u&255}return r+t};Buffer.prototype.writeIntBE=function writeIntBE(e,r,t,f){e=+e;r=r>>>0;if(!f){var n=Math.pow(2,8*t-1);checkInt(this,e,r,t,n-1,-n)}var i=t-1;var o=1;var u=0;this[r+i]=e&255;while(--i>=0&&(o*=256)){if(e<0&&u===0&&this[r+i+1]!==0){u=1}this[r+i]=(e/o>>0)-u&255}return r+t};Buffer.prototype.writeInt8=function writeInt8(e,r,t){e=+e;r=r>>>0;if(!t)checkInt(this,e,r,1,127,-128);if(e<0)e=255+e+1;this[r]=e&255;return r+1};Buffer.prototype.writeInt16LE=function writeInt16LE(e,r,t){e=+e;r=r>>>0;if(!t)checkInt(this,e,r,2,32767,-32768);this[r]=e&255;this[r+1]=e>>>8;return r+2};Buffer.prototype.writeInt16BE=function writeInt16BE(e,r,t){e=+e;r=r>>>0;if(!t)checkInt(this,e,r,2,32767,-32768);this[r]=e>>>8;this[r+1]=e&255;return r+2};Buffer.prototype.writeInt32LE=function writeInt32LE(e,r,t){e=+e;r=r>>>0;if(!t)checkInt(this,e,r,4,2147483647,-2147483648);this[r]=e&255;this[r+1]=e>>>8;this[r+2]=e>>>16;this[r+3]=e>>>24;return r+4};Buffer.prototype.writeInt32BE=function writeInt32BE(e,r,t){e=+e;r=r>>>0;if(!t)checkInt(this,e,r,4,2147483647,-2147483648);if(e<0)e=4294967295+e+1;this[r]=e>>>24;this[r+1]=e>>>16;this[r+2]=e>>>8;this[r+3]=e&255;return r+4};function checkIEEE754(e,r,t,f,n,i){if(t+f>e.length)throw new RangeError(\"Index out of range\");if(t<0)throw new RangeError(\"Index out of range\")}function writeFloat(e,r,t,f,i){r=+r;t=t>>>0;if(!i){checkIEEE754(e,r,t,4,34028234663852886e22,-34028234663852886e22)}n.write(e,r,t,f,23,4);return t+4}Buffer.prototype.writeFloatLE=function writeFloatLE(e,r,t){return writeFloat(this,e,r,true,t)};Buffer.prototype.writeFloatBE=function writeFloatBE(e,r,t){return writeFloat(this,e,r,false,t)};function writeDouble(e,r,t,f,i){r=+r;t=t>>>0;if(!i){checkIEEE754(e,r,t,8,17976931348623157e292,-17976931348623157e292)}n.write(e,r,t,f,52,8);return t+8}Buffer.prototype.writeDoubleLE=function writeDoubleLE(e,r,t){return writeDouble(this,e,r,true,t)};Buffer.prototype.writeDoubleBE=function writeDoubleBE(e,r,t){return writeDouble(this,e,r,false,t)};Buffer.prototype.copy=function copy(e,r,t,f){if(!Buffer.isBuffer(e))throw new TypeError(\"argument should be a Buffer\");if(!t)t=0;if(!f&&f!==0)f=this.length;if(r>=e.length)r=e.length;if(!r)r=0;if(f>0&&f<t)f=t;if(f===t)return 0;if(e.length===0||this.length===0)return 0;if(r<0){throw new RangeError(\"targetStart out of bounds\")}if(t<0||t>=this.length)throw new RangeError(\"Index out of range\");if(f<0)throw new RangeError(\"sourceEnd out of bounds\");if(f>this.length)f=this.length;if(e.length-r<f-t){f=e.length-r+t}var n=f-t;if(this===e&&typeof Uint8Array.prototype.copyWithin===\"function\"){this.copyWithin(r,t,f)}else if(this===e&&t<r&&r<f){for(var i=n-1;i>=0;--i){e[i+r]=this[i+t]}}else{Uint8Array.prototype.set.call(e,this.subarray(t,f),r)}return n};Buffer.prototype.fill=function fill(e,r,t,f){if(typeof e===\"string\"){if(typeof r===\"string\"){f=r;r=0;t=this.length}else if(typeof t===\"string\"){f=t;t=this.length}if(f!==undefined&&typeof f!==\"string\"){throw new TypeError(\"encoding must be a string\")}if(typeof f===\"string\"&&!Buffer.isEncoding(f)){throw new TypeError(\"Unknown encoding: \"+f)}if(e.length===1){var n=e.charCodeAt(0);if(f===\"utf8\"&&n<128||f===\"latin1\"){e=n}}}else if(typeof e===\"number\"){e=e&255}else if(typeof e===\"boolean\"){e=Number(e)}if(r<0||this.length<r||this.length<t){throw new RangeError(\"Out of range index\")}if(t<=r){return this}r=r>>>0;t=t===undefined?this.length:t>>>0;if(!e)e=0;var i;if(typeof e===\"number\"){for(i=r;i<t;++i){this[i]=e}}else{var o=Buffer.isBuffer(e)?e:Buffer.from(e,f);var u=o.length;if(u===0){throw new TypeError('The value \"'+e+'\" is invalid for argument \"value\"')}for(i=0;i<t-r;++i){this[i+r]=o[i%u]}}return this};var a=/[^+/0-9A-Za-z-_]/g;function base64clean(e){e=e.split(\"=\")[0];e=e.trim().replace(a,\"\");if(e.length<2)return\"\";while(e.length%4!==0){e=e+\"=\"}return e}function utf8ToBytes(e,r){r=r||Infinity;var t;var f=e.length;var n=null;var i=[];for(var o=0;o<f;++o){t=e.charCodeAt(o);if(t>55295&&t<57344){if(!n){if(t>56319){if((r-=3)>-1)i.push(239,191,189);continue}else if(o+1===f){if((r-=3)>-1)i.push(239,191,189);continue}n=t;continue}if(t<56320){if((r-=3)>-1)i.push(239,191,189);n=t;continue}t=(n-55296<<10|t-56320)+65536}else if(n){if((r-=3)>-1)i.push(239,191,189)}n=null;if(t<128){if((r-=1)<0)break;i.push(t)}else if(t<2048){if((r-=2)<0)break;i.push(t>>6|192,t&63|128)}else if(t<65536){if((r-=3)<0)break;i.push(t>>12|224,t>>6&63|128,t&63|128)}else if(t<1114112){if((r-=4)<0)break;i.push(t>>18|240,t>>12&63|128,t>>6&63|128,t&63|128)}else{throw new Error(\"Invalid code point\")}}return i}function asciiToBytes(e){var r=[];for(var t=0;t<e.length;++t){r.push(e.charCodeAt(t)&255)}return r}function utf16leToBytes(e,r){var t,f,n;var i=[];for(var o=0;o<e.length;++o){if((r-=2)<0)break;t=e.charCodeAt(o);f=t>>8;n=t%256;i.push(n);i.push(f)}return i}function base64ToBytes(e){return f.toByteArray(base64clean(e))}function blitBuffer(e,r,t,f){for(var n=0;n<f;++n){if(n+t>=r.length||n>=e.length)break;r[n+t]=e[n]}return n}function isInstance(e,r){return e instanceof r||e!=null&&e.constructor!=null&&e.constructor.name!=null&&e.constructor.name===r.name}function numberIsNaN(e){return e!==e}var s=function(){var e=\"0123456789abcdef\";var r=new Array(256);for(var t=0;t<16;++t){var f=t*16;for(var n=0;n<16;++n){r[f+n]=e[t]+e[n]}}return r}()},783:function(e,r){\n/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */\nr.read=function(e,r,t,f,n){var i,o;var u=n*8-f-1;var a=(1<<u)-1;var s=a>>1;var h=-7;var c=t?n-1:0;var l=t?-1:1;var p=e[r+c];c+=l;i=p&(1<<-h)-1;p>>=-h;h+=u;for(;h>0;i=i*256+e[r+c],c+=l,h-=8){}o=i&(1<<-h)-1;i>>=-h;h+=f;for(;h>0;o=o*256+e[r+c],c+=l,h-=8){}if(i===0){i=1-s}else if(i===a){return o?NaN:(p?-1:1)*Infinity}else{o=o+Math.pow(2,f);i=i-s}return(p?-1:1)*o*Math.pow(2,i-f)};r.write=function(e,r,t,f,n,i){var o,u,a;var s=i*8-n-1;var h=(1<<s)-1;var c=h>>1;var l=n===23?Math.pow(2,-24)-Math.pow(2,-77):0;var p=f?0:i-1;var y=f?1:-1;var g=r<0||r===0&&1/r<0?1:0;r=Math.abs(r);if(isNaN(r)||r===Infinity){u=isNaN(r)?1:0;o=h}else{o=Math.floor(Math.log(r)/Math.LN2);if(r*(a=Math.pow(2,-o))<1){o--;a*=2}if(o+c>=1){r+=l/a}else{r+=l*Math.pow(2,1-c)}if(r*a>=2){o++;a/=2}if(o+c>=h){u=0;o=h}else if(o+c>=1){u=(r*a-1)*Math.pow(2,n);o=o+c}else{u=r*Math.pow(2,c-1)*Math.pow(2,n);o=0}}for(;n>=8;e[t+p]=u&255,p+=y,u/=256,n-=8){}o=o<<n|u;s+=n;for(;s>0;e[t+p]=o&255,p+=y,o/=256,s-=8){}e[t+p-y]|=g*128}}};var r={};function __nccwpck_require__(t){var f=r[t];if(f!==undefined){return f.exports}var n=r[t]={exports:{}};var i=true;try{e[t](n,n.exports,__nccwpck_require__);i=false}finally{if(i)delete r[t]}return n.exports}if(typeof __nccwpck_require__!==\"undefined\")__nccwpck_require__.ab=__dirname+\"/\";var t=__nccwpck_require__(72);module.exports=t})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvYnVmZmVyL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7QUFBQSxZQUFZLE9BQU8sa0JBQWtCLGFBQWEsd0JBQXdCLDBCQUEwQiw4QkFBOEIsU0FBUyxTQUFTLHVEQUF1RCx5RUFBeUUsdUJBQXVCLElBQUksS0FBSyxVQUFVLHFCQUFxQix3QkFBd0Isd0JBQXdCLG9CQUFvQixlQUFlLFVBQVUsa0VBQWtFLHFCQUFxQixjQUFjLG9CQUFvQixZQUFZLHVCQUF1QixpQkFBaUIsV0FBVyxXQUFXLGtCQUFrQiw0QkFBNEIsa0JBQWtCLHdCQUF3QixNQUFNLGlCQUFpQixXQUFXLFdBQVcsZ0NBQWdDLFFBQVEsZ0JBQWdCLE1BQU0sUUFBUSxJQUFJLE1BQU0sK0ZBQStGLGlCQUFpQixnQkFBZ0IsYUFBYSxVQUFVLGdEQUFnRCxhQUFhLFVBQVUseUVBQXlFLGdCQUFnQixhQUFhLFNBQVMsNEJBQTRCLGtEQUFrRCw0QkFBNEIsTUFBTSxTQUFTLFlBQVksSUFBSSxNQUFNLHFEQUFxRCwyQkFBMkIsa0JBQWtCLDBCQUEwQixNQUFNLGVBQWUsVUFBVSxTQUFTLFlBQVksa0JBQWtCLElBQUksTUFBTSxxQ0FBcUMsVUFBVSxTQUFTLGdDQUFnQyxlQUFlLHFCQUFxQiwyQ0FBMkMsbUJBQW1CLG9CQUFvQjtBQUM5ckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixhQUFhLCtHQUErRyxnQkFBZ0Isd0JBQXdCLHVCQUF1QixpQkFBaUIsZUFBZSwrQ0FBK0MsaUdBQWlHLGtLQUFrSyw2QkFBNkIsSUFBSSx3QkFBd0IsT0FBTyxlQUFlLFlBQVksOENBQThDLDJCQUEyQixvQkFBb0IsU0FBUyxjQUFjLGlEQUFpRCwrQkFBK0IsMkNBQTJDLG9CQUFvQixFQUFFLGlEQUFpRCwrQkFBK0IsMkNBQTJDLHdCQUF3QixFQUFFLHlCQUF5QixRQUFRLHVFQUF1RSx3QkFBd0IsMENBQTBDLFNBQVMs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Q0FBK0MsY0FBYyxhQUFhLDRCQUE0QixjQUFjLDJCQUEyQixlQUFlLElBQUksS0FBSyxtQ0FBbUMsMkJBQTJCLElBQUksS0FBSyxXQUFXLE9BQU8sS0FBSyxxQkFBcUIsV0FBVyxJQUFJLEtBQUssV0FBVyxJQUFJLElBQUksZ0JBQWdCLHdCQUF3QixNQUFNLEtBQUssa0NBQWtDLEtBQUssS0FBSyxLQUFLLGdDQUFnQyxTQUFTLEtBQUssS0FBSyxJQUFJLGdDQUFnQyxtQkFBbUIsU0FBUyxnQ0FBZ0MsV0FBVyxrQkFBa0IsaUJBQWlCLFlBQVksWUFBWSxXQUFXLElBQUksc0NBQXNDLFFBQVEsUUFBUSxpQkFBaUIsaUJBQWlCLG1FQUFtRSxTQUFTLEtBQUssOEJBQThCLGlCQUFpQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL2J1ZmZlci9pbmRleC5qcz8wM2Y5Il0sInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbigpe3ZhciBlPXs2NzU6ZnVuY3Rpb24oZSxyKXtcInVzZSBzdHJpY3RcIjtyLmJ5dGVMZW5ndGg9Ynl0ZUxlbmd0aDtyLnRvQnl0ZUFycmF5PXRvQnl0ZUFycmF5O3IuZnJvbUJ5dGVBcnJheT1mcm9tQnl0ZUFycmF5O3ZhciB0PVtdO3ZhciBmPVtdO3ZhciBuPXR5cGVvZiBVaW50OEFycmF5IT09XCJ1bmRlZmluZWRcIj9VaW50OEFycmF5OkFycmF5O3ZhciBpPVwiQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrL1wiO2Zvcih2YXIgbz0wLHU9aS5sZW5ndGg7bzx1Oysrbyl7dFtvXT1pW29dO2ZbaS5jaGFyQ29kZUF0KG8pXT1vfWZbXCItXCIuY2hhckNvZGVBdCgwKV09NjI7ZltcIl9cIi5jaGFyQ29kZUF0KDApXT02MztmdW5jdGlvbiBnZXRMZW5zKGUpe3ZhciByPWUubGVuZ3RoO2lmKHIlND4wKXt0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHN0cmluZy4gTGVuZ3RoIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA0XCIpfXZhciB0PWUuaW5kZXhPZihcIj1cIik7aWYodD09PS0xKXQ9cjt2YXIgZj10PT09cj8wOjQtdCU0O3JldHVyblt0LGZdfWZ1bmN0aW9uIGJ5dGVMZW5ndGgoZSl7dmFyIHI9Z2V0TGVucyhlKTt2YXIgdD1yWzBdO3ZhciBmPXJbMV07cmV0dXJuKHQrZikqMy80LWZ9ZnVuY3Rpb24gX2J5dGVMZW5ndGgoZSxyLHQpe3JldHVybihyK3QpKjMvNC10fWZ1bmN0aW9uIHRvQnl0ZUFycmF5KGUpe3ZhciByO3ZhciB0PWdldExlbnMoZSk7dmFyIGk9dFswXTt2YXIgbz10WzFdO3ZhciB1PW5ldyBuKF9ieXRlTGVuZ3RoKGUsaSxvKSk7dmFyIGE9MDt2YXIgcz1vPjA/aS00Omk7dmFyIGg7Zm9yKGg9MDtoPHM7aCs9NCl7cj1mW2UuY2hhckNvZGVBdChoKV08PDE4fGZbZS5jaGFyQ29kZUF0KGgrMSldPDwxMnxmW2UuY2hhckNvZGVBdChoKzIpXTw8NnxmW2UuY2hhckNvZGVBdChoKzMpXTt1W2ErK109cj4+MTYmMjU1O3VbYSsrXT1yPj44JjI1NTt1W2ErK109ciYyNTV9aWYobz09PTIpe3I9ZltlLmNoYXJDb2RlQXQoaCldPDwyfGZbZS5jaGFyQ29kZUF0KGgrMSldPj40O3VbYSsrXT1yJjI1NX1pZihvPT09MSl7cj1mW2UuY2hhckNvZGVBdChoKV08PDEwfGZbZS5jaGFyQ29kZUF0KGgrMSldPDw0fGZbZS5jaGFyQ29kZUF0KGgrMildPj4yO3VbYSsrXT1yPj44JjI1NTt1W2ErK109ciYyNTV9cmV0dXJuIHV9ZnVuY3Rpb24gdHJpcGxldFRvQmFzZTY0KGUpe3JldHVybiB0W2U+PjE4JjYzXSt0W2U+PjEyJjYzXSt0W2U+PjYmNjNdK3RbZSY2M119ZnVuY3Rpb24gZW5jb2RlQ2h1bmsoZSxyLHQpe3ZhciBmO3ZhciBuPVtdO2Zvcih2YXIgaT1yO2k8dDtpKz0zKXtmPShlW2ldPDwxNiYxNjcxMTY4MCkrKGVbaSsxXTw8OCY2NTI4MCkrKGVbaSsyXSYyNTUpO24ucHVzaCh0cmlwbGV0VG9CYXNlNjQoZikpfXJldHVybiBuLmpvaW4oXCJcIil9ZnVuY3Rpb24gZnJvbUJ5dGVBcnJheShlKXt2YXIgcjt2YXIgZj1lLmxlbmd0aDt2YXIgbj1mJTM7dmFyIGk9W107dmFyIG89MTYzODM7Zm9yKHZhciB1PTAsYT1mLW47dTxhO3UrPW8pe2kucHVzaChlbmNvZGVDaHVuayhlLHUsdStvPmE/YTp1K28pKX1pZihuPT09MSl7cj1lW2YtMV07aS5wdXNoKHRbcj4+Ml0rdFtyPDw0JjYzXStcIj09XCIpfWVsc2UgaWYobj09PTIpe3I9KGVbZi0yXTw8OCkrZVtmLTFdO2kucHVzaCh0W3I+PjEwXSt0W3I+PjQmNjNdK3Rbcjw8MiY2M10rXCI9XCIpfXJldHVybiBpLmpvaW4oXCJcIil9fSw3MjpmdW5jdGlvbihlLHIsdCl7XCJ1c2Ugc3RyaWN0XCI7XG4vKiFcbiAqIFRoZSBidWZmZXIgbW9kdWxlIGZyb20gbm9kZS5qcywgZm9yIHRoZSBicm93c2VyLlxuICpcbiAqIEBhdXRob3IgICBGZXJvc3MgQWJvdWtoYWRpamVoIDxodHRwczovL2Zlcm9zcy5vcmc+XG4gKiBAbGljZW5zZSAgTUlUXG4gKi92YXIgZj10KDY3NSk7dmFyIG49dCg3ODMpO3ZhciBpPXR5cGVvZiBTeW1ib2w9PT1cImZ1bmN0aW9uXCImJnR5cGVvZiBTeW1ib2wuZm9yPT09XCJmdW5jdGlvblwiP1N5bWJvbC5mb3IoXCJub2RlanMudXRpbC5pbnNwZWN0LmN1c3RvbVwiKTpudWxsO3IuQnVmZmVyPUJ1ZmZlcjtyLlNsb3dCdWZmZXI9U2xvd0J1ZmZlcjtyLklOU1BFQ1RfTUFYX0JZVEVTPTUwO3ZhciBvPTIxNDc0ODM2NDc7ci5rTWF4TGVuZ3RoPW87QnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQ9dHlwZWRBcnJheVN1cHBvcnQoKTtpZighQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQmJnR5cGVvZiBjb25zb2xlIT09XCJ1bmRlZmluZWRcIiYmdHlwZW9mIGNvbnNvbGUuZXJyb3I9PT1cImZ1bmN0aW9uXCIpe2NvbnNvbGUuZXJyb3IoXCJUaGlzIGJyb3dzZXIgbGFja3MgdHlwZWQgYXJyYXkgKFVpbnQ4QXJyYXkpIHN1cHBvcnQgd2hpY2ggaXMgcmVxdWlyZWQgYnkgXCIrXCJgYnVmZmVyYCB2NS54LiBVc2UgYGJ1ZmZlcmAgdjQueCBpZiB5b3UgcmVxdWlyZSBvbGQgYnJvd3NlciBzdXBwb3J0LlwiKX1mdW5jdGlvbiB0eXBlZEFycmF5U3VwcG9ydCgpe3RyeXt2YXIgZT1uZXcgVWludDhBcnJheSgxKTt2YXIgcj17Zm9vOmZ1bmN0aW9uKCl7cmV0dXJuIDQyfX07T2JqZWN0LnNldFByb3RvdHlwZU9mKHIsVWludDhBcnJheS5wcm90b3R5cGUpO09iamVjdC5zZXRQcm90b3R5cGVPZihlLHIpO3JldHVybiBlLmZvbygpPT09NDJ9Y2F0Y2goZSl7cmV0dXJuIGZhbHNlfX1PYmplY3QuZGVmaW5lUHJvcGVydHkoQnVmZmVyLnByb3RvdHlwZSxcInBhcmVudFwiLHtlbnVtZXJhYmxlOnRydWUsZ2V0OmZ1bmN0aW9uKCl7aWYoIUJ1ZmZlci5pc0J1ZmZlcih0aGlzKSlyZXR1cm4gdW5kZWZpbmVkO3JldHVybiB0aGlzLmJ1ZmZlcn19KTtPYmplY3QuZGVmaW5lUHJvcGVydHkoQnVmZmVyLnByb3RvdHlwZSxcIm9mZnNldFwiLHtlbnVtZXJhYmxlOnRydWUsZ2V0OmZ1bmN0aW9uKCl7aWYoIUJ1ZmZlci5pc0J1ZmZlcih0aGlzKSlyZXR1cm4gdW5kZWZpbmVkO3JldHVybiB0aGlzLmJ5dGVPZmZzZXR9fSk7ZnVuY3Rpb24gY3JlYXRlQnVmZmVyKGUpe2lmKGU+byl7dGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RoZSB2YWx1ZSBcIicrZSsnXCIgaXMgaW52YWxpZCBmb3Igb3B0aW9uIFwic2l6ZVwiJyl9dmFyIHI9bmV3IFVpbnQ4QXJyYXkoZSk7T2JqZWN0LnNldFByb3RvdHlwZU9mKHIsQnVmZmVyLnByb3RvdHlwZSk7cmV0dXJuIHJ9ZnVuY3Rpb24gQnVmZmVyKGUscix0KXtpZih0eXBlb2YgZT09PVwibnVtYmVyXCIpe2lmKHR5cGVvZiByPT09XCJzdHJpbmdcIil7dGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIFwic3RyaW5nXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIHN0cmluZy4gUmVjZWl2ZWQgdHlwZSBudW1iZXInKX1yZXR1cm4gYWxsb2NVbnNhZmUoZSl9cmV0dXJuIGZyb20oZSxyLHQpfUJ1ZmZlci5wb29sU2l6ZT04MTkyO2Z1bmN0aW9uIGZyb20oZSxyLHQpe2lmKHR5cGVvZiBlPT09XCJzdHJpbmdcIil7cmV0dXJuIGZyb21TdHJpbmcoZSxyKX1pZihBcnJheUJ1ZmZlci5pc1ZpZXcoZSkpe3JldHVybiBmcm9tQXJyYXlMaWtlKGUpfWlmKGU9PW51bGwpe3Rocm93IG5ldyBUeXBlRXJyb3IoXCJUaGUgZmlyc3QgYXJndW1lbnQgbXVzdCBiZSBvbmUgb2YgdHlwZSBzdHJpbmcsIEJ1ZmZlciwgQXJyYXlCdWZmZXIsIEFycmF5LCBcIitcIm9yIEFycmF5LWxpa2UgT2JqZWN0LiBSZWNlaXZlZCB0eXBlIFwiK3R5cGVvZiBlKX1pZihpc0luc3RhbmNlKGUsQXJyYXlCdWZmZXIpfHxlJiZpc0luc3RhbmNlKGUuYnVmZmVyLEFycmF5QnVmZmVyKSl7cmV0dXJuIGZyb21BcnJheUJ1ZmZlcihlLHIsdCl9aWYodHlwZW9mIFNoYXJlZEFycmF5QnVmZmVyIT09XCJ1bmRlZmluZWRcIiYmKGlzSW5zdGFuY2UoZSxTaGFyZWRBcnJheUJ1ZmZlcil8fGUmJmlzSW5zdGFuY2UoZS5idWZmZXIsU2hhcmVkQXJyYXlCdWZmZXIpKSl7cmV0dXJuIGZyb21BcnJheUJ1ZmZlcihlLHIsdCl9aWYodHlwZW9mIGU9PT1cIm51bWJlclwiKXt0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgXCJ2YWx1ZVwiIGFyZ3VtZW50IG11c3Qgbm90IGJlIG9mIHR5cGUgbnVtYmVyLiBSZWNlaXZlZCB0eXBlIG51bWJlcicpfXZhciBmPWUudmFsdWVPZiYmZS52YWx1ZU9mKCk7aWYoZiE9bnVsbCYmZiE9PWUpe3JldHVybiBCdWZmZXIuZnJvbShmLHIsdCl9dmFyIG49ZnJvbU9iamVjdChlKTtpZihuKXJldHVybiBuO2lmKHR5cGVvZiBTeW1ib2whPT1cInVuZGVmaW5lZFwiJiZTeW1ib2wudG9QcmltaXRpdmUhPW51bGwmJnR5cGVvZiBlW1N5bWJvbC50b1ByaW1pdGl2ZV09PT1cImZ1bmN0aW9uXCIpe3JldHVybiBCdWZmZXIuZnJvbShlW1N5bWJvbC50b1ByaW1pdGl2ZV0oXCJzdHJpbmdcIikscix0KX10aHJvdyBuZXcgVHlwZUVycm9yKFwiVGhlIGZpcnN0IGFyZ3VtZW50IG11c3QgYmUgb25lIG9mIHR5cGUgc3RyaW5nLCBCdWZmZXIsIEFycmF5QnVmZmVyLCBBcnJheSwgXCIrXCJvciBBcnJheS1saWtlIE9iamVjdC4gUmVjZWl2ZWQgdHlwZSBcIit0eXBlb2YgZSl9QnVmZmVyLmZyb209ZnVuY3Rpb24oZSxyLHQpe3JldHVybiBmcm9tKGUscix0KX07T2JqZWN0LnNldFByb3RvdHlwZU9mKEJ1ZmZlci5wcm90b3R5cGUsVWludDhBcnJheS5wcm90b3R5cGUpO09iamVjdC5zZXRQcm90b3R5cGVPZihCdWZmZXIsVWludDhBcnJheSk7ZnVuY3Rpb24gYXNzZXJ0U2l6ZShlKXtpZih0eXBlb2YgZSE9PVwibnVtYmVyXCIpe3Rocm93IG5ldyBUeXBlRXJyb3IoJ1wic2l6ZVwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBudW1iZXInKX1lbHNlIGlmKGU8MCl7dGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RoZSB2YWx1ZSBcIicrZSsnXCIgaXMgaW52YWxpZCBmb3Igb3B0aW9uIFwic2l6ZVwiJyl9fWZ1bmN0aW9uIGFsbG9jKGUscix0KXthc3NlcnRTaXplKGUpO2lmKGU8PTApe3JldHVybiBjcmVhdGVCdWZmZXIoZSl9aWYociE9PXVuZGVmaW5lZCl7cmV0dXJuIHR5cGVvZiB0PT09XCJzdHJpbmdcIj9jcmVhdGVCdWZmZXIoZSkuZmlsbChyLHQpOmNyZWF0ZUJ1ZmZlcihlKS5maWxsKHIpfXJldHVybiBjcmVhdGVCdWZmZXIoZSl9QnVmZmVyLmFsbG9jPWZ1bmN0aW9uKGUscix0KXtyZXR1cm4gYWxsb2MoZSxyLHQpfTtmdW5jdGlvbiBhbGxvY1Vuc2FmZShlKXthc3NlcnRTaXplKGUpO3JldHVybiBjcmVhdGVCdWZmZXIoZTwwPzA6Y2hlY2tlZChlKXwwKX1CdWZmZXIuYWxsb2NVbnNhZmU9ZnVuY3Rpb24oZSl7cmV0dXJuIGFsbG9jVW5zYWZlKGUpfTtCdWZmZXIuYWxsb2NVbnNhZmVTbG93PWZ1bmN0aW9uKGUpe3JldHVybiBhbGxvY1Vuc2FmZShlKX07ZnVuY3Rpb24gZnJvbVN0cmluZyhlLHIpe2lmKHR5cGVvZiByIT09XCJzdHJpbmdcInx8cj09PVwiXCIpe3I9XCJ1dGY4XCJ9aWYoIUJ1ZmZlci5pc0VuY29kaW5nKHIpKXt0aHJvdyBuZXcgVHlwZUVycm9yKFwiVW5rbm93biBlbmNvZGluZzogXCIrcil9dmFyIHQ9Ynl0ZUxlbmd0aChlLHIpfDA7dmFyIGY9Y3JlYXRlQnVmZmVyKHQpO3ZhciBuPWYud3JpdGUoZSxyKTtpZihuIT09dCl7Zj1mLnNsaWNlKDAsbil9cmV0dXJuIGZ9ZnVuY3Rpb24gZnJvbUFycmF5TGlrZShlKXt2YXIgcj1lLmxlbmd0aDwwPzA6Y2hlY2tlZChlLmxlbmd0aCl8MDt2YXIgdD1jcmVhdGVCdWZmZXIocik7Zm9yKHZhciBmPTA7ZjxyO2YrPTEpe3RbZl09ZVtmXSYyNTV9cmV0dXJuIHR9ZnVuY3Rpb24gZnJvbUFycmF5QnVmZmVyKGUscix0KXtpZihyPDB8fGUuYnl0ZUxlbmd0aDxyKXt0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCJvZmZzZXRcIiBpcyBvdXRzaWRlIG9mIGJ1ZmZlciBib3VuZHMnKX1pZihlLmJ5dGVMZW5ndGg8cisodHx8MCkpe3Rocm93IG5ldyBSYW5nZUVycm9yKCdcImxlbmd0aFwiIGlzIG91dHNpZGUgb2YgYnVmZmVyIGJvdW5kcycpfXZhciBmO2lmKHI9PT11bmRlZmluZWQmJnQ9PT11bmRlZmluZWQpe2Y9bmV3IFVpbnQ4QXJyYXkoZSl9ZWxzZSBpZih0PT09dW5kZWZpbmVkKXtmPW5ldyBVaW50OEFycmF5KGUscil9ZWxzZXtmPW5ldyBVaW50OEFycmF5KGUscix0KX1PYmplY3Quc2V0UHJvdG90eXBlT2YoZixCdWZmZXIucHJvdG90eXBlKTtyZXR1cm4gZn1mdW5jdGlvbiBmcm9tT2JqZWN0KGUpe2lmKEJ1ZmZlci5pc0J1ZmZlcihlKSl7dmFyIHI9Y2hlY2tlZChlLmxlbmd0aCl8MDt2YXIgdD1jcmVhdGVCdWZmZXIocik7aWYodC5sZW5ndGg9PT0wKXtyZXR1cm4gdH1lLmNvcHkodCwwLDAscik7cmV0dXJuIHR9aWYoZS5sZW5ndGghPT11bmRlZmluZWQpe2lmKHR5cGVvZiBlLmxlbmd0aCE9PVwibnVtYmVyXCJ8fG51bWJlcklzTmFOKGUubGVuZ3RoKSl7cmV0dXJuIGNyZWF0ZUJ1ZmZlcigwKX1yZXR1cm4gZnJvbUFycmF5TGlrZShlKX1pZihlLnR5cGU9PT1cIkJ1ZmZlclwiJiZBcnJheS5pc0FycmF5KGUuZGF0YSkpe3JldHVybiBmcm9tQXJyYXlMaWtlKGUuZGF0YSl9fWZ1bmN0aW9uIGNoZWNrZWQoZSl7aWYoZT49byl7dGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJBdHRlbXB0IHRvIGFsbG9jYXRlIEJ1ZmZlciBsYXJnZXIgdGhhbiBtYXhpbXVtIFwiK1wic2l6ZTogMHhcIitvLnRvU3RyaW5nKDE2KStcIiBieXRlc1wiKX1yZXR1cm4gZXwwfWZ1bmN0aW9uIFNsb3dCdWZmZXIoZSl7aWYoK2UhPWUpe2U9MH1yZXR1cm4gQnVmZmVyLmFsbG9jKCtlKX1CdWZmZXIuaXNCdWZmZXI9ZnVuY3Rpb24gaXNCdWZmZXIoZSl7cmV0dXJuIGUhPW51bGwmJmUuX2lzQnVmZmVyPT09dHJ1ZSYmZSE9PUJ1ZmZlci5wcm90b3R5cGV9O0J1ZmZlci5jb21wYXJlPWZ1bmN0aW9uIGNvbXBhcmUoZSxyKXtpZihpc0luc3RhbmNlKGUsVWludDhBcnJheSkpZT1CdWZmZXIuZnJvbShlLGUub2Zmc2V0LGUuYnl0ZUxlbmd0aCk7aWYoaXNJbnN0YW5jZShyLFVpbnQ4QXJyYXkpKXI9QnVmZmVyLmZyb20ocixyLm9mZnNldCxyLmJ5dGVMZW5ndGgpO2lmKCFCdWZmZXIuaXNCdWZmZXIoZSl8fCFCdWZmZXIuaXNCdWZmZXIocikpe3Rocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBcImJ1ZjFcIiwgXCJidWYyXCIgYXJndW1lbnRzIG11c3QgYmUgb25lIG9mIHR5cGUgQnVmZmVyIG9yIFVpbnQ4QXJyYXknKX1pZihlPT09cilyZXR1cm4gMDt2YXIgdD1lLmxlbmd0aDt2YXIgZj1yLmxlbmd0aDtmb3IodmFyIG49MCxpPU1hdGgubWluKHQsZik7bjxpOysrbil7aWYoZVtuXSE9PXJbbl0pe3Q9ZVtuXTtmPXJbbl07YnJlYWt9fWlmKHQ8ZilyZXR1cm4tMTtpZihmPHQpcmV0dXJuIDE7cmV0dXJuIDB9O0J1ZmZlci5pc0VuY29kaW5nPWZ1bmN0aW9uIGlzRW5jb2RpbmcoZSl7c3dpdGNoKFN0cmluZyhlKS50b0xvd2VyQ2FzZSgpKXtjYXNlXCJoZXhcIjpjYXNlXCJ1dGY4XCI6Y2FzZVwidXRmLThcIjpjYXNlXCJhc2NpaVwiOmNhc2VcImxhdGluMVwiOmNhc2VcImJpbmFyeVwiOmNhc2VcImJhc2U2NFwiOmNhc2VcInVjczJcIjpjYXNlXCJ1Y3MtMlwiOmNhc2VcInV0ZjE2bGVcIjpjYXNlXCJ1dGYtMTZsZVwiOnJldHVybiB0cnVlO2RlZmF1bHQ6cmV0dXJuIGZhbHNlfX07QnVmZmVyLmNvbmNhdD1mdW5jdGlvbiBjb25jYXQoZSxyKXtpZighQXJyYXkuaXNBcnJheShlKSl7dGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0XCIgYXJndW1lbnQgbXVzdCBiZSBhbiBBcnJheSBvZiBCdWZmZXJzJyl9aWYoZS5sZW5ndGg9PT0wKXtyZXR1cm4gQnVmZmVyLmFsbG9jKDApfXZhciB0O2lmKHI9PT11bmRlZmluZWQpe3I9MDtmb3IodD0wO3Q8ZS5sZW5ndGg7Kyt0KXtyKz1lW3RdLmxlbmd0aH19dmFyIGY9QnVmZmVyLmFsbG9jVW5zYWZlKHIpO3ZhciBuPTA7Zm9yKHQ9MDt0PGUubGVuZ3RoOysrdCl7dmFyIGk9ZVt0XTtpZihpc0luc3RhbmNlKGksVWludDhBcnJheSkpe2k9QnVmZmVyLmZyb20oaSl9aWYoIUJ1ZmZlci5pc0J1ZmZlcihpKSl7dGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0XCIgYXJndW1lbnQgbXVzdCBiZSBhbiBBcnJheSBvZiBCdWZmZXJzJyl9aS5jb3B5KGYsbik7bis9aS5sZW5ndGh9cmV0dXJuIGZ9O2Z1bmN0aW9uIGJ5dGVMZW5ndGgoZSxyKXtpZihCdWZmZXIuaXNCdWZmZXIoZSkpe3JldHVybiBlLmxlbmd0aH1pZihBcnJheUJ1ZmZlci5pc1ZpZXcoZSl8fGlzSW5zdGFuY2UoZSxBcnJheUJ1ZmZlcikpe3JldHVybiBlLmJ5dGVMZW5ndGh9aWYodHlwZW9mIGUhPT1cInN0cmluZ1wiKXt0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgXCJzdHJpbmdcIiBhcmd1bWVudCBtdXN0IGJlIG9uZSBvZiB0eXBlIHN0cmluZywgQnVmZmVyLCBvciBBcnJheUJ1ZmZlci4gJytcIlJlY2VpdmVkIHR5cGUgXCIrdHlwZW9mIGUpfXZhciB0PWUubGVuZ3RoO3ZhciBmPWFyZ3VtZW50cy5sZW5ndGg+MiYmYXJndW1lbnRzWzJdPT09dHJ1ZTtpZighZiYmdD09PTApcmV0dXJuIDA7dmFyIG49ZmFsc2U7Zm9yKDs7KXtzd2l0Y2gocil7Y2FzZVwiYXNjaWlcIjpjYXNlXCJsYXRpbjFcIjpjYXNlXCJiaW5hcnlcIjpyZXR1cm4gdDtjYXNlXCJ1dGY4XCI6Y2FzZVwidXRmLThcIjpyZXR1cm4gdXRmOFRvQnl0ZXMoZSkubGVuZ3RoO2Nhc2VcInVjczJcIjpjYXNlXCJ1Y3MtMlwiOmNhc2VcInV0ZjE2bGVcIjpjYXNlXCJ1dGYtMTZsZVwiOnJldHVybiB0KjI7Y2FzZVwiaGV4XCI6cmV0dXJuIHQ+Pj4xO2Nhc2VcImJhc2U2NFwiOnJldHVybiBiYXNlNjRUb0J5dGVzKGUpLmxlbmd0aDtkZWZhdWx0OmlmKG4pe3JldHVybiBmPy0xOnV0ZjhUb0J5dGVzKGUpLmxlbmd0aH1yPShcIlwiK3IpLnRvTG93ZXJDYXNlKCk7bj10cnVlfX19QnVmZmVyLmJ5dGVMZW5ndGg9Ynl0ZUxlbmd0aDtmdW5jdGlvbiBzbG93VG9TdHJpbmcoZSxyLHQpe3ZhciBmPWZhbHNlO2lmKHI9PT11bmRlZmluZWR8fHI8MCl7cj0wfWlmKHI+dGhpcy5sZW5ndGgpe3JldHVyblwiXCJ9aWYodD09PXVuZGVmaW5lZHx8dD50aGlzLmxlbmd0aCl7dD10aGlzLmxlbmd0aH1pZih0PD0wKXtyZXR1cm5cIlwifXQ+Pj49MDtyPj4+PTA7aWYodDw9cil7cmV0dXJuXCJcIn1pZighZSllPVwidXRmOFwiO3doaWxlKHRydWUpe3N3aXRjaChlKXtjYXNlXCJoZXhcIjpyZXR1cm4gaGV4U2xpY2UodGhpcyxyLHQpO2Nhc2VcInV0ZjhcIjpjYXNlXCJ1dGYtOFwiOnJldHVybiB1dGY4U2xpY2UodGhpcyxyLHQpO2Nhc2VcImFzY2lpXCI6cmV0dXJuIGFzY2lpU2xpY2UodGhpcyxyLHQpO2Nhc2VcImxhdGluMVwiOmNhc2VcImJpbmFyeVwiOnJldHVybiBsYXRpbjFTbGljZSh0aGlzLHIsdCk7Y2FzZVwiYmFzZTY0XCI6cmV0dXJuIGJhc2U2NFNsaWNlKHRoaXMscix0KTtjYXNlXCJ1Y3MyXCI6Y2FzZVwidWNzLTJcIjpjYXNlXCJ1dGYxNmxlXCI6Y2FzZVwidXRmLTE2bGVcIjpyZXR1cm4gdXRmMTZsZVNsaWNlKHRoaXMscix0KTtkZWZhdWx0OmlmKGYpdGhyb3cgbmV3IFR5cGVFcnJvcihcIlVua25vd24gZW5jb2Rpbmc6IFwiK2UpO2U9KGUrXCJcIikudG9Mb3dlckNhc2UoKTtmPXRydWV9fX1CdWZmZXIucHJvdG90eXBlLl9pc0J1ZmZlcj10cnVlO2Z1bmN0aW9uIHN3YXAoZSxyLHQpe3ZhciBmPWVbcl07ZVtyXT1lW3RdO2VbdF09Zn1CdWZmZXIucHJvdG90eXBlLnN3YXAxNj1mdW5jdGlvbiBzd2FwMTYoKXt2YXIgZT10aGlzLmxlbmd0aDtpZihlJTIhPT0wKXt0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkJ1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAxNi1iaXRzXCIpfWZvcih2YXIgcj0wO3I8ZTtyKz0yKXtzd2FwKHRoaXMscixyKzEpfXJldHVybiB0aGlzfTtCdWZmZXIucHJvdG90eXBlLnN3YXAzMj1mdW5jdGlvbiBzd2FwMzIoKXt2YXIgZT10aGlzLmxlbmd0aDtpZihlJTQhPT0wKXt0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkJ1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAzMi1iaXRzXCIpfWZvcih2YXIgcj0wO3I8ZTtyKz00KXtzd2FwKHRoaXMscixyKzMpO3N3YXAodGhpcyxyKzEscisyKX1yZXR1cm4gdGhpc307QnVmZmVyLnByb3RvdHlwZS5zd2FwNjQ9ZnVuY3Rpb24gc3dhcDY0KCl7dmFyIGU9dGhpcy5sZW5ndGg7aWYoZSU4IT09MCl7dGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNjQtYml0c1wiKX1mb3IodmFyIHI9MDtyPGU7cis9OCl7c3dhcCh0aGlzLHIscis3KTtzd2FwKHRoaXMscisxLHIrNik7c3dhcCh0aGlzLHIrMixyKzUpO3N3YXAodGhpcyxyKzMscis0KX1yZXR1cm4gdGhpc307QnVmZmVyLnByb3RvdHlwZS50b1N0cmluZz1mdW5jdGlvbiB0b1N0cmluZygpe3ZhciBlPXRoaXMubGVuZ3RoO2lmKGU9PT0wKXJldHVyblwiXCI7aWYoYXJndW1lbnRzLmxlbmd0aD09PTApcmV0dXJuIHV0ZjhTbGljZSh0aGlzLDAsZSk7cmV0dXJuIHNsb3dUb1N0cmluZy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9O0J1ZmZlci5wcm90b3R5cGUudG9Mb2NhbGVTdHJpbmc9QnVmZmVyLnByb3RvdHlwZS50b1N0cmluZztCdWZmZXIucHJvdG90eXBlLmVxdWFscz1mdW5jdGlvbiBlcXVhbHMoZSl7aWYoIUJ1ZmZlci5pc0J1ZmZlcihlKSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiQXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlclwiKTtpZih0aGlzPT09ZSlyZXR1cm4gdHJ1ZTtyZXR1cm4gQnVmZmVyLmNvbXBhcmUodGhpcyxlKT09PTB9O0J1ZmZlci5wcm90b3R5cGUuaW5zcGVjdD1mdW5jdGlvbiBpbnNwZWN0KCl7dmFyIGU9XCJcIjt2YXIgdD1yLklOU1BFQ1RfTUFYX0JZVEVTO2U9dGhpcy50b1N0cmluZyhcImhleFwiLDAsdCkucmVwbGFjZSgvKC57Mn0pL2csXCIkMSBcIikudHJpbSgpO2lmKHRoaXMubGVuZ3RoPnQpZSs9XCIgLi4uIFwiO3JldHVyblwiPEJ1ZmZlciBcIitlK1wiPlwifTtpZihpKXtCdWZmZXIucHJvdG90eXBlW2ldPUJ1ZmZlci5wcm90b3R5cGUuaW5zcGVjdH1CdWZmZXIucHJvdG90eXBlLmNvbXBhcmU9ZnVuY3Rpb24gY29tcGFyZShlLHIsdCxmLG4pe2lmKGlzSW5zdGFuY2UoZSxVaW50OEFycmF5KSl7ZT1CdWZmZXIuZnJvbShlLGUub2Zmc2V0LGUuYnl0ZUxlbmd0aCl9aWYoIUJ1ZmZlci5pc0J1ZmZlcihlKSl7dGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIFwidGFyZ2V0XCIgYXJndW1lbnQgbXVzdCBiZSBvbmUgb2YgdHlwZSBCdWZmZXIgb3IgVWludDhBcnJheS4gJytcIlJlY2VpdmVkIHR5cGUgXCIrdHlwZW9mIGUpfWlmKHI9PT11bmRlZmluZWQpe3I9MH1pZih0PT09dW5kZWZpbmVkKXt0PWU/ZS5sZW5ndGg6MH1pZihmPT09dW5kZWZpbmVkKXtmPTB9aWYobj09PXVuZGVmaW5lZCl7bj10aGlzLmxlbmd0aH1pZihyPDB8fHQ+ZS5sZW5ndGh8fGY8MHx8bj50aGlzLmxlbmd0aCl7dGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJvdXQgb2YgcmFuZ2UgaW5kZXhcIil9aWYoZj49biYmcj49dCl7cmV0dXJuIDB9aWYoZj49bil7cmV0dXJuLTF9aWYocj49dCl7cmV0dXJuIDF9cj4+Pj0wO3Q+Pj49MDtmPj4+PTA7bj4+Pj0wO2lmKHRoaXM9PT1lKXJldHVybiAwO3ZhciBpPW4tZjt2YXIgbz10LXI7dmFyIHU9TWF0aC5taW4oaSxvKTt2YXIgYT10aGlzLnNsaWNlKGYsbik7dmFyIHM9ZS5zbGljZShyLHQpO2Zvcih2YXIgaD0wO2g8dTsrK2gpe2lmKGFbaF0hPT1zW2hdKXtpPWFbaF07bz1zW2hdO2JyZWFrfX1pZihpPG8pcmV0dXJuLTE7aWYobzxpKXJldHVybiAxO3JldHVybiAwfTtmdW5jdGlvbiBiaWRpcmVjdGlvbmFsSW5kZXhPZihlLHIsdCxmLG4pe2lmKGUubGVuZ3RoPT09MClyZXR1cm4tMTtpZih0eXBlb2YgdD09PVwic3RyaW5nXCIpe2Y9dDt0PTB9ZWxzZSBpZih0PjIxNDc0ODM2NDcpe3Q9MjE0NzQ4MzY0N31lbHNlIGlmKHQ8LTIxNDc0ODM2NDgpe3Q9LTIxNDc0ODM2NDh9dD0rdDtpZihudW1iZXJJc05hTih0KSl7dD1uPzA6ZS5sZW5ndGgtMX1pZih0PDApdD1lLmxlbmd0aCt0O2lmKHQ+PWUubGVuZ3RoKXtpZihuKXJldHVybi0xO2Vsc2UgdD1lLmxlbmd0aC0xfWVsc2UgaWYodDwwKXtpZihuKXQ9MDtlbHNlIHJldHVybi0xfWlmKHR5cGVvZiByPT09XCJzdHJpbmdcIil7cj1CdWZmZXIuZnJvbShyLGYpfWlmKEJ1ZmZlci5pc0J1ZmZlcihyKSl7aWYoci5sZW5ndGg9PT0wKXtyZXR1cm4tMX1yZXR1cm4gYXJyYXlJbmRleE9mKGUscix0LGYsbil9ZWxzZSBpZih0eXBlb2Ygcj09PVwibnVtYmVyXCIpe3I9ciYyNTU7aWYodHlwZW9mIFVpbnQ4QXJyYXkucHJvdG90eXBlLmluZGV4T2Y9PT1cImZ1bmN0aW9uXCIpe2lmKG4pe3JldHVybiBVaW50OEFycmF5LnByb3RvdHlwZS5pbmRleE9mLmNhbGwoZSxyLHQpfWVsc2V7cmV0dXJuIFVpbnQ4QXJyYXkucHJvdG90eXBlLmxhc3RJbmRleE9mLmNhbGwoZSxyLHQpfX1yZXR1cm4gYXJyYXlJbmRleE9mKGUsW3JdLHQsZixuKX10aHJvdyBuZXcgVHlwZUVycm9yKFwidmFsIG11c3QgYmUgc3RyaW5nLCBudW1iZXIgb3IgQnVmZmVyXCIpfWZ1bmN0aW9uIGFycmF5SW5kZXhPZihlLHIsdCxmLG4pe3ZhciBpPTE7dmFyIG89ZS5sZW5ndGg7dmFyIHU9ci5sZW5ndGg7aWYoZiE9PXVuZGVmaW5lZCl7Zj1TdHJpbmcoZikudG9Mb3dlckNhc2UoKTtpZihmPT09XCJ1Y3MyXCJ8fGY9PT1cInVjcy0yXCJ8fGY9PT1cInV0ZjE2bGVcInx8Zj09PVwidXRmLTE2bGVcIil7aWYoZS5sZW5ndGg8Mnx8ci5sZW5ndGg8Mil7cmV0dXJuLTF9aT0yO28vPTI7dS89Mjt0Lz0yfX1mdW5jdGlvbiByZWFkKGUscil7aWYoaT09PTEpe3JldHVybiBlW3JdfWVsc2V7cmV0dXJuIGUucmVhZFVJbnQxNkJFKHIqaSl9fXZhciBhO2lmKG4pe3ZhciBzPS0xO2ZvcihhPXQ7YTxvO2ErKyl7aWYocmVhZChlLGEpPT09cmVhZChyLHM9PT0tMT8wOmEtcykpe2lmKHM9PT0tMSlzPWE7aWYoYS1zKzE9PT11KXJldHVybiBzKml9ZWxzZXtpZihzIT09LTEpYS09YS1zO3M9LTF9fX1lbHNle2lmKHQrdT5vKXQ9by11O2ZvcihhPXQ7YT49MDthLS0pe3ZhciBoPXRydWU7Zm9yKHZhciBjPTA7Yzx1O2MrKyl7aWYocmVhZChlLGErYykhPT1yZWFkKHIsYykpe2g9ZmFsc2U7YnJlYWt9fWlmKGgpcmV0dXJuIGF9fXJldHVybi0xfUJ1ZmZlci5wcm90b3R5cGUuaW5jbHVkZXM9ZnVuY3Rpb24gaW5jbHVkZXMoZSxyLHQpe3JldHVybiB0aGlzLmluZGV4T2YoZSxyLHQpIT09LTF9O0J1ZmZlci5wcm90b3R5cGUuaW5kZXhPZj1mdW5jdGlvbiBpbmRleE9mKGUscix0KXtyZXR1cm4gYmlkaXJlY3Rpb25hbEluZGV4T2YodGhpcyxlLHIsdCx0cnVlKX07QnVmZmVyLnByb3RvdHlwZS5sYXN0SW5kZXhPZj1mdW5jdGlvbiBsYXN0SW5kZXhPZihlLHIsdCl7cmV0dXJuIGJpZGlyZWN0aW9uYWxJbmRleE9mKHRoaXMsZSxyLHQsZmFsc2UpfTtmdW5jdGlvbiBoZXhXcml0ZShlLHIsdCxmKXt0PU51bWJlcih0KXx8MDt2YXIgbj1lLmxlbmd0aC10O2lmKCFmKXtmPW59ZWxzZXtmPU51bWJlcihmKTtpZihmPm4pe2Y9bn19dmFyIGk9ci5sZW5ndGg7aWYoZj5pLzIpe2Y9aS8yfWZvcih2YXIgbz0wO288ZjsrK28pe3ZhciB1PXBhcnNlSW50KHIuc3Vic3RyKG8qMiwyKSwxNik7aWYobnVtYmVySXNOYU4odSkpcmV0dXJuIG87ZVt0K29dPXV9cmV0dXJuIG99ZnVuY3Rpb24gdXRmOFdyaXRlKGUscix0LGYpe3JldHVybiBibGl0QnVmZmVyKHV0ZjhUb0J5dGVzKHIsZS5sZW5ndGgtdCksZSx0LGYpfWZ1bmN0aW9uIGFzY2lpV3JpdGUoZSxyLHQsZil7cmV0dXJuIGJsaXRCdWZmZXIoYXNjaWlUb0J5dGVzKHIpLGUsdCxmKX1mdW5jdGlvbiBsYXRpbjFXcml0ZShlLHIsdCxmKXtyZXR1cm4gYXNjaWlXcml0ZShlLHIsdCxmKX1mdW5jdGlvbiBiYXNlNjRXcml0ZShlLHIsdCxmKXtyZXR1cm4gYmxpdEJ1ZmZlcihiYXNlNjRUb0J5dGVzKHIpLGUsdCxmKX1mdW5jdGlvbiB1Y3MyV3JpdGUoZSxyLHQsZil7cmV0dXJuIGJsaXRCdWZmZXIodXRmMTZsZVRvQnl0ZXMocixlLmxlbmd0aC10KSxlLHQsZil9QnVmZmVyLnByb3RvdHlwZS53cml0ZT1mdW5jdGlvbiB3cml0ZShlLHIsdCxmKXtpZihyPT09dW5kZWZpbmVkKXtmPVwidXRmOFwiO3Q9dGhpcy5sZW5ndGg7cj0wfWVsc2UgaWYodD09PXVuZGVmaW5lZCYmdHlwZW9mIHI9PT1cInN0cmluZ1wiKXtmPXI7dD10aGlzLmxlbmd0aDtyPTB9ZWxzZSBpZihpc0Zpbml0ZShyKSl7cj1yPj4+MDtpZihpc0Zpbml0ZSh0KSl7dD10Pj4+MDtpZihmPT09dW5kZWZpbmVkKWY9XCJ1dGY4XCJ9ZWxzZXtmPXQ7dD11bmRlZmluZWR9fWVsc2V7dGhyb3cgbmV3IEVycm9yKFwiQnVmZmVyLndyaXRlKHN0cmluZywgZW5jb2RpbmcsIG9mZnNldFssIGxlbmd0aF0pIGlzIG5vIGxvbmdlciBzdXBwb3J0ZWRcIil9dmFyIG49dGhpcy5sZW5ndGgtcjtpZih0PT09dW5kZWZpbmVkfHx0Pm4pdD1uO2lmKGUubGVuZ3RoPjAmJih0PDB8fHI8MCl8fHI+dGhpcy5sZW5ndGgpe3Rocm93IG5ldyBSYW5nZUVycm9yKFwiQXR0ZW1wdCB0byB3cml0ZSBvdXRzaWRlIGJ1ZmZlciBib3VuZHNcIil9aWYoIWYpZj1cInV0ZjhcIjt2YXIgaT1mYWxzZTtmb3IoOzspe3N3aXRjaChmKXtjYXNlXCJoZXhcIjpyZXR1cm4gaGV4V3JpdGUodGhpcyxlLHIsdCk7Y2FzZVwidXRmOFwiOmNhc2VcInV0Zi04XCI6cmV0dXJuIHV0ZjhXcml0ZSh0aGlzLGUscix0KTtjYXNlXCJhc2NpaVwiOnJldHVybiBhc2NpaVdyaXRlKHRoaXMsZSxyLHQpO2Nhc2VcImxhdGluMVwiOmNhc2VcImJpbmFyeVwiOnJldHVybiBsYXRpbjFXcml0ZSh0aGlzLGUscix0KTtjYXNlXCJiYXNlNjRcIjpyZXR1cm4gYmFzZTY0V3JpdGUodGhpcyxlLHIsdCk7Y2FzZVwidWNzMlwiOmNhc2VcInVjcy0yXCI6Y2FzZVwidXRmMTZsZVwiOmNhc2VcInV0Zi0xNmxlXCI6cmV0dXJuIHVjczJXcml0ZSh0aGlzLGUscix0KTtkZWZhdWx0OmlmKGkpdGhyb3cgbmV3IFR5cGVFcnJvcihcIlVua25vd24gZW5jb2Rpbmc6IFwiK2YpO2Y9KFwiXCIrZikudG9Mb3dlckNhc2UoKTtpPXRydWV9fX07QnVmZmVyLnByb3RvdHlwZS50b0pTT049ZnVuY3Rpb24gdG9KU09OKCl7cmV0dXJue3R5cGU6XCJCdWZmZXJcIixkYXRhOkFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHRoaXMuX2Fycnx8dGhpcywwKX19O2Z1bmN0aW9uIGJhc2U2NFNsaWNlKGUscix0KXtpZihyPT09MCYmdD09PWUubGVuZ3RoKXtyZXR1cm4gZi5mcm9tQnl0ZUFycmF5KGUpfWVsc2V7cmV0dXJuIGYuZnJvbUJ5dGVBcnJheShlLnNsaWNlKHIsdCkpfX1mdW5jdGlvbiB1dGY4U2xpY2UoZSxyLHQpe3Q9TWF0aC5taW4oZS5sZW5ndGgsdCk7dmFyIGY9W107dmFyIG49cjt3aGlsZShuPHQpe3ZhciBpPWVbbl07dmFyIG89bnVsbDt2YXIgdT1pPjIzOT80Omk+MjIzPzM6aT4xOTE/MjoxO2lmKG4rdTw9dCl7dmFyIGEscyxoLGM7c3dpdGNoKHUpe2Nhc2UgMTppZihpPDEyOCl7bz1pfWJyZWFrO2Nhc2UgMjphPWVbbisxXTtpZigoYSYxOTIpPT09MTI4KXtjPShpJjMxKTw8NnxhJjYzO2lmKGM+MTI3KXtvPWN9fWJyZWFrO2Nhc2UgMzphPWVbbisxXTtzPWVbbisyXTtpZigoYSYxOTIpPT09MTI4JiYocyYxOTIpPT09MTI4KXtjPShpJjE1KTw8MTJ8KGEmNjMpPDw2fHMmNjM7aWYoYz4yMDQ3JiYoYzw1NTI5Nnx8Yz41NzM0Mykpe289Y319YnJlYWs7Y2FzZSA0OmE9ZVtuKzFdO3M9ZVtuKzJdO2g9ZVtuKzNdO2lmKChhJjE5Mik9PT0xMjgmJihzJjE5Mik9PT0xMjgmJihoJjE5Mik9PT0xMjgpe2M9KGkmMTUpPDwxOHwoYSY2Myk8PDEyfChzJjYzKTw8NnxoJjYzO2lmKGM+NjU1MzUmJmM8MTExNDExMil7bz1jfX19fWlmKG89PT1udWxsKXtvPTY1NTMzO3U9MX1lbHNlIGlmKG8+NjU1MzUpe28tPTY1NTM2O2YucHVzaChvPj4+MTAmMTAyM3w1NTI5Nik7bz01NjMyMHxvJjEwMjN9Zi5wdXNoKG8pO24rPXV9cmV0dXJuIGRlY29kZUNvZGVQb2ludHNBcnJheShmKX12YXIgdT00MDk2O2Z1bmN0aW9uIGRlY29kZUNvZGVQb2ludHNBcnJheShlKXt2YXIgcj1lLmxlbmd0aDtpZihyPD11KXtyZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsZSl9dmFyIHQ9XCJcIjt2YXIgZj0wO3doaWxlKGY8cil7dCs9U3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsZS5zbGljZShmLGYrPXUpKX1yZXR1cm4gdH1mdW5jdGlvbiBhc2NpaVNsaWNlKGUscix0KXt2YXIgZj1cIlwiO3Q9TWF0aC5taW4oZS5sZW5ndGgsdCk7Zm9yKHZhciBuPXI7bjx0Oysrbil7Zis9U3RyaW5nLmZyb21DaGFyQ29kZShlW25dJjEyNyl9cmV0dXJuIGZ9ZnVuY3Rpb24gbGF0aW4xU2xpY2UoZSxyLHQpe3ZhciBmPVwiXCI7dD1NYXRoLm1pbihlLmxlbmd0aCx0KTtmb3IodmFyIG49cjtuPHQ7KytuKXtmKz1TdHJpbmcuZnJvbUNoYXJDb2RlKGVbbl0pfXJldHVybiBmfWZ1bmN0aW9uIGhleFNsaWNlKGUscix0KXt2YXIgZj1lLmxlbmd0aDtpZighcnx8cjwwKXI9MDtpZighdHx8dDwwfHx0PmYpdD1mO3ZhciBuPVwiXCI7Zm9yKHZhciBpPXI7aTx0OysraSl7bis9c1tlW2ldXX1yZXR1cm4gbn1mdW5jdGlvbiB1dGYxNmxlU2xpY2UoZSxyLHQpe3ZhciBmPWUuc2xpY2Uocix0KTt2YXIgbj1cIlwiO2Zvcih2YXIgaT0wO2k8Zi5sZW5ndGg7aSs9Mil7bis9U3RyaW5nLmZyb21DaGFyQ29kZShmW2ldK2ZbaSsxXSoyNTYpfXJldHVybiBufUJ1ZmZlci5wcm90b3R5cGUuc2xpY2U9ZnVuY3Rpb24gc2xpY2UoZSxyKXt2YXIgdD10aGlzLmxlbmd0aDtlPX5+ZTtyPXI9PT11bmRlZmluZWQ/dDp+fnI7aWYoZTwwKXtlKz10O2lmKGU8MCllPTB9ZWxzZSBpZihlPnQpe2U9dH1pZihyPDApe3IrPXQ7aWYocjwwKXI9MH1lbHNlIGlmKHI+dCl7cj10fWlmKHI8ZSlyPWU7dmFyIGY9dGhpcy5zdWJhcnJheShlLHIpO09iamVjdC5zZXRQcm90b3R5cGVPZihmLEJ1ZmZlci5wcm90b3R5cGUpO3JldHVybiBmfTtmdW5jdGlvbiBjaGVja09mZnNldChlLHIsdCl7aWYoZSUxIT09MHx8ZTwwKXRocm93IG5ldyBSYW5nZUVycm9yKFwib2Zmc2V0IGlzIG5vdCB1aW50XCIpO2lmKGUrcj50KXRocm93IG5ldyBSYW5nZUVycm9yKFwiVHJ5aW5nIHRvIGFjY2VzcyBiZXlvbmQgYnVmZmVyIGxlbmd0aFwiKX1CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50TEU9ZnVuY3Rpb24gcmVhZFVJbnRMRShlLHIsdCl7ZT1lPj4+MDtyPXI+Pj4wO2lmKCF0KWNoZWNrT2Zmc2V0KGUscix0aGlzLmxlbmd0aCk7dmFyIGY9dGhpc1tlXTt2YXIgbj0xO3ZhciBpPTA7d2hpbGUoKytpPHImJihuKj0yNTYpKXtmKz10aGlzW2UraV0qbn1yZXR1cm4gZn07QnVmZmVyLnByb3RvdHlwZS5yZWFkVUludEJFPWZ1bmN0aW9uIHJlYWRVSW50QkUoZSxyLHQpe2U9ZT4+PjA7cj1yPj4+MDtpZighdCl7Y2hlY2tPZmZzZXQoZSxyLHRoaXMubGVuZ3RoKX12YXIgZj10aGlzW2UrLS1yXTt2YXIgbj0xO3doaWxlKHI+MCYmKG4qPTI1Nikpe2YrPXRoaXNbZSstLXJdKm59cmV0dXJuIGZ9O0J1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQ4PWZ1bmN0aW9uIHJlYWRVSW50OChlLHIpe2U9ZT4+PjA7aWYoIXIpY2hlY2tPZmZzZXQoZSwxLHRoaXMubGVuZ3RoKTtyZXR1cm4gdGhpc1tlXX07QnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2TEU9ZnVuY3Rpb24gcmVhZFVJbnQxNkxFKGUscil7ZT1lPj4+MDtpZighciljaGVja09mZnNldChlLDIsdGhpcy5sZW5ndGgpO3JldHVybiB0aGlzW2VdfHRoaXNbZSsxXTw8OH07QnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2QkU9ZnVuY3Rpb24gcmVhZFVJbnQxNkJFKGUscil7ZT1lPj4+MDtpZighciljaGVja09mZnNldChlLDIsdGhpcy5sZW5ndGgpO3JldHVybiB0aGlzW2VdPDw4fHRoaXNbZSsxXX07QnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyTEU9ZnVuY3Rpb24gcmVhZFVJbnQzMkxFKGUscil7ZT1lPj4+MDtpZighciljaGVja09mZnNldChlLDQsdGhpcy5sZW5ndGgpO3JldHVybih0aGlzW2VdfHRoaXNbZSsxXTw8OHx0aGlzW2UrMl08PDE2KSt0aGlzW2UrM10qMTY3NzcyMTZ9O0J1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkJFPWZ1bmN0aW9uIHJlYWRVSW50MzJCRShlLHIpe2U9ZT4+PjA7aWYoIXIpY2hlY2tPZmZzZXQoZSw0LHRoaXMubGVuZ3RoKTtyZXR1cm4gdGhpc1tlXSoxNjc3NzIxNisodGhpc1tlKzFdPDwxNnx0aGlzW2UrMl08PDh8dGhpc1tlKzNdKX07QnVmZmVyLnByb3RvdHlwZS5yZWFkSW50TEU9ZnVuY3Rpb24gcmVhZEludExFKGUscix0KXtlPWU+Pj4wO3I9cj4+PjA7aWYoIXQpY2hlY2tPZmZzZXQoZSxyLHRoaXMubGVuZ3RoKTt2YXIgZj10aGlzW2VdO3ZhciBuPTE7dmFyIGk9MDt3aGlsZSgrK2k8ciYmKG4qPTI1Nikpe2YrPXRoaXNbZStpXSpufW4qPTEyODtpZihmPj1uKWYtPU1hdGgucG93KDIsOCpyKTtyZXR1cm4gZn07QnVmZmVyLnByb3RvdHlwZS5yZWFkSW50QkU9ZnVuY3Rpb24gcmVhZEludEJFKGUscix0KXtlPWU+Pj4wO3I9cj4+PjA7aWYoIXQpY2hlY2tPZmZzZXQoZSxyLHRoaXMubGVuZ3RoKTt2YXIgZj1yO3ZhciBuPTE7dmFyIGk9dGhpc1tlKy0tZl07d2hpbGUoZj4wJiYobio9MjU2KSl7aSs9dGhpc1tlKy0tZl0qbn1uKj0xMjg7aWYoaT49bilpLT1NYXRoLnBvdygyLDgqcik7cmV0dXJuIGl9O0J1ZmZlci5wcm90b3R5cGUucmVhZEludDg9ZnVuY3Rpb24gcmVhZEludDgoZSxyKXtlPWU+Pj4wO2lmKCFyKWNoZWNrT2Zmc2V0KGUsMSx0aGlzLmxlbmd0aCk7aWYoISh0aGlzW2VdJjEyOCkpcmV0dXJuIHRoaXNbZV07cmV0dXJuKDI1NS10aGlzW2VdKzEpKi0xfTtCdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkxFPWZ1bmN0aW9uIHJlYWRJbnQxNkxFKGUscil7ZT1lPj4+MDtpZighciljaGVja09mZnNldChlLDIsdGhpcy5sZW5ndGgpO3ZhciB0PXRoaXNbZV18dGhpc1tlKzFdPDw4O3JldHVybiB0JjMyNzY4P3R8NDI5NDkwMTc2MDp0fTtCdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkJFPWZ1bmN0aW9uIHJlYWRJbnQxNkJFKGUscil7ZT1lPj4+MDtpZighciljaGVja09mZnNldChlLDIsdGhpcy5sZW5ndGgpO3ZhciB0PXRoaXNbZSsxXXx0aGlzW2VdPDw4O3JldHVybiB0JjMyNzY4P3R8NDI5NDkwMTc2MDp0fTtCdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkxFPWZ1bmN0aW9uIHJlYWRJbnQzMkxFKGUscil7ZT1lPj4+MDtpZighciljaGVja09mZnNldChlLDQsdGhpcy5sZW5ndGgpO3JldHVybiB0aGlzW2VdfHRoaXNbZSsxXTw8OHx0aGlzW2UrMl08PDE2fHRoaXNbZSszXTw8MjR9O0J1ZmZlci5wcm90b3R5cGUucmVhZEludDMyQkU9ZnVuY3Rpb24gcmVhZEludDMyQkUoZSxyKXtlPWU+Pj4wO2lmKCFyKWNoZWNrT2Zmc2V0KGUsNCx0aGlzLmxlbmd0aCk7cmV0dXJuIHRoaXNbZV08PDI0fHRoaXNbZSsxXTw8MTZ8dGhpc1tlKzJdPDw4fHRoaXNbZSszXX07QnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRMRT1mdW5jdGlvbiByZWFkRmxvYXRMRShlLHIpe2U9ZT4+PjA7aWYoIXIpY2hlY2tPZmZzZXQoZSw0LHRoaXMubGVuZ3RoKTtyZXR1cm4gbi5yZWFkKHRoaXMsZSx0cnVlLDIzLDQpfTtCdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdEJFPWZ1bmN0aW9uIHJlYWRGbG9hdEJFKGUscil7ZT1lPj4+MDtpZighciljaGVja09mZnNldChlLDQsdGhpcy5sZW5ndGgpO3JldHVybiBuLnJlYWQodGhpcyxlLGZhbHNlLDIzLDQpfTtCdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVMRT1mdW5jdGlvbiByZWFkRG91YmxlTEUoZSxyKXtlPWU+Pj4wO2lmKCFyKWNoZWNrT2Zmc2V0KGUsOCx0aGlzLmxlbmd0aCk7cmV0dXJuIG4ucmVhZCh0aGlzLGUsdHJ1ZSw1Miw4KX07QnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlQkU9ZnVuY3Rpb24gcmVhZERvdWJsZUJFKGUscil7ZT1lPj4+MDtpZighciljaGVja09mZnNldChlLDgsdGhpcy5sZW5ndGgpO3JldHVybiBuLnJlYWQodGhpcyxlLGZhbHNlLDUyLDgpfTtmdW5jdGlvbiBjaGVja0ludChlLHIsdCxmLG4saSl7aWYoIUJ1ZmZlci5pc0J1ZmZlcihlKSl0aHJvdyBuZXcgVHlwZUVycm9yKCdcImJ1ZmZlclwiIGFyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXIgaW5zdGFuY2UnKTtpZihyPm58fHI8aSl0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCJ2YWx1ZVwiIGFyZ3VtZW50IGlzIG91dCBvZiBib3VuZHMnKTtpZih0K2Y+ZS5sZW5ndGgpdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbmRleCBvdXQgb2YgcmFuZ2VcIil9QnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnRMRT1mdW5jdGlvbiB3cml0ZVVJbnRMRShlLHIsdCxmKXtlPStlO3I9cj4+PjA7dD10Pj4+MDtpZighZil7dmFyIG49TWF0aC5wb3coMiw4KnQpLTE7Y2hlY2tJbnQodGhpcyxlLHIsdCxuLDApfXZhciBpPTE7dmFyIG89MDt0aGlzW3JdPWUmMjU1O3doaWxlKCsrbzx0JiYoaSo9MjU2KSl7dGhpc1tyK29dPWUvaSYyNTV9cmV0dXJuIHIrdH07QnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnRCRT1mdW5jdGlvbiB3cml0ZVVJbnRCRShlLHIsdCxmKXtlPStlO3I9cj4+PjA7dD10Pj4+MDtpZighZil7dmFyIG49TWF0aC5wb3coMiw4KnQpLTE7Y2hlY2tJbnQodGhpcyxlLHIsdCxuLDApfXZhciBpPXQtMTt2YXIgbz0xO3RoaXNbcitpXT1lJjI1NTt3aGlsZSgtLWk+PTAmJihvKj0yNTYpKXt0aGlzW3IraV09ZS9vJjI1NX1yZXR1cm4gcit0fTtCdWZmZXIucHJvdG90eXBlLndyaXRlVUludDg9ZnVuY3Rpb24gd3JpdGVVSW50OChlLHIsdCl7ZT0rZTtyPXI+Pj4wO2lmKCF0KWNoZWNrSW50KHRoaXMsZSxyLDEsMjU1LDApO3RoaXNbcl09ZSYyNTU7cmV0dXJuIHIrMX07QnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkxFPWZ1bmN0aW9uIHdyaXRlVUludDE2TEUoZSxyLHQpe2U9K2U7cj1yPj4+MDtpZighdCljaGVja0ludCh0aGlzLGUsciwyLDY1NTM1LDApO3RoaXNbcl09ZSYyNTU7dGhpc1tyKzFdPWU+Pj44O3JldHVybiByKzJ9O0J1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZCRT1mdW5jdGlvbiB3cml0ZVVJbnQxNkJFKGUscix0KXtlPStlO3I9cj4+PjA7aWYoIXQpY2hlY2tJbnQodGhpcyxlLHIsMiw2NTUzNSwwKTt0aGlzW3JdPWU+Pj44O3RoaXNbcisxXT1lJjI1NTtyZXR1cm4gcisyfTtCdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyTEU9ZnVuY3Rpb24gd3JpdGVVSW50MzJMRShlLHIsdCl7ZT0rZTtyPXI+Pj4wO2lmKCF0KWNoZWNrSW50KHRoaXMsZSxyLDQsNDI5NDk2NzI5NSwwKTt0aGlzW3IrM109ZT4+PjI0O3RoaXNbcisyXT1lPj4+MTY7dGhpc1tyKzFdPWU+Pj44O3RoaXNbcl09ZSYyNTU7cmV0dXJuIHIrNH07QnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkJFPWZ1bmN0aW9uIHdyaXRlVUludDMyQkUoZSxyLHQpe2U9K2U7cj1yPj4+MDtpZighdCljaGVja0ludCh0aGlzLGUsciw0LDQyOTQ5NjcyOTUsMCk7dGhpc1tyXT1lPj4+MjQ7dGhpc1tyKzFdPWU+Pj4xNjt0aGlzW3IrMl09ZT4+Pjg7dGhpc1tyKzNdPWUmMjU1O3JldHVybiByKzR9O0J1ZmZlci5wcm90b3R5cGUud3JpdGVJbnRMRT1mdW5jdGlvbiB3cml0ZUludExFKGUscix0LGYpe2U9K2U7cj1yPj4+MDtpZighZil7dmFyIG49TWF0aC5wb3coMiw4KnQtMSk7Y2hlY2tJbnQodGhpcyxlLHIsdCxuLTEsLW4pfXZhciBpPTA7dmFyIG89MTt2YXIgdT0wO3RoaXNbcl09ZSYyNTU7d2hpbGUoKytpPHQmJihvKj0yNTYpKXtpZihlPDAmJnU9PT0wJiZ0aGlzW3IraS0xXSE9PTApe3U9MX10aGlzW3IraV09KGUvbz4+MCktdSYyNTV9cmV0dXJuIHIrdH07QnVmZmVyLnByb3RvdHlwZS53cml0ZUludEJFPWZ1bmN0aW9uIHdyaXRlSW50QkUoZSxyLHQsZil7ZT0rZTtyPXI+Pj4wO2lmKCFmKXt2YXIgbj1NYXRoLnBvdygyLDgqdC0xKTtjaGVja0ludCh0aGlzLGUscix0LG4tMSwtbil9dmFyIGk9dC0xO3ZhciBvPTE7dmFyIHU9MDt0aGlzW3IraV09ZSYyNTU7d2hpbGUoLS1pPj0wJiYobyo9MjU2KSl7aWYoZTwwJiZ1PT09MCYmdGhpc1tyK2krMV0hPT0wKXt1PTF9dGhpc1tyK2ldPShlL28+PjApLXUmMjU1fXJldHVybiByK3R9O0J1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQ4PWZ1bmN0aW9uIHdyaXRlSW50OChlLHIsdCl7ZT0rZTtyPXI+Pj4wO2lmKCF0KWNoZWNrSW50KHRoaXMsZSxyLDEsMTI3LC0xMjgpO2lmKGU8MCllPTI1NStlKzE7dGhpc1tyXT1lJjI1NTtyZXR1cm4gcisxfTtCdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZMRT1mdW5jdGlvbiB3cml0ZUludDE2TEUoZSxyLHQpe2U9K2U7cj1yPj4+MDtpZighdCljaGVja0ludCh0aGlzLGUsciwyLDMyNzY3LC0zMjc2OCk7dGhpc1tyXT1lJjI1NTt0aGlzW3IrMV09ZT4+Pjg7cmV0dXJuIHIrMn07QnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2QkU9ZnVuY3Rpb24gd3JpdGVJbnQxNkJFKGUscix0KXtlPStlO3I9cj4+PjA7aWYoIXQpY2hlY2tJbnQodGhpcyxlLHIsMiwzMjc2NywtMzI3NjgpO3RoaXNbcl09ZT4+Pjg7dGhpc1tyKzFdPWUmMjU1O3JldHVybiByKzJ9O0J1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkxFPWZ1bmN0aW9uIHdyaXRlSW50MzJMRShlLHIsdCl7ZT0rZTtyPXI+Pj4wO2lmKCF0KWNoZWNrSW50KHRoaXMsZSxyLDQsMjE0NzQ4MzY0NywtMjE0NzQ4MzY0OCk7dGhpc1tyXT1lJjI1NTt0aGlzW3IrMV09ZT4+Pjg7dGhpc1tyKzJdPWU+Pj4xNjt0aGlzW3IrM109ZT4+PjI0O3JldHVybiByKzR9O0J1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkJFPWZ1bmN0aW9uIHdyaXRlSW50MzJCRShlLHIsdCl7ZT0rZTtyPXI+Pj4wO2lmKCF0KWNoZWNrSW50KHRoaXMsZSxyLDQsMjE0NzQ4MzY0NywtMjE0NzQ4MzY0OCk7aWYoZTwwKWU9NDI5NDk2NzI5NStlKzE7dGhpc1tyXT1lPj4+MjQ7dGhpc1tyKzFdPWU+Pj4xNjt0aGlzW3IrMl09ZT4+Pjg7dGhpc1tyKzNdPWUmMjU1O3JldHVybiByKzR9O2Z1bmN0aW9uIGNoZWNrSUVFRTc1NChlLHIsdCxmLG4saSl7aWYodCtmPmUubGVuZ3RoKXRocm93IG5ldyBSYW5nZUVycm9yKFwiSW5kZXggb3V0IG9mIHJhbmdlXCIpO2lmKHQ8MCl0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkluZGV4IG91dCBvZiByYW5nZVwiKX1mdW5jdGlvbiB3cml0ZUZsb2F0KGUscix0LGYsaSl7cj0rcjt0PXQ+Pj4wO2lmKCFpKXtjaGVja0lFRUU3NTQoZSxyLHQsNCwzNDAyODIzNDY2Mzg1Mjg4NmUyMiwtMzQwMjgyMzQ2NjM4NTI4ODZlMjIpfW4ud3JpdGUoZSxyLHQsZiwyMyw0KTtyZXR1cm4gdCs0fUJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdExFPWZ1bmN0aW9uIHdyaXRlRmxvYXRMRShlLHIsdCl7cmV0dXJuIHdyaXRlRmxvYXQodGhpcyxlLHIsdHJ1ZSx0KX07QnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0QkU9ZnVuY3Rpb24gd3JpdGVGbG9hdEJFKGUscix0KXtyZXR1cm4gd3JpdGVGbG9hdCh0aGlzLGUscixmYWxzZSx0KX07ZnVuY3Rpb24gd3JpdGVEb3VibGUoZSxyLHQsZixpKXtyPStyO3Q9dD4+PjA7aWYoIWkpe2NoZWNrSUVFRTc1NChlLHIsdCw4LDE3OTc2OTMxMzQ4NjIzMTU3ZTI5MiwtMTc5NzY5MzEzNDg2MjMxNTdlMjkyKX1uLndyaXRlKGUscix0LGYsNTIsOCk7cmV0dXJuIHQrOH1CdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlTEU9ZnVuY3Rpb24gd3JpdGVEb3VibGVMRShlLHIsdCl7cmV0dXJuIHdyaXRlRG91YmxlKHRoaXMsZSxyLHRydWUsdCl9O0J1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVCRT1mdW5jdGlvbiB3cml0ZURvdWJsZUJFKGUscix0KXtyZXR1cm4gd3JpdGVEb3VibGUodGhpcyxlLHIsZmFsc2UsdCl9O0J1ZmZlci5wcm90b3R5cGUuY29weT1mdW5jdGlvbiBjb3B5KGUscix0LGYpe2lmKCFCdWZmZXIuaXNCdWZmZXIoZSkpdGhyb3cgbmV3IFR5cGVFcnJvcihcImFyZ3VtZW50IHNob3VsZCBiZSBhIEJ1ZmZlclwiKTtpZighdCl0PTA7aWYoIWYmJmYhPT0wKWY9dGhpcy5sZW5ndGg7aWYocj49ZS5sZW5ndGgpcj1lLmxlbmd0aDtpZighcilyPTA7aWYoZj4wJiZmPHQpZj10O2lmKGY9PT10KXJldHVybiAwO2lmKGUubGVuZ3RoPT09MHx8dGhpcy5sZW5ndGg9PT0wKXJldHVybiAwO2lmKHI8MCl7dGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJ0YXJnZXRTdGFydCBvdXQgb2YgYm91bmRzXCIpfWlmKHQ8MHx8dD49dGhpcy5sZW5ndGgpdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbmRleCBvdXQgb2YgcmFuZ2VcIik7aWYoZjwwKXRocm93IG5ldyBSYW5nZUVycm9yKFwic291cmNlRW5kIG91dCBvZiBib3VuZHNcIik7aWYoZj50aGlzLmxlbmd0aClmPXRoaXMubGVuZ3RoO2lmKGUubGVuZ3RoLXI8Zi10KXtmPWUubGVuZ3RoLXIrdH12YXIgbj1mLXQ7aWYodGhpcz09PWUmJnR5cGVvZiBVaW50OEFycmF5LnByb3RvdHlwZS5jb3B5V2l0aGluPT09XCJmdW5jdGlvblwiKXt0aGlzLmNvcHlXaXRoaW4ocix0LGYpfWVsc2UgaWYodGhpcz09PWUmJnQ8ciYmcjxmKXtmb3IodmFyIGk9bi0xO2k+PTA7LS1pKXtlW2krcl09dGhpc1tpK3RdfX1lbHNle1VpbnQ4QXJyYXkucHJvdG90eXBlLnNldC5jYWxsKGUsdGhpcy5zdWJhcnJheSh0LGYpLHIpfXJldHVybiBufTtCdWZmZXIucHJvdG90eXBlLmZpbGw9ZnVuY3Rpb24gZmlsbChlLHIsdCxmKXtpZih0eXBlb2YgZT09PVwic3RyaW5nXCIpe2lmKHR5cGVvZiByPT09XCJzdHJpbmdcIil7Zj1yO3I9MDt0PXRoaXMubGVuZ3RofWVsc2UgaWYodHlwZW9mIHQ9PT1cInN0cmluZ1wiKXtmPXQ7dD10aGlzLmxlbmd0aH1pZihmIT09dW5kZWZpbmVkJiZ0eXBlb2YgZiE9PVwic3RyaW5nXCIpe3Rocm93IG5ldyBUeXBlRXJyb3IoXCJlbmNvZGluZyBtdXN0IGJlIGEgc3RyaW5nXCIpfWlmKHR5cGVvZiBmPT09XCJzdHJpbmdcIiYmIUJ1ZmZlci5pc0VuY29kaW5nKGYpKXt0aHJvdyBuZXcgVHlwZUVycm9yKFwiVW5rbm93biBlbmNvZGluZzogXCIrZil9aWYoZS5sZW5ndGg9PT0xKXt2YXIgbj1lLmNoYXJDb2RlQXQoMCk7aWYoZj09PVwidXRmOFwiJiZuPDEyOHx8Zj09PVwibGF0aW4xXCIpe2U9bn19fWVsc2UgaWYodHlwZW9mIGU9PT1cIm51bWJlclwiKXtlPWUmMjU1fWVsc2UgaWYodHlwZW9mIGU9PT1cImJvb2xlYW5cIil7ZT1OdW1iZXIoZSl9aWYocjwwfHx0aGlzLmxlbmd0aDxyfHx0aGlzLmxlbmd0aDx0KXt0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIk91dCBvZiByYW5nZSBpbmRleFwiKX1pZih0PD1yKXtyZXR1cm4gdGhpc31yPXI+Pj4wO3Q9dD09PXVuZGVmaW5lZD90aGlzLmxlbmd0aDp0Pj4+MDtpZighZSllPTA7dmFyIGk7aWYodHlwZW9mIGU9PT1cIm51bWJlclwiKXtmb3IoaT1yO2k8dDsrK2kpe3RoaXNbaV09ZX19ZWxzZXt2YXIgbz1CdWZmZXIuaXNCdWZmZXIoZSk/ZTpCdWZmZXIuZnJvbShlLGYpO3ZhciB1PW8ubGVuZ3RoO2lmKHU9PT0wKXt0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgdmFsdWUgXCInK2UrJ1wiIGlzIGludmFsaWQgZm9yIGFyZ3VtZW50IFwidmFsdWVcIicpfWZvcihpPTA7aTx0LXI7KytpKXt0aGlzW2krcl09b1tpJXVdfX1yZXR1cm4gdGhpc307dmFyIGE9L1teKy8wLTlBLVphLXotX10vZztmdW5jdGlvbiBiYXNlNjRjbGVhbihlKXtlPWUuc3BsaXQoXCI9XCIpWzBdO2U9ZS50cmltKCkucmVwbGFjZShhLFwiXCIpO2lmKGUubGVuZ3RoPDIpcmV0dXJuXCJcIjt3aGlsZShlLmxlbmd0aCU0IT09MCl7ZT1lK1wiPVwifXJldHVybiBlfWZ1bmN0aW9uIHV0ZjhUb0J5dGVzKGUscil7cj1yfHxJbmZpbml0eTt2YXIgdDt2YXIgZj1lLmxlbmd0aDt2YXIgbj1udWxsO3ZhciBpPVtdO2Zvcih2YXIgbz0wO288ZjsrK28pe3Q9ZS5jaGFyQ29kZUF0KG8pO2lmKHQ+NTUyOTUmJnQ8NTczNDQpe2lmKCFuKXtpZih0PjU2MzE5KXtpZigoci09Myk+LTEpaS5wdXNoKDIzOSwxOTEsMTg5KTtjb250aW51ZX1lbHNlIGlmKG8rMT09PWYpe2lmKChyLT0zKT4tMSlpLnB1c2goMjM5LDE5MSwxODkpO2NvbnRpbnVlfW49dDtjb250aW51ZX1pZih0PDU2MzIwKXtpZigoci09Myk+LTEpaS5wdXNoKDIzOSwxOTEsMTg5KTtuPXQ7Y29udGludWV9dD0obi01NTI5Njw8MTB8dC01NjMyMCkrNjU1MzZ9ZWxzZSBpZihuKXtpZigoci09Myk+LTEpaS5wdXNoKDIzOSwxOTEsMTg5KX1uPW51bGw7aWYodDwxMjgpe2lmKChyLT0xKTwwKWJyZWFrO2kucHVzaCh0KX1lbHNlIGlmKHQ8MjA0OCl7aWYoKHItPTIpPDApYnJlYWs7aS5wdXNoKHQ+PjZ8MTkyLHQmNjN8MTI4KX1lbHNlIGlmKHQ8NjU1MzYpe2lmKChyLT0zKTwwKWJyZWFrO2kucHVzaCh0Pj4xMnwyMjQsdD4+NiY2M3wxMjgsdCY2M3wxMjgpfWVsc2UgaWYodDwxMTE0MTEyKXtpZigoci09NCk8MClicmVhaztpLnB1c2godD4+MTh8MjQwLHQ+PjEyJjYzfDEyOCx0Pj42JjYzfDEyOCx0JjYzfDEyOCl9ZWxzZXt0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGNvZGUgcG9pbnRcIil9fXJldHVybiBpfWZ1bmN0aW9uIGFzY2lpVG9CeXRlcyhlKXt2YXIgcj1bXTtmb3IodmFyIHQ9MDt0PGUubGVuZ3RoOysrdCl7ci5wdXNoKGUuY2hhckNvZGVBdCh0KSYyNTUpfXJldHVybiByfWZ1bmN0aW9uIHV0ZjE2bGVUb0J5dGVzKGUscil7dmFyIHQsZixuO3ZhciBpPVtdO2Zvcih2YXIgbz0wO288ZS5sZW5ndGg7KytvKXtpZigoci09Mik8MClicmVhazt0PWUuY2hhckNvZGVBdChvKTtmPXQ+Pjg7bj10JTI1NjtpLnB1c2gobik7aS5wdXNoKGYpfXJldHVybiBpfWZ1bmN0aW9uIGJhc2U2NFRvQnl0ZXMoZSl7cmV0dXJuIGYudG9CeXRlQXJyYXkoYmFzZTY0Y2xlYW4oZSkpfWZ1bmN0aW9uIGJsaXRCdWZmZXIoZSxyLHQsZil7Zm9yKHZhciBuPTA7bjxmOysrbil7aWYobit0Pj1yLmxlbmd0aHx8bj49ZS5sZW5ndGgpYnJlYWs7cltuK3RdPWVbbl19cmV0dXJuIG59ZnVuY3Rpb24gaXNJbnN0YW5jZShlLHIpe3JldHVybiBlIGluc3RhbmNlb2Ygcnx8ZSE9bnVsbCYmZS5jb25zdHJ1Y3RvciE9bnVsbCYmZS5jb25zdHJ1Y3Rvci5uYW1lIT1udWxsJiZlLmNvbnN0cnVjdG9yLm5hbWU9PT1yLm5hbWV9ZnVuY3Rpb24gbnVtYmVySXNOYU4oZSl7cmV0dXJuIGUhPT1lfXZhciBzPWZ1bmN0aW9uKCl7dmFyIGU9XCIwMTIzNDU2Nzg5YWJjZGVmXCI7dmFyIHI9bmV3IEFycmF5KDI1Nik7Zm9yKHZhciB0PTA7dDwxNjsrK3Qpe3ZhciBmPXQqMTY7Zm9yKHZhciBuPTA7bjwxNjsrK24pe3JbZituXT1lW3RdK2Vbbl19fXJldHVybiByfSgpfSw3ODM6ZnVuY3Rpb24oZSxyKXtcbi8qISBpZWVlNzU0LiBCU0QtMy1DbGF1c2UgTGljZW5zZS4gRmVyb3NzIEFib3VraGFkaWplaCA8aHR0cHM6Ly9mZXJvc3Mub3JnL29wZW5zb3VyY2U+ICovXG5yLnJlYWQ9ZnVuY3Rpb24oZSxyLHQsZixuKXt2YXIgaSxvO3ZhciB1PW4qOC1mLTE7dmFyIGE9KDE8PHUpLTE7dmFyIHM9YT4+MTt2YXIgaD0tNzt2YXIgYz10P24tMTowO3ZhciBsPXQ/LTE6MTt2YXIgcD1lW3IrY107Yys9bDtpPXAmKDE8PC1oKS0xO3A+Pj0taDtoKz11O2Zvcig7aD4wO2k9aSoyNTYrZVtyK2NdLGMrPWwsaC09OCl7fW89aSYoMTw8LWgpLTE7aT4+PS1oO2grPWY7Zm9yKDtoPjA7bz1vKjI1NitlW3IrY10sYys9bCxoLT04KXt9aWYoaT09PTApe2k9MS1zfWVsc2UgaWYoaT09PWEpe3JldHVybiBvP05hTjoocD8tMToxKSpJbmZpbml0eX1lbHNle289bytNYXRoLnBvdygyLGYpO2k9aS1zfXJldHVybihwPy0xOjEpKm8qTWF0aC5wb3coMixpLWYpfTtyLndyaXRlPWZ1bmN0aW9uKGUscix0LGYsbixpKXt2YXIgbyx1LGE7dmFyIHM9aSo4LW4tMTt2YXIgaD0oMTw8cyktMTt2YXIgYz1oPj4xO3ZhciBsPW49PT0yMz9NYXRoLnBvdygyLC0yNCktTWF0aC5wb3coMiwtNzcpOjA7dmFyIHA9Zj8wOmktMTt2YXIgeT1mPzE6LTE7dmFyIGc9cjwwfHxyPT09MCYmMS9yPDA/MTowO3I9TWF0aC5hYnMocik7aWYoaXNOYU4ocil8fHI9PT1JbmZpbml0eSl7dT1pc05hTihyKT8xOjA7bz1ofWVsc2V7bz1NYXRoLmZsb29yKE1hdGgubG9nKHIpL01hdGguTE4yKTtpZihyKihhPU1hdGgucG93KDIsLW8pKTwxKXtvLS07YSo9Mn1pZihvK2M+PTEpe3IrPWwvYX1lbHNle3IrPWwqTWF0aC5wb3coMiwxLWMpfWlmKHIqYT49Mil7bysrO2EvPTJ9aWYobytjPj1oKXt1PTA7bz1ofWVsc2UgaWYobytjPj0xKXt1PShyKmEtMSkqTWF0aC5wb3coMixuKTtvPW8rY31lbHNle3U9cipNYXRoLnBvdygyLGMtMSkqTWF0aC5wb3coMixuKTtvPTB9fWZvcig7bj49ODtlW3QrcF09dSYyNTUscCs9eSx1Lz0yNTYsbi09OCl7fW89bzw8bnx1O3MrPW47Zm9yKDtzPjA7ZVt0K3BdPW8mMjU1LHArPXksby89MjU2LHMtPTgpe31lW3QrcC15XXw9ZyoxMjh9fX07dmFyIHI9e307ZnVuY3Rpb24gX19uY2N3cGNrX3JlcXVpcmVfXyh0KXt2YXIgZj1yW3RdO2lmKGYhPT11bmRlZmluZWQpe3JldHVybiBmLmV4cG9ydHN9dmFyIG49clt0XT17ZXhwb3J0czp7fX07dmFyIGk9dHJ1ZTt0cnl7ZVt0XShuLG4uZXhwb3J0cyxfX25jY3dwY2tfcmVxdWlyZV9fKTtpPWZhbHNlfWZpbmFsbHl7aWYoaSlkZWxldGUgclt0XX1yZXR1cm4gbi5leHBvcnRzfWlmKHR5cGVvZiBfX25jY3dwY2tfcmVxdWlyZV9fIT09XCJ1bmRlZmluZWRcIilfX25jY3dwY2tfcmVxdWlyZV9fLmFiPV9fZGlybmFtZStcIi9cIjt2YXIgdD1fX25jY3dwY2tfcmVxdWlyZV9fKDcyKTttb2R1bGUuZXhwb3J0cz10fSkoKTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/buffer/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/use-sync-external-store/cjs/use-sync-external-store-shim.development.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/use-sync-external-store/cjs/use-sync-external-store-shim.development.js ***!
  \**********************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/**\n * @license React\n * use-sync-external-store-shim.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\nif (true) {\n  (function() {\n\n          'use strict';\n\n/* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */\nif (\n  typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined' &&\n  typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart ===\n    'function'\n) {\n  __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());\n}\n          var React = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n\nvar ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\n\nfunction error(format) {\n  {\n    {\n      for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n        args[_key2 - 1] = arguments[_key2];\n      }\n\n      printWarning('error', format, args);\n    }\n  }\n}\n\nfunction printWarning(level, format, args) {\n  // When changing this logic, you might want to also\n  // update consoleWithStackDev.www.js as well.\n  {\n    var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\n    var stack = ReactDebugCurrentFrame.getStackAddendum();\n\n    if (stack !== '') {\n      format += '%s';\n      args = args.concat([stack]);\n    } // eslint-disable-next-line react-internal/safe-string-coercion\n\n\n    var argsWithFormat = args.map(function (item) {\n      return String(item);\n    }); // Careful: RN currently depends on this prefix\n\n    argsWithFormat.unshift('Warning: ' + format); // We intentionally don't use spread (or .apply) directly because it\n    // breaks IE9: https://github.com/facebook/react/issues/13610\n    // eslint-disable-next-line react-internal/no-production-logging\n\n    Function.prototype.apply.call(console[level], console, argsWithFormat);\n  }\n}\n\n/**\n * inlined Object.is polyfill to avoid requiring consumers ship their own\n * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is\n */\nfunction is(x, y) {\n  return x === y && (x !== 0 || 1 / x === 1 / y) || x !== x && y !== y // eslint-disable-line no-self-compare\n  ;\n}\n\nvar objectIs = typeof Object.is === 'function' ? Object.is : is;\n\n// dispatch for CommonJS interop named imports.\n\nvar useState = React.useState,\n    useEffect = React.useEffect,\n    useLayoutEffect = React.useLayoutEffect,\n    useDebugValue = React.useDebugValue;\nvar didWarnOld18Alpha = false;\nvar didWarnUncachedGetSnapshot = false; // Disclaimer: This shim breaks many of the rules of React, and only works\n// because of a very particular set of implementation details and assumptions\n// -- change any one of them and it will break. The most important assumption\n// is that updates are always synchronous, because concurrent rendering is\n// only available in versions of React that also have a built-in\n// useSyncExternalStore API. And we only use this shim when the built-in API\n// does not exist.\n//\n// Do not assume that the clever hacks used by this hook also work in general.\n// The point of this shim is to replace the need for hacks by other libraries.\n\nfunction useSyncExternalStore(subscribe, getSnapshot, // Note: The shim does not use getServerSnapshot, because pre-18 versions of\n// React do not expose a way to check if we're hydrating. So users of the shim\n// will need to track that themselves and return the correct value\n// from `getSnapshot`.\ngetServerSnapshot) {\n  {\n    if (!didWarnOld18Alpha) {\n      if (React.startTransition !== undefined) {\n        didWarnOld18Alpha = true;\n\n        error('You are using an outdated, pre-release alpha of React 18 that ' + 'does not support useSyncExternalStore. The ' + 'use-sync-external-store shim will not work correctly. Upgrade ' + 'to a newer pre-release.');\n      }\n    }\n  } // Read the current snapshot from the store on every render. Again, this\n  // breaks the rules of React, and only works here because of specific\n  // implementation details, most importantly that updates are\n  // always synchronous.\n\n\n  var value = getSnapshot();\n\n  {\n    if (!didWarnUncachedGetSnapshot) {\n      var cachedValue = getSnapshot();\n\n      if (!objectIs(value, cachedValue)) {\n        error('The result of getSnapshot should be cached to avoid an infinite loop');\n\n        didWarnUncachedGetSnapshot = true;\n      }\n    }\n  } // Because updates are synchronous, we don't queue them. Instead we force a\n  // re-render whenever the subscribed state changes by updating an some\n  // arbitrary useState hook. Then, during render, we call getSnapshot to read\n  // the current value.\n  //\n  // Because we don't actually use the state returned by the useState hook, we\n  // can save a bit of memory by storing other stuff in that slot.\n  //\n  // To implement the early bailout, we need to track some things on a mutable\n  // object. Usually, we would put that in a useRef hook, but we can stash it in\n  // our useState hook instead.\n  //\n  // To force a re-render, we call forceUpdate({inst}). That works because the\n  // new object always fails an equality check.\n\n\n  var _useState = useState({\n    inst: {\n      value: value,\n      getSnapshot: getSnapshot\n    }\n  }),\n      inst = _useState[0].inst,\n      forceUpdate = _useState[1]; // Track the latest getSnapshot function with a ref. This needs to be updated\n  // in the layout phase so we can access it during the tearing check that\n  // happens on subscribe.\n\n\n  useLayoutEffect(function () {\n    inst.value = value;\n    inst.getSnapshot = getSnapshot; // Whenever getSnapshot or subscribe changes, we need to check in the\n    // commit phase if there was an interleaved mutation. In concurrent mode\n    // this can happen all the time, but even in synchronous mode, an earlier\n    // effect may have mutated the store.\n\n    if (checkIfSnapshotChanged(inst)) {\n      // Force a re-render.\n      forceUpdate({\n        inst: inst\n      });\n    }\n  }, [subscribe, value, getSnapshot]);\n  useEffect(function () {\n    // Check for changes right before subscribing. Subsequent changes will be\n    // detected in the subscription handler.\n    if (checkIfSnapshotChanged(inst)) {\n      // Force a re-render.\n      forceUpdate({\n        inst: inst\n      });\n    }\n\n    var handleStoreChange = function () {\n      // TODO: Because there is no cross-renderer API for batching updates, it's\n      // up to the consumer of this library to wrap their subscription event\n      // with unstable_batchedUpdates. Should we try to detect when this isn't\n      // the case and print a warning in development?\n      // The store changed. Check if the snapshot changed since the last time we\n      // read from the store.\n      if (checkIfSnapshotChanged(inst)) {\n        // Force a re-render.\n        forceUpdate({\n          inst: inst\n        });\n      }\n    }; // Subscribe to the store and return a clean-up function.\n\n\n    return subscribe(handleStoreChange);\n  }, [subscribe]);\n  useDebugValue(value);\n  return value;\n}\n\nfunction checkIfSnapshotChanged(inst) {\n  var latestGetSnapshot = inst.getSnapshot;\n  var prevValue = inst.value;\n\n  try {\n    var nextValue = latestGetSnapshot();\n    return !objectIs(prevValue, nextValue);\n  } catch (error) {\n    return true;\n  }\n}\n\nfunction useSyncExternalStore$1(subscribe, getSnapshot, getServerSnapshot) {\n  // Note: The shim does not use getServerSnapshot, because pre-18 versions of\n  // React do not expose a way to check if we're hydrating. So users of the shim\n  // will need to track that themselves and return the correct value\n  // from `getSnapshot`.\n  return getSnapshot();\n}\n\nvar canUseDOM = !!(typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined');\n\nvar isServerEnvironment = !canUseDOM;\n\nvar shim = isServerEnvironment ? useSyncExternalStore$1 : useSyncExternalStore;\nvar useSyncExternalStore$2 = React.useSyncExternalStore !== undefined ? React.useSyncExternalStore : shim;\n\nexports.useSyncExternalStore = useSyncExternalStore$2;\n          /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */\nif (\n  typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined' &&\n  typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop ===\n    'function'\n) {\n  __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());\n}\n        \n  })();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy91c2Utc3luYy1leHRlcm5hbC1zdG9yZS9janMvdXNlLXN5bmMtZXh0ZXJuYWwtc3RvcmUtc2hpbS5kZXZlbG9wbWVudC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWE7O0FBRWIsSUFBSSxJQUFxQztBQUN6Qzs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLG1CQUFPLENBQUMsbUZBQU87O0FBRXJDOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlHQUFpRyxlQUFlO0FBQ2hIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07OztBQUdOO0FBQ0E7QUFDQSxLQUFLLEdBQUc7O0FBRVIsa0RBQWtEO0FBQ2xEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELEtBQUs7QUFDckQ7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLE9BQU87OztBQUdQO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0giLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3VzZS1zeW5jLWV4dGVybmFsLXN0b3JlL2Nqcy91c2Utc3luYy1leHRlcm5hbC1zdG9yZS1zaGltLmRldmVsb3BtZW50LmpzPzgzZmYiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZSBSZWFjdFxuICogdXNlLXN5bmMtZXh0ZXJuYWwtc3RvcmUtc2hpbS5kZXZlbG9wbWVudC5qc1xuICpcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAoZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgICAndXNlIHN0cmljdCc7XG5cbi8qIGdsb2JhbCBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18gKi9cbmlmIChcbiAgdHlwZW9mIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXyAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgdHlwZW9mIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXy5yZWdpc3RlckludGVybmFsTW9kdWxlU3RhcnQgPT09XG4gICAgJ2Z1bmN0aW9uJ1xuKSB7XG4gIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXy5yZWdpc3RlckludGVybmFsTW9kdWxlU3RhcnQobmV3IEVycm9yKCkpO1xufVxuICAgICAgICAgIHZhciBSZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG5cbnZhciBSZWFjdFNoYXJlZEludGVybmFscyA9IFJlYWN0Ll9fU0VDUkVUX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVEO1xuXG5mdW5jdGlvbiBlcnJvcihmb3JtYXQpIHtcbiAge1xuICAgIHtcbiAgICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMiA+IDEgPyBfbGVuMiAtIDEgOiAwKSwgX2tleTIgPSAxOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICAgIGFyZ3NbX2tleTIgLSAxXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gICAgICB9XG5cbiAgICAgIHByaW50V2FybmluZygnZXJyb3InLCBmb3JtYXQsIGFyZ3MpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBwcmludFdhcm5pbmcobGV2ZWwsIGZvcm1hdCwgYXJncykge1xuICAvLyBXaGVuIGNoYW5naW5nIHRoaXMgbG9naWMsIHlvdSBtaWdodCB3YW50IHRvIGFsc29cbiAgLy8gdXBkYXRlIGNvbnNvbGVXaXRoU3RhY2tEZXYud3d3LmpzIGFzIHdlbGwuXG4gIHtcbiAgICB2YXIgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0RGVidWdDdXJyZW50RnJhbWU7XG4gICAgdmFyIHN0YWNrID0gUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5nZXRTdGFja0FkZGVuZHVtKCk7XG5cbiAgICBpZiAoc3RhY2sgIT09ICcnKSB7XG4gICAgICBmb3JtYXQgKz0gJyVzJztcbiAgICAgIGFyZ3MgPSBhcmdzLmNvbmNhdChbc3RhY2tdKTtcbiAgICB9IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9zYWZlLXN0cmluZy1jb2VyY2lvblxuXG5cbiAgICB2YXIgYXJnc1dpdGhGb3JtYXQgPSBhcmdzLm1hcChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgcmV0dXJuIFN0cmluZyhpdGVtKTtcbiAgICB9KTsgLy8gQ2FyZWZ1bDogUk4gY3VycmVudGx5IGRlcGVuZHMgb24gdGhpcyBwcmVmaXhcblxuICAgIGFyZ3NXaXRoRm9ybWF0LnVuc2hpZnQoJ1dhcm5pbmc6ICcgKyBmb3JtYXQpOyAvLyBXZSBpbnRlbnRpb25hbGx5IGRvbid0IHVzZSBzcHJlYWQgKG9yIC5hcHBseSkgZGlyZWN0bHkgYmVjYXVzZSBpdFxuICAgIC8vIGJyZWFrcyBJRTk6IGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTM2MTBcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nXG5cbiAgICBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkuY2FsbChjb25zb2xlW2xldmVsXSwgY29uc29sZSwgYXJnc1dpdGhGb3JtYXQpO1xuICB9XG59XG5cbi8qKlxuICogaW5saW5lZCBPYmplY3QuaXMgcG9seWZpbGwgdG8gYXZvaWQgcmVxdWlyaW5nIGNvbnN1bWVycyBzaGlwIHRoZWlyIG93blxuICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvT2JqZWN0L2lzXG4gKi9cbmZ1bmN0aW9uIGlzKHgsIHkpIHtcbiAgcmV0dXJuIHggPT09IHkgJiYgKHggIT09IDAgfHwgMSAvIHggPT09IDEgLyB5KSB8fCB4ICE9PSB4ICYmIHkgIT09IHkgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1zZWxmLWNvbXBhcmVcbiAgO1xufVxuXG52YXIgb2JqZWN0SXMgPSB0eXBlb2YgT2JqZWN0LmlzID09PSAnZnVuY3Rpb24nID8gT2JqZWN0LmlzIDogaXM7XG5cbi8vIGRpc3BhdGNoIGZvciBDb21tb25KUyBpbnRlcm9wIG5hbWVkIGltcG9ydHMuXG5cbnZhciB1c2VTdGF0ZSA9IFJlYWN0LnVzZVN0YXRlLFxuICAgIHVzZUVmZmVjdCA9IFJlYWN0LnVzZUVmZmVjdCxcbiAgICB1c2VMYXlvdXRFZmZlY3QgPSBSZWFjdC51c2VMYXlvdXRFZmZlY3QsXG4gICAgdXNlRGVidWdWYWx1ZSA9IFJlYWN0LnVzZURlYnVnVmFsdWU7XG52YXIgZGlkV2Fybk9sZDE4QWxwaGEgPSBmYWxzZTtcbnZhciBkaWRXYXJuVW5jYWNoZWRHZXRTbmFwc2hvdCA9IGZhbHNlOyAvLyBEaXNjbGFpbWVyOiBUaGlzIHNoaW0gYnJlYWtzIG1hbnkgb2YgdGhlIHJ1bGVzIG9mIFJlYWN0LCBhbmQgb25seSB3b3Jrc1xuLy8gYmVjYXVzZSBvZiBhIHZlcnkgcGFydGljdWxhciBzZXQgb2YgaW1wbGVtZW50YXRpb24gZGV0YWlscyBhbmQgYXNzdW1wdGlvbnNcbi8vIC0tIGNoYW5nZSBhbnkgb25lIG9mIHRoZW0gYW5kIGl0IHdpbGwgYnJlYWsuIFRoZSBtb3N0IGltcG9ydGFudCBhc3N1bXB0aW9uXG4vLyBpcyB0aGF0IHVwZGF0ZXMgYXJlIGFsd2F5cyBzeW5jaHJvbm91cywgYmVjYXVzZSBjb25jdXJyZW50IHJlbmRlcmluZyBpc1xuLy8gb25seSBhdmFpbGFibGUgaW4gdmVyc2lvbnMgb2YgUmVhY3QgdGhhdCBhbHNvIGhhdmUgYSBidWlsdC1pblxuLy8gdXNlU3luY0V4dGVybmFsU3RvcmUgQVBJLiBBbmQgd2Ugb25seSB1c2UgdGhpcyBzaGltIHdoZW4gdGhlIGJ1aWx0LWluIEFQSVxuLy8gZG9lcyBub3QgZXhpc3QuXG4vL1xuLy8gRG8gbm90IGFzc3VtZSB0aGF0IHRoZSBjbGV2ZXIgaGFja3MgdXNlZCBieSB0aGlzIGhvb2sgYWxzbyB3b3JrIGluIGdlbmVyYWwuXG4vLyBUaGUgcG9pbnQgb2YgdGhpcyBzaGltIGlzIHRvIHJlcGxhY2UgdGhlIG5lZWQgZm9yIGhhY2tzIGJ5IG90aGVyIGxpYnJhcmllcy5cblxuZnVuY3Rpb24gdXNlU3luY0V4dGVybmFsU3RvcmUoc3Vic2NyaWJlLCBnZXRTbmFwc2hvdCwgLy8gTm90ZTogVGhlIHNoaW0gZG9lcyBub3QgdXNlIGdldFNlcnZlclNuYXBzaG90LCBiZWNhdXNlIHByZS0xOCB2ZXJzaW9ucyBvZlxuLy8gUmVhY3QgZG8gbm90IGV4cG9zZSBhIHdheSB0byBjaGVjayBpZiB3ZSdyZSBoeWRyYXRpbmcuIFNvIHVzZXJzIG9mIHRoZSBzaGltXG4vLyB3aWxsIG5lZWQgdG8gdHJhY2sgdGhhdCB0aGVtc2VsdmVzIGFuZCByZXR1cm4gdGhlIGNvcnJlY3QgdmFsdWVcbi8vIGZyb20gYGdldFNuYXBzaG90YC5cbmdldFNlcnZlclNuYXBzaG90KSB7XG4gIHtcbiAgICBpZiAoIWRpZFdhcm5PbGQxOEFscGhhKSB7XG4gICAgICBpZiAoUmVhY3Quc3RhcnRUcmFuc2l0aW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZGlkV2Fybk9sZDE4QWxwaGEgPSB0cnVlO1xuXG4gICAgICAgIGVycm9yKCdZb3UgYXJlIHVzaW5nIGFuIG91dGRhdGVkLCBwcmUtcmVsZWFzZSBhbHBoYSBvZiBSZWFjdCAxOCB0aGF0ICcgKyAnZG9lcyBub3Qgc3VwcG9ydCB1c2VTeW5jRXh0ZXJuYWxTdG9yZS4gVGhlICcgKyAndXNlLXN5bmMtZXh0ZXJuYWwtc3RvcmUgc2hpbSB3aWxsIG5vdCB3b3JrIGNvcnJlY3RseS4gVXBncmFkZSAnICsgJ3RvIGEgbmV3ZXIgcHJlLXJlbGVhc2UuJyk7XG4gICAgICB9XG4gICAgfVxuICB9IC8vIFJlYWQgdGhlIGN1cnJlbnQgc25hcHNob3QgZnJvbSB0aGUgc3RvcmUgb24gZXZlcnkgcmVuZGVyLiBBZ2FpbiwgdGhpc1xuICAvLyBicmVha3MgdGhlIHJ1bGVzIG9mIFJlYWN0LCBhbmQgb25seSB3b3JrcyBoZXJlIGJlY2F1c2Ugb2Ygc3BlY2lmaWNcbiAgLy8gaW1wbGVtZW50YXRpb24gZGV0YWlscywgbW9zdCBpbXBvcnRhbnRseSB0aGF0IHVwZGF0ZXMgYXJlXG4gIC8vIGFsd2F5cyBzeW5jaHJvbm91cy5cblxuXG4gIHZhciB2YWx1ZSA9IGdldFNuYXBzaG90KCk7XG5cbiAge1xuICAgIGlmICghZGlkV2FyblVuY2FjaGVkR2V0U25hcHNob3QpIHtcbiAgICAgIHZhciBjYWNoZWRWYWx1ZSA9IGdldFNuYXBzaG90KCk7XG5cbiAgICAgIGlmICghb2JqZWN0SXModmFsdWUsIGNhY2hlZFZhbHVlKSkge1xuICAgICAgICBlcnJvcignVGhlIHJlc3VsdCBvZiBnZXRTbmFwc2hvdCBzaG91bGQgYmUgY2FjaGVkIHRvIGF2b2lkIGFuIGluZmluaXRlIGxvb3AnKTtcblxuICAgICAgICBkaWRXYXJuVW5jYWNoZWRHZXRTbmFwc2hvdCA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9IC8vIEJlY2F1c2UgdXBkYXRlcyBhcmUgc3luY2hyb25vdXMsIHdlIGRvbid0IHF1ZXVlIHRoZW0uIEluc3RlYWQgd2UgZm9yY2UgYVxuICAvLyByZS1yZW5kZXIgd2hlbmV2ZXIgdGhlIHN1YnNjcmliZWQgc3RhdGUgY2hhbmdlcyBieSB1cGRhdGluZyBhbiBzb21lXG4gIC8vIGFyYml0cmFyeSB1c2VTdGF0ZSBob29rLiBUaGVuLCBkdXJpbmcgcmVuZGVyLCB3ZSBjYWxsIGdldFNuYXBzaG90IHRvIHJlYWRcbiAgLy8gdGhlIGN1cnJlbnQgdmFsdWUuXG4gIC8vXG4gIC8vIEJlY2F1c2Ugd2UgZG9uJ3QgYWN0dWFsbHkgdXNlIHRoZSBzdGF0ZSByZXR1cm5lZCBieSB0aGUgdXNlU3RhdGUgaG9vaywgd2VcbiAgLy8gY2FuIHNhdmUgYSBiaXQgb2YgbWVtb3J5IGJ5IHN0b3Jpbmcgb3RoZXIgc3R1ZmYgaW4gdGhhdCBzbG90LlxuICAvL1xuICAvLyBUbyBpbXBsZW1lbnQgdGhlIGVhcmx5IGJhaWxvdXQsIHdlIG5lZWQgdG8gdHJhY2sgc29tZSB0aGluZ3Mgb24gYSBtdXRhYmxlXG4gIC8vIG9iamVjdC4gVXN1YWxseSwgd2Ugd291bGQgcHV0IHRoYXQgaW4gYSB1c2VSZWYgaG9vaywgYnV0IHdlIGNhbiBzdGFzaCBpdCBpblxuICAvLyBvdXIgdXNlU3RhdGUgaG9vayBpbnN0ZWFkLlxuICAvL1xuICAvLyBUbyBmb3JjZSBhIHJlLXJlbmRlciwgd2UgY2FsbCBmb3JjZVVwZGF0ZSh7aW5zdH0pLiBUaGF0IHdvcmtzIGJlY2F1c2UgdGhlXG4gIC8vIG5ldyBvYmplY3QgYWx3YXlzIGZhaWxzIGFuIGVxdWFsaXR5IGNoZWNrLlxuXG5cbiAgdmFyIF91c2VTdGF0ZSA9IHVzZVN0YXRlKHtcbiAgICBpbnN0OiB7XG4gICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICBnZXRTbmFwc2hvdDogZ2V0U25hcHNob3RcbiAgICB9XG4gIH0pLFxuICAgICAgaW5zdCA9IF91c2VTdGF0ZVswXS5pbnN0LFxuICAgICAgZm9yY2VVcGRhdGUgPSBfdXNlU3RhdGVbMV07IC8vIFRyYWNrIHRoZSBsYXRlc3QgZ2V0U25hcHNob3QgZnVuY3Rpb24gd2l0aCBhIHJlZi4gVGhpcyBuZWVkcyB0byBiZSB1cGRhdGVkXG4gIC8vIGluIHRoZSBsYXlvdXQgcGhhc2Ugc28gd2UgY2FuIGFjY2VzcyBpdCBkdXJpbmcgdGhlIHRlYXJpbmcgY2hlY2sgdGhhdFxuICAvLyBoYXBwZW5zIG9uIHN1YnNjcmliZS5cblxuXG4gIHVzZUxheW91dEVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgaW5zdC52YWx1ZSA9IHZhbHVlO1xuICAgIGluc3QuZ2V0U25hcHNob3QgPSBnZXRTbmFwc2hvdDsgLy8gV2hlbmV2ZXIgZ2V0U25hcHNob3Qgb3Igc3Vic2NyaWJlIGNoYW5nZXMsIHdlIG5lZWQgdG8gY2hlY2sgaW4gdGhlXG4gICAgLy8gY29tbWl0IHBoYXNlIGlmIHRoZXJlIHdhcyBhbiBpbnRlcmxlYXZlZCBtdXRhdGlvbi4gSW4gY29uY3VycmVudCBtb2RlXG4gICAgLy8gdGhpcyBjYW4gaGFwcGVuIGFsbCB0aGUgdGltZSwgYnV0IGV2ZW4gaW4gc3luY2hyb25vdXMgbW9kZSwgYW4gZWFybGllclxuICAgIC8vIGVmZmVjdCBtYXkgaGF2ZSBtdXRhdGVkIHRoZSBzdG9yZS5cblxuICAgIGlmIChjaGVja0lmU25hcHNob3RDaGFuZ2VkKGluc3QpKSB7XG4gICAgICAvLyBGb3JjZSBhIHJlLXJlbmRlci5cbiAgICAgIGZvcmNlVXBkYXRlKHtcbiAgICAgICAgaW5zdDogaW5zdFxuICAgICAgfSk7XG4gICAgfVxuICB9LCBbc3Vic2NyaWJlLCB2YWx1ZSwgZ2V0U25hcHNob3RdKTtcbiAgdXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAvLyBDaGVjayBmb3IgY2hhbmdlcyByaWdodCBiZWZvcmUgc3Vic2NyaWJpbmcuIFN1YnNlcXVlbnQgY2hhbmdlcyB3aWxsIGJlXG4gICAgLy8gZGV0ZWN0ZWQgaW4gdGhlIHN1YnNjcmlwdGlvbiBoYW5kbGVyLlxuICAgIGlmIChjaGVja0lmU25hcHNob3RDaGFuZ2VkKGluc3QpKSB7XG4gICAgICAvLyBGb3JjZSBhIHJlLXJlbmRlci5cbiAgICAgIGZvcmNlVXBkYXRlKHtcbiAgICAgICAgaW5zdDogaW5zdFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgdmFyIGhhbmRsZVN0b3JlQ2hhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgLy8gVE9ETzogQmVjYXVzZSB0aGVyZSBpcyBubyBjcm9zcy1yZW5kZXJlciBBUEkgZm9yIGJhdGNoaW5nIHVwZGF0ZXMsIGl0J3NcbiAgICAgIC8vIHVwIHRvIHRoZSBjb25zdW1lciBvZiB0aGlzIGxpYnJhcnkgdG8gd3JhcCB0aGVpciBzdWJzY3JpcHRpb24gZXZlbnRcbiAgICAgIC8vIHdpdGggdW5zdGFibGVfYmF0Y2hlZFVwZGF0ZXMuIFNob3VsZCB3ZSB0cnkgdG8gZGV0ZWN0IHdoZW4gdGhpcyBpc24ndFxuICAgICAgLy8gdGhlIGNhc2UgYW5kIHByaW50IGEgd2FybmluZyBpbiBkZXZlbG9wbWVudD9cbiAgICAgIC8vIFRoZSBzdG9yZSBjaGFuZ2VkLiBDaGVjayBpZiB0aGUgc25hcHNob3QgY2hhbmdlZCBzaW5jZSB0aGUgbGFzdCB0aW1lIHdlXG4gICAgICAvLyByZWFkIGZyb20gdGhlIHN0b3JlLlxuICAgICAgaWYgKGNoZWNrSWZTbmFwc2hvdENoYW5nZWQoaW5zdCkpIHtcbiAgICAgICAgLy8gRm9yY2UgYSByZS1yZW5kZXIuXG4gICAgICAgIGZvcmNlVXBkYXRlKHtcbiAgICAgICAgICBpbnN0OiBpbnN0XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH07IC8vIFN1YnNjcmliZSB0byB0aGUgc3RvcmUgYW5kIHJldHVybiBhIGNsZWFuLXVwIGZ1bmN0aW9uLlxuXG5cbiAgICByZXR1cm4gc3Vic2NyaWJlKGhhbmRsZVN0b3JlQ2hhbmdlKTtcbiAgfSwgW3N1YnNjcmliZV0pO1xuICB1c2VEZWJ1Z1ZhbHVlKHZhbHVlKTtcbiAgcmV0dXJuIHZhbHVlO1xufVxuXG5mdW5jdGlvbiBjaGVja0lmU25hcHNob3RDaGFuZ2VkKGluc3QpIHtcbiAgdmFyIGxhdGVzdEdldFNuYXBzaG90ID0gaW5zdC5nZXRTbmFwc2hvdDtcbiAgdmFyIHByZXZWYWx1ZSA9IGluc3QudmFsdWU7XG5cbiAgdHJ5IHtcbiAgICB2YXIgbmV4dFZhbHVlID0gbGF0ZXN0R2V0U25hcHNob3QoKTtcbiAgICByZXR1cm4gIW9iamVjdElzKHByZXZWYWx1ZSwgbmV4dFZhbHVlKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufVxuXG5mdW5jdGlvbiB1c2VTeW5jRXh0ZXJuYWxTdG9yZSQxKHN1YnNjcmliZSwgZ2V0U25hcHNob3QsIGdldFNlcnZlclNuYXBzaG90KSB7XG4gIC8vIE5vdGU6IFRoZSBzaGltIGRvZXMgbm90IHVzZSBnZXRTZXJ2ZXJTbmFwc2hvdCwgYmVjYXVzZSBwcmUtMTggdmVyc2lvbnMgb2ZcbiAgLy8gUmVhY3QgZG8gbm90IGV4cG9zZSBhIHdheSB0byBjaGVjayBpZiB3ZSdyZSBoeWRyYXRpbmcuIFNvIHVzZXJzIG9mIHRoZSBzaGltXG4gIC8vIHdpbGwgbmVlZCB0byB0cmFjayB0aGF0IHRoZW1zZWx2ZXMgYW5kIHJldHVybiB0aGUgY29ycmVjdCB2YWx1ZVxuICAvLyBmcm9tIGBnZXRTbmFwc2hvdGAuXG4gIHJldHVybiBnZXRTbmFwc2hvdCgpO1xufVxuXG52YXIgY2FuVXNlRE9NID0gISEodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHdpbmRvdy5kb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHdpbmRvdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50ICE9PSAndW5kZWZpbmVkJyk7XG5cbnZhciBpc1NlcnZlckVudmlyb25tZW50ID0gIWNhblVzZURPTTtcblxudmFyIHNoaW0gPSBpc1NlcnZlckVudmlyb25tZW50ID8gdXNlU3luY0V4dGVybmFsU3RvcmUkMSA6IHVzZVN5bmNFeHRlcm5hbFN0b3JlO1xudmFyIHVzZVN5bmNFeHRlcm5hbFN0b3JlJDIgPSBSZWFjdC51c2VTeW5jRXh0ZXJuYWxTdG9yZSAhPT0gdW5kZWZpbmVkID8gUmVhY3QudXNlU3luY0V4dGVybmFsU3RvcmUgOiBzaGltO1xuXG5leHBvcnRzLnVzZVN5bmNFeHRlcm5hbFN0b3JlID0gdXNlU3luY0V4dGVybmFsU3RvcmUkMjtcbiAgICAgICAgICAvKiBnbG9iYWwgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fICovXG5pZiAoXG4gIHR5cGVvZiBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18gIT09ICd1bmRlZmluZWQnICYmXG4gIHR5cGVvZiBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18ucmVnaXN0ZXJJbnRlcm5hbE1vZHVsZVN0b3AgPT09XG4gICAgJ2Z1bmN0aW9uJ1xuKSB7XG4gIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXy5yZWdpc3RlckludGVybmFsTW9kdWxlU3RvcChuZXcgRXJyb3IoKSk7XG59XG4gICAgICAgIFxuICB9KSgpO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/use-sync-external-store/cjs/use-sync-external-store-shim.development.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/use-sync-external-store/cjs/use-sync-external-store-shim/with-selector.development.js":
/*!************************************************************************************************************!*\
  !*** ./node_modules/use-sync-external-store/cjs/use-sync-external-store-shim/with-selector.development.js ***!
  \************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/**\n * @license React\n * use-sync-external-store-shim/with-selector.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\nif (true) {\n  (function() {\n\n          'use strict';\n\n/* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */\nif (\n  typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined' &&\n  typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart ===\n    'function'\n) {\n  __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());\n}\n          var React = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\nvar shim = __webpack_require__(/*! use-sync-external-store/shim */ \"(app-pages-browser)/./node_modules/use-sync-external-store/shim/index.js\");\n\n/**\n * inlined Object.is polyfill to avoid requiring consumers ship their own\n * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is\n */\nfunction is(x, y) {\n  return x === y && (x !== 0 || 1 / x === 1 / y) || x !== x && y !== y // eslint-disable-line no-self-compare\n  ;\n}\n\nvar objectIs = typeof Object.is === 'function' ? Object.is : is;\n\nvar useSyncExternalStore = shim.useSyncExternalStore;\n\n// for CommonJS interop.\n\nvar useRef = React.useRef,\n    useEffect = React.useEffect,\n    useMemo = React.useMemo,\n    useDebugValue = React.useDebugValue; // Same as useSyncExternalStore, but supports selector and isEqual arguments.\n\nfunction useSyncExternalStoreWithSelector(subscribe, getSnapshot, getServerSnapshot, selector, isEqual) {\n  // Use this to track the rendered snapshot.\n  var instRef = useRef(null);\n  var inst;\n\n  if (instRef.current === null) {\n    inst = {\n      hasValue: false,\n      value: null\n    };\n    instRef.current = inst;\n  } else {\n    inst = instRef.current;\n  }\n\n  var _useMemo = useMemo(function () {\n    // Track the memoized state using closure variables that are local to this\n    // memoized instance of a getSnapshot function. Intentionally not using a\n    // useRef hook, because that state would be shared across all concurrent\n    // copies of the hook/component.\n    var hasMemo = false;\n    var memoizedSnapshot;\n    var memoizedSelection;\n\n    var memoizedSelector = function (nextSnapshot) {\n      if (!hasMemo) {\n        // The first time the hook is called, there is no memoized result.\n        hasMemo = true;\n        memoizedSnapshot = nextSnapshot;\n\n        var _nextSelection = selector(nextSnapshot);\n\n        if (isEqual !== undefined) {\n          // Even if the selector has changed, the currently rendered selection\n          // may be equal to the new selection. We should attempt to reuse the\n          // current value if possible, to preserve downstream memoizations.\n          if (inst.hasValue) {\n            var currentSelection = inst.value;\n\n            if (isEqual(currentSelection, _nextSelection)) {\n              memoizedSelection = currentSelection;\n              return currentSelection;\n            }\n          }\n        }\n\n        memoizedSelection = _nextSelection;\n        return _nextSelection;\n      } // We may be able to reuse the previous invocation's result.\n\n\n      // We may be able to reuse the previous invocation's result.\n      var prevSnapshot = memoizedSnapshot;\n      var prevSelection = memoizedSelection;\n\n      if (objectIs(prevSnapshot, nextSnapshot)) {\n        // The snapshot is the same as last time. Reuse the previous selection.\n        return prevSelection;\n      } // The snapshot has changed, so we need to compute a new selection.\n\n\n      // The snapshot has changed, so we need to compute a new selection.\n      var nextSelection = selector(nextSnapshot); // If a custom isEqual function is provided, use that to check if the data\n      // has changed. If it hasn't, return the previous selection. That signals\n      // to React that the selections are conceptually equal, and we can bail\n      // out of rendering.\n\n      // If a custom isEqual function is provided, use that to check if the data\n      // has changed. If it hasn't, return the previous selection. That signals\n      // to React that the selections are conceptually equal, and we can bail\n      // out of rendering.\n      if (isEqual !== undefined && isEqual(prevSelection, nextSelection)) {\n        return prevSelection;\n      }\n\n      memoizedSnapshot = nextSnapshot;\n      memoizedSelection = nextSelection;\n      return nextSelection;\n    }; // Assigning this to a constant so that Flow knows it can't change.\n\n\n    // Assigning this to a constant so that Flow knows it can't change.\n    var maybeGetServerSnapshot = getServerSnapshot === undefined ? null : getServerSnapshot;\n\n    var getSnapshotWithSelector = function () {\n      return memoizedSelector(getSnapshot());\n    };\n\n    var getServerSnapshotWithSelector = maybeGetServerSnapshot === null ? undefined : function () {\n      return memoizedSelector(maybeGetServerSnapshot());\n    };\n    return [getSnapshotWithSelector, getServerSnapshotWithSelector];\n  }, [getSnapshot, getServerSnapshot, selector, isEqual]),\n      getSelection = _useMemo[0],\n      getServerSelection = _useMemo[1];\n\n  var value = useSyncExternalStore(subscribe, getSelection, getServerSelection);\n  useEffect(function () {\n    inst.hasValue = true;\n    inst.value = value;\n  }, [value]);\n  useDebugValue(value);\n  return value;\n}\n\nexports.useSyncExternalStoreWithSelector = useSyncExternalStoreWithSelector;\n          /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */\nif (\n  typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined' &&\n  typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop ===\n    'function'\n) {\n  __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());\n}\n        \n  })();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy91c2Utc3luYy1leHRlcm5hbC1zdG9yZS9janMvdXNlLXN5bmMtZXh0ZXJuYWwtc3RvcmUtc2hpbS93aXRoLXNlbGVjdG9yLmRldmVsb3BtZW50LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFYTs7QUFFYixJQUFJLElBQXFDO0FBQ3pDOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsbUJBQU8sQ0FBQyxtRkFBTztBQUNyQyxXQUFXLG1CQUFPLENBQUMsOEdBQThCOztBQUVqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5Qzs7QUFFekM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7OztBQUdSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFROzs7QUFHUjtBQUNBLGtEQUFrRDtBQUNsRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7O0FBR1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUEsd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvdXNlLXN5bmMtZXh0ZXJuYWwtc3RvcmUvY2pzL3VzZS1zeW5jLWV4dGVybmFsLXN0b3JlLXNoaW0vd2l0aC1zZWxlY3Rvci5kZXZlbG9wbWVudC5qcz9jY2UxIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2UgUmVhY3RcbiAqIHVzZS1zeW5jLWV4dGVybmFsLXN0b3JlLXNoaW0vd2l0aC1zZWxlY3Rvci5kZXZlbG9wbWVudC5qc1xuICpcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAoZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgICAndXNlIHN0cmljdCc7XG5cbi8qIGdsb2JhbCBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18gKi9cbmlmIChcbiAgdHlwZW9mIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXyAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgdHlwZW9mIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXy5yZWdpc3RlckludGVybmFsTW9kdWxlU3RhcnQgPT09XG4gICAgJ2Z1bmN0aW9uJ1xuKSB7XG4gIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXy5yZWdpc3RlckludGVybmFsTW9kdWxlU3RhcnQobmV3IEVycm9yKCkpO1xufVxuICAgICAgICAgIHZhciBSZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG52YXIgc2hpbSA9IHJlcXVpcmUoJ3VzZS1zeW5jLWV4dGVybmFsLXN0b3JlL3NoaW0nKTtcblxuLyoqXG4gKiBpbmxpbmVkIE9iamVjdC5pcyBwb2x5ZmlsbCB0byBhdm9pZCByZXF1aXJpbmcgY29uc3VtZXJzIHNoaXAgdGhlaXIgb3duXG4gKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9PYmplY3QvaXNcbiAqL1xuZnVuY3Rpb24gaXMoeCwgeSkge1xuICByZXR1cm4geCA9PT0geSAmJiAoeCAhPT0gMCB8fCAxIC8geCA9PT0gMSAvIHkpIHx8IHggIT09IHggJiYgeSAhPT0geSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXNlbGYtY29tcGFyZVxuICA7XG59XG5cbnZhciBvYmplY3RJcyA9IHR5cGVvZiBPYmplY3QuaXMgPT09ICdmdW5jdGlvbicgPyBPYmplY3QuaXMgOiBpcztcblxudmFyIHVzZVN5bmNFeHRlcm5hbFN0b3JlID0gc2hpbS51c2VTeW5jRXh0ZXJuYWxTdG9yZTtcblxuLy8gZm9yIENvbW1vbkpTIGludGVyb3AuXG5cbnZhciB1c2VSZWYgPSBSZWFjdC51c2VSZWYsXG4gICAgdXNlRWZmZWN0ID0gUmVhY3QudXNlRWZmZWN0LFxuICAgIHVzZU1lbW8gPSBSZWFjdC51c2VNZW1vLFxuICAgIHVzZURlYnVnVmFsdWUgPSBSZWFjdC51c2VEZWJ1Z1ZhbHVlOyAvLyBTYW1lIGFzIHVzZVN5bmNFeHRlcm5hbFN0b3JlLCBidXQgc3VwcG9ydHMgc2VsZWN0b3IgYW5kIGlzRXF1YWwgYXJndW1lbnRzLlxuXG5mdW5jdGlvbiB1c2VTeW5jRXh0ZXJuYWxTdG9yZVdpdGhTZWxlY3RvcihzdWJzY3JpYmUsIGdldFNuYXBzaG90LCBnZXRTZXJ2ZXJTbmFwc2hvdCwgc2VsZWN0b3IsIGlzRXF1YWwpIHtcbiAgLy8gVXNlIHRoaXMgdG8gdHJhY2sgdGhlIHJlbmRlcmVkIHNuYXBzaG90LlxuICB2YXIgaW5zdFJlZiA9IHVzZVJlZihudWxsKTtcbiAgdmFyIGluc3Q7XG5cbiAgaWYgKGluc3RSZWYuY3VycmVudCA9PT0gbnVsbCkge1xuICAgIGluc3QgPSB7XG4gICAgICBoYXNWYWx1ZTogZmFsc2UsXG4gICAgICB2YWx1ZTogbnVsbFxuICAgIH07XG4gICAgaW5zdFJlZi5jdXJyZW50ID0gaW5zdDtcbiAgfSBlbHNlIHtcbiAgICBpbnN0ID0gaW5zdFJlZi5jdXJyZW50O1xuICB9XG5cbiAgdmFyIF91c2VNZW1vID0gdXNlTWVtbyhmdW5jdGlvbiAoKSB7XG4gICAgLy8gVHJhY2sgdGhlIG1lbW9pemVkIHN0YXRlIHVzaW5nIGNsb3N1cmUgdmFyaWFibGVzIHRoYXQgYXJlIGxvY2FsIHRvIHRoaXNcbiAgICAvLyBtZW1vaXplZCBpbnN0YW5jZSBvZiBhIGdldFNuYXBzaG90IGZ1bmN0aW9uLiBJbnRlbnRpb25hbGx5IG5vdCB1c2luZyBhXG4gICAgLy8gdXNlUmVmIGhvb2ssIGJlY2F1c2UgdGhhdCBzdGF0ZSB3b3VsZCBiZSBzaGFyZWQgYWNyb3NzIGFsbCBjb25jdXJyZW50XG4gICAgLy8gY29waWVzIG9mIHRoZSBob29rL2NvbXBvbmVudC5cbiAgICB2YXIgaGFzTWVtbyA9IGZhbHNlO1xuICAgIHZhciBtZW1vaXplZFNuYXBzaG90O1xuICAgIHZhciBtZW1vaXplZFNlbGVjdGlvbjtcblxuICAgIHZhciBtZW1vaXplZFNlbGVjdG9yID0gZnVuY3Rpb24gKG5leHRTbmFwc2hvdCkge1xuICAgICAgaWYgKCFoYXNNZW1vKSB7XG4gICAgICAgIC8vIFRoZSBmaXJzdCB0aW1lIHRoZSBob29rIGlzIGNhbGxlZCwgdGhlcmUgaXMgbm8gbWVtb2l6ZWQgcmVzdWx0LlxuICAgICAgICBoYXNNZW1vID0gdHJ1ZTtcbiAgICAgICAgbWVtb2l6ZWRTbmFwc2hvdCA9IG5leHRTbmFwc2hvdDtcblxuICAgICAgICB2YXIgX25leHRTZWxlY3Rpb24gPSBzZWxlY3RvcihuZXh0U25hcHNob3QpO1xuXG4gICAgICAgIGlmIChpc0VxdWFsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAvLyBFdmVuIGlmIHRoZSBzZWxlY3RvciBoYXMgY2hhbmdlZCwgdGhlIGN1cnJlbnRseSByZW5kZXJlZCBzZWxlY3Rpb25cbiAgICAgICAgICAvLyBtYXkgYmUgZXF1YWwgdG8gdGhlIG5ldyBzZWxlY3Rpb24uIFdlIHNob3VsZCBhdHRlbXB0IHRvIHJldXNlIHRoZVxuICAgICAgICAgIC8vIGN1cnJlbnQgdmFsdWUgaWYgcG9zc2libGUsIHRvIHByZXNlcnZlIGRvd25zdHJlYW0gbWVtb2l6YXRpb25zLlxuICAgICAgICAgIGlmIChpbnN0Lmhhc1ZhbHVlKSB7XG4gICAgICAgICAgICB2YXIgY3VycmVudFNlbGVjdGlvbiA9IGluc3QudmFsdWU7XG5cbiAgICAgICAgICAgIGlmIChpc0VxdWFsKGN1cnJlbnRTZWxlY3Rpb24sIF9uZXh0U2VsZWN0aW9uKSkge1xuICAgICAgICAgICAgICBtZW1vaXplZFNlbGVjdGlvbiA9IGN1cnJlbnRTZWxlY3Rpb247XG4gICAgICAgICAgICAgIHJldHVybiBjdXJyZW50U2VsZWN0aW9uO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIG1lbW9pemVkU2VsZWN0aW9uID0gX25leHRTZWxlY3Rpb247XG4gICAgICAgIHJldHVybiBfbmV4dFNlbGVjdGlvbjtcbiAgICAgIH0gLy8gV2UgbWF5IGJlIGFibGUgdG8gcmV1c2UgdGhlIHByZXZpb3VzIGludm9jYXRpb24ncyByZXN1bHQuXG5cblxuICAgICAgLy8gV2UgbWF5IGJlIGFibGUgdG8gcmV1c2UgdGhlIHByZXZpb3VzIGludm9jYXRpb24ncyByZXN1bHQuXG4gICAgICB2YXIgcHJldlNuYXBzaG90ID0gbWVtb2l6ZWRTbmFwc2hvdDtcbiAgICAgIHZhciBwcmV2U2VsZWN0aW9uID0gbWVtb2l6ZWRTZWxlY3Rpb247XG5cbiAgICAgIGlmIChvYmplY3RJcyhwcmV2U25hcHNob3QsIG5leHRTbmFwc2hvdCkpIHtcbiAgICAgICAgLy8gVGhlIHNuYXBzaG90IGlzIHRoZSBzYW1lIGFzIGxhc3QgdGltZS4gUmV1c2UgdGhlIHByZXZpb3VzIHNlbGVjdGlvbi5cbiAgICAgICAgcmV0dXJuIHByZXZTZWxlY3Rpb247XG4gICAgICB9IC8vIFRoZSBzbmFwc2hvdCBoYXMgY2hhbmdlZCwgc28gd2UgbmVlZCB0byBjb21wdXRlIGEgbmV3IHNlbGVjdGlvbi5cblxuXG4gICAgICAvLyBUaGUgc25hcHNob3QgaGFzIGNoYW5nZWQsIHNvIHdlIG5lZWQgdG8gY29tcHV0ZSBhIG5ldyBzZWxlY3Rpb24uXG4gICAgICB2YXIgbmV4dFNlbGVjdGlvbiA9IHNlbGVjdG9yKG5leHRTbmFwc2hvdCk7IC8vIElmIGEgY3VzdG9tIGlzRXF1YWwgZnVuY3Rpb24gaXMgcHJvdmlkZWQsIHVzZSB0aGF0IHRvIGNoZWNrIGlmIHRoZSBkYXRhXG4gICAgICAvLyBoYXMgY2hhbmdlZC4gSWYgaXQgaGFzbid0LCByZXR1cm4gdGhlIHByZXZpb3VzIHNlbGVjdGlvbi4gVGhhdCBzaWduYWxzXG4gICAgICAvLyB0byBSZWFjdCB0aGF0IHRoZSBzZWxlY3Rpb25zIGFyZSBjb25jZXB0dWFsbHkgZXF1YWwsIGFuZCB3ZSBjYW4gYmFpbFxuICAgICAgLy8gb3V0IG9mIHJlbmRlcmluZy5cblxuICAgICAgLy8gSWYgYSBjdXN0b20gaXNFcXVhbCBmdW5jdGlvbiBpcyBwcm92aWRlZCwgdXNlIHRoYXQgdG8gY2hlY2sgaWYgdGhlIGRhdGFcbiAgICAgIC8vIGhhcyBjaGFuZ2VkLiBJZiBpdCBoYXNuJ3QsIHJldHVybiB0aGUgcHJldmlvdXMgc2VsZWN0aW9uLiBUaGF0IHNpZ25hbHNcbiAgICAgIC8vIHRvIFJlYWN0IHRoYXQgdGhlIHNlbGVjdGlvbnMgYXJlIGNvbmNlcHR1YWxseSBlcXVhbCwgYW5kIHdlIGNhbiBiYWlsXG4gICAgICAvLyBvdXQgb2YgcmVuZGVyaW5nLlxuICAgICAgaWYgKGlzRXF1YWwgIT09IHVuZGVmaW5lZCAmJiBpc0VxdWFsKHByZXZTZWxlY3Rpb24sIG5leHRTZWxlY3Rpb24pKSB7XG4gICAgICAgIHJldHVybiBwcmV2U2VsZWN0aW9uO1xuICAgICAgfVxuXG4gICAgICBtZW1vaXplZFNuYXBzaG90ID0gbmV4dFNuYXBzaG90O1xuICAgICAgbWVtb2l6ZWRTZWxlY3Rpb24gPSBuZXh0U2VsZWN0aW9uO1xuICAgICAgcmV0dXJuIG5leHRTZWxlY3Rpb247XG4gICAgfTsgLy8gQXNzaWduaW5nIHRoaXMgdG8gYSBjb25zdGFudCBzbyB0aGF0IEZsb3cga25vd3MgaXQgY2FuJ3QgY2hhbmdlLlxuXG5cbiAgICAvLyBBc3NpZ25pbmcgdGhpcyB0byBhIGNvbnN0YW50IHNvIHRoYXQgRmxvdyBrbm93cyBpdCBjYW4ndCBjaGFuZ2UuXG4gICAgdmFyIG1heWJlR2V0U2VydmVyU25hcHNob3QgPSBnZXRTZXJ2ZXJTbmFwc2hvdCA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IGdldFNlcnZlclNuYXBzaG90O1xuXG4gICAgdmFyIGdldFNuYXBzaG90V2l0aFNlbGVjdG9yID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIG1lbW9pemVkU2VsZWN0b3IoZ2V0U25hcHNob3QoKSk7XG4gICAgfTtcblxuICAgIHZhciBnZXRTZXJ2ZXJTbmFwc2hvdFdpdGhTZWxlY3RvciA9IG1heWJlR2V0U2VydmVyU25hcHNob3QgPT09IG51bGwgPyB1bmRlZmluZWQgOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gbWVtb2l6ZWRTZWxlY3RvcihtYXliZUdldFNlcnZlclNuYXBzaG90KCkpO1xuICAgIH07XG4gICAgcmV0dXJuIFtnZXRTbmFwc2hvdFdpdGhTZWxlY3RvciwgZ2V0U2VydmVyU25hcHNob3RXaXRoU2VsZWN0b3JdO1xuICB9LCBbZ2V0U25hcHNob3QsIGdldFNlcnZlclNuYXBzaG90LCBzZWxlY3RvciwgaXNFcXVhbF0pLFxuICAgICAgZ2V0U2VsZWN0aW9uID0gX3VzZU1lbW9bMF0sXG4gICAgICBnZXRTZXJ2ZXJTZWxlY3Rpb24gPSBfdXNlTWVtb1sxXTtcblxuICB2YXIgdmFsdWUgPSB1c2VTeW5jRXh0ZXJuYWxTdG9yZShzdWJzY3JpYmUsIGdldFNlbGVjdGlvbiwgZ2V0U2VydmVyU2VsZWN0aW9uKTtcbiAgdXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICBpbnN0Lmhhc1ZhbHVlID0gdHJ1ZTtcbiAgICBpbnN0LnZhbHVlID0gdmFsdWU7XG4gIH0sIFt2YWx1ZV0pO1xuICB1c2VEZWJ1Z1ZhbHVlKHZhbHVlKTtcbiAgcmV0dXJuIHZhbHVlO1xufVxuXG5leHBvcnRzLnVzZVN5bmNFeHRlcm5hbFN0b3JlV2l0aFNlbGVjdG9yID0gdXNlU3luY0V4dGVybmFsU3RvcmVXaXRoU2VsZWN0b3I7XG4gICAgICAgICAgLyogZ2xvYmFsIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXyAqL1xuaWYgKFxuICB0eXBlb2YgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fICE9PSAndW5kZWZpbmVkJyAmJlxuICB0eXBlb2YgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fLnJlZ2lzdGVySW50ZXJuYWxNb2R1bGVTdG9wID09PVxuICAgICdmdW5jdGlvbidcbikge1xuICBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18ucmVnaXN0ZXJJbnRlcm5hbE1vZHVsZVN0b3AobmV3IEVycm9yKCkpO1xufVxuICAgICAgICBcbiAgfSkoKTtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/use-sync-external-store/cjs/use-sync-external-store-shim/with-selector.development.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/use-sync-external-store/shim/index.js":
/*!************************************************************!*\
  !*** ./node_modules/use-sync-external-store/shim/index.js ***!
  \************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\nif (false) {} else {\n  module.exports = __webpack_require__(/*! ../cjs/use-sync-external-store-shim.development.js */ \"(app-pages-browser)/./node_modules/use-sync-external-store/cjs/use-sync-external-store-shim.development.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy91c2Utc3luYy1leHRlcm5hbC1zdG9yZS9zaGltL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLElBQUksS0FBcUMsRUFBRSxFQUUxQyxDQUFDO0FBQ0YsRUFBRSw0TUFBOEU7QUFDaEYiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3VzZS1zeW5jLWV4dGVybmFsLXN0b3JlL3NoaW0vaW5kZXguanM/MzJhMCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vY2pzL3VzZS1zeW5jLWV4dGVybmFsLXN0b3JlLXNoaW0ucHJvZHVjdGlvbi5taW4uanMnKTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vY2pzL3VzZS1zeW5jLWV4dGVybmFsLXN0b3JlLXNoaW0uZGV2ZWxvcG1lbnQuanMnKTtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/use-sync-external-store/shim/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/use-sync-external-store/shim/with-selector.js":
/*!********************************************************************!*\
  !*** ./node_modules/use-sync-external-store/shim/with-selector.js ***!
  \********************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\nif (false) {} else {\n  module.exports = __webpack_require__(/*! ../cjs/use-sync-external-store-shim/with-selector.development.js */ \"(app-pages-browser)/./node_modules/use-sync-external-store/cjs/use-sync-external-store-shim/with-selector.development.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy91c2Utc3luYy1leHRlcm5hbC1zdG9yZS9zaGltL3dpdGgtc2VsZWN0b3IuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsSUFBSSxLQUFxQyxFQUFFLEVBRTFDLENBQUM7QUFDRixFQUFFLHdPQUE0RjtBQUM5RiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvdXNlLXN5bmMtZXh0ZXJuYWwtc3RvcmUvc2hpbS93aXRoLXNlbGVjdG9yLmpzPzY0ZTYiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJykge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uL2Nqcy91c2Utc3luYy1leHRlcm5hbC1zdG9yZS1zaGltL3dpdGgtc2VsZWN0b3IucHJvZHVjdGlvbi5taW4uanMnKTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vY2pzL3VzZS1zeW5jLWV4dGVybmFsLXN0b3JlLXNoaW0vd2l0aC1zZWxlY3Rvci5kZXZlbG9wbWVudC5qcycpO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/use-sync-external-store/shim/with-selector.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/app/dashboard/page.tsx":
/*!************************************!*\
  !*** ./src/app/dashboard/page.tsx ***!
  \************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ Dashboard; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var _store_useLoginStore_store__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/store/useLoginStore.store */ \"(app-pages-browser)/./src/store/useLoginStore.store.ts\");\n/* harmony import */ var hazley_ui__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! hazley-ui */ \"(app-pages-browser)/./node_modules/hazley-ui/dist/hazley-ui.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_3__);\n/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"(app-pages-browser)/./node_modules/next/dist/compiled/buffer/index.js\")[\"Buffer\"];\n/* __next_internal_client_entry_do_not_use__ default auto */ \nvar _s = $RefreshSig$();\n\n\n\nfunction Dashboard() {\n    _s();\n    const { id, password } = (0,_store_useLoginStore_store__WEBPACK_IMPORTED_MODULE_1__.useLoginStore)();\n    const token = Buffer.from(\"\".concat(id, \":\").concat(password), \"utf8\").toString(\"base64\");\n    console.log(\"token\", token);\n    const data = [\n        {\n            name: \"Ene\",\n            uv: 400,\n            pv: 2400,\n            amt: 2400\n        },\n        {\n            name: \"Feb\",\n            uv: 300,\n            pv: 1398,\n            amt: 2210\n        },\n        {\n            name: \"Marz\",\n            uv: 200,\n            pv: 9800,\n            amt: 2290\n        },\n        {\n            name: \"Abril\",\n            uv: 278,\n            pv: 3908,\n            amt: 2000\n        }\n    ];\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        style: {\n            width: \"100%\",\n            height: \"100vh\",\n            display: \"flex\",\n            justifyContent: \"center\",\n            alignItems: \"center\"\n        },\n        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n            children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(hazley_ui__WEBPACK_IMPORTED_MODULE_2__.Graph, {\n                data: data\n            }, void 0, false, {\n                fileName: \"C:\\\\Users\\\\USUARIO\\\\Desktop\\\\transactions-app-manager\\\\src\\\\app\\\\dashboard\\\\page.tsx\",\n                lineNumber: 28,\n                columnNumber: 9\n            }, this)\n        }, void 0, false, {\n            fileName: \"C:\\\\Users\\\\USUARIO\\\\Desktop\\\\transactions-app-manager\\\\src\\\\app\\\\dashboard\\\\page.tsx\",\n            lineNumber: 27,\n            columnNumber: 7\n        }, this)\n    }, void 0, false, {\n        fileName: \"C:\\\\Users\\\\USUARIO\\\\Desktop\\\\transactions-app-manager\\\\src\\\\app\\\\dashboard\\\\page.tsx\",\n        lineNumber: 18,\n        columnNumber: 5\n    }, this);\n}\n_s(Dashboard, \"fZrXiwM0ZGy3zLjyDtmA/nsRSJ4=\", false, function() {\n    return [\n        _store_useLoginStore_store__WEBPACK_IMPORTED_MODULE_1__.useLoginStore\n    ];\n});\n_c = Dashboard;\nvar _c;\n$RefreshReg$(_c, \"Dashboard\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9hcHAvZGFzaGJvYXJkL3BhZ2UudHN4IiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUU0RDtBQUMxQjtBQUNSO0FBRVgsU0FBU0c7O0lBQ3RCLE1BQU0sRUFBRUMsRUFBRSxFQUFFQyxRQUFRLEVBQUUsR0FBR0wseUVBQWFBO0lBQ3RDLE1BQU1NLFFBQVFDLE1BQU1BLENBQUNDLElBQUksQ0FBQyxHQUFTSCxPQUFORCxJQUFHLEtBQVksT0FBVEMsV0FBWSxRQUFRSSxRQUFRLENBQUM7SUFDaEVDLFFBQVFDLEdBQUcsQ0FBQyxTQUFTTDtJQUNyQixNQUFNTSxPQUFPO1FBQ1g7WUFBRUMsTUFBTTtZQUFPQyxJQUFJO1lBQUtDLElBQUk7WUFBTUMsS0FBSztRQUFLO1FBQzVDO1lBQUVILE1BQU07WUFBT0MsSUFBSTtZQUFLQyxJQUFJO1lBQU1DLEtBQUs7UUFBSztRQUM1QztZQUFFSCxNQUFNO1lBQVFDLElBQUk7WUFBS0MsSUFBSTtZQUFNQyxLQUFLO1FBQUs7UUFDN0M7WUFBRUgsTUFBTTtZQUFTQyxJQUFJO1lBQUtDLElBQUk7WUFBTUMsS0FBSztRQUFLO0tBQy9DO0lBQ0QscUJBQ0UsOERBQUNDO1FBQ0NDLE9BQU87WUFDTEMsT0FBTztZQUNQQyxRQUFRO1lBQ1JDLFNBQVM7WUFDVEMsZ0JBQWdCO1lBQ2hCQyxZQUFZO1FBQ2Q7a0JBRUEsNEVBQUNOO3NCQUNDLDRFQUFDaEIsNENBQUtBO2dCQUFDVyxNQUFNQTs7Ozs7Ozs7Ozs7Ozs7OztBQUlyQjtHQXpCd0JUOztRQUNHSCxxRUFBYUE7OztLQURoQkciLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2FwcC9kYXNoYm9hcmQvcGFnZS50c3g/YzE1ZSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBjbGllbnRcIjtcclxuXHJcbmltcG9ydCB7IHVzZUxvZ2luU3RvcmUgfSBmcm9tIFwiQC9zdG9yZS91c2VMb2dpblN0b3JlLnN0b3JlXCI7XHJcbmltcG9ydCB7IEdyYXBoIH0gZnJvbSBcImhhemxleS11aVwiO1xyXG5pbXBvcnQgUmVhY3QgZnJvbSBcInJlYWN0XCI7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBEYXNoYm9hcmQoKSB7XHJcbiAgY29uc3QgeyBpZCwgcGFzc3dvcmQgfSA9IHVzZUxvZ2luU3RvcmUoKTtcclxuICBjb25zdCB0b2tlbiA9IEJ1ZmZlci5mcm9tKGAke2lkfToke3Bhc3N3b3JkfWAsIFwidXRmOFwiKS50b1N0cmluZyhcImJhc2U2NFwiKTtcclxuICBjb25zb2xlLmxvZyhcInRva2VuXCIsIHRva2VuKTtcclxuICBjb25zdCBkYXRhID0gW1xyXG4gICAgeyBuYW1lOiBcIkVuZVwiLCB1djogNDAwLCBwdjogMjQwMCwgYW10OiAyNDAwIH0sXHJcbiAgICB7IG5hbWU6IFwiRmViXCIsIHV2OiAzMDAsIHB2OiAxMzk4LCBhbXQ6IDIyMTAgfSxcclxuICAgIHsgbmFtZTogXCJNYXJ6XCIsIHV2OiAyMDAsIHB2OiA5ODAwLCBhbXQ6IDIyOTAgfSxcclxuICAgIHsgbmFtZTogXCJBYnJpbFwiLCB1djogMjc4LCBwdjogMzkwOCwgYW10OiAyMDAwIH0sXHJcbiAgXTtcclxuICByZXR1cm4gKFxyXG4gICAgPGRpdlxyXG4gICAgICBzdHlsZT17e1xyXG4gICAgICAgIHdpZHRoOiBcIjEwMCVcIixcclxuICAgICAgICBoZWlnaHQ6IFwiMTAwdmhcIixcclxuICAgICAgICBkaXNwbGF5OiBcImZsZXhcIixcclxuICAgICAgICBqdXN0aWZ5Q29udGVudDogXCJjZW50ZXJcIixcclxuICAgICAgICBhbGlnbkl0ZW1zOiBcImNlbnRlclwiLFxyXG4gICAgICB9fVxyXG4gICAgPlxyXG4gICAgICA8ZGl2PlxyXG4gICAgICAgIDxHcmFwaCBkYXRhPXtkYXRhfSAvPlxyXG4gICAgICA8L2Rpdj5cclxuICAgIDwvZGl2PlxyXG4gICk7XHJcbn1cclxuIl0sIm5hbWVzIjpbInVzZUxvZ2luU3RvcmUiLCJHcmFwaCIsIlJlYWN0IiwiRGFzaGJvYXJkIiwiaWQiLCJwYXNzd29yZCIsInRva2VuIiwiQnVmZmVyIiwiZnJvbSIsInRvU3RyaW5nIiwiY29uc29sZSIsImxvZyIsImRhdGEiLCJuYW1lIiwidXYiLCJwdiIsImFtdCIsImRpdiIsInN0eWxlIiwid2lkdGgiLCJoZWlnaHQiLCJkaXNwbGF5IiwianVzdGlmeUNvbnRlbnQiLCJhbGlnbkl0ZW1zIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/app/dashboard/page.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/store/useLoginStore.store.ts":
/*!******************************************!*\
  !*** ./src/store/useLoginStore.store.ts ***!
  \******************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useLoginStore: function() { return /* binding */ useLoginStore; }\n/* harmony export */ });\n/* harmony import */ var zustand_middleware__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! zustand/middleware */ \"(app-pages-browser)/./node_modules/zustand/esm/middleware.mjs\");\n/* harmony import */ var zustand_traditional__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! zustand/traditional */ \"(app-pages-browser)/./node_modules/zustand/esm/traditional.mjs\");\n\n\nconst useLoginStore = (0,zustand_traditional__WEBPACK_IMPORTED_MODULE_0__.createWithEqualityFn)((0,zustand_middleware__WEBPACK_IMPORTED_MODULE_1__.persist)((set)=>({\n        id: null,\n        setId: (id)=>set({\n                id\n            }),\n        password: null,\n        setPassword: (password)=>set({\n                password\n            }),\n        access: null,\n        setAccess: (access)=>set({\n                access\n            })\n    }), {\n    name: \"auth-token\"\n}));\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9zdG9yZS91c2VMb2dpblN0b3JlLnN0b3JlLnRzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUE2QztBQUVjO0FBV3BELE1BQU1FLGdCQUFnQkQseUVBQW9CQSxDQUMvQ0QsMkRBQU9BLENBQ0wsQ0FBQ0csTUFBUztRQUNSQyxJQUFJO1FBQ0pDLE9BQU8sQ0FBQ0QsS0FBZUQsSUFBSTtnQkFBRUM7WUFBRztRQUNoQ0UsVUFBVTtRQUNWQyxhQUFhLENBQUNELFdBQXFCSCxJQUFJO2dCQUFFRztZQUFTO1FBQ2xERSxRQUFRO1FBQ1JDLFdBQVcsQ0FBQ0QsU0FBbUJMLElBQUk7Z0JBQUVLO1lBQU87SUFDOUMsSUFDQTtJQUFFRSxNQUFNO0FBQWEsSUFFdkIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL3N0b3JlL3VzZUxvZ2luU3RvcmUuc3RvcmUudHM/MTc1NiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBwZXJzaXN0IH0gZnJvbSBcInp1c3RhbmQvbWlkZGxld2FyZVwiO1xyXG5cclxuaW1wb3J0IHsgY3JlYXRlV2l0aEVxdWFsaXR5Rm4gfSBmcm9tIFwienVzdGFuZC90cmFkaXRpb25hbFwiO1xyXG5cclxuaW50ZXJmYWNlIExvZ2luU3RhdGUge1xyXG4gIGlkOiBzdHJpbmcgfCBudWxsO1xyXG4gIHNldElkOiAoaWQ6IHN0cmluZykgPT4gdm9pZDtcclxuICBwYXNzd29yZDogc3RyaW5nIHwgbnVsbDtcclxuICBzZXRQYXNzd29yZDogKHBhc3N3b3JkOiBzdHJpbmcpID0+IHZvaWQ7XHJcbiAgYWNjZXNzOiBzdHJpbmcgfCBudWxsO1xyXG4gIHNldEFjY2VzczogKGFjY2Vzczogc3RyaW5nKSA9PiB2b2lkO1xyXG59XHJcblxyXG5leHBvcnQgY29uc3QgdXNlTG9naW5TdG9yZSA9IGNyZWF0ZVdpdGhFcXVhbGl0eUZuKFxyXG4gIHBlcnNpc3Q8TG9naW5TdGF0ZT4oXHJcbiAgICAoc2V0KSA9PiAoe1xyXG4gICAgICBpZDogbnVsbCxcclxuICAgICAgc2V0SWQ6IChpZDogc3RyaW5nKSA9PiBzZXQoeyBpZCB9KSxcclxuICAgICAgcGFzc3dvcmQ6IG51bGwsXHJcbiAgICAgIHNldFBhc3N3b3JkOiAocGFzc3dvcmQ6IHN0cmluZykgPT4gc2V0KHsgcGFzc3dvcmQgfSksXHJcbiAgICAgIGFjY2VzczogbnVsbCxcclxuICAgICAgc2V0QWNjZXNzOiAoYWNjZXNzOiBzdHJpbmcpID0+IHNldCh7IGFjY2VzcyB9KSxcclxuICAgIH0pLFxyXG4gICAgeyBuYW1lOiBcImF1dGgtdG9rZW5cIiB9XHJcbiAgKVxyXG4pO1xyXG4iXSwibmFtZXMiOlsicGVyc2lzdCIsImNyZWF0ZVdpdGhFcXVhbGl0eUZuIiwidXNlTG9naW5TdG9yZSIsInNldCIsImlkIiwic2V0SWQiLCJwYXNzd29yZCIsInNldFBhc3N3b3JkIiwiYWNjZXNzIiwic2V0QWNjZXNzIiwibmFtZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/store/useLoginStore.store.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js ***!
  \****************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/**\n * @license React\n * react-jsx-dev-runtime.development.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\nif (true) {\n  (function() {\n'use strict';\n\nvar React = __webpack_require__(/*! next/dist/compiled/react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n\n// ATTENTION\n// When adding new symbols to this file,\n// Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'\n// The Symbol used to tag the ReactElement-like types.\nvar REACT_ELEMENT_TYPE = Symbol.for('react.element');\nvar REACT_PORTAL_TYPE = Symbol.for('react.portal');\nvar REACT_FRAGMENT_TYPE = Symbol.for('react.fragment');\nvar REACT_STRICT_MODE_TYPE = Symbol.for('react.strict_mode');\nvar REACT_PROFILER_TYPE = Symbol.for('react.profiler');\nvar REACT_PROVIDER_TYPE = Symbol.for('react.provider'); // TODO: Delete with enableRenderableContext\n\nvar REACT_CONSUMER_TYPE = Symbol.for('react.consumer');\nvar REACT_CONTEXT_TYPE = Symbol.for('react.context');\nvar REACT_FORWARD_REF_TYPE = Symbol.for('react.forward_ref');\nvar REACT_SUSPENSE_TYPE = Symbol.for('react.suspense');\nvar REACT_SUSPENSE_LIST_TYPE = Symbol.for('react.suspense_list');\nvar REACT_MEMO_TYPE = Symbol.for('react.memo');\nvar REACT_LAZY_TYPE = Symbol.for('react.lazy');\nvar REACT_OFFSCREEN_TYPE = Symbol.for('react.offscreen');\nvar REACT_CACHE_TYPE = Symbol.for('react.cache');\nvar MAYBE_ITERATOR_SYMBOL = Symbol.iterator;\nvar FAUX_ITERATOR_SYMBOL = '@@iterator';\nfunction getIteratorFn(maybeIterable) {\n  if (maybeIterable === null || typeof maybeIterable !== 'object') {\n    return null;\n  }\n\n  var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];\n\n  if (typeof maybeIterator === 'function') {\n    return maybeIterator;\n  }\n\n  return null;\n}\n\nvar ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\n\nfunction error(format) {\n  {\n    {\n      for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n        args[_key2 - 1] = arguments[_key2];\n      }\n\n      printWarning('error', format, args);\n    }\n  }\n}\n\nfunction printWarning(level, format, args) {\n  // When changing this logic, you might want to also\n  // update consoleWithStackDev.www.js as well.\n  {\n    var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\n    var stack = ReactDebugCurrentFrame.getStackAddendum();\n\n    if (stack !== '') {\n      format += '%s';\n      args = args.concat([stack]);\n    } // eslint-disable-next-line react-internal/safe-string-coercion\n\n\n    var argsWithFormat = args.map(function (item) {\n      return String(item);\n    }); // Careful: RN currently depends on this prefix\n\n    argsWithFormat.unshift('Warning: ' + format); // We intentionally don't use spread (or .apply) directly because it\n    // breaks IE9: https://github.com/facebook/react/issues/13610\n    // eslint-disable-next-line react-internal/no-production-logging\n\n    Function.prototype.apply.call(console[level], console, argsWithFormat);\n  }\n}\n\n// -----------------------------------------------------------------------------\n\nvar enableScopeAPI = false; // Experimental Create Event Handle API.\nvar enableCacheElement = false;\nvar enableTransitionTracing = false; // No known bugs, but needs performance testing\n\nvar enableLegacyHidden = false; // Enables unstable_avoidThisFallback feature in Fiber\nvar enableRenderableContext = false;\n// stuff. Intended to enable React core members to more easily debug scheduling\n// issues in DEV builds.\n\nvar enableDebugTracing = false;\n\nfunction getWrappedName(outerType, innerType, wrapperName) {\n  var displayName = outerType.displayName;\n\n  if (displayName) {\n    return displayName;\n  }\n\n  var functionName = innerType.displayName || innerType.name || '';\n  return functionName !== '' ? wrapperName + \"(\" + functionName + \")\" : wrapperName;\n} // Keep in sync with react-reconciler/getComponentNameFromFiber\n\n\nfunction getContextName(type) {\n  return type.displayName || 'Context';\n}\n\nvar REACT_CLIENT_REFERENCE$2 = Symbol.for('react.client.reference'); // Note that the reconciler package should generally prefer to use getComponentNameFromFiber() instead.\n\nfunction getComponentNameFromType(type) {\n  if (type == null) {\n    // Host root, text node or just invalid type.\n    return null;\n  }\n\n  if (typeof type === 'function') {\n    if (type.$$typeof === REACT_CLIENT_REFERENCE$2) {\n      // TODO: Create a convention for naming client references with debug info.\n      return null;\n    }\n\n    return type.displayName || type.name || null;\n  }\n\n  if (typeof type === 'string') {\n    return type;\n  }\n\n  switch (type) {\n    case REACT_FRAGMENT_TYPE:\n      return 'Fragment';\n\n    case REACT_PORTAL_TYPE:\n      return 'Portal';\n\n    case REACT_PROFILER_TYPE:\n      return 'Profiler';\n\n    case REACT_STRICT_MODE_TYPE:\n      return 'StrictMode';\n\n    case REACT_SUSPENSE_TYPE:\n      return 'Suspense';\n\n    case REACT_SUSPENSE_LIST_TYPE:\n      return 'SuspenseList';\n\n    case REACT_CACHE_TYPE:\n      {\n        return 'Cache';\n      }\n\n  }\n\n  if (typeof type === 'object') {\n    {\n      if (typeof type.tag === 'number') {\n        error('Received an unexpected object in getComponentNameFromType(). ' + 'This is likely a bug in React. Please file an issue.');\n      }\n    }\n\n    switch (type.$$typeof) {\n      case REACT_PROVIDER_TYPE:\n        {\n          var provider = type;\n          return getContextName(provider._context) + '.Provider';\n        }\n\n      case REACT_CONTEXT_TYPE:\n        var context = type;\n\n        {\n          return getContextName(context) + '.Consumer';\n        }\n\n      case REACT_CONSUMER_TYPE:\n        {\n          return null;\n        }\n\n      case REACT_FORWARD_REF_TYPE:\n        return getWrappedName(type, type.render, 'ForwardRef');\n\n      case REACT_MEMO_TYPE:\n        var outerName = type.displayName || null;\n\n        if (outerName !== null) {\n          return outerName;\n        }\n\n        return getComponentNameFromType(type.type) || 'Memo';\n\n      case REACT_LAZY_TYPE:\n        {\n          var lazyComponent = type;\n          var payload = lazyComponent._payload;\n          var init = lazyComponent._init;\n\n          try {\n            return getComponentNameFromType(init(payload));\n          } catch (x) {\n            return null;\n          }\n        }\n    }\n  }\n\n  return null;\n}\n\n// $FlowFixMe[method-unbinding]\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\nvar assign = Object.assign;\n\n/*\n * The `'' + value` pattern (used in perf-sensitive code) throws for Symbol\n * and Temporal.* types. See https://github.com/facebook/react/pull/22064.\n *\n * The functions in this module will throw an easier-to-understand,\n * easier-to-debug exception with a clear errors message message explaining the\n * problem. (Instead of a confusing exception thrown inside the implementation\n * of the `value` object).\n */\n// $FlowFixMe[incompatible-return] only called in DEV, so void return is not possible.\nfunction typeName(value) {\n  {\n    // toStringTag is needed for namespaced types like Temporal.Instant\n    var hasToStringTag = typeof Symbol === 'function' && Symbol.toStringTag;\n    var type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || 'Object'; // $FlowFixMe[incompatible-return]\n\n    return type;\n  }\n} // $FlowFixMe[incompatible-return] only called in DEV, so void return is not possible.\n\n\nfunction willCoercionThrow(value) {\n  {\n    try {\n      testStringCoercion(value);\n      return false;\n    } catch (e) {\n      return true;\n    }\n  }\n}\n\nfunction testStringCoercion(value) {\n  // If you ended up here by following an exception call stack, here's what's\n  // happened: you supplied an object or symbol value to React (as a prop, key,\n  // DOM attribute, CSS property, string ref, etc.) and when React tried to\n  // coerce it to a string using `'' + value`, an exception was thrown.\n  //\n  // The most common types that will cause this exception are `Symbol` instances\n  // and Temporal objects like `Temporal.Instant`. But any object that has a\n  // `valueOf` or `[Symbol.toPrimitive]` method that throws will also cause this\n  // exception. (Library authors do this to prevent users from using built-in\n  // numeric operators like `+` or comparison operators like `>=` because custom\n  // methods are needed to perform accurate arithmetic or comparison.)\n  //\n  // To fix the problem, coerce this object or symbol value to a string before\n  // passing it to React. The most reliable way is usually `String(value)`.\n  //\n  // To find which value is throwing, check the browser or debugger console.\n  // Before this exception was thrown, there should be `console.error` output\n  // that shows the type (Symbol, Temporal.PlainDate, etc.) that caused the\n  // problem and how that type was used: key, atrribute, input value prop, etc.\n  // In most cases, this console output also shows the component and its\n  // ancestor components where the exception happened.\n  //\n  // eslint-disable-next-line react-internal/safe-string-coercion\n  return '' + value;\n}\nfunction checkKeyStringCoercion(value) {\n  {\n    if (willCoercionThrow(value)) {\n      error('The provided key is an unsupported type %s.' + ' This value must be coerced to a string before using it here.', typeName(value));\n\n      return testStringCoercion(value); // throw (to help callers find troubleshooting comments)\n    }\n  }\n}\n\nvar REACT_CLIENT_REFERENCE$1 = Symbol.for('react.client.reference');\nfunction isValidElementType(type) {\n  if (typeof type === 'string' || typeof type === 'function') {\n    return true;\n  } // Note: typeof might be other than 'symbol' or 'number' (e.g. if it's a polyfill).\n\n\n  if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || enableDebugTracing  || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden  || type === REACT_OFFSCREEN_TYPE || enableScopeAPI  || enableCacheElement  || enableTransitionTracing ) {\n    return true;\n  }\n\n  if (typeof type === 'object' && type !== null) {\n    if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || enableRenderableContext  || type.$$typeof === REACT_FORWARD_REF_TYPE || // This needs to include all possible module reference object\n    // types supported by any Flight configuration anywhere since\n    // we don't know which Flight build this will end up being used\n    // with.\n    type.$$typeof === REACT_CLIENT_REFERENCE$1 || type.getModuleId !== undefined) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nvar isArrayImpl = Array.isArray; // eslint-disable-next-line no-redeclare\n\nfunction isArray(a) {\n  return isArrayImpl(a);\n}\n\n// Helpers to patch console.logs to avoid logging during side-effect free\n// replaying on render function. This currently only patches the object\n// lazily which won't cover if the log function was extracted eagerly.\n// We could also eagerly patch the method.\nvar disabledDepth = 0;\nvar prevLog;\nvar prevInfo;\nvar prevWarn;\nvar prevError;\nvar prevGroup;\nvar prevGroupCollapsed;\nvar prevGroupEnd;\n\nfunction disabledLog() {}\n\ndisabledLog.__reactDisabledLog = true;\nfunction disableLogs() {\n  {\n    if (disabledDepth === 0) {\n      /* eslint-disable react-internal/no-production-logging */\n      prevLog = console.log;\n      prevInfo = console.info;\n      prevWarn = console.warn;\n      prevError = console.error;\n      prevGroup = console.group;\n      prevGroupCollapsed = console.groupCollapsed;\n      prevGroupEnd = console.groupEnd; // https://github.com/facebook/react/issues/19099\n\n      var props = {\n        configurable: true,\n        enumerable: true,\n        value: disabledLog,\n        writable: true\n      }; // $FlowFixMe[cannot-write] Flow thinks console is immutable.\n\n      Object.defineProperties(console, {\n        info: props,\n        log: props,\n        warn: props,\n        error: props,\n        group: props,\n        groupCollapsed: props,\n        groupEnd: props\n      });\n      /* eslint-enable react-internal/no-production-logging */\n    }\n\n    disabledDepth++;\n  }\n}\nfunction reenableLogs() {\n  {\n    disabledDepth--;\n\n    if (disabledDepth === 0) {\n      /* eslint-disable react-internal/no-production-logging */\n      var props = {\n        configurable: true,\n        enumerable: true,\n        writable: true\n      }; // $FlowFixMe[cannot-write] Flow thinks console is immutable.\n\n      Object.defineProperties(console, {\n        log: assign({}, props, {\n          value: prevLog\n        }),\n        info: assign({}, props, {\n          value: prevInfo\n        }),\n        warn: assign({}, props, {\n          value: prevWarn\n        }),\n        error: assign({}, props, {\n          value: prevError\n        }),\n        group: assign({}, props, {\n          value: prevGroup\n        }),\n        groupCollapsed: assign({}, props, {\n          value: prevGroupCollapsed\n        }),\n        groupEnd: assign({}, props, {\n          value: prevGroupEnd\n        })\n      });\n      /* eslint-enable react-internal/no-production-logging */\n    }\n\n    if (disabledDepth < 0) {\n      error('disabledDepth fell below zero. ' + 'This is a bug in React. Please file an issue.');\n    }\n  }\n}\n\nvar ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;\nvar prefix;\nfunction describeBuiltInComponentFrame(name, ownerFn) {\n  {\n    if (prefix === undefined) {\n      // Extract the VM specific prefix used by each line.\n      try {\n        throw Error();\n      } catch (x) {\n        var match = x.stack.trim().match(/\\n( *(at )?)/);\n        prefix = match && match[1] || '';\n      }\n    } // We use the prefix to ensure our stacks line up with native stack frames.\n\n\n    return '\\n' + prefix + name;\n  }\n}\nvar reentry = false;\nvar componentFrameCache;\n\n{\n  var PossiblyWeakMap = typeof WeakMap === 'function' ? WeakMap : Map;\n  componentFrameCache = new PossiblyWeakMap();\n}\n/**\n * Leverages native browser/VM stack frames to get proper details (e.g.\n * filename, line + col number) for a single component in a component stack. We\n * do this by:\n *   (1) throwing and catching an error in the function - this will be our\n *       control error.\n *   (2) calling the component which will eventually throw an error that we'll\n *       catch - this will be our sample error.\n *   (3) diffing the control and sample error stacks to find the stack frame\n *       which represents our component.\n */\n\n\nfunction describeNativeComponentFrame(fn, construct) {\n  // If something asked for a stack inside a fake render, it should get ignored.\n  if (!fn || reentry) {\n    return '';\n  }\n\n  {\n    var frame = componentFrameCache.get(fn);\n\n    if (frame !== undefined) {\n      return frame;\n    }\n  }\n\n  reentry = true;\n  var previousPrepareStackTrace = Error.prepareStackTrace; // $FlowFixMe[incompatible-type] It does accept undefined.\n\n  Error.prepareStackTrace = undefined;\n  var previousDispatcher;\n\n  {\n    previousDispatcher = ReactCurrentDispatcher.current; // Set the dispatcher in DEV because this might be call in the render function\n    // for warnings.\n\n    ReactCurrentDispatcher.current = null;\n    disableLogs();\n  }\n  /**\n   * Finding a common stack frame between sample and control errors can be\n   * tricky given the different types and levels of stack trace truncation from\n   * different JS VMs. So instead we'll attempt to control what that common\n   * frame should be through this object method:\n   * Having both the sample and control errors be in the function under the\n   * `DescribeNativeComponentFrameRoot` property, + setting the `name` and\n   * `displayName` properties of the function ensures that a stack\n   * frame exists that has the method name `DescribeNativeComponentFrameRoot` in\n   * it for both control and sample stacks.\n   */\n\n\n  var RunInRootFrame = {\n    DetermineComponentFrameRoot: function () {\n      var control;\n\n      try {\n        // This should throw.\n        if (construct) {\n          // Something should be setting the props in the constructor.\n          var Fake = function () {\n            throw Error();\n          }; // $FlowFixMe[prop-missing]\n\n\n          Object.defineProperty(Fake.prototype, 'props', {\n            set: function () {\n              // We use a throwing setter instead of frozen or non-writable props\n              // because that won't throw in a non-strict mode function.\n              throw Error();\n            }\n          });\n\n          if (typeof Reflect === 'object' && Reflect.construct) {\n            // We construct a different control for this case to include any extra\n            // frames added by the construct call.\n            try {\n              Reflect.construct(Fake, []);\n            } catch (x) {\n              control = x;\n            }\n\n            Reflect.construct(fn, [], Fake);\n          } else {\n            try {\n              Fake.call();\n            } catch (x) {\n              control = x;\n            } // $FlowFixMe[prop-missing] found when upgrading Flow\n\n\n            fn.call(Fake.prototype);\n          }\n        } else {\n          try {\n            throw Error();\n          } catch (x) {\n            control = x;\n          } // TODO(luna): This will currently only throw if the function component\n          // tries to access React/ReactDOM/props. We should probably make this throw\n          // in simple components too\n\n\n          var maybePromise = fn(); // If the function component returns a promise, it's likely an async\n          // component, which we don't yet support. Attach a noop catch handler to\n          // silence the error.\n          // TODO: Implement component stacks for async client components?\n\n          if (maybePromise && typeof maybePromise.catch === 'function') {\n            maybePromise.catch(function () {});\n          }\n        }\n      } catch (sample) {\n        // This is inlined manually because closure doesn't do it for us.\n        if (sample && control && typeof sample.stack === 'string') {\n          return [sample.stack, control.stack];\n        }\n      }\n\n      return [null, null];\n    }\n  }; // $FlowFixMe[prop-missing]\n\n  RunInRootFrame.DetermineComponentFrameRoot.displayName = 'DetermineComponentFrameRoot';\n  var namePropDescriptor = Object.getOwnPropertyDescriptor(RunInRootFrame.DetermineComponentFrameRoot, 'name'); // Before ES6, the `name` property was not configurable.\n\n  if (namePropDescriptor && namePropDescriptor.configurable) {\n    // V8 utilizes a function's `name` property when generating a stack trace.\n    Object.defineProperty(RunInRootFrame.DetermineComponentFrameRoot, // Configurable properties can be updated even if its writable descriptor\n    // is set to `false`.\n    // $FlowFixMe[cannot-write]\n    'name', {\n      value: 'DetermineComponentFrameRoot'\n    });\n  }\n\n  try {\n    var _RunInRootFrame$Deter = RunInRootFrame.DetermineComponentFrameRoot(),\n        sampleStack = _RunInRootFrame$Deter[0],\n        controlStack = _RunInRootFrame$Deter[1];\n\n    if (sampleStack && controlStack) {\n      // This extracts the first frame from the sample that isn't also in the control.\n      // Skipping one frame that we assume is the frame that calls the two.\n      var sampleLines = sampleStack.split('\\n');\n      var controlLines = controlStack.split('\\n');\n      var s = 0;\n      var c = 0;\n\n      while (s < sampleLines.length && !sampleLines[s].includes('DetermineComponentFrameRoot')) {\n        s++;\n      }\n\n      while (c < controlLines.length && !controlLines[c].includes('DetermineComponentFrameRoot')) {\n        c++;\n      } // We couldn't find our intentionally injected common root frame, attempt\n      // to find another common root frame by search from the bottom of the\n      // control stack...\n\n\n      if (s === sampleLines.length || c === controlLines.length) {\n        s = sampleLines.length - 1;\n        c = controlLines.length - 1;\n\n        while (s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]) {\n          // We expect at least one stack frame to be shared.\n          // Typically this will be the root most one. However, stack frames may be\n          // cut off due to maximum stack limits. In this case, one maybe cut off\n          // earlier than the other. We assume that the sample is longer or the same\n          // and there for cut off earlier. So we should find the root most frame in\n          // the sample somewhere in the control.\n          c--;\n        }\n      }\n\n      for (; s >= 1 && c >= 0; s--, c--) {\n        // Next we find the first one that isn't the same which should be the\n        // frame that called our sample function and the control.\n        if (sampleLines[s] !== controlLines[c]) {\n          // In V8, the first line is describing the message but other VMs don't.\n          // If we're about to return the first line, and the control is also on the same\n          // line, that's a pretty good indicator that our sample threw at same line as\n          // the control. I.e. before we entered the sample frame. So we ignore this result.\n          // This can happen if you passed a class to function component, or non-function.\n          if (s !== 1 || c !== 1) {\n            do {\n              s--;\n              c--; // We may still have similar intermediate frames from the construct call.\n              // The next one that isn't the same should be our match though.\n\n              if (c < 0 || sampleLines[s] !== controlLines[c]) {\n                // V8 adds a \"new\" prefix for native classes. Let's remove it to make it prettier.\n                var _frame = '\\n' + sampleLines[s].replace(' at new ', ' at '); // If our component frame is labeled \"<anonymous>\"\n                // but we have a user-provided \"displayName\"\n                // splice it in to make the stack more readable.\n\n\n                if (fn.displayName && _frame.includes('<anonymous>')) {\n                  _frame = _frame.replace('<anonymous>', fn.displayName);\n                }\n\n                if (true) {\n                  if (typeof fn === 'function') {\n                    componentFrameCache.set(fn, _frame);\n                  }\n                } // Return the line we found.\n\n\n                return _frame;\n              }\n            } while (s >= 1 && c >= 0);\n          }\n\n          break;\n        }\n      }\n    }\n  } finally {\n    reentry = false;\n\n    {\n      ReactCurrentDispatcher.current = previousDispatcher;\n      reenableLogs();\n    }\n\n    Error.prepareStackTrace = previousPrepareStackTrace;\n  } // Fallback to just using the name if we couldn't make it throw.\n\n\n  var name = fn ? fn.displayName || fn.name : '';\n  var syntheticFrame = name ? describeBuiltInComponentFrame(name) : '';\n\n  {\n    if (typeof fn === 'function') {\n      componentFrameCache.set(fn, syntheticFrame);\n    }\n  }\n\n  return syntheticFrame;\n}\nfunction describeFunctionComponentFrame(fn, ownerFn) {\n  {\n    return describeNativeComponentFrame(fn, false);\n  }\n}\n\nfunction shouldConstruct(Component) {\n  var prototype = Component.prototype;\n  return !!(prototype && prototype.isReactComponent);\n}\n\nfunction describeUnknownElementTypeFrameInDEV(type, ownerFn) {\n\n  if (type == null) {\n    return '';\n  }\n\n  if (typeof type === 'function') {\n    {\n      return describeNativeComponentFrame(type, shouldConstruct(type));\n    }\n  }\n\n  if (typeof type === 'string') {\n    return describeBuiltInComponentFrame(type);\n  }\n\n  switch (type) {\n    case REACT_SUSPENSE_TYPE:\n      return describeBuiltInComponentFrame('Suspense');\n\n    case REACT_SUSPENSE_LIST_TYPE:\n      return describeBuiltInComponentFrame('SuspenseList');\n  }\n\n  if (typeof type === 'object') {\n    switch (type.$$typeof) {\n      case REACT_FORWARD_REF_TYPE:\n        return describeFunctionComponentFrame(type.render);\n\n      case REACT_MEMO_TYPE:\n        // Memo may contain any component type so we recursively resolve it.\n        return describeUnknownElementTypeFrameInDEV(type.type, ownerFn);\n\n      case REACT_LAZY_TYPE:\n        {\n          var lazyComponent = type;\n          var payload = lazyComponent._payload;\n          var init = lazyComponent._init;\n\n          try {\n            // Lazy may contain any component type so we recursively resolve it.\n            return describeUnknownElementTypeFrameInDEV(init(payload), ownerFn);\n          } catch (x) {}\n        }\n    }\n  }\n\n  return '';\n}\n\nvar ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;\nvar ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\nvar REACT_CLIENT_REFERENCE = Symbol.for('react.client.reference');\nvar specialPropKeyWarningShown;\nvar specialPropRefWarningShown;\nvar didWarnAboutStringRefs;\n\n{\n  didWarnAboutStringRefs = {};\n}\n\nfunction hasValidRef(config) {\n  {\n    if (hasOwnProperty.call(config, 'ref')) {\n      var getter = Object.getOwnPropertyDescriptor(config, 'ref').get;\n\n      if (getter && getter.isReactWarning) {\n        return false;\n      }\n    }\n  }\n\n  return config.ref !== undefined;\n}\n\nfunction hasValidKey(config) {\n  {\n    if (hasOwnProperty.call(config, 'key')) {\n      var getter = Object.getOwnPropertyDescriptor(config, 'key').get;\n\n      if (getter && getter.isReactWarning) {\n        return false;\n      }\n    }\n  }\n\n  return config.key !== undefined;\n}\n\nfunction warnIfStringRefCannotBeAutoConverted(config, self) {\n  {\n    if (typeof config.ref === 'string' && ReactCurrentOwner.current && self && ReactCurrentOwner.current.stateNode !== self) {\n      var componentName = getComponentNameFromType(ReactCurrentOwner.current.type);\n\n      if (!didWarnAboutStringRefs[componentName]) {\n        error('Component \"%s\" contains the string ref \"%s\". ' + 'Support for string refs will be removed in a future major release. ' + 'This case cannot be automatically converted to an arrow function. ' + 'We ask you to manually fix this case by using useRef() or createRef() instead. ' + 'Learn more about using refs safely here: ' + 'https://reactjs.org/link/strict-mode-string-ref', getComponentNameFromType(ReactCurrentOwner.current.type), config.ref);\n\n        didWarnAboutStringRefs[componentName] = true;\n      }\n    }\n  }\n}\n\nfunction defineKeyPropWarningGetter(props, displayName) {\n  {\n    var warnAboutAccessingKey = function () {\n      if (!specialPropKeyWarningShown) {\n        specialPropKeyWarningShown = true;\n\n        error('%s: `key` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);\n      }\n    };\n\n    warnAboutAccessingKey.isReactWarning = true;\n    Object.defineProperty(props, 'key', {\n      get: warnAboutAccessingKey,\n      configurable: true\n    });\n  }\n}\n\nfunction defineRefPropWarningGetter(props, displayName) {\n  {\n    {\n      var warnAboutAccessingRef = function () {\n        if (!specialPropRefWarningShown) {\n          specialPropRefWarningShown = true;\n\n          error('%s: `ref` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);\n        }\n      };\n\n      warnAboutAccessingRef.isReactWarning = true;\n      Object.defineProperty(props, 'ref', {\n        get: warnAboutAccessingRef,\n        configurable: true\n      });\n    }\n  }\n}\n/**\n * Factory method to create a new React element. This no longer adheres to\n * the class pattern, so do not use new to call it. Also, instanceof check\n * will not work. Instead test $$typeof field against Symbol.for('react.element') to check\n * if something is a React Element.\n *\n * @param {*} type\n * @param {*} props\n * @param {*} key\n * @param {string|object} ref\n * @param {*} owner\n * @param {*} self A *temporary* helper to detect places where `this` is\n * different from the `owner` when React.createElement is called, so that we\n * can warn. We want to get rid of owner and replace string `ref`s with arrow\n * functions, and as long as `this` and owner are the same, there will be no\n * change in behavior.\n * @param {*} source An annotation object (added by a transpiler or otherwise)\n * indicating filename, line number, and/or other information.\n * @internal\n */\n\n\nfunction ReactElement(type, key, _ref, self, source, owner, props) {\n  var ref;\n\n  {\n    ref = _ref;\n  }\n\n  var element;\n\n  {\n    // In prod, `ref` is a regular property. It will be removed in a\n    // future release.\n    element = {\n      // This tag allows us to uniquely identify this as a React Element\n      $$typeof: REACT_ELEMENT_TYPE,\n      // Built-in properties that belong on the element\n      type: type,\n      key: key,\n      ref: ref,\n      props: props,\n      // Record the component responsible for creating this element.\n      _owner: owner\n    };\n  }\n\n  {\n    // The validation flag is currently mutative. We put it on\n    // an external backing store so that we can freeze the whole object.\n    // This can be replaced with a WeakMap once they are implemented in\n    // commonly used development environments.\n    element._store = {}; // To make comparing ReactElements easier for testing purposes, we make\n    // the validation flag non-enumerable (where possible, which should\n    // include every environment we run tests in), so the test framework\n    // ignores it.\n\n    Object.defineProperty(element._store, 'validated', {\n      configurable: false,\n      enumerable: false,\n      writable: true,\n      value: false\n    }); // debugInfo contains Server Component debug information.\n\n    Object.defineProperty(element, '_debugInfo', {\n      configurable: false,\n      enumerable: false,\n      writable: true,\n      value: null\n    });\n\n    if (Object.freeze) {\n      Object.freeze(element.props);\n      Object.freeze(element);\n    }\n  }\n\n  return element;\n}\nvar didWarnAboutKeySpread = {};\n/**\n * https://github.com/reactjs/rfcs/pull/107\n * @param {*} type\n * @param {object} props\n * @param {string} key\n */\n\nfunction jsxDEV$1(type, config, maybeKey, isStaticChildren, source, self) {\n  {\n    if (!isValidElementType(type)) {\n      // This is an invalid element type.\n      //\n      // We warn in this case but don't throw. We expect the element creation to\n      // succeed and there will likely be errors in render.\n      var info = '';\n\n      if (type === undefined || typeof type === 'object' && type !== null && Object.keys(type).length === 0) {\n        info += ' You likely forgot to export your component from the file ' + \"it's defined in, or you might have mixed up default and named imports.\";\n      }\n\n      var typeString;\n\n      if (type === null) {\n        typeString = 'null';\n      } else if (isArray(type)) {\n        typeString = 'array';\n      } else if (type !== undefined && type.$$typeof === REACT_ELEMENT_TYPE) {\n        typeString = \"<\" + (getComponentNameFromType(type.type) || 'Unknown') + \" />\";\n        info = ' Did you accidentally export a JSX literal instead of a component?';\n      } else {\n        typeString = typeof type;\n      }\n\n      error('React.jsx: type is invalid -- expected a string (for ' + 'built-in components) or a class/function (for composite ' + 'components) but got: %s.%s', typeString, info);\n    } else {\n      // This is a valid element type.\n      // Skip key warning if the type isn't valid since our key validation logic\n      // doesn't expect a non-string/function type and can throw confusing\n      // errors. We don't want exception behavior to differ between dev and\n      // prod. (Rendering will throw with a helpful message and as soon as the\n      // type is fixed, the key warnings will appear.)\n      var children = config.children;\n\n      if (children !== undefined) {\n        if (isStaticChildren) {\n          if (isArray(children)) {\n            for (var i = 0; i < children.length; i++) {\n              validateChildKeys(children[i], type);\n            }\n\n            if (Object.freeze) {\n              Object.freeze(children);\n            }\n          } else {\n            error('React.jsx: Static children should always be an array. ' + 'You are likely explicitly calling React.jsxs or React.jsxDEV. ' + 'Use the Babel transform instead.');\n          }\n        } else {\n          validateChildKeys(children, type);\n        }\n      }\n    } // Warn about key spread regardless of whether the type is valid.\n\n\n    if (hasOwnProperty.call(config, 'key')) {\n      var componentName = getComponentNameFromType(type);\n      var keys = Object.keys(config).filter(function (k) {\n        return k !== 'key';\n      });\n      var beforeExample = keys.length > 0 ? '{key: someKey, ' + keys.join(': ..., ') + ': ...}' : '{key: someKey}';\n\n      if (!didWarnAboutKeySpread[componentName + beforeExample]) {\n        var afterExample = keys.length > 0 ? '{' + keys.join(': ..., ') + ': ...}' : '{}';\n\n        error('A props object containing a \"key\" prop is being spread into JSX:\\n' + '  let props = %s;\\n' + '  <%s {...props} />\\n' + 'React keys must be passed directly to JSX without using spread:\\n' + '  let props = %s;\\n' + '  <%s key={someKey} {...props} />', beforeExample, componentName, afterExample, componentName);\n\n        didWarnAboutKeySpread[componentName + beforeExample] = true;\n      }\n    }\n\n    var propName; // Reserved names are extracted\n\n    var props = {};\n    var key = null;\n    var ref = null; // Currently, key can be spread in as a prop. This causes a potential\n    // issue if key is also explicitly declared (ie. <div {...props} key=\"Hi\" />\n    // or <div key=\"Hi\" {...props} /> ). We want to deprecate key spread,\n    // but as an intermediary step, we will use jsxDEV for everything except\n    // <div {...props} key=\"Hi\" />, because we aren't currently able to tell if\n    // key is explicitly declared to be undefined or not.\n\n    if (maybeKey !== undefined) {\n      {\n        checkKeyStringCoercion(maybeKey);\n      }\n\n      key = '' + maybeKey;\n    }\n\n    if (hasValidKey(config)) {\n      {\n        checkKeyStringCoercion(config.key);\n      }\n\n      key = '' + config.key;\n    }\n\n    if (hasValidRef(config)) {\n      {\n        ref = config.ref;\n      }\n\n      warnIfStringRefCannotBeAutoConverted(config, self);\n    } // Remaining properties are added to a new props object\n\n\n    for (propName in config) {\n      if (hasOwnProperty.call(config, propName) && // Skip over reserved prop names\n      propName !== 'key' && (propName !== 'ref')) {\n        props[propName] = config[propName];\n      }\n    } // Resolve default props\n\n\n    if (type && type.defaultProps) {\n      var defaultProps = type.defaultProps;\n\n      for (propName in defaultProps) {\n        if (props[propName] === undefined) {\n          props[propName] = defaultProps[propName];\n        }\n      }\n    }\n\n    if (key || ref) {\n      var displayName = typeof type === 'function' ? type.displayName || type.name || 'Unknown' : type;\n\n      if (key) {\n        defineKeyPropWarningGetter(props, displayName);\n      }\n\n      if (ref) {\n        defineRefPropWarningGetter(props, displayName);\n      }\n    }\n\n    var element = ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);\n\n    if (type === REACT_FRAGMENT_TYPE) {\n      validateFragmentProps(element);\n    }\n\n    return element;\n  }\n}\n\nfunction getDeclarationErrorAddendum() {\n  {\n    if (ReactCurrentOwner.current) {\n      var name = getComponentNameFromType(ReactCurrentOwner.current.type);\n\n      if (name) {\n        return '\\n\\nCheck the render method of `' + name + '`.';\n      }\n    }\n\n    return '';\n  }\n}\n/**\n * Ensure that every element either is passed in a static location, in an\n * array with an explicit keys property defined, or in an object literal\n * with valid key property.\n *\n * @internal\n * @param {ReactNode} node Statically passed child of any type.\n * @param {*} parentType node's parent's type.\n */\n\n\nfunction validateChildKeys(node, parentType) {\n  {\n    if (typeof node !== 'object' || !node) {\n      return;\n    }\n\n    if (node.$$typeof === REACT_CLIENT_REFERENCE) ; else if (isArray(node)) {\n      for (var i = 0; i < node.length; i++) {\n        var child = node[i];\n\n        if (isValidElement(child)) {\n          validateExplicitKey(child, parentType);\n        }\n      }\n    } else if (isValidElement(node)) {\n      // This element was passed in a valid location.\n      if (node._store) {\n        node._store.validated = true;\n      }\n    } else {\n      var iteratorFn = getIteratorFn(node);\n\n      if (typeof iteratorFn === 'function') {\n        // Entry iterators used to provide implicit keys,\n        // but now we print a separate warning for them later.\n        if (iteratorFn !== node.entries) {\n          var iterator = iteratorFn.call(node);\n          var step;\n\n          while (!(step = iterator.next()).done) {\n            if (isValidElement(step.value)) {\n              validateExplicitKey(step.value, parentType);\n            }\n          }\n        }\n      }\n    }\n  }\n}\n/**\n * Verifies the object is a ReactElement.\n * See https://reactjs.org/docs/react-api.html#isvalidelement\n * @param {?object} object\n * @return {boolean} True if `object` is a ReactElement.\n * @final\n */\n\n\nfunction isValidElement(object) {\n  return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;\n}\nvar ownerHasKeyUseWarning = {};\n/**\n * Warn if the element doesn't have an explicit key assigned to it.\n * This element is in an array. The array could grow and shrink or be\n * reordered. All children that haven't already been validated are required to\n * have a \"key\" property assigned to it. Error statuses are cached so a warning\n * will only be shown once.\n *\n * @internal\n * @param {ReactElement} element Element that requires a key.\n * @param {*} parentType element's parent's type.\n */\n\nfunction validateExplicitKey(element, parentType) {\n  {\n    if (!element._store || element._store.validated || element.key != null) {\n      return;\n    }\n\n    element._store.validated = true;\n    var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);\n\n    if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {\n      return;\n    }\n\n    ownerHasKeyUseWarning[currentComponentErrorInfo] = true; // Usually the current owner is the offender, but if it accepts children as a\n    // property, it may be the creator of the child that's responsible for\n    // assigning it a key.\n\n    var childOwner = '';\n\n    if (element && element._owner && element._owner !== ReactCurrentOwner.current) {\n      // Give the component that originally created this child.\n      childOwner = \" It was passed a child from \" + getComponentNameFromType(element._owner.type) + \".\";\n    }\n\n    setCurrentlyValidatingElement(element);\n\n    error('Each child in a list should have a unique \"key\" prop.' + '%s%s See https://reactjs.org/link/warning-keys for more information.', currentComponentErrorInfo, childOwner);\n\n    setCurrentlyValidatingElement(null);\n  }\n}\n\nfunction setCurrentlyValidatingElement(element) {\n  {\n    if (element) {\n      var owner = element._owner;\n      var stack = describeUnknownElementTypeFrameInDEV(element.type, owner ? owner.type : null);\n      ReactDebugCurrentFrame.setExtraStackFrame(stack);\n    } else {\n      ReactDebugCurrentFrame.setExtraStackFrame(null);\n    }\n  }\n}\n\nfunction getCurrentComponentErrorInfo(parentType) {\n  {\n    var info = getDeclarationErrorAddendum();\n\n    if (!info) {\n      var parentName = getComponentNameFromType(parentType);\n\n      if (parentName) {\n        info = \"\\n\\nCheck the top-level render call using <\" + parentName + \">.\";\n      }\n    }\n\n    return info;\n  }\n}\n/**\n * Given a fragment, validate that it can only be provided with fragment props\n * @param {ReactElement} fragment\n */\n\n\nfunction validateFragmentProps(fragment) {\n  // TODO: Move this to render phase instead of at element creation.\n  {\n    var keys = Object.keys(fragment.props);\n\n    for (var i = 0; i < keys.length; i++) {\n      var key = keys[i];\n\n      if (key !== 'children' && key !== 'key') {\n        setCurrentlyValidatingElement(fragment);\n\n        error('Invalid prop `%s` supplied to `React.Fragment`. ' + 'React.Fragment can only have `key` and `children` props.', key);\n\n        setCurrentlyValidatingElement(null);\n        break;\n      }\n    }\n\n    if (fragment.ref !== null) {\n      setCurrentlyValidatingElement(fragment);\n\n      error('Invalid attribute `ref` supplied to `React.Fragment`.');\n\n      setCurrentlyValidatingElement(null);\n    }\n  }\n}\n\nvar jsxDEV = jsxDEV$1 ;\n\nexports.Fragment = REACT_FRAGMENT_TYPE;\nexports.jsxDEV = jsxDEV;\n  })();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QvY2pzL3JlYWN0LWpzeC1kZXYtcnVudGltZS5kZXZlbG9wbWVudC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWE7O0FBRWIsSUFBSSxJQUFxQztBQUN6QztBQUNBOztBQUVBLFlBQVksbUJBQU8sQ0FBQyxzR0FBMEI7O0FBRTlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RDs7QUFFeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlHQUFpRyxlQUFlO0FBQ2hIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07OztBQUdOO0FBQ0E7QUFDQSxLQUFLLEdBQUc7O0FBRVIsa0RBQWtEO0FBQ2xEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLDRCQUE0QjtBQUM1QjtBQUNBLHFDQUFxQzs7QUFFckMsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBOztBQUVBLHFFQUFxRTs7QUFFckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0dBQWtHOztBQUVsRztBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxpQ0FBaUM7O0FBRWpDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1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O0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEdBQUc7QUFDZCxXQUFXLEdBQUc7QUFDZCxXQUFXLEdBQUc7QUFDZCxXQUFXLGVBQWU7QUFDMUIsV0FBVyxHQUFHO0FBQ2QsV0FBVyxHQUFHO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEdBQUc7QUFDZDtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtB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QUFXLGNBQWM7QUFDekI7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9CQUFvQixpQkFBaUI7QUFDckM7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLGdCQUFnQjtBQUNoQixjQUFjO0FBQ2QsR0FBRztBQUNIIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QvY2pzL3JlYWN0LWpzeC1kZXYtcnVudGltZS5kZXZlbG9wbWVudC5qcz8xYTdjIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2UgUmVhY3RcbiAqIHJlYWN0LWpzeC1kZXYtcnVudGltZS5kZXZlbG9wbWVudC5qc1xuICpcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gIChmdW5jdGlvbigpIHtcbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0ID0gcmVxdWlyZShcIm5leHQvZGlzdC9jb21waWxlZC9yZWFjdFwiKTtcblxuLy8gQVRURU5USU9OXG4vLyBXaGVuIGFkZGluZyBuZXcgc3ltYm9scyB0byB0aGlzIGZpbGUsXG4vLyBQbGVhc2UgY29uc2lkZXIgYWxzbyBhZGRpbmcgdG8gJ3JlYWN0LWRldnRvb2xzLXNoYXJlZC9zcmMvYmFja2VuZC9SZWFjdFN5bWJvbHMnXG4vLyBUaGUgU3ltYm9sIHVzZWQgdG8gdGFnIHRoZSBSZWFjdEVsZW1lbnQtbGlrZSB0eXBlcy5cbnZhciBSRUFDVF9FTEVNRU5UX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5lbGVtZW50Jyk7XG52YXIgUkVBQ1RfUE9SVEFMX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5wb3J0YWwnKTtcbnZhciBSRUFDVF9GUkFHTUVOVF9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QuZnJhZ21lbnQnKTtcbnZhciBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFID0gU3ltYm9sLmZvcigncmVhY3Quc3RyaWN0X21vZGUnKTtcbnZhciBSRUFDVF9QUk9GSUxFUl9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QucHJvZmlsZXInKTtcbnZhciBSRUFDVF9QUk9WSURFUl9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QucHJvdmlkZXInKTsgLy8gVE9ETzogRGVsZXRlIHdpdGggZW5hYmxlUmVuZGVyYWJsZUNvbnRleHRcblxudmFyIFJFQUNUX0NPTlNVTUVSX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5jb25zdW1lcicpO1xudmFyIFJFQUNUX0NPTlRFWFRfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmNvbnRleHQnKTtcbnZhciBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QuZm9yd2FyZF9yZWYnKTtcbnZhciBSRUFDVF9TVVNQRU5TRV9UWVBFID0gU3ltYm9sLmZvcigncmVhY3Quc3VzcGVuc2UnKTtcbnZhciBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5zdXNwZW5zZV9saXN0Jyk7XG52YXIgUkVBQ1RfTUVNT19UWVBFID0gU3ltYm9sLmZvcigncmVhY3QubWVtbycpO1xudmFyIFJFQUNUX0xBWllfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmxhenknKTtcbnZhciBSRUFDVF9PRkZTQ1JFRU5fVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0Lm9mZnNjcmVlbicpO1xudmFyIFJFQUNUX0NBQ0hFX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5jYWNoZScpO1xudmFyIE1BWUJFX0lURVJBVE9SX1NZTUJPTCA9IFN5bWJvbC5pdGVyYXRvcjtcbnZhciBGQVVYX0lURVJBVE9SX1NZTUJPTCA9ICdAQGl0ZXJhdG9yJztcbmZ1bmN0aW9uIGdldEl0ZXJhdG9yRm4obWF5YmVJdGVyYWJsZSkge1xuICBpZiAobWF5YmVJdGVyYWJsZSA9PT0gbnVsbCB8fCB0eXBlb2YgbWF5YmVJdGVyYWJsZSAhPT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBtYXliZUl0ZXJhdG9yID0gTUFZQkVfSVRFUkFUT1JfU1lNQk9MICYmIG1heWJlSXRlcmFibGVbTUFZQkVfSVRFUkFUT1JfU1lNQk9MXSB8fCBtYXliZUl0ZXJhYmxlW0ZBVVhfSVRFUkFUT1JfU1lNQk9MXTtcblxuICBpZiAodHlwZW9mIG1heWJlSXRlcmF0b3IgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gbWF5YmVJdGVyYXRvcjtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG52YXIgUmVhY3RTaGFyZWRJbnRlcm5hbHMgPSBSZWFjdC5fX1NFQ1JFVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRDtcblxuZnVuY3Rpb24gZXJyb3IoZm9ybWF0KSB7XG4gIHtcbiAgICB7XG4gICAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjIgPiAxID8gX2xlbjIgLSAxIDogMCksIF9rZXkyID0gMTsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgICAgICBhcmdzW19rZXkyIC0gMV0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgICAgfVxuXG4gICAgICBwcmludFdhcm5pbmcoJ2Vycm9yJywgZm9ybWF0LCBhcmdzKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJpbnRXYXJuaW5nKGxldmVsLCBmb3JtYXQsIGFyZ3MpIHtcbiAgLy8gV2hlbiBjaGFuZ2luZyB0aGlzIGxvZ2ljLCB5b3UgbWlnaHQgd2FudCB0byBhbHNvXG4gIC8vIHVwZGF0ZSBjb25zb2xlV2l0aFN0YWNrRGV2Lnd3dy5qcyBhcyB3ZWxsLlxuICB7XG4gICAgdmFyIFJlYWN0RGVidWdDdXJyZW50RnJhbWUgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdERlYnVnQ3VycmVudEZyYW1lO1xuICAgIHZhciBzdGFjayA9IFJlYWN0RGVidWdDdXJyZW50RnJhbWUuZ2V0U3RhY2tBZGRlbmR1bSgpO1xuXG4gICAgaWYgKHN0YWNrICE9PSAnJykge1xuICAgICAgZm9ybWF0ICs9ICclcyc7XG4gICAgICBhcmdzID0gYXJncy5jb25jYXQoW3N0YWNrXSk7XG4gICAgfSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvc2FmZS1zdHJpbmctY29lcmNpb25cblxuXG4gICAgdmFyIGFyZ3NXaXRoRm9ybWF0ID0gYXJncy5tYXAoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgIHJldHVybiBTdHJpbmcoaXRlbSk7XG4gICAgfSk7IC8vIENhcmVmdWw6IFJOIGN1cnJlbnRseSBkZXBlbmRzIG9uIHRoaXMgcHJlZml4XG5cbiAgICBhcmdzV2l0aEZvcm1hdC51bnNoaWZ0KCdXYXJuaW5nOiAnICsgZm9ybWF0KTsgLy8gV2UgaW50ZW50aW9uYWxseSBkb24ndCB1c2Ugc3ByZWFkIChvciAuYXBwbHkpIGRpcmVjdGx5IGJlY2F1c2UgaXRcbiAgICAvLyBicmVha3MgSUU5OiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzEzNjEwXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZ1xuXG4gICAgRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5LmNhbGwoY29uc29sZVtsZXZlbF0sIGNvbnNvbGUsIGFyZ3NXaXRoRm9ybWF0KTtcbiAgfVxufVxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG52YXIgZW5hYmxlU2NvcGVBUEkgPSBmYWxzZTsgLy8gRXhwZXJpbWVudGFsIENyZWF0ZSBFdmVudCBIYW5kbGUgQVBJLlxudmFyIGVuYWJsZUNhY2hlRWxlbWVudCA9IGZhbHNlO1xudmFyIGVuYWJsZVRyYW5zaXRpb25UcmFjaW5nID0gZmFsc2U7IC8vIE5vIGtub3duIGJ1Z3MsIGJ1dCBuZWVkcyBwZXJmb3JtYW5jZSB0ZXN0aW5nXG5cbnZhciBlbmFibGVMZWdhY3lIaWRkZW4gPSBmYWxzZTsgLy8gRW5hYmxlcyB1bnN0YWJsZV9hdm9pZFRoaXNGYWxsYmFjayBmZWF0dXJlIGluIEZpYmVyXG52YXIgZW5hYmxlUmVuZGVyYWJsZUNvbnRleHQgPSBmYWxzZTtcbi8vIHN0dWZmLiBJbnRlbmRlZCB0byBlbmFibGUgUmVhY3QgY29yZSBtZW1iZXJzIHRvIG1vcmUgZWFzaWx5IGRlYnVnIHNjaGVkdWxpbmdcbi8vIGlzc3VlcyBpbiBERVYgYnVpbGRzLlxuXG52YXIgZW5hYmxlRGVidWdUcmFjaW5nID0gZmFsc2U7XG5cbmZ1bmN0aW9uIGdldFdyYXBwZWROYW1lKG91dGVyVHlwZSwgaW5uZXJUeXBlLCB3cmFwcGVyTmFtZSkge1xuICB2YXIgZGlzcGxheU5hbWUgPSBvdXRlclR5cGUuZGlzcGxheU5hbWU7XG5cbiAgaWYgKGRpc3BsYXlOYW1lKSB7XG4gICAgcmV0dXJuIGRpc3BsYXlOYW1lO1xuICB9XG5cbiAgdmFyIGZ1bmN0aW9uTmFtZSA9IGlubmVyVHlwZS5kaXNwbGF5TmFtZSB8fCBpbm5lclR5cGUubmFtZSB8fCAnJztcbiAgcmV0dXJuIGZ1bmN0aW9uTmFtZSAhPT0gJycgPyB3cmFwcGVyTmFtZSArIFwiKFwiICsgZnVuY3Rpb25OYW1lICsgXCIpXCIgOiB3cmFwcGVyTmFtZTtcbn0gLy8gS2VlcCBpbiBzeW5jIHdpdGggcmVhY3QtcmVjb25jaWxlci9nZXRDb21wb25lbnROYW1lRnJvbUZpYmVyXG5cblxuZnVuY3Rpb24gZ2V0Q29udGV4dE5hbWUodHlwZSkge1xuICByZXR1cm4gdHlwZS5kaXNwbGF5TmFtZSB8fCAnQ29udGV4dCc7XG59XG5cbnZhciBSRUFDVF9DTElFTlRfUkVGRVJFTkNFJDIgPSBTeW1ib2wuZm9yKCdyZWFjdC5jbGllbnQucmVmZXJlbmNlJyk7IC8vIE5vdGUgdGhhdCB0aGUgcmVjb25jaWxlciBwYWNrYWdlIHNob3VsZCBnZW5lcmFsbHkgcHJlZmVyIHRvIHVzZSBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKCkgaW5zdGVhZC5cblxuZnVuY3Rpb24gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpIHtcbiAgaWYgKHR5cGUgPT0gbnVsbCkge1xuICAgIC8vIEhvc3Qgcm9vdCwgdGV4dCBub2RlIG9yIGp1c3QgaW52YWxpZCB0eXBlLlxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgaWYgKHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0NMSUVOVF9SRUZFUkVOQ0UkMikge1xuICAgICAgLy8gVE9ETzogQ3JlYXRlIGEgY29udmVudGlvbiBmb3IgbmFtaW5nIGNsaWVudCByZWZlcmVuY2VzIHdpdGggZGVidWcgaW5mby5cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiB0eXBlLmRpc3BsYXlOYW1lIHx8IHR5cGUubmFtZSB8fCBudWxsO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB0eXBlO1xuICB9XG5cbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSBSRUFDVF9GUkFHTUVOVF9UWVBFOlxuICAgICAgcmV0dXJuICdGcmFnbWVudCc7XG5cbiAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxuICAgICAgcmV0dXJuICdQb3J0YWwnO1xuXG4gICAgY2FzZSBSRUFDVF9QUk9GSUxFUl9UWVBFOlxuICAgICAgcmV0dXJuICdQcm9maWxlcic7XG5cbiAgICBjYXNlIFJFQUNUX1NUUklDVF9NT0RFX1RZUEU6XG4gICAgICByZXR1cm4gJ1N0cmljdE1vZGUnO1xuXG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9UWVBFOlxuICAgICAgcmV0dXJuICdTdXNwZW5zZSc7XG5cbiAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRTpcbiAgICAgIHJldHVybiAnU3VzcGVuc2VMaXN0JztcblxuICAgIGNhc2UgUkVBQ1RfQ0FDSEVfVFlQRTpcbiAgICAgIHtcbiAgICAgICAgcmV0dXJuICdDYWNoZSc7XG4gICAgICB9XG5cbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICB7XG4gICAgICBpZiAodHlwZW9mIHR5cGUudGFnID09PSAnbnVtYmVyJykge1xuICAgICAgICBlcnJvcignUmVjZWl2ZWQgYW4gdW5leHBlY3RlZCBvYmplY3QgaW4gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKCkuICcgKyAnVGhpcyBpcyBsaWtlbHkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHN3aXRjaCAodHlwZS4kJHR5cGVvZikge1xuICAgICAgY2FzZSBSRUFDVF9QUk9WSURFUl9UWVBFOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIHByb3ZpZGVyID0gdHlwZTtcbiAgICAgICAgICByZXR1cm4gZ2V0Q29udGV4dE5hbWUocHJvdmlkZXIuX2NvbnRleHQpICsgJy5Qcm92aWRlcic7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBSRUFDVF9DT05URVhUX1RZUEU6XG4gICAgICAgIHZhciBjb250ZXh0ID0gdHlwZTtcblxuICAgICAgICB7XG4gICAgICAgICAgcmV0dXJuIGdldENvbnRleHROYW1lKGNvbnRleHQpICsgJy5Db25zdW1lcic7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBSRUFDVF9DT05TVU1FUl9UWVBFOlxuICAgICAgICB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFOlxuICAgICAgICByZXR1cm4gZ2V0V3JhcHBlZE5hbWUodHlwZSwgdHlwZS5yZW5kZXIsICdGb3J3YXJkUmVmJyk7XG5cbiAgICAgIGNhc2UgUkVBQ1RfTUVNT19UWVBFOlxuICAgICAgICB2YXIgb3V0ZXJOYW1lID0gdHlwZS5kaXNwbGF5TmFtZSB8fCBudWxsO1xuXG4gICAgICAgIGlmIChvdXRlck5hbWUgIT09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gb3V0ZXJOYW1lO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlLnR5cGUpIHx8ICdNZW1vJztcblxuICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgbGF6eUNvbXBvbmVudCA9IHR5cGU7XG4gICAgICAgICAgdmFyIHBheWxvYWQgPSBsYXp5Q29tcG9uZW50Ll9wYXlsb2FkO1xuICAgICAgICAgIHZhciBpbml0ID0gbGF6eUNvbXBvbmVudC5faW5pdDtcblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKGluaXQocGF5bG9hZCkpO1xuICAgICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG4vLyAkRmxvd0ZpeE1lW21ldGhvZC11bmJpbmRpbmddXG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG52YXIgYXNzaWduID0gT2JqZWN0LmFzc2lnbjtcblxuLypcbiAqIFRoZSBgJycgKyB2YWx1ZWAgcGF0dGVybiAodXNlZCBpbiBwZXJmLXNlbnNpdGl2ZSBjb2RlKSB0aHJvd3MgZm9yIFN5bWJvbFxuICogYW5kIFRlbXBvcmFsLiogdHlwZXMuIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvcHVsbC8yMjA2NC5cbiAqXG4gKiBUaGUgZnVuY3Rpb25zIGluIHRoaXMgbW9kdWxlIHdpbGwgdGhyb3cgYW4gZWFzaWVyLXRvLXVuZGVyc3RhbmQsXG4gKiBlYXNpZXItdG8tZGVidWcgZXhjZXB0aW9uIHdpdGggYSBjbGVhciBlcnJvcnMgbWVzc2FnZSBtZXNzYWdlIGV4cGxhaW5pbmcgdGhlXG4gKiBwcm9ibGVtLiAoSW5zdGVhZCBvZiBhIGNvbmZ1c2luZyBleGNlcHRpb24gdGhyb3duIGluc2lkZSB0aGUgaW1wbGVtZW50YXRpb25cbiAqIG9mIHRoZSBgdmFsdWVgIG9iamVjdCkuXG4gKi9cbi8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXJldHVybl0gb25seSBjYWxsZWQgaW4gREVWLCBzbyB2b2lkIHJldHVybiBpcyBub3QgcG9zc2libGUuXG5mdW5jdGlvbiB0eXBlTmFtZSh2YWx1ZSkge1xuICB7XG4gICAgLy8gdG9TdHJpbmdUYWcgaXMgbmVlZGVkIGZvciBuYW1lc3BhY2VkIHR5cGVzIGxpa2UgVGVtcG9yYWwuSW5zdGFudFxuICAgIHZhciBoYXNUb1N0cmluZ1RhZyA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLnRvU3RyaW5nVGFnO1xuICAgIHZhciB0eXBlID0gaGFzVG9TdHJpbmdUYWcgJiYgdmFsdWVbU3ltYm9sLnRvU3RyaW5nVGFnXSB8fCB2YWx1ZS5jb25zdHJ1Y3Rvci5uYW1lIHx8ICdPYmplY3QnOyAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1yZXR1cm5dXG5cbiAgICByZXR1cm4gdHlwZTtcbiAgfVxufSAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1yZXR1cm5dIG9ubHkgY2FsbGVkIGluIERFViwgc28gdm9pZCByZXR1cm4gaXMgbm90IHBvc3NpYmxlLlxuXG5cbmZ1bmN0aW9uIHdpbGxDb2VyY2lvblRocm93KHZhbHVlKSB7XG4gIHtcbiAgICB0cnkge1xuICAgICAgdGVzdFN0cmluZ0NvZXJjaW9uKHZhbHVlKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gdGVzdFN0cmluZ0NvZXJjaW9uKHZhbHVlKSB7XG4gIC8vIElmIHlvdSBlbmRlZCB1cCBoZXJlIGJ5IGZvbGxvd2luZyBhbiBleGNlcHRpb24gY2FsbCBzdGFjaywgaGVyZSdzIHdoYXQnc1xuICAvLyBoYXBwZW5lZDogeW91IHN1cHBsaWVkIGFuIG9iamVjdCBvciBzeW1ib2wgdmFsdWUgdG8gUmVhY3QgKGFzIGEgcHJvcCwga2V5LFxuICAvLyBET00gYXR0cmlidXRlLCBDU1MgcHJvcGVydHksIHN0cmluZyByZWYsIGV0Yy4pIGFuZCB3aGVuIFJlYWN0IHRyaWVkIHRvXG4gIC8vIGNvZXJjZSBpdCB0byBhIHN0cmluZyB1c2luZyBgJycgKyB2YWx1ZWAsIGFuIGV4Y2VwdGlvbiB3YXMgdGhyb3duLlxuICAvL1xuICAvLyBUaGUgbW9zdCBjb21tb24gdHlwZXMgdGhhdCB3aWxsIGNhdXNlIHRoaXMgZXhjZXB0aW9uIGFyZSBgU3ltYm9sYCBpbnN0YW5jZXNcbiAgLy8gYW5kIFRlbXBvcmFsIG9iamVjdHMgbGlrZSBgVGVtcG9yYWwuSW5zdGFudGAuIEJ1dCBhbnkgb2JqZWN0IHRoYXQgaGFzIGFcbiAgLy8gYHZhbHVlT2ZgIG9yIGBbU3ltYm9sLnRvUHJpbWl0aXZlXWAgbWV0aG9kIHRoYXQgdGhyb3dzIHdpbGwgYWxzbyBjYXVzZSB0aGlzXG4gIC8vIGV4Y2VwdGlvbi4gKExpYnJhcnkgYXV0aG9ycyBkbyB0aGlzIHRvIHByZXZlbnQgdXNlcnMgZnJvbSB1c2luZyBidWlsdC1pblxuICAvLyBudW1lcmljIG9wZXJhdG9ycyBsaWtlIGArYCBvciBjb21wYXJpc29uIG9wZXJhdG9ycyBsaWtlIGA+PWAgYmVjYXVzZSBjdXN0b21cbiAgLy8gbWV0aG9kcyBhcmUgbmVlZGVkIHRvIHBlcmZvcm0gYWNjdXJhdGUgYXJpdGhtZXRpYyBvciBjb21wYXJpc29uLilcbiAgLy9cbiAgLy8gVG8gZml4IHRoZSBwcm9ibGVtLCBjb2VyY2UgdGhpcyBvYmplY3Qgb3Igc3ltYm9sIHZhbHVlIHRvIGEgc3RyaW5nIGJlZm9yZVxuICAvLyBwYXNzaW5nIGl0IHRvIFJlYWN0LiBUaGUgbW9zdCByZWxpYWJsZSB3YXkgaXMgdXN1YWxseSBgU3RyaW5nKHZhbHVlKWAuXG4gIC8vXG4gIC8vIFRvIGZpbmQgd2hpY2ggdmFsdWUgaXMgdGhyb3dpbmcsIGNoZWNrIHRoZSBicm93c2VyIG9yIGRlYnVnZ2VyIGNvbnNvbGUuXG4gIC8vIEJlZm9yZSB0aGlzIGV4Y2VwdGlvbiB3YXMgdGhyb3duLCB0aGVyZSBzaG91bGQgYmUgYGNvbnNvbGUuZXJyb3JgIG91dHB1dFxuICAvLyB0aGF0IHNob3dzIHRoZSB0eXBlIChTeW1ib2wsIFRlbXBvcmFsLlBsYWluRGF0ZSwgZXRjLikgdGhhdCBjYXVzZWQgdGhlXG4gIC8vIHByb2JsZW0gYW5kIGhvdyB0aGF0IHR5cGUgd2FzIHVzZWQ6IGtleSwgYXRycmlidXRlLCBpbnB1dCB2YWx1ZSBwcm9wLCBldGMuXG4gIC8vIEluIG1vc3QgY2FzZXMsIHRoaXMgY29uc29sZSBvdXRwdXQgYWxzbyBzaG93cyB0aGUgY29tcG9uZW50IGFuZCBpdHNcbiAgLy8gYW5jZXN0b3IgY29tcG9uZW50cyB3aGVyZSB0aGUgZXhjZXB0aW9uIGhhcHBlbmVkLlxuICAvL1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvc2FmZS1zdHJpbmctY29lcmNpb25cbiAgcmV0dXJuICcnICsgdmFsdWU7XG59XG5mdW5jdGlvbiBjaGVja0tleVN0cmluZ0NvZXJjaW9uKHZhbHVlKSB7XG4gIHtcbiAgICBpZiAod2lsbENvZXJjaW9uVGhyb3codmFsdWUpKSB7XG4gICAgICBlcnJvcignVGhlIHByb3ZpZGVkIGtleSBpcyBhbiB1bnN1cHBvcnRlZCB0eXBlICVzLicgKyAnIFRoaXMgdmFsdWUgbXVzdCBiZSBjb2VyY2VkIHRvIGEgc3RyaW5nIGJlZm9yZSB1c2luZyBpdCBoZXJlLicsIHR5cGVOYW1lKHZhbHVlKSk7XG5cbiAgICAgIHJldHVybiB0ZXN0U3RyaW5nQ29lcmNpb24odmFsdWUpOyAvLyB0aHJvdyAodG8gaGVscCBjYWxsZXJzIGZpbmQgdHJvdWJsZXNob290aW5nIGNvbW1lbnRzKVxuICAgIH1cbiAgfVxufVxuXG52YXIgUkVBQ1RfQ0xJRU5UX1JFRkVSRU5DRSQxID0gU3ltYm9sLmZvcigncmVhY3QuY2xpZW50LnJlZmVyZW5jZScpO1xuZnVuY3Rpb24gaXNWYWxpZEVsZW1lbnRUeXBlKHR5cGUpIHtcbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiB0cnVlO1xuICB9IC8vIE5vdGU6IHR5cGVvZiBtaWdodCBiZSBvdGhlciB0aGFuICdzeW1ib2wnIG9yICdudW1iZXInIChlLmcuIGlmIGl0J3MgYSBwb2x5ZmlsbCkuXG5cblxuICBpZiAodHlwZSA9PT0gUkVBQ1RfRlJBR01FTlRfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9QUk9GSUxFUl9UWVBFIHx8IGVuYWJsZURlYnVnVHJhY2luZyAgfHwgdHlwZSA9PT0gUkVBQ1RfU1RSSUNUX01PREVfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9TVVNQRU5TRV9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSB8fCBlbmFibGVMZWdhY3lIaWRkZW4gIHx8IHR5cGUgPT09IFJFQUNUX09GRlNDUkVFTl9UWVBFIHx8IGVuYWJsZVNjb3BlQVBJICB8fCBlbmFibGVDYWNoZUVsZW1lbnQgIHx8IGVuYWJsZVRyYW5zaXRpb25UcmFjaW5nICkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0JyAmJiB0eXBlICE9PSBudWxsKSB7XG4gICAgaWYgKHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0xBWllfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9NRU1PX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfQ09OVEVYVF9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX1BST1ZJREVSX1RZUEUgfHwgZW5hYmxlUmVuZGVyYWJsZUNvbnRleHQgIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgfHwgLy8gVGhpcyBuZWVkcyB0byBpbmNsdWRlIGFsbCBwb3NzaWJsZSBtb2R1bGUgcmVmZXJlbmNlIG9iamVjdFxuICAgIC8vIHR5cGVzIHN1cHBvcnRlZCBieSBhbnkgRmxpZ2h0IGNvbmZpZ3VyYXRpb24gYW55d2hlcmUgc2luY2VcbiAgICAvLyB3ZSBkb24ndCBrbm93IHdoaWNoIEZsaWdodCBidWlsZCB0aGlzIHdpbGwgZW5kIHVwIGJlaW5nIHVzZWRcbiAgICAvLyB3aXRoLlxuICAgIHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0NMSUVOVF9SRUZFUkVOQ0UkMSB8fCB0eXBlLmdldE1vZHVsZUlkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxudmFyIGlzQXJyYXlJbXBsID0gQXJyYXkuaXNBcnJheTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlZGVjbGFyZVxuXG5mdW5jdGlvbiBpc0FycmF5KGEpIHtcbiAgcmV0dXJuIGlzQXJyYXlJbXBsKGEpO1xufVxuXG4vLyBIZWxwZXJzIHRvIHBhdGNoIGNvbnNvbGUubG9ncyB0byBhdm9pZCBsb2dnaW5nIGR1cmluZyBzaWRlLWVmZmVjdCBmcmVlXG4vLyByZXBsYXlpbmcgb24gcmVuZGVyIGZ1bmN0aW9uLiBUaGlzIGN1cnJlbnRseSBvbmx5IHBhdGNoZXMgdGhlIG9iamVjdFxuLy8gbGF6aWx5IHdoaWNoIHdvbid0IGNvdmVyIGlmIHRoZSBsb2cgZnVuY3Rpb24gd2FzIGV4dHJhY3RlZCBlYWdlcmx5LlxuLy8gV2UgY291bGQgYWxzbyBlYWdlcmx5IHBhdGNoIHRoZSBtZXRob2QuXG52YXIgZGlzYWJsZWREZXB0aCA9IDA7XG52YXIgcHJldkxvZztcbnZhciBwcmV2SW5mbztcbnZhciBwcmV2V2FybjtcbnZhciBwcmV2RXJyb3I7XG52YXIgcHJldkdyb3VwO1xudmFyIHByZXZHcm91cENvbGxhcHNlZDtcbnZhciBwcmV2R3JvdXBFbmQ7XG5cbmZ1bmN0aW9uIGRpc2FibGVkTG9nKCkge31cblxuZGlzYWJsZWRMb2cuX19yZWFjdERpc2FibGVkTG9nID0gdHJ1ZTtcbmZ1bmN0aW9uIGRpc2FibGVMb2dzKCkge1xuICB7XG4gICAgaWYgKGRpc2FibGVkRGVwdGggPT09IDApIHtcbiAgICAgIC8qIGVzbGludC1kaXNhYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgICAgcHJldkxvZyA9IGNvbnNvbGUubG9nO1xuICAgICAgcHJldkluZm8gPSBjb25zb2xlLmluZm87XG4gICAgICBwcmV2V2FybiA9IGNvbnNvbGUud2FybjtcbiAgICAgIHByZXZFcnJvciA9IGNvbnNvbGUuZXJyb3I7XG4gICAgICBwcmV2R3JvdXAgPSBjb25zb2xlLmdyb3VwO1xuICAgICAgcHJldkdyb3VwQ29sbGFwc2VkID0gY29uc29sZS5ncm91cENvbGxhcHNlZDtcbiAgICAgIHByZXZHcm91cEVuZCA9IGNvbnNvbGUuZ3JvdXBFbmQ7IC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTkwOTlcblxuICAgICAgdmFyIHByb3BzID0ge1xuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIHZhbHVlOiBkaXNhYmxlZExvZyxcbiAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgIH07IC8vICRGbG93Rml4TWVbY2Fubm90LXdyaXRlXSBGbG93IHRoaW5rcyBjb25zb2xlIGlzIGltbXV0YWJsZS5cblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoY29uc29sZSwge1xuICAgICAgICBpbmZvOiBwcm9wcyxcbiAgICAgICAgbG9nOiBwcm9wcyxcbiAgICAgICAgd2FybjogcHJvcHMsXG4gICAgICAgIGVycm9yOiBwcm9wcyxcbiAgICAgICAgZ3JvdXA6IHByb3BzLFxuICAgICAgICBncm91cENvbGxhcHNlZDogcHJvcHMsXG4gICAgICAgIGdyb3VwRW5kOiBwcm9wc1xuICAgICAgfSk7XG4gICAgICAvKiBlc2xpbnQtZW5hYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgIH1cblxuICAgIGRpc2FibGVkRGVwdGgrKztcbiAgfVxufVxuZnVuY3Rpb24gcmVlbmFibGVMb2dzKCkge1xuICB7XG4gICAgZGlzYWJsZWREZXB0aC0tO1xuXG4gICAgaWYgKGRpc2FibGVkRGVwdGggPT09IDApIHtcbiAgICAgIC8qIGVzbGludC1kaXNhYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgICAgdmFyIHByb3BzID0ge1xuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICB9OyAvLyAkRmxvd0ZpeE1lW2Nhbm5vdC13cml0ZV0gRmxvdyB0aGlua3MgY29uc29sZSBpcyBpbW11dGFibGUuXG5cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGNvbnNvbGUsIHtcbiAgICAgICAgbG9nOiBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZMb2dcbiAgICAgICAgfSksXG4gICAgICAgIGluZm86IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkluZm9cbiAgICAgICAgfSksXG4gICAgICAgIHdhcm46IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldldhcm5cbiAgICAgICAgfSksXG4gICAgICAgIGVycm9yOiBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZFcnJvclxuICAgICAgICB9KSxcbiAgICAgICAgZ3JvdXA6IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkdyb3VwXG4gICAgICAgIH0pLFxuICAgICAgICBncm91cENvbGxhcHNlZDogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2R3JvdXBDb2xsYXBzZWRcbiAgICAgICAgfSksXG4gICAgICAgIGdyb3VwRW5kOiBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZHcm91cEVuZFxuICAgICAgICB9KVxuICAgICAgfSk7XG4gICAgICAvKiBlc2xpbnQtZW5hYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgIH1cblxuICAgIGlmIChkaXNhYmxlZERlcHRoIDwgMCkge1xuICAgICAgZXJyb3IoJ2Rpc2FibGVkRGVwdGggZmVsbCBiZWxvdyB6ZXJvLiAnICsgJ1RoaXMgaXMgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgIH1cbiAgfVxufVxuXG52YXIgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0Q3VycmVudERpc3BhdGNoZXI7XG52YXIgcHJlZml4O1xuZnVuY3Rpb24gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUobmFtZSwgb3duZXJGbikge1xuICB7XG4gICAgaWYgKHByZWZpeCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBFeHRyYWN0IHRoZSBWTSBzcGVjaWZpYyBwcmVmaXggdXNlZCBieSBlYWNoIGxpbmUuXG4gICAgICB0cnkge1xuICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICB2YXIgbWF0Y2ggPSB4LnN0YWNrLnRyaW0oKS5tYXRjaCgvXFxuKCAqKGF0ICk/KS8pO1xuICAgICAgICBwcmVmaXggPSBtYXRjaCAmJiBtYXRjaFsxXSB8fCAnJztcbiAgICAgIH1cbiAgICB9IC8vIFdlIHVzZSB0aGUgcHJlZml4IHRvIGVuc3VyZSBvdXIgc3RhY2tzIGxpbmUgdXAgd2l0aCBuYXRpdmUgc3RhY2sgZnJhbWVzLlxuXG5cbiAgICByZXR1cm4gJ1xcbicgKyBwcmVmaXggKyBuYW1lO1xuICB9XG59XG52YXIgcmVlbnRyeSA9IGZhbHNlO1xudmFyIGNvbXBvbmVudEZyYW1lQ2FjaGU7XG5cbntcbiAgdmFyIFBvc3NpYmx5V2Vha01hcCA9IHR5cGVvZiBXZWFrTWFwID09PSAnZnVuY3Rpb24nID8gV2Vha01hcCA6IE1hcDtcbiAgY29tcG9uZW50RnJhbWVDYWNoZSA9IG5ldyBQb3NzaWJseVdlYWtNYXAoKTtcbn1cbi8qKlxuICogTGV2ZXJhZ2VzIG5hdGl2ZSBicm93c2VyL1ZNIHN0YWNrIGZyYW1lcyB0byBnZXQgcHJvcGVyIGRldGFpbHMgKGUuZy5cbiAqIGZpbGVuYW1lLCBsaW5lICsgY29sIG51bWJlcikgZm9yIGEgc2luZ2xlIGNvbXBvbmVudCBpbiBhIGNvbXBvbmVudCBzdGFjay4gV2VcbiAqIGRvIHRoaXMgYnk6XG4gKiAgICgxKSB0aHJvd2luZyBhbmQgY2F0Y2hpbmcgYW4gZXJyb3IgaW4gdGhlIGZ1bmN0aW9uIC0gdGhpcyB3aWxsIGJlIG91clxuICogICAgICAgY29udHJvbCBlcnJvci5cbiAqICAgKDIpIGNhbGxpbmcgdGhlIGNvbXBvbmVudCB3aGljaCB3aWxsIGV2ZW50dWFsbHkgdGhyb3cgYW4gZXJyb3IgdGhhdCB3ZSdsbFxuICogICAgICAgY2F0Y2ggLSB0aGlzIHdpbGwgYmUgb3VyIHNhbXBsZSBlcnJvci5cbiAqICAgKDMpIGRpZmZpbmcgdGhlIGNvbnRyb2wgYW5kIHNhbXBsZSBlcnJvciBzdGFja3MgdG8gZmluZCB0aGUgc3RhY2sgZnJhbWVcbiAqICAgICAgIHdoaWNoIHJlcHJlc2VudHMgb3VyIGNvbXBvbmVudC5cbiAqL1xuXG5cbmZ1bmN0aW9uIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUoZm4sIGNvbnN0cnVjdCkge1xuICAvLyBJZiBzb21ldGhpbmcgYXNrZWQgZm9yIGEgc3RhY2sgaW5zaWRlIGEgZmFrZSByZW5kZXIsIGl0IHNob3VsZCBnZXQgaWdub3JlZC5cbiAgaWYgKCFmbiB8fCByZWVudHJ5KSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAge1xuICAgIHZhciBmcmFtZSA9IGNvbXBvbmVudEZyYW1lQ2FjaGUuZ2V0KGZuKTtcblxuICAgIGlmIChmcmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZnJhbWU7XG4gICAgfVxuICB9XG5cbiAgcmVlbnRyeSA9IHRydWU7XG4gIHZhciBwcmV2aW91c1ByZXBhcmVTdGFja1RyYWNlID0gRXJyb3IucHJlcGFyZVN0YWNrVHJhY2U7IC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXR5cGVdIEl0IGRvZXMgYWNjZXB0IHVuZGVmaW5lZC5cblxuICBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZSA9IHVuZGVmaW5lZDtcbiAgdmFyIHByZXZpb3VzRGlzcGF0Y2hlcjtcblxuICB7XG4gICAgcHJldmlvdXNEaXNwYXRjaGVyID0gUmVhY3RDdXJyZW50RGlzcGF0Y2hlci5jdXJyZW50OyAvLyBTZXQgdGhlIGRpc3BhdGNoZXIgaW4gREVWIGJlY2F1c2UgdGhpcyBtaWdodCBiZSBjYWxsIGluIHRoZSByZW5kZXIgZnVuY3Rpb25cbiAgICAvLyBmb3Igd2FybmluZ3MuXG5cbiAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyLmN1cnJlbnQgPSBudWxsO1xuICAgIGRpc2FibGVMb2dzKCk7XG4gIH1cbiAgLyoqXG4gICAqIEZpbmRpbmcgYSBjb21tb24gc3RhY2sgZnJhbWUgYmV0d2VlbiBzYW1wbGUgYW5kIGNvbnRyb2wgZXJyb3JzIGNhbiBiZVxuICAgKiB0cmlja3kgZ2l2ZW4gdGhlIGRpZmZlcmVudCB0eXBlcyBhbmQgbGV2ZWxzIG9mIHN0YWNrIHRyYWNlIHRydW5jYXRpb24gZnJvbVxuICAgKiBkaWZmZXJlbnQgSlMgVk1zLiBTbyBpbnN0ZWFkIHdlJ2xsIGF0dGVtcHQgdG8gY29udHJvbCB3aGF0IHRoYXQgY29tbW9uXG4gICAqIGZyYW1lIHNob3VsZCBiZSB0aHJvdWdoIHRoaXMgb2JqZWN0IG1ldGhvZDpcbiAgICogSGF2aW5nIGJvdGggdGhlIHNhbXBsZSBhbmQgY29udHJvbCBlcnJvcnMgYmUgaW4gdGhlIGZ1bmN0aW9uIHVuZGVyIHRoZVxuICAgKiBgRGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZVJvb3RgIHByb3BlcnR5LCArIHNldHRpbmcgdGhlIGBuYW1lYCBhbmRcbiAgICogYGRpc3BsYXlOYW1lYCBwcm9wZXJ0aWVzIG9mIHRoZSBmdW5jdGlvbiBlbnN1cmVzIHRoYXQgYSBzdGFja1xuICAgKiBmcmFtZSBleGlzdHMgdGhhdCBoYXMgdGhlIG1ldGhvZCBuYW1lIGBEZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lUm9vdGAgaW5cbiAgICogaXQgZm9yIGJvdGggY29udHJvbCBhbmQgc2FtcGxlIHN0YWNrcy5cbiAgICovXG5cblxuICB2YXIgUnVuSW5Sb290RnJhbWUgPSB7XG4gICAgRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290OiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgY29udHJvbDtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gVGhpcyBzaG91bGQgdGhyb3cuXG4gICAgICAgIGlmIChjb25zdHJ1Y3QpIHtcbiAgICAgICAgICAvLyBTb21ldGhpbmcgc2hvdWxkIGJlIHNldHRpbmcgdGhlIHByb3BzIGluIHRoZSBjb25zdHJ1Y3Rvci5cbiAgICAgICAgICB2YXIgRmFrZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICAgICAgfTsgLy8gJEZsb3dGaXhNZVtwcm9wLW1pc3NpbmddXG5cblxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShGYWtlLnByb3RvdHlwZSwgJ3Byb3BzJywge1xuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIC8vIFdlIHVzZSBhIHRocm93aW5nIHNldHRlciBpbnN0ZWFkIG9mIGZyb3plbiBvciBub24td3JpdGFibGUgcHJvcHNcbiAgICAgICAgICAgICAgLy8gYmVjYXVzZSB0aGF0IHdvbid0IHRocm93IGluIGEgbm9uLXN0cmljdCBtb2RlIGZ1bmN0aW9uLlxuICAgICAgICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSAnb2JqZWN0JyAmJiBSZWZsZWN0LmNvbnN0cnVjdCkge1xuICAgICAgICAgICAgLy8gV2UgY29uc3RydWN0IGEgZGlmZmVyZW50IGNvbnRyb2wgZm9yIHRoaXMgY2FzZSB0byBpbmNsdWRlIGFueSBleHRyYVxuICAgICAgICAgICAgLy8gZnJhbWVzIGFkZGVkIGJ5IHRoZSBjb25zdHJ1Y3QgY2FsbC5cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIFJlZmxlY3QuY29uc3RydWN0KEZha2UsIFtdKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICAgICAgY29udHJvbCA9IHg7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIFJlZmxlY3QuY29uc3RydWN0KGZuLCBbXSwgRmFrZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIEZha2UuY2FsbCgpO1xuICAgICAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgICAgICBjb250cm9sID0geDtcbiAgICAgICAgICAgIH0gLy8gJEZsb3dGaXhNZVtwcm9wLW1pc3NpbmddIGZvdW5kIHdoZW4gdXBncmFkaW5nIEZsb3dcblxuXG4gICAgICAgICAgICBmbi5jYWxsKEZha2UucHJvdG90eXBlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgICAgY29udHJvbCA9IHg7XG4gICAgICAgICAgfSAvLyBUT0RPKGx1bmEpOiBUaGlzIHdpbGwgY3VycmVudGx5IG9ubHkgdGhyb3cgaWYgdGhlIGZ1bmN0aW9uIGNvbXBvbmVudFxuICAgICAgICAgIC8vIHRyaWVzIHRvIGFjY2VzcyBSZWFjdC9SZWFjdERPTS9wcm9wcy4gV2Ugc2hvdWxkIHByb2JhYmx5IG1ha2UgdGhpcyB0aHJvd1xuICAgICAgICAgIC8vIGluIHNpbXBsZSBjb21wb25lbnRzIHRvb1xuXG5cbiAgICAgICAgICB2YXIgbWF5YmVQcm9taXNlID0gZm4oKTsgLy8gSWYgdGhlIGZ1bmN0aW9uIGNvbXBvbmVudCByZXR1cm5zIGEgcHJvbWlzZSwgaXQncyBsaWtlbHkgYW4gYXN5bmNcbiAgICAgICAgICAvLyBjb21wb25lbnQsIHdoaWNoIHdlIGRvbid0IHlldCBzdXBwb3J0LiBBdHRhY2ggYSBub29wIGNhdGNoIGhhbmRsZXIgdG9cbiAgICAgICAgICAvLyBzaWxlbmNlIHRoZSBlcnJvci5cbiAgICAgICAgICAvLyBUT0RPOiBJbXBsZW1lbnQgY29tcG9uZW50IHN0YWNrcyBmb3IgYXN5bmMgY2xpZW50IGNvbXBvbmVudHM/XG5cbiAgICAgICAgICBpZiAobWF5YmVQcm9taXNlICYmIHR5cGVvZiBtYXliZVByb21pc2UuY2F0Y2ggPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIG1heWJlUHJvbWlzZS5jYXRjaChmdW5jdGlvbiAoKSB7fSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChzYW1wbGUpIHtcbiAgICAgICAgLy8gVGhpcyBpcyBpbmxpbmVkIG1hbnVhbGx5IGJlY2F1c2UgY2xvc3VyZSBkb2Vzbid0IGRvIGl0IGZvciB1cy5cbiAgICAgICAgaWYgKHNhbXBsZSAmJiBjb250cm9sICYmIHR5cGVvZiBzYW1wbGUuc3RhY2sgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgcmV0dXJuIFtzYW1wbGUuc3RhY2ssIGNvbnRyb2wuc3RhY2tdO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBbbnVsbCwgbnVsbF07XG4gICAgfVxuICB9OyAvLyAkRmxvd0ZpeE1lW3Byb3AtbWlzc2luZ11cblxuICBSdW5JblJvb3RGcmFtZS5EZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3QuZGlzcGxheU5hbWUgPSAnRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290JztcbiAgdmFyIG5hbWVQcm9wRGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoUnVuSW5Sb290RnJhbWUuRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290LCAnbmFtZScpOyAvLyBCZWZvcmUgRVM2LCB0aGUgYG5hbWVgIHByb3BlcnR5IHdhcyBub3QgY29uZmlndXJhYmxlLlxuXG4gIGlmIChuYW1lUHJvcERlc2NyaXB0b3IgJiYgbmFtZVByb3BEZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSkge1xuICAgIC8vIFY4IHV0aWxpemVzIGEgZnVuY3Rpb24ncyBgbmFtZWAgcHJvcGVydHkgd2hlbiBnZW5lcmF0aW5nIGEgc3RhY2sgdHJhY2UuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFJ1bkluUm9vdEZyYW1lLkRldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdCwgLy8gQ29uZmlndXJhYmxlIHByb3BlcnRpZXMgY2FuIGJlIHVwZGF0ZWQgZXZlbiBpZiBpdHMgd3JpdGFibGUgZGVzY3JpcHRvclxuICAgIC8vIGlzIHNldCB0byBgZmFsc2VgLlxuICAgIC8vICRGbG93Rml4TWVbY2Fubm90LXdyaXRlXVxuICAgICduYW1lJywge1xuICAgICAgdmFsdWU6ICdEZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3QnXG4gICAgfSk7XG4gIH1cblxuICB0cnkge1xuICAgIHZhciBfUnVuSW5Sb290RnJhbWUkRGV0ZXIgPSBSdW5JblJvb3RGcmFtZS5EZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3QoKSxcbiAgICAgICAgc2FtcGxlU3RhY2sgPSBfUnVuSW5Sb290RnJhbWUkRGV0ZXJbMF0sXG4gICAgICAgIGNvbnRyb2xTdGFjayA9IF9SdW5JblJvb3RGcmFtZSREZXRlclsxXTtcblxuICAgIGlmIChzYW1wbGVTdGFjayAmJiBjb250cm9sU3RhY2spIHtcbiAgICAgIC8vIFRoaXMgZXh0cmFjdHMgdGhlIGZpcnN0IGZyYW1lIGZyb20gdGhlIHNhbXBsZSB0aGF0IGlzbid0IGFsc28gaW4gdGhlIGNvbnRyb2wuXG4gICAgICAvLyBTa2lwcGluZyBvbmUgZnJhbWUgdGhhdCB3ZSBhc3N1bWUgaXMgdGhlIGZyYW1lIHRoYXQgY2FsbHMgdGhlIHR3by5cbiAgICAgIHZhciBzYW1wbGVMaW5lcyA9IHNhbXBsZVN0YWNrLnNwbGl0KCdcXG4nKTtcbiAgICAgIHZhciBjb250cm9sTGluZXMgPSBjb250cm9sU3RhY2suc3BsaXQoJ1xcbicpO1xuICAgICAgdmFyIHMgPSAwO1xuICAgICAgdmFyIGMgPSAwO1xuXG4gICAgICB3aGlsZSAocyA8IHNhbXBsZUxpbmVzLmxlbmd0aCAmJiAhc2FtcGxlTGluZXNbc10uaW5jbHVkZXMoJ0RldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdCcpKSB7XG4gICAgICAgIHMrKztcbiAgICAgIH1cblxuICAgICAgd2hpbGUgKGMgPCBjb250cm9sTGluZXMubGVuZ3RoICYmICFjb250cm9sTGluZXNbY10uaW5jbHVkZXMoJ0RldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdCcpKSB7XG4gICAgICAgIGMrKztcbiAgICAgIH0gLy8gV2UgY291bGRuJ3QgZmluZCBvdXIgaW50ZW50aW9uYWxseSBpbmplY3RlZCBjb21tb24gcm9vdCBmcmFtZSwgYXR0ZW1wdFxuICAgICAgLy8gdG8gZmluZCBhbm90aGVyIGNvbW1vbiByb290IGZyYW1lIGJ5IHNlYXJjaCBmcm9tIHRoZSBib3R0b20gb2YgdGhlXG4gICAgICAvLyBjb250cm9sIHN0YWNrLi4uXG5cblxuICAgICAgaWYgKHMgPT09IHNhbXBsZUxpbmVzLmxlbmd0aCB8fCBjID09PSBjb250cm9sTGluZXMubGVuZ3RoKSB7XG4gICAgICAgIHMgPSBzYW1wbGVMaW5lcy5sZW5ndGggLSAxO1xuICAgICAgICBjID0gY29udHJvbExpbmVzLmxlbmd0aCAtIDE7XG5cbiAgICAgICAgd2hpbGUgKHMgPj0gMSAmJiBjID49IDAgJiYgc2FtcGxlTGluZXNbc10gIT09IGNvbnRyb2xMaW5lc1tjXSkge1xuICAgICAgICAgIC8vIFdlIGV4cGVjdCBhdCBsZWFzdCBvbmUgc3RhY2sgZnJhbWUgdG8gYmUgc2hhcmVkLlxuICAgICAgICAgIC8vIFR5cGljYWxseSB0aGlzIHdpbGwgYmUgdGhlIHJvb3QgbW9zdCBvbmUuIEhvd2V2ZXIsIHN0YWNrIGZyYW1lcyBtYXkgYmVcbiAgICAgICAgICAvLyBjdXQgb2ZmIGR1ZSB0byBtYXhpbXVtIHN0YWNrIGxpbWl0cy4gSW4gdGhpcyBjYXNlLCBvbmUgbWF5YmUgY3V0IG9mZlxuICAgICAgICAgIC8vIGVhcmxpZXIgdGhhbiB0aGUgb3RoZXIuIFdlIGFzc3VtZSB0aGF0IHRoZSBzYW1wbGUgaXMgbG9uZ2VyIG9yIHRoZSBzYW1lXG4gICAgICAgICAgLy8gYW5kIHRoZXJlIGZvciBjdXQgb2ZmIGVhcmxpZXIuIFNvIHdlIHNob3VsZCBmaW5kIHRoZSByb290IG1vc3QgZnJhbWUgaW5cbiAgICAgICAgICAvLyB0aGUgc2FtcGxlIHNvbWV3aGVyZSBpbiB0aGUgY29udHJvbC5cbiAgICAgICAgICBjLS07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZm9yICg7IHMgPj0gMSAmJiBjID49IDA7IHMtLSwgYy0tKSB7XG4gICAgICAgIC8vIE5leHQgd2UgZmluZCB0aGUgZmlyc3Qgb25lIHRoYXQgaXNuJ3QgdGhlIHNhbWUgd2hpY2ggc2hvdWxkIGJlIHRoZVxuICAgICAgICAvLyBmcmFtZSB0aGF0IGNhbGxlZCBvdXIgc2FtcGxlIGZ1bmN0aW9uIGFuZCB0aGUgY29udHJvbC5cbiAgICAgICAgaWYgKHNhbXBsZUxpbmVzW3NdICE9PSBjb250cm9sTGluZXNbY10pIHtcbiAgICAgICAgICAvLyBJbiBWOCwgdGhlIGZpcnN0IGxpbmUgaXMgZGVzY3JpYmluZyB0aGUgbWVzc2FnZSBidXQgb3RoZXIgVk1zIGRvbid0LlxuICAgICAgICAgIC8vIElmIHdlJ3JlIGFib3V0IHRvIHJldHVybiB0aGUgZmlyc3QgbGluZSwgYW5kIHRoZSBjb250cm9sIGlzIGFsc28gb24gdGhlIHNhbWVcbiAgICAgICAgICAvLyBsaW5lLCB0aGF0J3MgYSBwcmV0dHkgZ29vZCBpbmRpY2F0b3IgdGhhdCBvdXIgc2FtcGxlIHRocmV3IGF0IHNhbWUgbGluZSBhc1xuICAgICAgICAgIC8vIHRoZSBjb250cm9sLiBJLmUuIGJlZm9yZSB3ZSBlbnRlcmVkIHRoZSBzYW1wbGUgZnJhbWUuIFNvIHdlIGlnbm9yZSB0aGlzIHJlc3VsdC5cbiAgICAgICAgICAvLyBUaGlzIGNhbiBoYXBwZW4gaWYgeW91IHBhc3NlZCBhIGNsYXNzIHRvIGZ1bmN0aW9uIGNvbXBvbmVudCwgb3Igbm9uLWZ1bmN0aW9uLlxuICAgICAgICAgIGlmIChzICE9PSAxIHx8IGMgIT09IDEpIHtcbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgcy0tO1xuICAgICAgICAgICAgICBjLS07IC8vIFdlIG1heSBzdGlsbCBoYXZlIHNpbWlsYXIgaW50ZXJtZWRpYXRlIGZyYW1lcyBmcm9tIHRoZSBjb25zdHJ1Y3QgY2FsbC5cbiAgICAgICAgICAgICAgLy8gVGhlIG5leHQgb25lIHRoYXQgaXNuJ3QgdGhlIHNhbWUgc2hvdWxkIGJlIG91ciBtYXRjaCB0aG91Z2guXG5cbiAgICAgICAgICAgICAgaWYgKGMgPCAwIHx8IHNhbXBsZUxpbmVzW3NdICE9PSBjb250cm9sTGluZXNbY10pIHtcbiAgICAgICAgICAgICAgICAvLyBWOCBhZGRzIGEgXCJuZXdcIiBwcmVmaXggZm9yIG5hdGl2ZSBjbGFzc2VzLiBMZXQncyByZW1vdmUgaXQgdG8gbWFrZSBpdCBwcmV0dGllci5cbiAgICAgICAgICAgICAgICB2YXIgX2ZyYW1lID0gJ1xcbicgKyBzYW1wbGVMaW5lc1tzXS5yZXBsYWNlKCcgYXQgbmV3ICcsICcgYXQgJyk7IC8vIElmIG91ciBjb21wb25lbnQgZnJhbWUgaXMgbGFiZWxlZCBcIjxhbm9ueW1vdXM+XCJcbiAgICAgICAgICAgICAgICAvLyBidXQgd2UgaGF2ZSBhIHVzZXItcHJvdmlkZWQgXCJkaXNwbGF5TmFtZVwiXG4gICAgICAgICAgICAgICAgLy8gc3BsaWNlIGl0IGluIHRvIG1ha2UgdGhlIHN0YWNrIG1vcmUgcmVhZGFibGUuXG5cblxuICAgICAgICAgICAgICAgIGlmIChmbi5kaXNwbGF5TmFtZSAmJiBfZnJhbWUuaW5jbHVkZXMoJzxhbm9ueW1vdXM+JykpIHtcbiAgICAgICAgICAgICAgICAgIF9mcmFtZSA9IF9mcmFtZS5yZXBsYWNlKCc8YW5vbnltb3VzPicsIGZuLmRpc3BsYXlOYW1lKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAodHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICBjb21wb25lbnRGcmFtZUNhY2hlLnNldChmbiwgX2ZyYW1lKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IC8vIFJldHVybiB0aGUgbGluZSB3ZSBmb3VuZC5cblxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9mcmFtZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSB3aGlsZSAocyA+PSAxICYmIGMgPj0gMCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0gZmluYWxseSB7XG4gICAgcmVlbnRyeSA9IGZhbHNlO1xuXG4gICAge1xuICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlci5jdXJyZW50ID0gcHJldmlvdXNEaXNwYXRjaGVyO1xuICAgICAgcmVlbmFibGVMb2dzKCk7XG4gICAgfVxuXG4gICAgRXJyb3IucHJlcGFyZVN0YWNrVHJhY2UgPSBwcmV2aW91c1ByZXBhcmVTdGFja1RyYWNlO1xuICB9IC8vIEZhbGxiYWNrIHRvIGp1c3QgdXNpbmcgdGhlIG5hbWUgaWYgd2UgY291bGRuJ3QgbWFrZSBpdCB0aHJvdy5cblxuXG4gIHZhciBuYW1lID0gZm4gPyBmbi5kaXNwbGF5TmFtZSB8fCBmbi5uYW1lIDogJyc7XG4gIHZhciBzeW50aGV0aWNGcmFtZSA9IG5hbWUgPyBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZShuYW1lKSA6ICcnO1xuXG4gIHtcbiAgICBpZiAodHlwZW9mIGZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjb21wb25lbnRGcmFtZUNhY2hlLnNldChmbiwgc3ludGhldGljRnJhbWUpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzeW50aGV0aWNGcmFtZTtcbn1cbmZ1bmN0aW9uIGRlc2NyaWJlRnVuY3Rpb25Db21wb25lbnRGcmFtZShmbiwgb3duZXJGbikge1xuICB7XG4gICAgcmV0dXJuIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUoZm4sIGZhbHNlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzaG91bGRDb25zdHJ1Y3QoQ29tcG9uZW50KSB7XG4gIHZhciBwcm90b3R5cGUgPSBDb21wb25lbnQucHJvdG90eXBlO1xuICByZXR1cm4gISEocHJvdG90eXBlICYmIHByb3RvdHlwZS5pc1JlYWN0Q29tcG9uZW50KTtcbn1cblxuZnVuY3Rpb24gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKHR5cGUsIG93bmVyRm4pIHtcblxuICBpZiAodHlwZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAge1xuICAgICAgcmV0dXJuIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUodHlwZSwgc2hvdWxkQ29uc3RydWN0KHR5cGUpKTtcbiAgICB9XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKHR5cGUpO1xuICB9XG5cbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9UWVBFOlxuICAgICAgcmV0dXJuIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKCdTdXNwZW5zZScpO1xuXG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEU6XG4gICAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUoJ1N1c3BlbnNlTGlzdCcpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0Jykge1xuICAgIHN3aXRjaCAodHlwZS4kJHR5cGVvZikge1xuICAgICAgY2FzZSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFOlxuICAgICAgICByZXR1cm4gZGVzY3JpYmVGdW5jdGlvbkNvbXBvbmVudEZyYW1lKHR5cGUucmVuZGVyKTtcblxuICAgICAgY2FzZSBSRUFDVF9NRU1PX1RZUEU6XG4gICAgICAgIC8vIE1lbW8gbWF5IGNvbnRhaW4gYW55IGNvbXBvbmVudCB0eXBlIHNvIHdlIHJlY3Vyc2l2ZWx5IHJlc29sdmUgaXQuXG4gICAgICAgIHJldHVybiBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYodHlwZS50eXBlLCBvd25lckZuKTtcblxuICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgbGF6eUNvbXBvbmVudCA9IHR5cGU7XG4gICAgICAgICAgdmFyIHBheWxvYWQgPSBsYXp5Q29tcG9uZW50Ll9wYXlsb2FkO1xuICAgICAgICAgIHZhciBpbml0ID0gbGF6eUNvbXBvbmVudC5faW5pdDtcblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBMYXp5IG1heSBjb250YWluIGFueSBjb21wb25lbnQgdHlwZSBzbyB3ZSByZWN1cnNpdmVseSByZXNvbHZlIGl0LlxuICAgICAgICAgICAgcmV0dXJuIGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVihpbml0KHBheWxvYWQpLCBvd25lckZuKTtcbiAgICAgICAgICB9IGNhdGNoICh4KSB7fVxuICAgICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuICcnO1xufVxuXG52YXIgUmVhY3RDdXJyZW50T3duZXIgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdEN1cnJlbnRPd25lcjtcbnZhciBSZWFjdERlYnVnQ3VycmVudEZyYW1lID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZTtcbnZhciBSRUFDVF9DTElFTlRfUkVGRVJFTkNFID0gU3ltYm9sLmZvcigncmVhY3QuY2xpZW50LnJlZmVyZW5jZScpO1xudmFyIHNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duO1xudmFyIHNwZWNpYWxQcm9wUmVmV2FybmluZ1Nob3duO1xudmFyIGRpZFdhcm5BYm91dFN0cmluZ1JlZnM7XG5cbntcbiAgZGlkV2FybkFib3V0U3RyaW5nUmVmcyA9IHt9O1xufVxuXG5mdW5jdGlvbiBoYXNWYWxpZFJlZihjb25maWcpIHtcbiAge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgJ3JlZicpKSB7XG4gICAgICB2YXIgZ2V0dGVyID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihjb25maWcsICdyZWYnKS5nZXQ7XG5cbiAgICAgIGlmIChnZXR0ZXIgJiYgZ2V0dGVyLmlzUmVhY3RXYXJuaW5nKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gY29uZmlnLnJlZiAhPT0gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiBoYXNWYWxpZEtleShjb25maWcpIHtcbiAge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgJ2tleScpKSB7XG4gICAgICB2YXIgZ2V0dGVyID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihjb25maWcsICdrZXknKS5nZXQ7XG5cbiAgICAgIGlmIChnZXR0ZXIgJiYgZ2V0dGVyLmlzUmVhY3RXYXJuaW5nKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gY29uZmlnLmtleSAhPT0gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiB3YXJuSWZTdHJpbmdSZWZDYW5ub3RCZUF1dG9Db252ZXJ0ZWQoY29uZmlnLCBzZWxmKSB7XG4gIHtcbiAgICBpZiAodHlwZW9mIGNvbmZpZy5yZWYgPT09ICdzdHJpbmcnICYmIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQgJiYgc2VsZiAmJiBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50LnN0YXRlTm9kZSAhPT0gc2VsZikge1xuICAgICAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudC50eXBlKTtcblxuICAgICAgaWYgKCFkaWRXYXJuQWJvdXRTdHJpbmdSZWZzW2NvbXBvbmVudE5hbWVdKSB7XG4gICAgICAgIGVycm9yKCdDb21wb25lbnQgXCIlc1wiIGNvbnRhaW5zIHRoZSBzdHJpbmcgcmVmIFwiJXNcIi4gJyArICdTdXBwb3J0IGZvciBzdHJpbmcgcmVmcyB3aWxsIGJlIHJlbW92ZWQgaW4gYSBmdXR1cmUgbWFqb3IgcmVsZWFzZS4gJyArICdUaGlzIGNhc2UgY2Fubm90IGJlIGF1dG9tYXRpY2FsbHkgY29udmVydGVkIHRvIGFuIGFycm93IGZ1bmN0aW9uLiAnICsgJ1dlIGFzayB5b3UgdG8gbWFudWFsbHkgZml4IHRoaXMgY2FzZSBieSB1c2luZyB1c2VSZWYoKSBvciBjcmVhdGVSZWYoKSBpbnN0ZWFkLiAnICsgJ0xlYXJuIG1vcmUgYWJvdXQgdXNpbmcgcmVmcyBzYWZlbHkgaGVyZTogJyArICdodHRwczovL3JlYWN0anMub3JnL2xpbmsvc3RyaWN0LW1vZGUtc3RyaW5nLXJlZicsIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50LnR5cGUpLCBjb25maWcucmVmKTtcblxuICAgICAgICBkaWRXYXJuQWJvdXRTdHJpbmdSZWZzW2NvbXBvbmVudE5hbWVdID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZGVmaW5lS2V5UHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKSB7XG4gIHtcbiAgICB2YXIgd2FybkFib3V0QWNjZXNzaW5nS2V5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKCFzcGVjaWFsUHJvcEtleVdhcm5pbmdTaG93bikge1xuICAgICAgICBzcGVjaWFsUHJvcEtleVdhcm5pbmdTaG93biA9IHRydWU7XG5cbiAgICAgICAgZXJyb3IoJyVzOiBga2V5YCBpcyBub3QgYSBwcm9wLiBUcnlpbmcgdG8gYWNjZXNzIGl0IHdpbGwgcmVzdWx0ICcgKyAnaW4gYHVuZGVmaW5lZGAgYmVpbmcgcmV0dXJuZWQuIElmIHlvdSBuZWVkIHRvIGFjY2VzcyB0aGUgc2FtZSAnICsgJ3ZhbHVlIHdpdGhpbiB0aGUgY2hpbGQgY29tcG9uZW50LCB5b3Ugc2hvdWxkIHBhc3MgaXQgYXMgYSBkaWZmZXJlbnQgJyArICdwcm9wLiAoaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3NwZWNpYWwtcHJvcHMpJywgZGlzcGxheU5hbWUpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB3YXJuQWJvdXRBY2Nlc3NpbmdLZXkuaXNSZWFjdFdhcm5pbmcgPSB0cnVlO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm9wcywgJ2tleScsIHtcbiAgICAgIGdldDogd2FybkFib3V0QWNjZXNzaW5nS2V5LFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZGVmaW5lUmVmUHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKSB7XG4gIHtcbiAgICB7XG4gICAgICB2YXIgd2FybkFib3V0QWNjZXNzaW5nUmVmID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXNwZWNpYWxQcm9wUmVmV2FybmluZ1Nob3duKSB7XG4gICAgICAgICAgc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd24gPSB0cnVlO1xuXG4gICAgICAgICAgZXJyb3IoJyVzOiBgcmVmYCBpcyBub3QgYSBwcm9wLiBUcnlpbmcgdG8gYWNjZXNzIGl0IHdpbGwgcmVzdWx0ICcgKyAnaW4gYHVuZGVmaW5lZGAgYmVpbmcgcmV0dXJuZWQuIElmIHlvdSBuZWVkIHRvIGFjY2VzcyB0aGUgc2FtZSAnICsgJ3ZhbHVlIHdpdGhpbiB0aGUgY2hpbGQgY29tcG9uZW50LCB5b3Ugc2hvdWxkIHBhc3MgaXQgYXMgYSBkaWZmZXJlbnQgJyArICdwcm9wLiAoaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3NwZWNpYWwtcHJvcHMpJywgZGlzcGxheU5hbWUpO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICB3YXJuQWJvdXRBY2Nlc3NpbmdSZWYuaXNSZWFjdFdhcm5pbmcgPSB0cnVlO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3BzLCAncmVmJywge1xuICAgICAgICBnZXQ6IHdhcm5BYm91dEFjY2Vzc2luZ1JlZixcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbn1cbi8qKlxuICogRmFjdG9yeSBtZXRob2QgdG8gY3JlYXRlIGEgbmV3IFJlYWN0IGVsZW1lbnQuIFRoaXMgbm8gbG9uZ2VyIGFkaGVyZXMgdG9cbiAqIHRoZSBjbGFzcyBwYXR0ZXJuLCBzbyBkbyBub3QgdXNlIG5ldyB0byBjYWxsIGl0LiBBbHNvLCBpbnN0YW5jZW9mIGNoZWNrXG4gKiB3aWxsIG5vdCB3b3JrLiBJbnN0ZWFkIHRlc3QgJCR0eXBlb2YgZmllbGQgYWdhaW5zdCBTeW1ib2wuZm9yKCdyZWFjdC5lbGVtZW50JykgdG8gY2hlY2tcbiAqIGlmIHNvbWV0aGluZyBpcyBhIFJlYWN0IEVsZW1lbnQuXG4gKlxuICogQHBhcmFtIHsqfSB0eXBlXG4gKiBAcGFyYW0geyp9IHByb3BzXG4gKiBAcGFyYW0geyp9IGtleVxuICogQHBhcmFtIHtzdHJpbmd8b2JqZWN0fSByZWZcbiAqIEBwYXJhbSB7Kn0gb3duZXJcbiAqIEBwYXJhbSB7Kn0gc2VsZiBBICp0ZW1wb3JhcnkqIGhlbHBlciB0byBkZXRlY3QgcGxhY2VzIHdoZXJlIGB0aGlzYCBpc1xuICogZGlmZmVyZW50IGZyb20gdGhlIGBvd25lcmAgd2hlbiBSZWFjdC5jcmVhdGVFbGVtZW50IGlzIGNhbGxlZCwgc28gdGhhdCB3ZVxuICogY2FuIHdhcm4uIFdlIHdhbnQgdG8gZ2V0IHJpZCBvZiBvd25lciBhbmQgcmVwbGFjZSBzdHJpbmcgYHJlZmBzIHdpdGggYXJyb3dcbiAqIGZ1bmN0aW9ucywgYW5kIGFzIGxvbmcgYXMgYHRoaXNgIGFuZCBvd25lciBhcmUgdGhlIHNhbWUsIHRoZXJlIHdpbGwgYmUgbm9cbiAqIGNoYW5nZSBpbiBiZWhhdmlvci5cbiAqIEBwYXJhbSB7Kn0gc291cmNlIEFuIGFubm90YXRpb24gb2JqZWN0IChhZGRlZCBieSBhIHRyYW5zcGlsZXIgb3Igb3RoZXJ3aXNlKVxuICogaW5kaWNhdGluZyBmaWxlbmFtZSwgbGluZSBudW1iZXIsIGFuZC9vciBvdGhlciBpbmZvcm1hdGlvbi5cbiAqIEBpbnRlcm5hbFxuICovXG5cblxuZnVuY3Rpb24gUmVhY3RFbGVtZW50KHR5cGUsIGtleSwgX3JlZiwgc2VsZiwgc291cmNlLCBvd25lciwgcHJvcHMpIHtcbiAgdmFyIHJlZjtcblxuICB7XG4gICAgcmVmID0gX3JlZjtcbiAgfVxuXG4gIHZhciBlbGVtZW50O1xuXG4gIHtcbiAgICAvLyBJbiBwcm9kLCBgcmVmYCBpcyBhIHJlZ3VsYXIgcHJvcGVydHkuIEl0IHdpbGwgYmUgcmVtb3ZlZCBpbiBhXG4gICAgLy8gZnV0dXJlIHJlbGVhc2UuXG4gICAgZWxlbWVudCA9IHtcbiAgICAgIC8vIFRoaXMgdGFnIGFsbG93cyB1cyB0byB1bmlxdWVseSBpZGVudGlmeSB0aGlzIGFzIGEgUmVhY3QgRWxlbWVudFxuICAgICAgJCR0eXBlb2Y6IFJFQUNUX0VMRU1FTlRfVFlQRSxcbiAgICAgIC8vIEJ1aWx0LWluIHByb3BlcnRpZXMgdGhhdCBiZWxvbmcgb24gdGhlIGVsZW1lbnRcbiAgICAgIHR5cGU6IHR5cGUsXG4gICAgICBrZXk6IGtleSxcbiAgICAgIHJlZjogcmVmLFxuICAgICAgcHJvcHM6IHByb3BzLFxuICAgICAgLy8gUmVjb3JkIHRoZSBjb21wb25lbnQgcmVzcG9uc2libGUgZm9yIGNyZWF0aW5nIHRoaXMgZWxlbWVudC5cbiAgICAgIF9vd25lcjogb3duZXJcbiAgICB9O1xuICB9XG5cbiAge1xuICAgIC8vIFRoZSB2YWxpZGF0aW9uIGZsYWcgaXMgY3VycmVudGx5IG11dGF0aXZlLiBXZSBwdXQgaXQgb25cbiAgICAvLyBhbiBleHRlcm5hbCBiYWNraW5nIHN0b3JlIHNvIHRoYXQgd2UgY2FuIGZyZWV6ZSB0aGUgd2hvbGUgb2JqZWN0LlxuICAgIC8vIFRoaXMgY2FuIGJlIHJlcGxhY2VkIHdpdGggYSBXZWFrTWFwIG9uY2UgdGhleSBhcmUgaW1wbGVtZW50ZWQgaW5cbiAgICAvLyBjb21tb25seSB1c2VkIGRldmVsb3BtZW50IGVudmlyb25tZW50cy5cbiAgICBlbGVtZW50Ll9zdG9yZSA9IHt9OyAvLyBUbyBtYWtlIGNvbXBhcmluZyBSZWFjdEVsZW1lbnRzIGVhc2llciBmb3IgdGVzdGluZyBwdXJwb3Nlcywgd2UgbWFrZVxuICAgIC8vIHRoZSB2YWxpZGF0aW9uIGZsYWcgbm9uLWVudW1lcmFibGUgKHdoZXJlIHBvc3NpYmxlLCB3aGljaCBzaG91bGRcbiAgICAvLyBpbmNsdWRlIGV2ZXJ5IGVudmlyb25tZW50IHdlIHJ1biB0ZXN0cyBpbiksIHNvIHRoZSB0ZXN0IGZyYW1ld29ya1xuICAgIC8vIGlnbm9yZXMgaXQuXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudC5fc3RvcmUsICd2YWxpZGF0ZWQnLCB7XG4gICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIHZhbHVlOiBmYWxzZVxuICAgIH0pOyAvLyBkZWJ1Z0luZm8gY29udGFpbnMgU2VydmVyIENvbXBvbmVudCBkZWJ1ZyBpbmZvcm1hdGlvbi5cblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbGVtZW50LCAnX2RlYnVnSW5mbycsIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgdmFsdWU6IG51bGxcbiAgICB9KTtcblxuICAgIGlmIChPYmplY3QuZnJlZXplKSB7XG4gICAgICBPYmplY3QuZnJlZXplKGVsZW1lbnQucHJvcHMpO1xuICAgICAgT2JqZWN0LmZyZWV6ZShlbGVtZW50KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZWxlbWVudDtcbn1cbnZhciBkaWRXYXJuQWJvdXRLZXlTcHJlYWQgPSB7fTtcbi8qKlxuICogaHR0cHM6Ly9naXRodWIuY29tL3JlYWN0anMvcmZjcy9wdWxsLzEwN1xuICogQHBhcmFtIHsqfSB0eXBlXG4gKiBAcGFyYW0ge29iamVjdH0gcHJvcHNcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAqL1xuXG5mdW5jdGlvbiBqc3hERVYkMSh0eXBlLCBjb25maWcsIG1heWJlS2V5LCBpc1N0YXRpY0NoaWxkcmVuLCBzb3VyY2UsIHNlbGYpIHtcbiAge1xuICAgIGlmICghaXNWYWxpZEVsZW1lbnRUeXBlKHR5cGUpKSB7XG4gICAgICAvLyBUaGlzIGlzIGFuIGludmFsaWQgZWxlbWVudCB0eXBlLlxuICAgICAgLy9cbiAgICAgIC8vIFdlIHdhcm4gaW4gdGhpcyBjYXNlIGJ1dCBkb24ndCB0aHJvdy4gV2UgZXhwZWN0IHRoZSBlbGVtZW50IGNyZWF0aW9uIHRvXG4gICAgICAvLyBzdWNjZWVkIGFuZCB0aGVyZSB3aWxsIGxpa2VseSBiZSBlcnJvcnMgaW4gcmVuZGVyLlxuICAgICAgdmFyIGluZm8gPSAnJztcblxuICAgICAgaWYgKHR5cGUgPT09IHVuZGVmaW5lZCB8fCB0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcgJiYgdHlwZSAhPT0gbnVsbCAmJiBPYmplY3Qua2V5cyh0eXBlKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgaW5mbyArPSAnIFlvdSBsaWtlbHkgZm9yZ290IHRvIGV4cG9ydCB5b3VyIGNvbXBvbmVudCBmcm9tIHRoZSBmaWxlICcgKyBcIml0J3MgZGVmaW5lZCBpbiwgb3IgeW91IG1pZ2h0IGhhdmUgbWl4ZWQgdXAgZGVmYXVsdCBhbmQgbmFtZWQgaW1wb3J0cy5cIjtcbiAgICAgIH1cblxuICAgICAgdmFyIHR5cGVTdHJpbmc7XG5cbiAgICAgIGlmICh0eXBlID09PSBudWxsKSB7XG4gICAgICAgIHR5cGVTdHJpbmcgPSAnbnVsbCc7XG4gICAgICB9IGVsc2UgaWYgKGlzQXJyYXkodHlwZSkpIHtcbiAgICAgICAgdHlwZVN0cmluZyA9ICdhcnJheSc7XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgIT09IHVuZGVmaW5lZCAmJiB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEUpIHtcbiAgICAgICAgdHlwZVN0cmluZyA9IFwiPFwiICsgKGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlLnR5cGUpIHx8ICdVbmtub3duJykgKyBcIiAvPlwiO1xuICAgICAgICBpbmZvID0gJyBEaWQgeW91IGFjY2lkZW50YWxseSBleHBvcnQgYSBKU1ggbGl0ZXJhbCBpbnN0ZWFkIG9mIGEgY29tcG9uZW50Pyc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0eXBlU3RyaW5nID0gdHlwZW9mIHR5cGU7XG4gICAgICB9XG5cbiAgICAgIGVycm9yKCdSZWFjdC5qc3g6IHR5cGUgaXMgaW52YWxpZCAtLSBleHBlY3RlZCBhIHN0cmluZyAoZm9yICcgKyAnYnVpbHQtaW4gY29tcG9uZW50cykgb3IgYSBjbGFzcy9mdW5jdGlvbiAoZm9yIGNvbXBvc2l0ZSAnICsgJ2NvbXBvbmVudHMpIGJ1dCBnb3Q6ICVzLiVzJywgdHlwZVN0cmluZywgaW5mbyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRoaXMgaXMgYSB2YWxpZCBlbGVtZW50IHR5cGUuXG4gICAgICAvLyBTa2lwIGtleSB3YXJuaW5nIGlmIHRoZSB0eXBlIGlzbid0IHZhbGlkIHNpbmNlIG91ciBrZXkgdmFsaWRhdGlvbiBsb2dpY1xuICAgICAgLy8gZG9lc24ndCBleHBlY3QgYSBub24tc3RyaW5nL2Z1bmN0aW9uIHR5cGUgYW5kIGNhbiB0aHJvdyBjb25mdXNpbmdcbiAgICAgIC8vIGVycm9ycy4gV2UgZG9uJ3Qgd2FudCBleGNlcHRpb24gYmVoYXZpb3IgdG8gZGlmZmVyIGJldHdlZW4gZGV2IGFuZFxuICAgICAgLy8gcHJvZC4gKFJlbmRlcmluZyB3aWxsIHRocm93IHdpdGggYSBoZWxwZnVsIG1lc3NhZ2UgYW5kIGFzIHNvb24gYXMgdGhlXG4gICAgICAvLyB0eXBlIGlzIGZpeGVkLCB0aGUga2V5IHdhcm5pbmdzIHdpbGwgYXBwZWFyLilcbiAgICAgIHZhciBjaGlsZHJlbiA9IGNvbmZpZy5jaGlsZHJlbjtcblxuICAgICAgaWYgKGNoaWxkcmVuICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKGlzU3RhdGljQ2hpbGRyZW4pIHtcbiAgICAgICAgICBpZiAoaXNBcnJheShjaGlsZHJlbikpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgdmFsaWRhdGVDaGlsZEtleXMoY2hpbGRyZW5baV0sIHR5cGUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoT2JqZWN0LmZyZWV6ZSkge1xuICAgICAgICAgICAgICBPYmplY3QuZnJlZXplKGNoaWxkcmVuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZXJyb3IoJ1JlYWN0LmpzeDogU3RhdGljIGNoaWxkcmVuIHNob3VsZCBhbHdheXMgYmUgYW4gYXJyYXkuICcgKyAnWW91IGFyZSBsaWtlbHkgZXhwbGljaXRseSBjYWxsaW5nIFJlYWN0LmpzeHMgb3IgUmVhY3QuanN4REVWLiAnICsgJ1VzZSB0aGUgQmFiZWwgdHJhbnNmb3JtIGluc3RlYWQuJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbGlkYXRlQ2hpbGRLZXlzKGNoaWxkcmVuLCB0eXBlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gLy8gV2FybiBhYm91dCBrZXkgc3ByZWFkIHJlZ2FyZGxlc3Mgb2Ygd2hldGhlciB0aGUgdHlwZSBpcyB2YWxpZC5cblxuXG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCAna2V5JykpIHtcbiAgICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpO1xuICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhjb25maWcpLmZpbHRlcihmdW5jdGlvbiAoaykge1xuICAgICAgICByZXR1cm4gayAhPT0gJ2tleSc7XG4gICAgICB9KTtcbiAgICAgIHZhciBiZWZvcmVFeGFtcGxlID0ga2V5cy5sZW5ndGggPiAwID8gJ3trZXk6IHNvbWVLZXksICcgKyBrZXlzLmpvaW4oJzogLi4uLCAnKSArICc6IC4uLn0nIDogJ3trZXk6IHNvbWVLZXl9JztcblxuICAgICAgaWYgKCFkaWRXYXJuQWJvdXRLZXlTcHJlYWRbY29tcG9uZW50TmFtZSArIGJlZm9yZUV4YW1wbGVdKSB7XG4gICAgICAgIHZhciBhZnRlckV4YW1wbGUgPSBrZXlzLmxlbmd0aCA+IDAgPyAneycgKyBrZXlzLmpvaW4oJzogLi4uLCAnKSArICc6IC4uLn0nIDogJ3t9JztcblxuICAgICAgICBlcnJvcignQSBwcm9wcyBvYmplY3QgY29udGFpbmluZyBhIFwia2V5XCIgcHJvcCBpcyBiZWluZyBzcHJlYWQgaW50byBKU1g6XFxuJyArICcgIGxldCBwcm9wcyA9ICVzO1xcbicgKyAnICA8JXMgey4uLnByb3BzfSAvPlxcbicgKyAnUmVhY3Qga2V5cyBtdXN0IGJlIHBhc3NlZCBkaXJlY3RseSB0byBKU1ggd2l0aG91dCB1c2luZyBzcHJlYWQ6XFxuJyArICcgIGxldCBwcm9wcyA9ICVzO1xcbicgKyAnICA8JXMga2V5PXtzb21lS2V5fSB7Li4ucHJvcHN9IC8+JywgYmVmb3JlRXhhbXBsZSwgY29tcG9uZW50TmFtZSwgYWZ0ZXJFeGFtcGxlLCBjb21wb25lbnROYW1lKTtcblxuICAgICAgICBkaWRXYXJuQWJvdXRLZXlTcHJlYWRbY29tcG9uZW50TmFtZSArIGJlZm9yZUV4YW1wbGVdID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgcHJvcE5hbWU7IC8vIFJlc2VydmVkIG5hbWVzIGFyZSBleHRyYWN0ZWRcblxuICAgIHZhciBwcm9wcyA9IHt9O1xuICAgIHZhciBrZXkgPSBudWxsO1xuICAgIHZhciByZWYgPSBudWxsOyAvLyBDdXJyZW50bHksIGtleSBjYW4gYmUgc3ByZWFkIGluIGFzIGEgcHJvcC4gVGhpcyBjYXVzZXMgYSBwb3RlbnRpYWxcbiAgICAvLyBpc3N1ZSBpZiBrZXkgaXMgYWxzbyBleHBsaWNpdGx5IGRlY2xhcmVkIChpZS4gPGRpdiB7Li4ucHJvcHN9IGtleT1cIkhpXCIgLz5cbiAgICAvLyBvciA8ZGl2IGtleT1cIkhpXCIgey4uLnByb3BzfSAvPiApLiBXZSB3YW50IHRvIGRlcHJlY2F0ZSBrZXkgc3ByZWFkLFxuICAgIC8vIGJ1dCBhcyBhbiBpbnRlcm1lZGlhcnkgc3RlcCwgd2Ugd2lsbCB1c2UganN4REVWIGZvciBldmVyeXRoaW5nIGV4Y2VwdFxuICAgIC8vIDxkaXYgey4uLnByb3BzfSBrZXk9XCJIaVwiIC8+LCBiZWNhdXNlIHdlIGFyZW4ndCBjdXJyZW50bHkgYWJsZSB0byB0ZWxsIGlmXG4gICAgLy8ga2V5IGlzIGV4cGxpY2l0bHkgZGVjbGFyZWQgdG8gYmUgdW5kZWZpbmVkIG9yIG5vdC5cblxuICAgIGlmIChtYXliZUtleSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB7XG4gICAgICAgIGNoZWNrS2V5U3RyaW5nQ29lcmNpb24obWF5YmVLZXkpO1xuICAgICAgfVxuXG4gICAgICBrZXkgPSAnJyArIG1heWJlS2V5O1xuICAgIH1cblxuICAgIGlmIChoYXNWYWxpZEtleShjb25maWcpKSB7XG4gICAgICB7XG4gICAgICAgIGNoZWNrS2V5U3RyaW5nQ29lcmNpb24oY29uZmlnLmtleSk7XG4gICAgICB9XG5cbiAgICAgIGtleSA9ICcnICsgY29uZmlnLmtleTtcbiAgICB9XG5cbiAgICBpZiAoaGFzVmFsaWRSZWYoY29uZmlnKSkge1xuICAgICAge1xuICAgICAgICByZWYgPSBjb25maWcucmVmO1xuICAgICAgfVxuXG4gICAgICB3YXJuSWZTdHJpbmdSZWZDYW5ub3RCZUF1dG9Db252ZXJ0ZWQoY29uZmlnLCBzZWxmKTtcbiAgICB9IC8vIFJlbWFpbmluZyBwcm9wZXJ0aWVzIGFyZSBhZGRlZCB0byBhIG5ldyBwcm9wcyBvYmplY3RcblxuXG4gICAgZm9yIChwcm9wTmFtZSBpbiBjb25maWcpIHtcbiAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgcHJvcE5hbWUpICYmIC8vIFNraXAgb3ZlciByZXNlcnZlZCBwcm9wIG5hbWVzXG4gICAgICBwcm9wTmFtZSAhPT0gJ2tleScgJiYgKHByb3BOYW1lICE9PSAncmVmJykpIHtcbiAgICAgICAgcHJvcHNbcHJvcE5hbWVdID0gY29uZmlnW3Byb3BOYW1lXTtcbiAgICAgIH1cbiAgICB9IC8vIFJlc29sdmUgZGVmYXVsdCBwcm9wc1xuXG5cbiAgICBpZiAodHlwZSAmJiB0eXBlLmRlZmF1bHRQcm9wcykge1xuICAgICAgdmFyIGRlZmF1bHRQcm9wcyA9IHR5cGUuZGVmYXVsdFByb3BzO1xuXG4gICAgICBmb3IgKHByb3BOYW1lIGluIGRlZmF1bHRQcm9wcykge1xuICAgICAgICBpZiAocHJvcHNbcHJvcE5hbWVdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBwcm9wc1twcm9wTmFtZV0gPSBkZWZhdWx0UHJvcHNbcHJvcE5hbWVdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGtleSB8fCByZWYpIHtcbiAgICAgIHZhciBkaXNwbGF5TmFtZSA9IHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nID8gdHlwZS5kaXNwbGF5TmFtZSB8fCB0eXBlLm5hbWUgfHwgJ1Vua25vd24nIDogdHlwZTtcblxuICAgICAgaWYgKGtleSkge1xuICAgICAgICBkZWZpbmVLZXlQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpO1xuICAgICAgfVxuXG4gICAgICBpZiAocmVmKSB7XG4gICAgICAgIGRlZmluZVJlZlByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGVsZW1lbnQgPSBSZWFjdEVsZW1lbnQodHlwZSwga2V5LCByZWYsIHNlbGYsIHNvdXJjZSwgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCwgcHJvcHMpO1xuXG4gICAgaWYgKHR5cGUgPT09IFJFQUNUX0ZSQUdNRU5UX1RZUEUpIHtcbiAgICAgIHZhbGlkYXRlRnJhZ21lbnRQcm9wcyhlbGVtZW50KTtcbiAgICB9XG5cbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKSB7XG4gIHtcbiAgICBpZiAoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCkge1xuICAgICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudC50eXBlKTtcblxuICAgICAgaWYgKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuICdcXG5cXG5DaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiBgJyArIG5hbWUgKyAnYC4nO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiAnJztcbiAgfVxufVxuLyoqXG4gKiBFbnN1cmUgdGhhdCBldmVyeSBlbGVtZW50IGVpdGhlciBpcyBwYXNzZWQgaW4gYSBzdGF0aWMgbG9jYXRpb24sIGluIGFuXG4gKiBhcnJheSB3aXRoIGFuIGV4cGxpY2l0IGtleXMgcHJvcGVydHkgZGVmaW5lZCwgb3IgaW4gYW4gb2JqZWN0IGxpdGVyYWxcbiAqIHdpdGggdmFsaWQga2V5IHByb3BlcnR5LlxuICpcbiAqIEBpbnRlcm5hbFxuICogQHBhcmFtIHtSZWFjdE5vZGV9IG5vZGUgU3RhdGljYWxseSBwYXNzZWQgY2hpbGQgb2YgYW55IHR5cGUuXG4gKiBAcGFyYW0geyp9IHBhcmVudFR5cGUgbm9kZSdzIHBhcmVudCdzIHR5cGUuXG4gKi9cblxuXG5mdW5jdGlvbiB2YWxpZGF0ZUNoaWxkS2V5cyhub2RlLCBwYXJlbnRUeXBlKSB7XG4gIHtcbiAgICBpZiAodHlwZW9mIG5vZGUgIT09ICdvYmplY3QnIHx8ICFub2RlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKG5vZGUuJCR0eXBlb2YgPT09IFJFQUNUX0NMSUVOVF9SRUZFUkVOQ0UpIDsgZWxzZSBpZiAoaXNBcnJheShub2RlKSkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjaGlsZCA9IG5vZGVbaV07XG5cbiAgICAgICAgaWYgKGlzVmFsaWRFbGVtZW50KGNoaWxkKSkge1xuICAgICAgICAgIHZhbGlkYXRlRXhwbGljaXRLZXkoY2hpbGQsIHBhcmVudFR5cGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpc1ZhbGlkRWxlbWVudChub2RlKSkge1xuICAgICAgLy8gVGhpcyBlbGVtZW50IHdhcyBwYXNzZWQgaW4gYSB2YWxpZCBsb2NhdGlvbi5cbiAgICAgIGlmIChub2RlLl9zdG9yZSkge1xuICAgICAgICBub2RlLl9zdG9yZS52YWxpZGF0ZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgaXRlcmF0b3JGbiA9IGdldEl0ZXJhdG9yRm4obm9kZSk7XG5cbiAgICAgIGlmICh0eXBlb2YgaXRlcmF0b3JGbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAvLyBFbnRyeSBpdGVyYXRvcnMgdXNlZCB0byBwcm92aWRlIGltcGxpY2l0IGtleXMsXG4gICAgICAgIC8vIGJ1dCBub3cgd2UgcHJpbnQgYSBzZXBhcmF0ZSB3YXJuaW5nIGZvciB0aGVtIGxhdGVyLlxuICAgICAgICBpZiAoaXRlcmF0b3JGbiAhPT0gbm9kZS5lbnRyaWVzKSB7XG4gICAgICAgICAgdmFyIGl0ZXJhdG9yID0gaXRlcmF0b3JGbi5jYWxsKG5vZGUpO1xuICAgICAgICAgIHZhciBzdGVwO1xuXG4gICAgICAgICAgd2hpbGUgKCEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZSkge1xuICAgICAgICAgICAgaWYgKGlzVmFsaWRFbGVtZW50KHN0ZXAudmFsdWUpKSB7XG4gICAgICAgICAgICAgIHZhbGlkYXRlRXhwbGljaXRLZXkoc3RlcC52YWx1ZSwgcGFyZW50VHlwZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG4vKipcbiAqIFZlcmlmaWVzIHRoZSBvYmplY3QgaXMgYSBSZWFjdEVsZW1lbnQuXG4gKiBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL3JlYWN0LWFwaS5odG1sI2lzdmFsaWRlbGVtZW50XG4gKiBAcGFyYW0gez9vYmplY3R9IG9iamVjdFxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBgb2JqZWN0YCBpcyBhIFJlYWN0RWxlbWVudC5cbiAqIEBmaW5hbFxuICovXG5cblxuZnVuY3Rpb24gaXNWYWxpZEVsZW1lbnQob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0JyAmJiBvYmplY3QgIT09IG51bGwgJiYgb2JqZWN0LiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEU7XG59XG52YXIgb3duZXJIYXNLZXlVc2VXYXJuaW5nID0ge307XG4vKipcbiAqIFdhcm4gaWYgdGhlIGVsZW1lbnQgZG9lc24ndCBoYXZlIGFuIGV4cGxpY2l0IGtleSBhc3NpZ25lZCB0byBpdC5cbiAqIFRoaXMgZWxlbWVudCBpcyBpbiBhbiBhcnJheS4gVGhlIGFycmF5IGNvdWxkIGdyb3cgYW5kIHNocmluayBvciBiZVxuICogcmVvcmRlcmVkLiBBbGwgY2hpbGRyZW4gdGhhdCBoYXZlbid0IGFscmVhZHkgYmVlbiB2YWxpZGF0ZWQgYXJlIHJlcXVpcmVkIHRvXG4gKiBoYXZlIGEgXCJrZXlcIiBwcm9wZXJ0eSBhc3NpZ25lZCB0byBpdC4gRXJyb3Igc3RhdHVzZXMgYXJlIGNhY2hlZCBzbyBhIHdhcm5pbmdcbiAqIHdpbGwgb25seSBiZSBzaG93biBvbmNlLlxuICpcbiAqIEBpbnRlcm5hbFxuICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IGVsZW1lbnQgRWxlbWVudCB0aGF0IHJlcXVpcmVzIGEga2V5LlxuICogQHBhcmFtIHsqfSBwYXJlbnRUeXBlIGVsZW1lbnQncyBwYXJlbnQncyB0eXBlLlxuICovXG5cbmZ1bmN0aW9uIHZhbGlkYXRlRXhwbGljaXRLZXkoZWxlbWVudCwgcGFyZW50VHlwZSkge1xuICB7XG4gICAgaWYgKCFlbGVtZW50Ll9zdG9yZSB8fCBlbGVtZW50Ll9zdG9yZS52YWxpZGF0ZWQgfHwgZWxlbWVudC5rZXkgIT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGVsZW1lbnQuX3N0b3JlLnZhbGlkYXRlZCA9IHRydWU7XG4gICAgdmFyIGN1cnJlbnRDb21wb25lbnRFcnJvckluZm8gPSBnZXRDdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvKHBhcmVudFR5cGUpO1xuXG4gICAgaWYgKG93bmVySGFzS2V5VXNlV2FybmluZ1tjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvXSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIG93bmVySGFzS2V5VXNlV2FybmluZ1tjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvXSA9IHRydWU7IC8vIFVzdWFsbHkgdGhlIGN1cnJlbnQgb3duZXIgaXMgdGhlIG9mZmVuZGVyLCBidXQgaWYgaXQgYWNjZXB0cyBjaGlsZHJlbiBhcyBhXG4gICAgLy8gcHJvcGVydHksIGl0IG1heSBiZSB0aGUgY3JlYXRvciBvZiB0aGUgY2hpbGQgdGhhdCdzIHJlc3BvbnNpYmxlIGZvclxuICAgIC8vIGFzc2lnbmluZyBpdCBhIGtleS5cblxuICAgIHZhciBjaGlsZE93bmVyID0gJyc7XG5cbiAgICBpZiAoZWxlbWVudCAmJiBlbGVtZW50Ll9vd25lciAmJiBlbGVtZW50Ll9vd25lciAhPT0gUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCkge1xuICAgICAgLy8gR2l2ZSB0aGUgY29tcG9uZW50IHRoYXQgb3JpZ2luYWxseSBjcmVhdGVkIHRoaXMgY2hpbGQuXG4gICAgICBjaGlsZE93bmVyID0gXCIgSXQgd2FzIHBhc3NlZCBhIGNoaWxkIGZyb20gXCIgKyBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoZWxlbWVudC5fb3duZXIudHlwZSkgKyBcIi5cIjtcbiAgICB9XG5cbiAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChlbGVtZW50KTtcblxuICAgIGVycm9yKCdFYWNoIGNoaWxkIGluIGEgbGlzdCBzaG91bGQgaGF2ZSBhIHVuaXF1ZSBcImtleVwiIHByb3AuJyArICclcyVzIFNlZSBodHRwczovL3JlYWN0anMub3JnL2xpbmsvd2FybmluZy1rZXlzIGZvciBtb3JlIGluZm9ybWF0aW9uLicsIGN1cnJlbnRDb21wb25lbnRFcnJvckluZm8sIGNoaWxkT3duZXIpO1xuXG4gICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQobnVsbCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQoZWxlbWVudCkge1xuICB7XG4gICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgIHZhciBvd25lciA9IGVsZW1lbnQuX293bmVyO1xuICAgICAgdmFyIHN0YWNrID0gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKGVsZW1lbnQudHlwZSwgb3duZXIgPyBvd25lci50eXBlIDogbnVsbCk7XG4gICAgICBSZWFjdERlYnVnQ3VycmVudEZyYW1lLnNldEV4dHJhU3RhY2tGcmFtZShzdGFjayk7XG4gICAgfSBlbHNlIHtcbiAgICAgIFJlYWN0RGVidWdDdXJyZW50RnJhbWUuc2V0RXh0cmFTdGFja0ZyYW1lKG51bGwpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRDdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvKHBhcmVudFR5cGUpIHtcbiAge1xuICAgIHZhciBpbmZvID0gZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKCk7XG5cbiAgICBpZiAoIWluZm8pIHtcbiAgICAgIHZhciBwYXJlbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHBhcmVudFR5cGUpO1xuXG4gICAgICBpZiAocGFyZW50TmFtZSkge1xuICAgICAgICBpbmZvID0gXCJcXG5cXG5DaGVjayB0aGUgdG9wLWxldmVsIHJlbmRlciBjYWxsIHVzaW5nIDxcIiArIHBhcmVudE5hbWUgKyBcIj4uXCI7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGluZm87XG4gIH1cbn1cbi8qKlxuICogR2l2ZW4gYSBmcmFnbWVudCwgdmFsaWRhdGUgdGhhdCBpdCBjYW4gb25seSBiZSBwcm92aWRlZCB3aXRoIGZyYWdtZW50IHByb3BzXG4gKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gZnJhZ21lbnRcbiAqL1xuXG5cbmZ1bmN0aW9uIHZhbGlkYXRlRnJhZ21lbnRQcm9wcyhmcmFnbWVudCkge1xuICAvLyBUT0RPOiBNb3ZlIHRoaXMgdG8gcmVuZGVyIHBoYXNlIGluc3RlYWQgb2YgYXQgZWxlbWVudCBjcmVhdGlvbi5cbiAge1xuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoZnJhZ21lbnQucHJvcHMpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIga2V5ID0ga2V5c1tpXTtcblxuICAgICAgaWYgKGtleSAhPT0gJ2NoaWxkcmVuJyAmJiBrZXkgIT09ICdrZXknKSB7XG4gICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KGZyYWdtZW50KTtcblxuICAgICAgICBlcnJvcignSW52YWxpZCBwcm9wIGAlc2Agc3VwcGxpZWQgdG8gYFJlYWN0LkZyYWdtZW50YC4gJyArICdSZWFjdC5GcmFnbWVudCBjYW4gb25seSBoYXZlIGBrZXlgIGFuZCBgY2hpbGRyZW5gIHByb3BzLicsIGtleSk7XG5cbiAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQobnVsbCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChmcmFnbWVudC5yZWYgIT09IG51bGwpIHtcbiAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KGZyYWdtZW50KTtcblxuICAgICAgZXJyb3IoJ0ludmFsaWQgYXR0cmlidXRlIGByZWZgIHN1cHBsaWVkIHRvIGBSZWFjdC5GcmFnbWVudGAuJyk7XG5cbiAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KG51bGwpO1xuICAgIH1cbiAgfVxufVxuXG52YXIganN4REVWID0ganN4REVWJDEgO1xuXG5leHBvcnRzLkZyYWdtZW50ID0gUkVBQ1RfRlJBR01FTlRfVFlQRTtcbmV4cG9ydHMuanN4REVWID0ganN4REVWO1xuICB9KSgpO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js":
/*!******************************************************************!*\
  !*** ./node_modules/next/dist/compiled/react/jsx-dev-runtime.js ***!
  \******************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\nif (false) {} else {\n  module.exports = __webpack_require__(/*! ./cjs/react-jsx-dev-runtime.development.js */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QvanN4LWRldi1ydW50aW1lLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLElBQUksS0FBcUMsRUFBRSxFQUUxQyxDQUFDO0FBQ0YsRUFBRSw4TEFBc0U7QUFDeEUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9yZWFjdC9qc3gtZGV2LXJ1bnRpbWUuanM/NmYwZSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtanN4LWRldi1ydW50aW1lLnByb2R1Y3Rpb24ubWluLmpzJyk7XG59IGVsc2Uge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3JlYWN0LWpzeC1kZXYtcnVudGltZS5kZXZlbG9wbWVudC5qcycpO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/hazley-ui/dist/hazley-ui.js":
/*!**************************************************!*\
  !*** ./node_modules/hazley-ui/dist/hazley-ui.js ***!
  \**************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Button: function() { return /* binding */ ar; },\n/* harmony export */   Card: function() { return /* binding */ Sm; },\n/* harmony export */   DataTable: function() { return /* binding */ nH; },\n/* harmony export */   Graph: function() { return /* binding */ tH; },\n/* harmony export */   NewButton: function() { return /* binding */ KU; },\n/* harmony export */   NewCard: function() { return /* binding */ YU; },\n/* harmony export */   ToggleButton: function() { return /* binding */ eH; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react-dom */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react-dom/index.js\");\n\n\n\n\nvar ta = typeof globalThis < \"u\" ? globalThis : typeof window < \"u\" ? window : typeof global < \"u\" ? global : typeof self < \"u\" ? self : {};\nfunction je(e) {\n  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, \"default\") ? e.default : e;\n}\nvar hc = { exports: {} }, Ai = {};\n/**\n * @license React\n * react-jsx-runtime.production.min.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nvar kd;\nfunction $x() {\n  if (kd)\n    return Ai;\n  kd = 1;\n  var e = react__WEBPACK_IMPORTED_MODULE_0__, t = Symbol.for(\"react.element\"), n = Symbol.for(\"react.fragment\"), r = Object.prototype.hasOwnProperty, i = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, o = { key: !0, ref: !0, __self: !0, __source: !0 };\n  function a(s, u, c) {\n    var f, l = {}, d = null, p = null;\n    c !== void 0 && (d = \"\" + c), u.key !== void 0 && (d = \"\" + u.key), u.ref !== void 0 && (p = u.ref);\n    for (f in u)\n      r.call(u, f) && !o.hasOwnProperty(f) && (l[f] = u[f]);\n    if (s && s.defaultProps)\n      for (f in u = s.defaultProps, u)\n        l[f] === void 0 && (l[f] = u[f]);\n    return { $$typeof: t, type: s, key: d, ref: p, props: l, _owner: i.current };\n  }\n  return Ai.Fragment = n, Ai.jsx = a, Ai.jsxs = a, Ai;\n}\nvar Pi = {};\n/**\n * @license React\n * react-jsx-runtime.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nvar Dd;\nfunction Ox() {\n  return Dd || (Dd = 1,  true && function() {\n    var e = react__WEBPACK_IMPORTED_MODULE_0__, t = Symbol.for(\"react.element\"), n = Symbol.for(\"react.portal\"), r = Symbol.for(\"react.fragment\"), i = Symbol.for(\"react.strict_mode\"), o = Symbol.for(\"react.profiler\"), a = Symbol.for(\"react.provider\"), s = Symbol.for(\"react.context\"), u = Symbol.for(\"react.forward_ref\"), c = Symbol.for(\"react.suspense\"), f = Symbol.for(\"react.suspense_list\"), l = Symbol.for(\"react.memo\"), d = Symbol.for(\"react.lazy\"), p = Symbol.for(\"react.offscreen\"), g = Symbol.iterator, h = \"@@iterator\";\n    function v(_) {\n      if (_ === null || typeof _ != \"object\")\n        return null;\n      var W = g && _[g] || _[h];\n      return typeof W == \"function\" ? W : null;\n    }\n    var w = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\n    function b(_) {\n      {\n        for (var W = arguments.length, Z = new Array(W > 1 ? W - 1 : 0), ue = 1; ue < W; ue++)\n          Z[ue - 1] = arguments[ue];\n        x(\"error\", _, Z);\n      }\n    }\n    function x(_, W, Z) {\n      {\n        var ue = w.ReactDebugCurrentFrame, Ae = ue.getStackAddendum();\n        Ae !== \"\" && (W += \"%s\", Z = Z.concat([Ae]));\n        var Me = Z.map(function(be) {\n          return String(be);\n        });\n        Me.unshift(\"Warning: \" + W), Function.prototype.apply.call(console[_], console, Me);\n      }\n    }\n    var m = !1, y = !1, S = !1, $ = !1, O = !1, T;\n    T = Symbol.for(\"react.module.reference\");\n    function M(_) {\n      return !!(typeof _ == \"string\" || typeof _ == \"function\" || _ === r || _ === o || O || _ === i || _ === c || _ === f || $ || _ === p || m || y || S || typeof _ == \"object\" && _ !== null && (_.$$typeof === d || _.$$typeof === l || _.$$typeof === a || _.$$typeof === s || _.$$typeof === u || // This needs to include all possible module reference object\n      // types supported by any Flight configuration anywhere since\n      // we don't know which Flight build this will end up being used\n      // with.\n      _.$$typeof === T || _.getModuleId !== void 0));\n    }\n    function E(_, W, Z) {\n      var ue = _.displayName;\n      if (ue)\n        return ue;\n      var Ae = W.displayName || W.name || \"\";\n      return Ae !== \"\" ? Z + \"(\" + Ae + \")\" : Z;\n    }\n    function A(_) {\n      return _.displayName || \"Context\";\n    }\n    function j(_) {\n      if (_ == null)\n        return null;\n      if (typeof _.tag == \"number\" && b(\"Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue.\"), typeof _ == \"function\")\n        return _.displayName || _.name || null;\n      if (typeof _ == \"string\")\n        return _;\n      switch (_) {\n        case r:\n          return \"Fragment\";\n        case n:\n          return \"Portal\";\n        case o:\n          return \"Profiler\";\n        case i:\n          return \"StrictMode\";\n        case c:\n          return \"Suspense\";\n        case f:\n          return \"SuspenseList\";\n      }\n      if (typeof _ == \"object\")\n        switch (_.$$typeof) {\n          case s:\n            var W = _;\n            return A(W) + \".Consumer\";\n          case a:\n            var Z = _;\n            return A(Z._context) + \".Provider\";\n          case u:\n            return E(_, _.render, \"ForwardRef\");\n          case l:\n            var ue = _.displayName || null;\n            return ue !== null ? ue : j(_.type) || \"Memo\";\n          case d: {\n            var Ae = _, Me = Ae._payload, be = Ae._init;\n            try {\n              return j(be(Me));\n            } catch {\n              return null;\n            }\n          }\n        }\n      return null;\n    }\n    var R = Object.assign, N = 0, k, F, V, L, I, D, G;\n    function q() {\n    }\n    q.__reactDisabledLog = !0;\n    function J() {\n      {\n        if (N === 0) {\n          k = console.log, F = console.info, V = console.warn, L = console.error, I = console.group, D = console.groupCollapsed, G = console.groupEnd;\n          var _ = {\n            configurable: !0,\n            enumerable: !0,\n            value: q,\n            writable: !0\n          };\n          Object.defineProperties(console, {\n            info: _,\n            log: _,\n            warn: _,\n            error: _,\n            group: _,\n            groupCollapsed: _,\n            groupEnd: _\n          });\n        }\n        N++;\n      }\n    }\n    function ne() {\n      {\n        if (N--, N === 0) {\n          var _ = {\n            configurable: !0,\n            enumerable: !0,\n            writable: !0\n          };\n          Object.defineProperties(console, {\n            log: R({}, _, {\n              value: k\n            }),\n            info: R({}, _, {\n              value: F\n            }),\n            warn: R({}, _, {\n              value: V\n            }),\n            error: R({}, _, {\n              value: L\n            }),\n            group: R({}, _, {\n              value: I\n            }),\n            groupCollapsed: R({}, _, {\n              value: D\n            }),\n            groupEnd: R({}, _, {\n              value: G\n            })\n          });\n        }\n        N < 0 && b(\"disabledDepth fell below zero. This is a bug in React. Please file an issue.\");\n      }\n    }\n    var te = w.ReactCurrentDispatcher, ee;\n    function ie(_, W, Z) {\n      {\n        if (ee === void 0)\n          try {\n            throw Error();\n          } catch (Ae) {\n            var ue = Ae.stack.trim().match(/\\n( *(at )?)/);\n            ee = ue && ue[1] || \"\";\n          }\n        return `\n` + ee + _;\n      }\n    }\n    var B = !1, U;\n    {\n      var re = typeof WeakMap == \"function\" ? WeakMap : Map;\n      U = new re();\n    }\n    function C(_, W) {\n      if (!_ || B)\n        return \"\";\n      {\n        var Z = U.get(_);\n        if (Z !== void 0)\n          return Z;\n      }\n      var ue;\n      B = !0;\n      var Ae = Error.prepareStackTrace;\n      Error.prepareStackTrace = void 0;\n      var Me;\n      Me = te.current, te.current = null, J();\n      try {\n        if (W) {\n          var be = function() {\n            throw Error();\n          };\n          if (Object.defineProperty(be.prototype, \"props\", {\n            set: function() {\n              throw Error();\n            }\n          }), typeof Reflect == \"object\" && Reflect.construct) {\n            try {\n              Reflect.construct(be, []);\n            } catch (pt) {\n              ue = pt;\n            }\n            Reflect.construct(_, [], be);\n          } else {\n            try {\n              be.call();\n            } catch (pt) {\n              ue = pt;\n            }\n            _.call(be.prototype);\n          }\n        } else {\n          try {\n            throw Error();\n          } catch (pt) {\n            ue = pt;\n          }\n          _();\n        }\n      } catch (pt) {\n        if (pt && ue && typeof pt.stack == \"string\") {\n          for (var ve = pt.stack.split(`\n`), ct = ue.stack.split(`\n`), Ve = ve.length - 1, Ue = ct.length - 1; Ve >= 1 && Ue >= 0 && ve[Ve] !== ct[Ue]; )\n            Ue--;\n          for (; Ve >= 1 && Ue >= 0; Ve--, Ue--)\n            if (ve[Ve] !== ct[Ue]) {\n              if (Ve !== 1 || Ue !== 1)\n                do\n                  if (Ve--, Ue--, Ue < 0 || ve[Ve] !== ct[Ue]) {\n                    var Ct = `\n` + ve[Ve].replace(\" at new \", \" at \");\n                    return _.displayName && Ct.includes(\"<anonymous>\") && (Ct = Ct.replace(\"<anonymous>\", _.displayName)), typeof _ == \"function\" && U.set(_, Ct), Ct;\n                  }\n                while (Ve >= 1 && Ue >= 0);\n              break;\n            }\n        }\n      } finally {\n        B = !1, te.current = Me, ne(), Error.prepareStackTrace = Ae;\n      }\n      var wr = _ ? _.displayName || _.name : \"\", Zn = wr ? ie(wr) : \"\";\n      return typeof _ == \"function\" && U.set(_, Zn), Zn;\n    }\n    function ge(_, W, Z) {\n      return C(_, !1);\n    }\n    function le(_) {\n      var W = _.prototype;\n      return !!(W && W.isReactComponent);\n    }\n    function xe(_, W, Z) {\n      if (_ == null)\n        return \"\";\n      if (typeof _ == \"function\")\n        return C(_, le(_));\n      if (typeof _ == \"string\")\n        return ie(_);\n      switch (_) {\n        case c:\n          return ie(\"Suspense\");\n        case f:\n          return ie(\"SuspenseList\");\n      }\n      if (typeof _ == \"object\")\n        switch (_.$$typeof) {\n          case u:\n            return ge(_.render);\n          case l:\n            return xe(_.type, W, Z);\n          case d: {\n            var ue = _, Ae = ue._payload, Me = ue._init;\n            try {\n              return xe(Me(Ae), W, Z);\n            } catch {\n            }\n          }\n        }\n      return \"\";\n    }\n    var Ee = Object.prototype.hasOwnProperty, Ze = {}, dt = w.ReactDebugCurrentFrame;\n    function zt(_) {\n      if (_) {\n        var W = _._owner, Z = xe(_.type, _._source, W ? W.type : null);\n        dt.setExtraStackFrame(Z);\n      } else\n        dt.setExtraStackFrame(null);\n    }\n    function Vt(_, W, Z, ue, Ae) {\n      {\n        var Me = Function.call.bind(Ee);\n        for (var be in _)\n          if (Me(_, be)) {\n            var ve = void 0;\n            try {\n              if (typeof _[be] != \"function\") {\n                var ct = Error((ue || \"React class\") + \": \" + Z + \" type `\" + be + \"` is invalid; it must be a function, usually from the `prop-types` package, but received `\" + typeof _[be] + \"`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.\");\n                throw ct.name = \"Invariant Violation\", ct;\n              }\n              ve = _[be](W, be, ue, Z, null, \"SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED\");\n            } catch (Ve) {\n              ve = Ve;\n            }\n            ve && !(ve instanceof Error) && (zt(Ae), b(\"%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).\", ue || \"React class\", Z, be, typeof ve), zt(null)), ve instanceof Error && !(ve.message in Ze) && (Ze[ve.message] = !0, zt(Ae), b(\"Failed %s type: %s\", Z, ve.message), zt(null));\n          }\n      }\n    }\n    var rt = Array.isArray;\n    function Xn(_) {\n      return rt(_);\n    }\n    function xi(_) {\n      {\n        var W = typeof Symbol == \"function\" && Symbol.toStringTag, Z = W && _[Symbol.toStringTag] || _.constructor.name || \"Object\";\n        return Z;\n      }\n    }\n    function Si(_) {\n      try {\n        return $i(_), !1;\n      } catch {\n        return !0;\n      }\n    }\n    function $i(_) {\n      return \"\" + _;\n    }\n    function Oi(_) {\n      if (Si(_))\n        return b(\"The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.\", xi(_)), $i(_);\n    }\n    var _i = w.ReactCurrentOwner, nx = {\n      key: !0,\n      ref: !0,\n      __self: !0,\n      __source: !0\n    }, Ad, Pd, fu;\n    fu = {};\n    function rx(_) {\n      if (Ee.call(_, \"ref\")) {\n        var W = Object.getOwnPropertyDescriptor(_, \"ref\").get;\n        if (W && W.isReactWarning)\n          return !1;\n      }\n      return _.ref !== void 0;\n    }\n    function ix(_) {\n      if (Ee.call(_, \"key\")) {\n        var W = Object.getOwnPropertyDescriptor(_, \"key\").get;\n        if (W && W.isReactWarning)\n          return !1;\n      }\n      return _.key !== void 0;\n    }\n    function ox(_, W) {\n      if (typeof _.ref == \"string\" && _i.current && W && _i.current.stateNode !== W) {\n        var Z = j(_i.current.type);\n        fu[Z] || (b('Component \"%s\" contains the string ref \"%s\". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', j(_i.current.type), _.ref), fu[Z] = !0);\n      }\n    }\n    function ax(_, W) {\n      {\n        var Z = function() {\n          Ad || (Ad = !0, b(\"%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)\", W));\n        };\n        Z.isReactWarning = !0, Object.defineProperty(_, \"key\", {\n          get: Z,\n          configurable: !0\n        });\n      }\n    }\n    function sx(_, W) {\n      {\n        var Z = function() {\n          Pd || (Pd = !0, b(\"%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)\", W));\n        };\n        Z.isReactWarning = !0, Object.defineProperty(_, \"ref\", {\n          get: Z,\n          configurable: !0\n        });\n      }\n    }\n    var ux = function(_, W, Z, ue, Ae, Me, be) {\n      var ve = {\n        // This tag allows us to uniquely identify this as a React Element\n        $$typeof: t,\n        // Built-in properties that belong on the element\n        type: _,\n        key: W,\n        ref: Z,\n        props: be,\n        // Record the component responsible for creating this element.\n        _owner: Me\n      };\n      return ve._store = {}, Object.defineProperty(ve._store, \"validated\", {\n        configurable: !1,\n        enumerable: !1,\n        writable: !0,\n        value: !1\n      }), Object.defineProperty(ve, \"_self\", {\n        configurable: !1,\n        enumerable: !1,\n        writable: !1,\n        value: ue\n      }), Object.defineProperty(ve, \"_source\", {\n        configurable: !1,\n        enumerable: !1,\n        writable: !1,\n        value: Ae\n      }), Object.freeze && (Object.freeze(ve.props), Object.freeze(ve)), ve;\n    };\n    function cx(_, W, Z, ue, Ae) {\n      {\n        var Me, be = {}, ve = null, ct = null;\n        Z !== void 0 && (Oi(Z), ve = \"\" + Z), ix(W) && (Oi(W.key), ve = \"\" + W.key), rx(W) && (ct = W.ref, ox(W, Ae));\n        for (Me in W)\n          Ee.call(W, Me) && !nx.hasOwnProperty(Me) && (be[Me] = W[Me]);\n        if (_ && _.defaultProps) {\n          var Ve = _.defaultProps;\n          for (Me in Ve)\n            be[Me] === void 0 && (be[Me] = Ve[Me]);\n        }\n        if (ve || ct) {\n          var Ue = typeof _ == \"function\" ? _.displayName || _.name || \"Unknown\" : _;\n          ve && ax(be, Ue), ct && sx(be, Ue);\n        }\n        return ux(_, ve, ct, Ae, ue, _i.current, be);\n      }\n    }\n    var du = w.ReactCurrentOwner, Cd = w.ReactDebugCurrentFrame;\n    function br(_) {\n      if (_) {\n        var W = _._owner, Z = xe(_.type, _._source, W ? W.type : null);\n        Cd.setExtraStackFrame(Z);\n      } else\n        Cd.setExtraStackFrame(null);\n    }\n    var pu;\n    pu = !1;\n    function hu(_) {\n      return typeof _ == \"object\" && _ !== null && _.$$typeof === t;\n    }\n    function Ed() {\n      {\n        if (du.current) {\n          var _ = j(du.current.type);\n          if (_)\n            return `\n\nCheck the render method of \\`` + _ + \"`.\";\n        }\n        return \"\";\n      }\n    }\n    function lx(_) {\n      return \"\";\n    }\n    var Td = {};\n    function fx(_) {\n      {\n        var W = Ed();\n        if (!W) {\n          var Z = typeof _ == \"string\" ? _ : _.displayName || _.name;\n          Z && (W = `\n\nCheck the top-level render call using <` + Z + \">.\");\n        }\n        return W;\n      }\n    }\n    function Md(_, W) {\n      {\n        if (!_._store || _._store.validated || _.key != null)\n          return;\n        _._store.validated = !0;\n        var Z = fx(W);\n        if (Td[Z])\n          return;\n        Td[Z] = !0;\n        var ue = \"\";\n        _ && _._owner && _._owner !== du.current && (ue = \" It was passed a child from \" + j(_._owner.type) + \".\"), br(_), b('Each child in a list should have a unique \"key\" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', Z, ue), br(null);\n      }\n    }\n    function Rd(_, W) {\n      {\n        if (typeof _ != \"object\")\n          return;\n        if (Xn(_))\n          for (var Z = 0; Z < _.length; Z++) {\n            var ue = _[Z];\n            hu(ue) && Md(ue, W);\n          }\n        else if (hu(_))\n          _._store && (_._store.validated = !0);\n        else if (_) {\n          var Ae = v(_);\n          if (typeof Ae == \"function\" && Ae !== _.entries)\n            for (var Me = Ae.call(_), be; !(be = Me.next()).done; )\n              hu(be.value) && Md(be.value, W);\n        }\n      }\n    }\n    function dx(_) {\n      {\n        var W = _.type;\n        if (W == null || typeof W == \"string\")\n          return;\n        var Z;\n        if (typeof W == \"function\")\n          Z = W.propTypes;\n        else if (typeof W == \"object\" && (W.$$typeof === u || // Note: Memo only checks outer props here.\n        // Inner props are checked in the reconciler.\n        W.$$typeof === l))\n          Z = W.propTypes;\n        else\n          return;\n        if (Z) {\n          var ue = j(W);\n          Vt(Z, _.props, \"prop\", ue, _);\n        } else if (W.PropTypes !== void 0 && !pu) {\n          pu = !0;\n          var Ae = j(W);\n          b(\"Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?\", Ae || \"Unknown\");\n        }\n        typeof W.getDefaultProps == \"function\" && !W.getDefaultProps.isReactClassApproved && b(\"getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.\");\n      }\n    }\n    function px(_) {\n      {\n        for (var W = Object.keys(_.props), Z = 0; Z < W.length; Z++) {\n          var ue = W[Z];\n          if (ue !== \"children\" && ue !== \"key\") {\n            br(_), b(\"Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.\", ue), br(null);\n            break;\n          }\n        }\n        _.ref !== null && (br(_), b(\"Invalid attribute `ref` supplied to `React.Fragment`.\"), br(null));\n      }\n    }\n    var Id = {};\n    function jd(_, W, Z, ue, Ae, Me) {\n      {\n        var be = M(_);\n        if (!be) {\n          var ve = \"\";\n          (_ === void 0 || typeof _ == \"object\" && _ !== null && Object.keys(_).length === 0) && (ve += \" You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.\");\n          var ct = lx();\n          ct ? ve += ct : ve += Ed();\n          var Ve;\n          _ === null ? Ve = \"null\" : Xn(_) ? Ve = \"array\" : _ !== void 0 && _.$$typeof === t ? (Ve = \"<\" + (j(_.type) || \"Unknown\") + \" />\", ve = \" Did you accidentally export a JSX literal instead of a component?\") : Ve = typeof _, b(\"React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s\", Ve, ve);\n        }\n        var Ue = cx(_, W, Z, Ae, Me);\n        if (Ue == null)\n          return Ue;\n        if (be) {\n          var Ct = W.children;\n          if (Ct !== void 0)\n            if (ue)\n              if (Xn(Ct)) {\n                for (var wr = 0; wr < Ct.length; wr++)\n                  Rd(Ct[wr], _);\n                Object.freeze && Object.freeze(Ct);\n              } else\n                b(\"React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.\");\n            else\n              Rd(Ct, _);\n        }\n        if (Ee.call(W, \"key\")) {\n          var Zn = j(_), pt = Object.keys(W).filter(function(bx) {\n            return bx !== \"key\";\n          }), gu = pt.length > 0 ? \"{key: someKey, \" + pt.join(\": ..., \") + \": ...}\" : \"{key: someKey}\";\n          if (!Id[Zn + gu]) {\n            var yx = pt.length > 0 ? \"{\" + pt.join(\": ..., \") + \": ...}\" : \"{}\";\n            b(`A props object containing a \"key\" prop is being spread into JSX:\n  let props = %s;\n  <%s {...props} />\nReact keys must be passed directly to JSX without using spread:\n  let props = %s;\n  <%s key={someKey} {...props} />`, gu, Zn, yx, Zn), Id[Zn + gu] = !0;\n          }\n        }\n        return _ === r ? px(Ue) : dx(Ue), Ue;\n      }\n    }\n    function hx(_, W, Z) {\n      return jd(_, W, Z, !0);\n    }\n    function gx(_, W, Z) {\n      return jd(_, W, Z, !1);\n    }\n    var vx = gx, mx = hx;\n    Pi.Fragment = r, Pi.jsx = vx, Pi.jsxs = mx;\n  }()), Pi;\n}\n false ? 0 : hc.exports = Ox();\nvar dm = hc.exports;\nconst X = dm.jsx, ze = dm.jsxs;\nfunction ce() {\n  return ce = Object.assign ? Object.assign.bind() : function(e) {\n    for (var t = 1; t < arguments.length; t++) {\n      var n = arguments[t];\n      for (var r in n)\n        ({}).hasOwnProperty.call(n, r) && (e[r] = n[r]);\n    }\n    return e;\n  }, ce.apply(null, arguments);\n}\nfunction _x(e, t) {\n  typeof e == \"function\" ? e(t) : e != null && (e.current = t);\n}\nfunction Ms(...e) {\n  return (t) => e.forEach(\n    (n) => _x(n, t)\n  );\n}\nfunction _t(...e) {\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(Ms(...e), e);\n}\nconst kr = /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)((e, t) => {\n  const { children: n, ...r } = e, i = react__WEBPACK_IMPORTED_MODULE_0__.Children.toArray(n), o = i.find(Px);\n  if (o) {\n    const a = o.props.children, s = i.map((u) => u === o ? react__WEBPACK_IMPORTED_MODULE_0__.Children.count(a) > 1 ? react__WEBPACK_IMPORTED_MODULE_0__.Children.only(null) : /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.isValidElement)(a) ? a.props.children : null : u);\n    return /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(gc, ce({}, r, {\n      ref: t\n    }), /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.isValidElement)(a) ? /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.cloneElement)(a, void 0, s) : null);\n  }\n  return /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(gc, ce({}, r, {\n    ref: t\n  }), n);\n});\nkr.displayName = \"Slot\";\nconst gc = /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)((e, t) => {\n  const { children: n, ...r } = e;\n  return /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.isValidElement)(n) ? /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.cloneElement)(n, {\n    ...Cx(r, n.props),\n    ref: t ? Ms(t, n.ref) : n.ref\n  }) : react__WEBPACK_IMPORTED_MODULE_0__.Children.count(n) > 1 ? react__WEBPACK_IMPORTED_MODULE_0__.Children.only(null) : null;\n});\ngc.displayName = \"SlotClone\";\nconst Ax = ({ children: e }) => /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, e);\nfunction Px(e) {\n  return /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.isValidElement)(e) && e.type === Ax;\n}\nfunction Cx(e, t) {\n  const n = {\n    ...t\n  };\n  for (const r in t) {\n    const i = e[r], o = t[r];\n    /^on[A-Z]/.test(r) ? i && o ? n[r] = (...s) => {\n      o(...s), i(...s);\n    } : i && (n[r] = i) : r === \"style\" ? n[r] = {\n      ...i,\n      ...o\n    } : r === \"className\" && (n[r] = [\n      i,\n      o\n    ].filter(Boolean).join(\" \"));\n  }\n  return {\n    ...e,\n    ...n\n  };\n}\nfunction pm(e) {\n  var t, n, r = \"\";\n  if (typeof e == \"string\" || typeof e == \"number\")\n    r += e;\n  else if (typeof e == \"object\")\n    if (Array.isArray(e))\n      for (t = 0; t < e.length; t++)\n        e[t] && (n = pm(e[t])) && (r && (r += \" \"), r += n);\n    else\n      for (t in e)\n        e[t] && (r && (r += \" \"), r += t);\n  return r;\n}\nfunction Ex() {\n  for (var e, t, n = 0, r = \"\"; n < arguments.length; )\n    (e = arguments[n++]) && (t = pm(e)) && (r && (r += \" \"), r += t);\n  return r;\n}\nconst Nd = (e) => typeof e == \"boolean\" ? \"\".concat(e) : e === 0 ? \"0\" : e, Fd = Ex, Tx = (e, t) => (n) => {\n  var r;\n  if ((t == null ? void 0 : t.variants) == null)\n    return Fd(e, n == null ? void 0 : n.class, n == null ? void 0 : n.className);\n  const { variants: i, defaultVariants: o } = t, a = Object.keys(i).map((c) => {\n    const f = n == null ? void 0 : n[c], l = o == null ? void 0 : o[c];\n    if (f === null)\n      return null;\n    const d = Nd(f) || Nd(l);\n    return i[c][d];\n  }), s = n && Object.entries(n).reduce((c, f) => {\n    let [l, d] = f;\n    return d === void 0 || (c[l] = d), c;\n  }, {}), u = t == null || (r = t.compoundVariants) === null || r === void 0 ? void 0 : r.reduce((c, f) => {\n    let { class: l, className: d, ...p } = f;\n    return Object.entries(p).every((g) => {\n      let [h, v] = g;\n      return Array.isArray(v) ? v.includes({\n        ...o,\n        ...s\n      }[h]) : {\n        ...o,\n        ...s\n      }[h] === v;\n    }) ? [\n      ...c,\n      l,\n      d\n    ] : c;\n  }, []);\n  return Fd(e, a, u, n == null ? void 0 : n.class, n == null ? void 0 : n.className);\n};\nfunction hm(e) {\n  var t, n, r = \"\";\n  if (typeof e == \"string\" || typeof e == \"number\")\n    r += e;\n  else if (typeof e == \"object\")\n    if (Array.isArray(e)) {\n      var i = e.length;\n      for (t = 0; t < i; t++)\n        e[t] && (n = hm(e[t])) && (r && (r += \" \"), r += n);\n    } else\n      for (n in e)\n        e[n] && (r && (r += \" \"), r += n);\n  return r;\n}\nfunction $e() {\n  for (var e, t, n = 0, r = \"\", i = arguments.length; n < i; n++)\n    (e = arguments[n]) && (t = hm(e)) && (r && (r += \" \"), r += t);\n  return r;\n}\nconst ef = \"-\";\nfunction Mx(e) {\n  const t = Ix(e), {\n    conflictingClassGroups: n,\n    conflictingClassGroupModifiers: r\n  } = e;\n  function i(a) {\n    const s = a.split(ef);\n    return s[0] === \"\" && s.length !== 1 && s.shift(), gm(s, t) || Rx(a);\n  }\n  function o(a, s) {\n    const u = n[a] || [];\n    return s && r[a] ? [...u, ...r[a]] : u;\n  }\n  return {\n    getClassGroupId: i,\n    getConflictingClassGroupIds: o\n  };\n}\nfunction gm(e, t) {\n  var a;\n  if (e.length === 0)\n    return t.classGroupId;\n  const n = e[0], r = t.nextPart.get(n), i = r ? gm(e.slice(1), r) : void 0;\n  if (i)\n    return i;\n  if (t.validators.length === 0)\n    return;\n  const o = e.join(ef);\n  return (a = t.validators.find(({\n    validator: s\n  }) => s(o))) == null ? void 0 : a.classGroupId;\n}\nconst Ld = /^\\[(.+)\\]$/;\nfunction Rx(e) {\n  if (Ld.test(e)) {\n    const t = Ld.exec(e)[1], n = t == null ? void 0 : t.substring(0, t.indexOf(\":\"));\n    if (n)\n      return \"arbitrary..\" + n;\n  }\n}\nfunction Ix(e) {\n  const {\n    theme: t,\n    prefix: n\n  } = e, r = {\n    nextPart: /* @__PURE__ */ new Map(),\n    validators: []\n  };\n  return kx(Object.entries(e.classGroups), n).forEach(([o, a]) => {\n    vc(a, r, o, t);\n  }), r;\n}\nfunction vc(e, t, n, r) {\n  e.forEach((i) => {\n    if (typeof i == \"string\") {\n      const o = i === \"\" ? t : Bd(t, i);\n      o.classGroupId = n;\n      return;\n    }\n    if (typeof i == \"function\") {\n      if (jx(i)) {\n        vc(i(r), t, n, r);\n        return;\n      }\n      t.validators.push({\n        validator: i,\n        classGroupId: n\n      });\n      return;\n    }\n    Object.entries(i).forEach(([o, a]) => {\n      vc(a, Bd(t, o), n, r);\n    });\n  });\n}\nfunction Bd(e, t) {\n  let n = e;\n  return t.split(ef).forEach((r) => {\n    n.nextPart.has(r) || n.nextPart.set(r, {\n      nextPart: /* @__PURE__ */ new Map(),\n      validators: []\n    }), n = n.nextPart.get(r);\n  }), n;\n}\nfunction jx(e) {\n  return e.isThemeGetter;\n}\nfunction kx(e, t) {\n  return t ? e.map(([n, r]) => {\n    const i = r.map((o) => typeof o == \"string\" ? t + o : typeof o == \"object\" ? Object.fromEntries(Object.entries(o).map(([a, s]) => [t + a, s])) : o);\n    return [n, i];\n  }) : e;\n}\nfunction Dx(e) {\n  if (e < 1)\n    return {\n      get: () => {\n      },\n      set: () => {\n      }\n    };\n  let t = 0, n = /* @__PURE__ */ new Map(), r = /* @__PURE__ */ new Map();\n  function i(o, a) {\n    n.set(o, a), t++, t > e && (t = 0, r = n, n = /* @__PURE__ */ new Map());\n  }\n  return {\n    get(o) {\n      let a = n.get(o);\n      if (a !== void 0)\n        return a;\n      if ((a = r.get(o)) !== void 0)\n        return i(o, a), a;\n    },\n    set(o, a) {\n      n.has(o) ? n.set(o, a) : i(o, a);\n    }\n  };\n}\nconst vm = \"!\";\nfunction Nx(e) {\n  const t = e.separator, n = t.length === 1, r = t[0], i = t.length;\n  return function(a) {\n    const s = [];\n    let u = 0, c = 0, f;\n    for (let h = 0; h < a.length; h++) {\n      let v = a[h];\n      if (u === 0) {\n        if (v === r && (n || a.slice(h, h + i) === t)) {\n          s.push(a.slice(c, h)), c = h + i;\n          continue;\n        }\n        if (v === \"/\") {\n          f = h;\n          continue;\n        }\n      }\n      v === \"[\" ? u++ : v === \"]\" && u--;\n    }\n    const l = s.length === 0 ? a : a.substring(c), d = l.startsWith(vm), p = d ? l.substring(1) : l, g = f && f > c ? f - c : void 0;\n    return {\n      modifiers: s,\n      hasImportantModifier: d,\n      baseClassName: p,\n      maybePostfixModifierPosition: g\n    };\n  };\n}\nfunction Fx(e) {\n  if (e.length <= 1)\n    return e;\n  const t = [];\n  let n = [];\n  return e.forEach((r) => {\n    r[0] === \"[\" ? (t.push(...n.sort(), r), n = []) : n.push(r);\n  }), t.push(...n.sort()), t;\n}\nfunction Lx(e) {\n  return {\n    cache: Dx(e.cacheSize),\n    splitModifiers: Nx(e),\n    ...Mx(e)\n  };\n}\nconst Bx = /\\s+/;\nfunction zx(e, t) {\n  const {\n    splitModifiers: n,\n    getClassGroupId: r,\n    getConflictingClassGroupIds: i\n  } = t, o = /* @__PURE__ */ new Set();\n  return e.trim().split(Bx).map((a) => {\n    const {\n      modifiers: s,\n      hasImportantModifier: u,\n      baseClassName: c,\n      maybePostfixModifierPosition: f\n    } = n(a);\n    let l = r(f ? c.substring(0, f) : c), d = !!f;\n    if (!l) {\n      if (!f)\n        return {\n          isTailwindClass: !1,\n          originalClassName: a\n        };\n      if (l = r(c), !l)\n        return {\n          isTailwindClass: !1,\n          originalClassName: a\n        };\n      d = !1;\n    }\n    const p = Fx(s).join(\":\");\n    return {\n      isTailwindClass: !0,\n      modifierId: u ? p + vm : p,\n      classGroupId: l,\n      originalClassName: a,\n      hasPostfixModifier: d\n    };\n  }).reverse().filter((a) => {\n    if (!a.isTailwindClass)\n      return !0;\n    const {\n      modifierId: s,\n      classGroupId: u,\n      hasPostfixModifier: c\n    } = a, f = s + u;\n    return o.has(f) ? !1 : (o.add(f), i(u, c).forEach((l) => o.add(s + l)), !0);\n  }).reverse().map((a) => a.originalClassName).join(\" \");\n}\nfunction Vx() {\n  let e = 0, t, n, r = \"\";\n  for (; e < arguments.length; )\n    (t = arguments[e++]) && (n = mm(t)) && (r && (r += \" \"), r += n);\n  return r;\n}\nfunction mm(e) {\n  if (typeof e == \"string\")\n    return e;\n  let t, n = \"\";\n  for (let r = 0; r < e.length; r++)\n    e[r] && (t = mm(e[r])) && (n && (n += \" \"), n += t);\n  return n;\n}\nfunction Gx(e, ...t) {\n  let n, r, i, o = a;\n  function a(u) {\n    const c = t.reduce((f, l) => l(f), e());\n    return n = Lx(c), r = n.cache.get, i = n.cache.set, o = s, s(u);\n  }\n  function s(u) {\n    const c = r(u);\n    if (c)\n      return c;\n    const f = zx(u, n);\n    return i(u, f), f;\n  }\n  return function() {\n    return o(Vx.apply(null, arguments));\n  };\n}\nfunction ke(e) {\n  const t = (n) => n[e] || [];\n  return t.isThemeGetter = !0, t;\n}\nconst ym = /^\\[(?:([a-z-]+):)?(.+)\\]$/i, Wx = /^\\d+\\/\\d+$/, Ux = /* @__PURE__ */ new Set([\"px\", \"full\", \"screen\"]), Hx = /^(\\d+(\\.\\d+)?)?(xs|sm|md|lg|xl)$/, qx = /\\d+(%|px|r?em|[sdl]?v([hwib]|min|max)|pt|pc|in|cm|mm|cap|ch|ex|r?lh|cq(w|h|i|b|min|max))|\\b(calc|min|max|clamp)\\(.+\\)|^0$/, Kx = /^(rgba?|hsla?|hwb|(ok)?(lab|lch))\\(.+\\)$/, Yx = /^(inset_)?-?((\\d+)?\\.?(\\d+)[a-z]+|0)_-?((\\d+)?\\.?(\\d+)[a-z]+|0)/, Xx = /^(url|image|image-set|cross-fade|element|(repeating-)?(linear|radial|conic)-gradient)\\(.+\\)$/;\nfunction pn(e) {\n  return nr(e) || Ux.has(e) || Wx.test(e);\n}\nfunction Tn(e) {\n  return ii(e, \"length\", i1);\n}\nfunction nr(e) {\n  return !!e && !Number.isNaN(Number(e));\n}\nfunction na(e) {\n  return ii(e, \"number\", nr);\n}\nfunction Ci(e) {\n  return !!e && Number.isInteger(Number(e));\n}\nfunction Zx(e) {\n  return e.endsWith(\"%\") && nr(e.slice(0, -1));\n}\nfunction fe(e) {\n  return ym.test(e);\n}\nfunction Mn(e) {\n  return Hx.test(e);\n}\nconst Jx = /* @__PURE__ */ new Set([\"length\", \"size\", \"percentage\"]);\nfunction Qx(e) {\n  return ii(e, Jx, bm);\n}\nfunction e1(e) {\n  return ii(e, \"position\", bm);\n}\nconst t1 = /* @__PURE__ */ new Set([\"image\", \"url\"]);\nfunction n1(e) {\n  return ii(e, t1, a1);\n}\nfunction r1(e) {\n  return ii(e, \"\", o1);\n}\nfunction Ei() {\n  return !0;\n}\nfunction ii(e, t, n) {\n  const r = ym.exec(e);\n  return r ? r[1] ? typeof t == \"string\" ? r[1] === t : t.has(r[1]) : n(r[2]) : !1;\n}\nfunction i1(e) {\n  return qx.test(e) && !Kx.test(e);\n}\nfunction bm() {\n  return !1;\n}\nfunction o1(e) {\n  return Yx.test(e);\n}\nfunction a1(e) {\n  return Xx.test(e);\n}\nfunction s1() {\n  const e = ke(\"colors\"), t = ke(\"spacing\"), n = ke(\"blur\"), r = ke(\"brightness\"), i = ke(\"borderColor\"), o = ke(\"borderRadius\"), a = ke(\"borderSpacing\"), s = ke(\"borderWidth\"), u = ke(\"contrast\"), c = ke(\"grayscale\"), f = ke(\"hueRotate\"), l = ke(\"invert\"), d = ke(\"gap\"), p = ke(\"gradientColorStops\"), g = ke(\"gradientColorStopPositions\"), h = ke(\"inset\"), v = ke(\"margin\"), w = ke(\"opacity\"), b = ke(\"padding\"), x = ke(\"saturate\"), m = ke(\"scale\"), y = ke(\"sepia\"), S = ke(\"skew\"), $ = ke(\"space\"), O = ke(\"translate\"), T = () => [\"auto\", \"contain\", \"none\"], M = () => [\"auto\", \"hidden\", \"clip\", \"visible\", \"scroll\"], E = () => [\"auto\", fe, t], A = () => [fe, t], j = () => [\"\", pn, Tn], R = () => [\"auto\", nr, fe], N = () => [\"bottom\", \"center\", \"left\", \"left-bottom\", \"left-top\", \"right\", \"right-bottom\", \"right-top\", \"top\"], k = () => [\"solid\", \"dashed\", \"dotted\", \"double\", \"none\"], F = () => [\"normal\", \"multiply\", \"screen\", \"overlay\", \"darken\", \"lighten\", \"color-dodge\", \"color-burn\", \"hard-light\", \"soft-light\", \"difference\", \"exclusion\", \"hue\", \"saturation\", \"color\", \"luminosity\"], V = () => [\"start\", \"end\", \"center\", \"between\", \"around\", \"evenly\", \"stretch\"], L = () => [\"\", \"0\", fe], I = () => [\"auto\", \"avoid\", \"all\", \"avoid-page\", \"page\", \"left\", \"right\", \"column\"], D = () => [nr, na], G = () => [nr, fe];\n  return {\n    cacheSize: 500,\n    separator: \":\",\n    theme: {\n      colors: [Ei],\n      spacing: [pn, Tn],\n      blur: [\"none\", \"\", Mn, fe],\n      brightness: D(),\n      borderColor: [e],\n      borderRadius: [\"none\", \"\", \"full\", Mn, fe],\n      borderSpacing: A(),\n      borderWidth: j(),\n      contrast: D(),\n      grayscale: L(),\n      hueRotate: G(),\n      invert: L(),\n      gap: A(),\n      gradientColorStops: [e],\n      gradientColorStopPositions: [Zx, Tn],\n      inset: E(),\n      margin: E(),\n      opacity: D(),\n      padding: A(),\n      saturate: D(),\n      scale: D(),\n      sepia: L(),\n      skew: G(),\n      space: A(),\n      translate: A()\n    },\n    classGroups: {\n      // Layout\n      /**\n       * Aspect Ratio\n       * @see https://tailwindcss.com/docs/aspect-ratio\n       */\n      aspect: [{\n        aspect: [\"auto\", \"square\", \"video\", fe]\n      }],\n      /**\n       * Container\n       * @see https://tailwindcss.com/docs/container\n       */\n      container: [\"container\"],\n      /**\n       * Columns\n       * @see https://tailwindcss.com/docs/columns\n       */\n      columns: [{\n        columns: [Mn]\n      }],\n      /**\n       * Break After\n       * @see https://tailwindcss.com/docs/break-after\n       */\n      \"break-after\": [{\n        \"break-after\": I()\n      }],\n      /**\n       * Break Before\n       * @see https://tailwindcss.com/docs/break-before\n       */\n      \"break-before\": [{\n        \"break-before\": I()\n      }],\n      /**\n       * Break Inside\n       * @see https://tailwindcss.com/docs/break-inside\n       */\n      \"break-inside\": [{\n        \"break-inside\": [\"auto\", \"avoid\", \"avoid-page\", \"avoid-column\"]\n      }],\n      /**\n       * Box Decoration Break\n       * @see https://tailwindcss.com/docs/box-decoration-break\n       */\n      \"box-decoration\": [{\n        \"box-decoration\": [\"slice\", \"clone\"]\n      }],\n      /**\n       * Box Sizing\n       * @see https://tailwindcss.com/docs/box-sizing\n       */\n      box: [{\n        box: [\"border\", \"content\"]\n      }],\n      /**\n       * Display\n       * @see https://tailwindcss.com/docs/display\n       */\n      display: [\"block\", \"inline-block\", \"inline\", \"flex\", \"inline-flex\", \"table\", \"inline-table\", \"table-caption\", \"table-cell\", \"table-column\", \"table-column-group\", \"table-footer-group\", \"table-header-group\", \"table-row-group\", \"table-row\", \"flow-root\", \"grid\", \"inline-grid\", \"contents\", \"list-item\", \"hidden\"],\n      /**\n       * Floats\n       * @see https://tailwindcss.com/docs/float\n       */\n      float: [{\n        float: [\"right\", \"left\", \"none\", \"start\", \"end\"]\n      }],\n      /**\n       * Clear\n       * @see https://tailwindcss.com/docs/clear\n       */\n      clear: [{\n        clear: [\"left\", \"right\", \"both\", \"none\", \"start\", \"end\"]\n      }],\n      /**\n       * Isolation\n       * @see https://tailwindcss.com/docs/isolation\n       */\n      isolation: [\"isolate\", \"isolation-auto\"],\n      /**\n       * Object Fit\n       * @see https://tailwindcss.com/docs/object-fit\n       */\n      \"object-fit\": [{\n        object: [\"contain\", \"cover\", \"fill\", \"none\", \"scale-down\"]\n      }],\n      /**\n       * Object Position\n       * @see https://tailwindcss.com/docs/object-position\n       */\n      \"object-position\": [{\n        object: [...N(), fe]\n      }],\n      /**\n       * Overflow\n       * @see https://tailwindcss.com/docs/overflow\n       */\n      overflow: [{\n        overflow: M()\n      }],\n      /**\n       * Overflow X\n       * @see https://tailwindcss.com/docs/overflow\n       */\n      \"overflow-x\": [{\n        \"overflow-x\": M()\n      }],\n      /**\n       * Overflow Y\n       * @see https://tailwindcss.com/docs/overflow\n       */\n      \"overflow-y\": [{\n        \"overflow-y\": M()\n      }],\n      /**\n       * Overscroll Behavior\n       * @see https://tailwindcss.com/docs/overscroll-behavior\n       */\n      overscroll: [{\n        overscroll: T()\n      }],\n      /**\n       * Overscroll Behavior X\n       * @see https://tailwindcss.com/docs/overscroll-behavior\n       */\n      \"overscroll-x\": [{\n        \"overscroll-x\": T()\n      }],\n      /**\n       * Overscroll Behavior Y\n       * @see https://tailwindcss.com/docs/overscroll-behavior\n       */\n      \"overscroll-y\": [{\n        \"overscroll-y\": T()\n      }],\n      /**\n       * Position\n       * @see https://tailwindcss.com/docs/position\n       */\n      position: [\"static\", \"fixed\", \"absolute\", \"relative\", \"sticky\"],\n      /**\n       * Top / Right / Bottom / Left\n       * @see https://tailwindcss.com/docs/top-right-bottom-left\n       */\n      inset: [{\n        inset: [h]\n      }],\n      /**\n       * Right / Left\n       * @see https://tailwindcss.com/docs/top-right-bottom-left\n       */\n      \"inset-x\": [{\n        \"inset-x\": [h]\n      }],\n      /**\n       * Top / Bottom\n       * @see https://tailwindcss.com/docs/top-right-bottom-left\n       */\n      \"inset-y\": [{\n        \"inset-y\": [h]\n      }],\n      /**\n       * Start\n       * @see https://tailwindcss.com/docs/top-right-bottom-left\n       */\n      start: [{\n        start: [h]\n      }],\n      /**\n       * End\n       * @see https://tailwindcss.com/docs/top-right-bottom-left\n       */\n      end: [{\n        end: [h]\n      }],\n      /**\n       * Top\n       * @see https://tailwindcss.com/docs/top-right-bottom-left\n       */\n      top: [{\n        top: [h]\n      }],\n      /**\n       * Right\n       * @see https://tailwindcss.com/docs/top-right-bottom-left\n       */\n      right: [{\n        right: [h]\n      }],\n      /**\n       * Bottom\n       * @see https://tailwindcss.com/docs/top-right-bottom-left\n       */\n      bottom: [{\n        bottom: [h]\n      }],\n      /**\n       * Left\n       * @see https://tailwindcss.com/docs/top-right-bottom-left\n       */\n      left: [{\n        left: [h]\n      }],\n      /**\n       * Visibility\n       * @see https://tailwindcss.com/docs/visibility\n       */\n      visibility: [\"visible\", \"invisible\", \"collapse\"],\n      /**\n       * Z-Index\n       * @see https://tailwindcss.com/docs/z-index\n       */\n      z: [{\n        z: [\"auto\", Ci, fe]\n      }],\n      // Flexbox and Grid\n      /**\n       * Flex Basis\n       * @see https://tailwindcss.com/docs/flex-basis\n       */\n      basis: [{\n        basis: E()\n      }],\n      /**\n       * Flex Direction\n       * @see https://tailwindcss.com/docs/flex-direction\n       */\n      \"flex-direction\": [{\n        flex: [\"row\", \"row-reverse\", \"col\", \"col-reverse\"]\n      }],\n      /**\n       * Flex Wrap\n       * @see https://tailwindcss.com/docs/flex-wrap\n       */\n      \"flex-wrap\": [{\n        flex: [\"wrap\", \"wrap-reverse\", \"nowrap\"]\n      }],\n      /**\n       * Flex\n       * @see https://tailwindcss.com/docs/flex\n       */\n      flex: [{\n        flex: [\"1\", \"auto\", \"initial\", \"none\", fe]\n      }],\n      /**\n       * Flex Grow\n       * @see https://tailwindcss.com/docs/flex-grow\n       */\n      grow: [{\n        grow: L()\n      }],\n      /**\n       * Flex Shrink\n       * @see https://tailwindcss.com/docs/flex-shrink\n       */\n      shrink: [{\n        shrink: L()\n      }],\n      /**\n       * Order\n       * @see https://tailwindcss.com/docs/order\n       */\n      order: [{\n        order: [\"first\", \"last\", \"none\", Ci, fe]\n      }],\n      /**\n       * Grid Template Columns\n       * @see https://tailwindcss.com/docs/grid-template-columns\n       */\n      \"grid-cols\": [{\n        \"grid-cols\": [Ei]\n      }],\n      /**\n       * Grid Column Start / End\n       * @see https://tailwindcss.com/docs/grid-column\n       */\n      \"col-start-end\": [{\n        col: [\"auto\", {\n          span: [\"full\", Ci, fe]\n        }, fe]\n      }],\n      /**\n       * Grid Column Start\n       * @see https://tailwindcss.com/docs/grid-column\n       */\n      \"col-start\": [{\n        \"col-start\": R()\n      }],\n      /**\n       * Grid Column End\n       * @see https://tailwindcss.com/docs/grid-column\n       */\n      \"col-end\": [{\n        \"col-end\": R()\n      }],\n      /**\n       * Grid Template Rows\n       * @see https://tailwindcss.com/docs/grid-template-rows\n       */\n      \"grid-rows\": [{\n        \"grid-rows\": [Ei]\n      }],\n      /**\n       * Grid Row Start / End\n       * @see https://tailwindcss.com/docs/grid-row\n       */\n      \"row-start-end\": [{\n        row: [\"auto\", {\n          span: [Ci, fe]\n        }, fe]\n      }],\n      /**\n       * Grid Row Start\n       * @see https://tailwindcss.com/docs/grid-row\n       */\n      \"row-start\": [{\n        \"row-start\": R()\n      }],\n      /**\n       * Grid Row End\n       * @see https://tailwindcss.com/docs/grid-row\n       */\n      \"row-end\": [{\n        \"row-end\": R()\n      }],\n      /**\n       * Grid Auto Flow\n       * @see https://tailwindcss.com/docs/grid-auto-flow\n       */\n      \"grid-flow\": [{\n        \"grid-flow\": [\"row\", \"col\", \"dense\", \"row-dense\", \"col-dense\"]\n      }],\n      /**\n       * Grid Auto Columns\n       * @see https://tailwindcss.com/docs/grid-auto-columns\n       */\n      \"auto-cols\": [{\n        \"auto-cols\": [\"auto\", \"min\", \"max\", \"fr\", fe]\n      }],\n      /**\n       * Grid Auto Rows\n       * @see https://tailwindcss.com/docs/grid-auto-rows\n       */\n      \"auto-rows\": [{\n        \"auto-rows\": [\"auto\", \"min\", \"max\", \"fr\", fe]\n      }],\n      /**\n       * Gap\n       * @see https://tailwindcss.com/docs/gap\n       */\n      gap: [{\n        gap: [d]\n      }],\n      /**\n       * Gap X\n       * @see https://tailwindcss.com/docs/gap\n       */\n      \"gap-x\": [{\n        \"gap-x\": [d]\n      }],\n      /**\n       * Gap Y\n       * @see https://tailwindcss.com/docs/gap\n       */\n      \"gap-y\": [{\n        \"gap-y\": [d]\n      }],\n      /**\n       * Justify Content\n       * @see https://tailwindcss.com/docs/justify-content\n       */\n      \"justify-content\": [{\n        justify: [\"normal\", ...V()]\n      }],\n      /**\n       * Justify Items\n       * @see https://tailwindcss.com/docs/justify-items\n       */\n      \"justify-items\": [{\n        \"justify-items\": [\"start\", \"end\", \"center\", \"stretch\"]\n      }],\n      /**\n       * Justify Self\n       * @see https://tailwindcss.com/docs/justify-self\n       */\n      \"justify-self\": [{\n        \"justify-self\": [\"auto\", \"start\", \"end\", \"center\", \"stretch\"]\n      }],\n      /**\n       * Align Content\n       * @see https://tailwindcss.com/docs/align-content\n       */\n      \"align-content\": [{\n        content: [\"normal\", ...V(), \"baseline\"]\n      }],\n      /**\n       * Align Items\n       * @see https://tailwindcss.com/docs/align-items\n       */\n      \"align-items\": [{\n        items: [\"start\", \"end\", \"center\", \"baseline\", \"stretch\"]\n      }],\n      /**\n       * Align Self\n       * @see https://tailwindcss.com/docs/align-self\n       */\n      \"align-self\": [{\n        self: [\"auto\", \"start\", \"end\", \"center\", \"stretch\", \"baseline\"]\n      }],\n      /**\n       * Place Content\n       * @see https://tailwindcss.com/docs/place-content\n       */\n      \"place-content\": [{\n        \"place-content\": [...V(), \"baseline\"]\n      }],\n      /**\n       * Place Items\n       * @see https://tailwindcss.com/docs/place-items\n       */\n      \"place-items\": [{\n        \"place-items\": [\"start\", \"end\", \"center\", \"baseline\", \"stretch\"]\n      }],\n      /**\n       * Place Self\n       * @see https://tailwindcss.com/docs/place-self\n       */\n      \"place-self\": [{\n        \"place-self\": [\"auto\", \"start\", \"end\", \"center\", \"stretch\"]\n      }],\n      // Spacing\n      /**\n       * Padding\n       * @see https://tailwindcss.com/docs/padding\n       */\n      p: [{\n        p: [b]\n      }],\n      /**\n       * Padding X\n       * @see https://tailwindcss.com/docs/padding\n       */\n      px: [{\n        px: [b]\n      }],\n      /**\n       * Padding Y\n       * @see https://tailwindcss.com/docs/padding\n       */\n      py: [{\n        py: [b]\n      }],\n      /**\n       * Padding Start\n       * @see https://tailwindcss.com/docs/padding\n       */\n      ps: [{\n        ps: [b]\n      }],\n      /**\n       * Padding End\n       * @see https://tailwindcss.com/docs/padding\n       */\n      pe: [{\n        pe: [b]\n      }],\n      /**\n       * Padding Top\n       * @see https://tailwindcss.com/docs/padding\n       */\n      pt: [{\n        pt: [b]\n      }],\n      /**\n       * Padding Right\n       * @see https://tailwindcss.com/docs/padding\n       */\n      pr: [{\n        pr: [b]\n      }],\n      /**\n       * Padding Bottom\n       * @see https://tailwindcss.com/docs/padding\n       */\n      pb: [{\n        pb: [b]\n      }],\n      /**\n       * Padding Left\n       * @see https://tailwindcss.com/docs/padding\n       */\n      pl: [{\n        pl: [b]\n      }],\n      /**\n       * Margin\n       * @see https://tailwindcss.com/docs/margin\n       */\n      m: [{\n        m: [v]\n      }],\n      /**\n       * Margin X\n       * @see https://tailwindcss.com/docs/margin\n       */\n      mx: [{\n        mx: [v]\n      }],\n      /**\n       * Margin Y\n       * @see https://tailwindcss.com/docs/margin\n       */\n      my: [{\n        my: [v]\n      }],\n      /**\n       * Margin Start\n       * @see https://tailwindcss.com/docs/margin\n       */\n      ms: [{\n        ms: [v]\n      }],\n      /**\n       * Margin End\n       * @see https://tailwindcss.com/docs/margin\n       */\n      me: [{\n        me: [v]\n      }],\n      /**\n       * Margin Top\n       * @see https://tailwindcss.com/docs/margin\n       */\n      mt: [{\n        mt: [v]\n      }],\n      /**\n       * Margin Right\n       * @see https://tailwindcss.com/docs/margin\n       */\n      mr: [{\n        mr: [v]\n      }],\n      /**\n       * Margin Bottom\n       * @see https://tailwindcss.com/docs/margin\n       */\n      mb: [{\n        mb: [v]\n      }],\n      /**\n       * Margin Left\n       * @see https://tailwindcss.com/docs/margin\n       */\n      ml: [{\n        ml: [v]\n      }],\n      /**\n       * Space Between X\n       * @see https://tailwindcss.com/docs/space\n       */\n      \"space-x\": [{\n        \"space-x\": [$]\n      }],\n      /**\n       * Space Between X Reverse\n       * @see https://tailwindcss.com/docs/space\n       */\n      \"space-x-reverse\": [\"space-x-reverse\"],\n      /**\n       * Space Between Y\n       * @see https://tailwindcss.com/docs/space\n       */\n      \"space-y\": [{\n        \"space-y\": [$]\n      }],\n      /**\n       * Space Between Y Reverse\n       * @see https://tailwindcss.com/docs/space\n       */\n      \"space-y-reverse\": [\"space-y-reverse\"],\n      // Sizing\n      /**\n       * Width\n       * @see https://tailwindcss.com/docs/width\n       */\n      w: [{\n        w: [\"auto\", \"min\", \"max\", \"fit\", \"svw\", \"lvw\", \"dvw\", fe, t]\n      }],\n      /**\n       * Min-Width\n       * @see https://tailwindcss.com/docs/min-width\n       */\n      \"min-w\": [{\n        \"min-w\": [fe, t, \"min\", \"max\", \"fit\"]\n      }],\n      /**\n       * Max-Width\n       * @see https://tailwindcss.com/docs/max-width\n       */\n      \"max-w\": [{\n        \"max-w\": [fe, t, \"none\", \"full\", \"min\", \"max\", \"fit\", \"prose\", {\n          screen: [Mn]\n        }, Mn]\n      }],\n      /**\n       * Height\n       * @see https://tailwindcss.com/docs/height\n       */\n      h: [{\n        h: [fe, t, \"auto\", \"min\", \"max\", \"fit\", \"svh\", \"lvh\", \"dvh\"]\n      }],\n      /**\n       * Min-Height\n       * @see https://tailwindcss.com/docs/min-height\n       */\n      \"min-h\": [{\n        \"min-h\": [fe, t, \"min\", \"max\", \"fit\", \"svh\", \"lvh\", \"dvh\"]\n      }],\n      /**\n       * Max-Height\n       * @see https://tailwindcss.com/docs/max-height\n       */\n      \"max-h\": [{\n        \"max-h\": [fe, t, \"min\", \"max\", \"fit\", \"svh\", \"lvh\", \"dvh\"]\n      }],\n      /**\n       * Size\n       * @see https://tailwindcss.com/docs/size\n       */\n      size: [{\n        size: [fe, t, \"auto\", \"min\", \"max\", \"fit\"]\n      }],\n      // Typography\n      /**\n       * Font Size\n       * @see https://tailwindcss.com/docs/font-size\n       */\n      \"font-size\": [{\n        text: [\"base\", Mn, Tn]\n      }],\n      /**\n       * Font Smoothing\n       * @see https://tailwindcss.com/docs/font-smoothing\n       */\n      \"font-smoothing\": [\"antialiased\", \"subpixel-antialiased\"],\n      /**\n       * Font Style\n       * @see https://tailwindcss.com/docs/font-style\n       */\n      \"font-style\": [\"italic\", \"not-italic\"],\n      /**\n       * Font Weight\n       * @see https://tailwindcss.com/docs/font-weight\n       */\n      \"font-weight\": [{\n        font: [\"thin\", \"extralight\", \"light\", \"normal\", \"medium\", \"semibold\", \"bold\", \"extrabold\", \"black\", na]\n      }],\n      /**\n       * Font Family\n       * @see https://tailwindcss.com/docs/font-family\n       */\n      \"font-family\": [{\n        font: [Ei]\n      }],\n      /**\n       * Font Variant Numeric\n       * @see https://tailwindcss.com/docs/font-variant-numeric\n       */\n      \"fvn-normal\": [\"normal-nums\"],\n      /**\n       * Font Variant Numeric\n       * @see https://tailwindcss.com/docs/font-variant-numeric\n       */\n      \"fvn-ordinal\": [\"ordinal\"],\n      /**\n       * Font Variant Numeric\n       * @see https://tailwindcss.com/docs/font-variant-numeric\n       */\n      \"fvn-slashed-zero\": [\"slashed-zero\"],\n      /**\n       * Font Variant Numeric\n       * @see https://tailwindcss.com/docs/font-variant-numeric\n       */\n      \"fvn-figure\": [\"lining-nums\", \"oldstyle-nums\"],\n      /**\n       * Font Variant Numeric\n       * @see https://tailwindcss.com/docs/font-variant-numeric\n       */\n      \"fvn-spacing\": [\"proportional-nums\", \"tabular-nums\"],\n      /**\n       * Font Variant Numeric\n       * @see https://tailwindcss.com/docs/font-variant-numeric\n       */\n      \"fvn-fraction\": [\"diagonal-fractions\", \"stacked-fractons\"],\n      /**\n       * Letter Spacing\n       * @see https://tailwindcss.com/docs/letter-spacing\n       */\n      tracking: [{\n        tracking: [\"tighter\", \"tight\", \"normal\", \"wide\", \"wider\", \"widest\", fe]\n      }],\n      /**\n       * Line Clamp\n       * @see https://tailwindcss.com/docs/line-clamp\n       */\n      \"line-clamp\": [{\n        \"line-clamp\": [\"none\", nr, na]\n      }],\n      /**\n       * Line Height\n       * @see https://tailwindcss.com/docs/line-height\n       */\n      leading: [{\n        leading: [\"none\", \"tight\", \"snug\", \"normal\", \"relaxed\", \"loose\", pn, fe]\n      }],\n      /**\n       * List Style Image\n       * @see https://tailwindcss.com/docs/list-style-image\n       */\n      \"list-image\": [{\n        \"list-image\": [\"none\", fe]\n      }],\n      /**\n       * List Style Type\n       * @see https://tailwindcss.com/docs/list-style-type\n       */\n      \"list-style-type\": [{\n        list: [\"none\", \"disc\", \"decimal\", fe]\n      }],\n      /**\n       * List Style Position\n       * @see https://tailwindcss.com/docs/list-style-position\n       */\n      \"list-style-position\": [{\n        list: [\"inside\", \"outside\"]\n      }],\n      /**\n       * Placeholder Color\n       * @deprecated since Tailwind CSS v3.0.0\n       * @see https://tailwindcss.com/docs/placeholder-color\n       */\n      \"placeholder-color\": [{\n        placeholder: [e]\n      }],\n      /**\n       * Placeholder Opacity\n       * @see https://tailwindcss.com/docs/placeholder-opacity\n       */\n      \"placeholder-opacity\": [{\n        \"placeholder-opacity\": [w]\n      }],\n      /**\n       * Text Alignment\n       * @see https://tailwindcss.com/docs/text-align\n       */\n      \"text-alignment\": [{\n        text: [\"left\", \"center\", \"right\", \"justify\", \"start\", \"end\"]\n      }],\n      /**\n       * Text Color\n       * @see https://tailwindcss.com/docs/text-color\n       */\n      \"text-color\": [{\n        text: [e]\n      }],\n      /**\n       * Text Opacity\n       * @see https://tailwindcss.com/docs/text-opacity\n       */\n      \"text-opacity\": [{\n        \"text-opacity\": [w]\n      }],\n      /**\n       * Text Decoration\n       * @see https://tailwindcss.com/docs/text-decoration\n       */\n      \"text-decoration\": [\"underline\", \"overline\", \"line-through\", \"no-underline\"],\n      /**\n       * Text Decoration Style\n       * @see https://tailwindcss.com/docs/text-decoration-style\n       */\n      \"text-decoration-style\": [{\n        decoration: [...k(), \"wavy\"]\n      }],\n      /**\n       * Text Decoration Thickness\n       * @see https://tailwindcss.com/docs/text-decoration-thickness\n       */\n      \"text-decoration-thickness\": [{\n        decoration: [\"auto\", \"from-font\", pn, Tn]\n      }],\n      /**\n       * Text Underline Offset\n       * @see https://tailwindcss.com/docs/text-underline-offset\n       */\n      \"underline-offset\": [{\n        \"underline-offset\": [\"auto\", pn, fe]\n      }],\n      /**\n       * Text Decoration Color\n       * @see https://tailwindcss.com/docs/text-decoration-color\n       */\n      \"text-decoration-color\": [{\n        decoration: [e]\n      }],\n      /**\n       * Text Transform\n       * @see https://tailwindcss.com/docs/text-transform\n       */\n      \"text-transform\": [\"uppercase\", \"lowercase\", \"capitalize\", \"normal-case\"],\n      /**\n       * Text Overflow\n       * @see https://tailwindcss.com/docs/text-overflow\n       */\n      \"text-overflow\": [\"truncate\", \"text-ellipsis\", \"text-clip\"],\n      /**\n       * Text Wrap\n       * @see https://tailwindcss.com/docs/text-wrap\n       */\n      \"text-wrap\": [{\n        text: [\"wrap\", \"nowrap\", \"balance\", \"pretty\"]\n      }],\n      /**\n       * Text Indent\n       * @see https://tailwindcss.com/docs/text-indent\n       */\n      indent: [{\n        indent: A()\n      }],\n      /**\n       * Vertical Alignment\n       * @see https://tailwindcss.com/docs/vertical-align\n       */\n      \"vertical-align\": [{\n        align: [\"baseline\", \"top\", \"middle\", \"bottom\", \"text-top\", \"text-bottom\", \"sub\", \"super\", fe]\n      }],\n      /**\n       * Whitespace\n       * @see https://tailwindcss.com/docs/whitespace\n       */\n      whitespace: [{\n        whitespace: [\"normal\", \"nowrap\", \"pre\", \"pre-line\", \"pre-wrap\", \"break-spaces\"]\n      }],\n      /**\n       * Word Break\n       * @see https://tailwindcss.com/docs/word-break\n       */\n      break: [{\n        break: [\"normal\", \"words\", \"all\", \"keep\"]\n      }],\n      /**\n       * Hyphens\n       * @see https://tailwindcss.com/docs/hyphens\n       */\n      hyphens: [{\n        hyphens: [\"none\", \"manual\", \"auto\"]\n      }],\n      /**\n       * Content\n       * @see https://tailwindcss.com/docs/content\n       */\n      content: [{\n        content: [\"none\", fe]\n      }],\n      // Backgrounds\n      /**\n       * Background Attachment\n       * @see https://tailwindcss.com/docs/background-attachment\n       */\n      \"bg-attachment\": [{\n        bg: [\"fixed\", \"local\", \"scroll\"]\n      }],\n      /**\n       * Background Clip\n       * @see https://tailwindcss.com/docs/background-clip\n       */\n      \"bg-clip\": [{\n        \"bg-clip\": [\"border\", \"padding\", \"content\", \"text\"]\n      }],\n      /**\n       * Background Opacity\n       * @deprecated since Tailwind CSS v3.0.0\n       * @see https://tailwindcss.com/docs/background-opacity\n       */\n      \"bg-opacity\": [{\n        \"bg-opacity\": [w]\n      }],\n      /**\n       * Background Origin\n       * @see https://tailwindcss.com/docs/background-origin\n       */\n      \"bg-origin\": [{\n        \"bg-origin\": [\"border\", \"padding\", \"content\"]\n      }],\n      /**\n       * Background Position\n       * @see https://tailwindcss.com/docs/background-position\n       */\n      \"bg-position\": [{\n        bg: [...N(), e1]\n      }],\n      /**\n       * Background Repeat\n       * @see https://tailwindcss.com/docs/background-repeat\n       */\n      \"bg-repeat\": [{\n        bg: [\"no-repeat\", {\n          repeat: [\"\", \"x\", \"y\", \"round\", \"space\"]\n        }]\n      }],\n      /**\n       * Background Size\n       * @see https://tailwindcss.com/docs/background-size\n       */\n      \"bg-size\": [{\n        bg: [\"auto\", \"cover\", \"contain\", Qx]\n      }],\n      /**\n       * Background Image\n       * @see https://tailwindcss.com/docs/background-image\n       */\n      \"bg-image\": [{\n        bg: [\"none\", {\n          \"gradient-to\": [\"t\", \"tr\", \"r\", \"br\", \"b\", \"bl\", \"l\", \"tl\"]\n        }, n1]\n      }],\n      /**\n       * Background Color\n       * @see https://tailwindcss.com/docs/background-color\n       */\n      \"bg-color\": [{\n        bg: [e]\n      }],\n      /**\n       * Gradient Color Stops From Position\n       * @see https://tailwindcss.com/docs/gradient-color-stops\n       */\n      \"gradient-from-pos\": [{\n        from: [g]\n      }],\n      /**\n       * Gradient Color Stops Via Position\n       * @see https://tailwindcss.com/docs/gradient-color-stops\n       */\n      \"gradient-via-pos\": [{\n        via: [g]\n      }],\n      /**\n       * Gradient Color Stops To Position\n       * @see https://tailwindcss.com/docs/gradient-color-stops\n       */\n      \"gradient-to-pos\": [{\n        to: [g]\n      }],\n      /**\n       * Gradient Color Stops From\n       * @see https://tailwindcss.com/docs/gradient-color-stops\n       */\n      \"gradient-from\": [{\n        from: [p]\n      }],\n      /**\n       * Gradient Color Stops Via\n       * @see https://tailwindcss.com/docs/gradient-color-stops\n       */\n      \"gradient-via\": [{\n        via: [p]\n      }],\n      /**\n       * Gradient Color Stops To\n       * @see https://tailwindcss.com/docs/gradient-color-stops\n       */\n      \"gradient-to\": [{\n        to: [p]\n      }],\n      // Borders\n      /**\n       * Border Radius\n       * @see https://tailwindcss.com/docs/border-radius\n       */\n      rounded: [{\n        rounded: [o]\n      }],\n      /**\n       * Border Radius Start\n       * @see https://tailwindcss.com/docs/border-radius\n       */\n      \"rounded-s\": [{\n        \"rounded-s\": [o]\n      }],\n      /**\n       * Border Radius End\n       * @see https://tailwindcss.com/docs/border-radius\n       */\n      \"rounded-e\": [{\n        \"rounded-e\": [o]\n      }],\n      /**\n       * Border Radius Top\n       * @see https://tailwindcss.com/docs/border-radius\n       */\n      \"rounded-t\": [{\n        \"rounded-t\": [o]\n      }],\n      /**\n       * Border Radius Right\n       * @see https://tailwindcss.com/docs/border-radius\n       */\n      \"rounded-r\": [{\n        \"rounded-r\": [o]\n      }],\n      /**\n       * Border Radius Bottom\n       * @see https://tailwindcss.com/docs/border-radius\n       */\n      \"rounded-b\": [{\n        \"rounded-b\": [o]\n      }],\n      /**\n       * Border Radius Left\n       * @see https://tailwindcss.com/docs/border-radius\n       */\n      \"rounded-l\": [{\n        \"rounded-l\": [o]\n      }],\n      /**\n       * Border Radius Start Start\n       * @see https://tailwindcss.com/docs/border-radius\n       */\n      \"rounded-ss\": [{\n        \"rounded-ss\": [o]\n      }],\n      /**\n       * Border Radius Start End\n       * @see https://tailwindcss.com/docs/border-radius\n       */\n      \"rounded-se\": [{\n        \"rounded-se\": [o]\n      }],\n      /**\n       * Border Radius End End\n       * @see https://tailwindcss.com/docs/border-radius\n       */\n      \"rounded-ee\": [{\n        \"rounded-ee\": [o]\n      }],\n      /**\n       * Border Radius End Start\n       * @see https://tailwindcss.com/docs/border-radius\n       */\n      \"rounded-es\": [{\n        \"rounded-es\": [o]\n      }],\n      /**\n       * Border Radius Top Left\n       * @see https://tailwindcss.com/docs/border-radius\n       */\n      \"rounded-tl\": [{\n        \"rounded-tl\": [o]\n      }],\n      /**\n       * Border Radius Top Right\n       * @see https://tailwindcss.com/docs/border-radius\n       */\n      \"rounded-tr\": [{\n        \"rounded-tr\": [o]\n      }],\n      /**\n       * Border Radius Bottom Right\n       * @see https://tailwindcss.com/docs/border-radius\n       */\n      \"rounded-br\": [{\n        \"rounded-br\": [o]\n      }],\n      /**\n       * Border Radius Bottom Left\n       * @see https://tailwindcss.com/docs/border-radius\n       */\n      \"rounded-bl\": [{\n        \"rounded-bl\": [o]\n      }],\n      /**\n       * Border Width\n       * @see https://tailwindcss.com/docs/border-width\n       */\n      \"border-w\": [{\n        border: [s]\n      }],\n      /**\n       * Border Width X\n       * @see https://tailwindcss.com/docs/border-width\n       */\n      \"border-w-x\": [{\n        \"border-x\": [s]\n      }],\n      /**\n       * Border Width Y\n       * @see https://tailwindcss.com/docs/border-width\n       */\n      \"border-w-y\": [{\n        \"border-y\": [s]\n      }],\n      /**\n       * Border Width Start\n       * @see https://tailwindcss.com/docs/border-width\n       */\n      \"border-w-s\": [{\n        \"border-s\": [s]\n      }],\n      /**\n       * Border Width End\n       * @see https://tailwindcss.com/docs/border-width\n       */\n      \"border-w-e\": [{\n        \"border-e\": [s]\n      }],\n      /**\n       * Border Width Top\n       * @see https://tailwindcss.com/docs/border-width\n       */\n      \"border-w-t\": [{\n        \"border-t\": [s]\n      }],\n      /**\n       * Border Width Right\n       * @see https://tailwindcss.com/docs/border-width\n       */\n      \"border-w-r\": [{\n        \"border-r\": [s]\n      }],\n      /**\n       * Border Width Bottom\n       * @see https://tailwindcss.com/docs/border-width\n       */\n      \"border-w-b\": [{\n        \"border-b\": [s]\n      }],\n      /**\n       * Border Width Left\n       * @see https://tailwindcss.com/docs/border-width\n       */\n      \"border-w-l\": [{\n        \"border-l\": [s]\n      }],\n      /**\n       * Border Opacity\n       * @see https://tailwindcss.com/docs/border-opacity\n       */\n      \"border-opacity\": [{\n        \"border-opacity\": [w]\n      }],\n      /**\n       * Border Style\n       * @see https://tailwindcss.com/docs/border-style\n       */\n      \"border-style\": [{\n        border: [...k(), \"hidden\"]\n      }],\n      /**\n       * Divide Width X\n       * @see https://tailwindcss.com/docs/divide-width\n       */\n      \"divide-x\": [{\n        \"divide-x\": [s]\n      }],\n      /**\n       * Divide Width X Reverse\n       * @see https://tailwindcss.com/docs/divide-width\n       */\n      \"divide-x-reverse\": [\"divide-x-reverse\"],\n      /**\n       * Divide Width Y\n       * @see https://tailwindcss.com/docs/divide-width\n       */\n      \"divide-y\": [{\n        \"divide-y\": [s]\n      }],\n      /**\n       * Divide Width Y Reverse\n       * @see https://tailwindcss.com/docs/divide-width\n       */\n      \"divide-y-reverse\": [\"divide-y-reverse\"],\n      /**\n       * Divide Opacity\n       * @see https://tailwindcss.com/docs/divide-opacity\n       */\n      \"divide-opacity\": [{\n        \"divide-opacity\": [w]\n      }],\n      /**\n       * Divide Style\n       * @see https://tailwindcss.com/docs/divide-style\n       */\n      \"divide-style\": [{\n        divide: k()\n      }],\n      /**\n       * Border Color\n       * @see https://tailwindcss.com/docs/border-color\n       */\n      \"border-color\": [{\n        border: [i]\n      }],\n      /**\n       * Border Color X\n       * @see https://tailwindcss.com/docs/border-color\n       */\n      \"border-color-x\": [{\n        \"border-x\": [i]\n      }],\n      /**\n       * Border Color Y\n       * @see https://tailwindcss.com/docs/border-color\n       */\n      \"border-color-y\": [{\n        \"border-y\": [i]\n      }],\n      /**\n       * Border Color Top\n       * @see https://tailwindcss.com/docs/border-color\n       */\n      \"border-color-t\": [{\n        \"border-t\": [i]\n      }],\n      /**\n       * Border Color Right\n       * @see https://tailwindcss.com/docs/border-color\n       */\n      \"border-color-r\": [{\n        \"border-r\": [i]\n      }],\n      /**\n       * Border Color Bottom\n       * @see https://tailwindcss.com/docs/border-color\n       */\n      \"border-color-b\": [{\n        \"border-b\": [i]\n      }],\n      /**\n       * Border Color Left\n       * @see https://tailwindcss.com/docs/border-color\n       */\n      \"border-color-l\": [{\n        \"border-l\": [i]\n      }],\n      /**\n       * Divide Color\n       * @see https://tailwindcss.com/docs/divide-color\n       */\n      \"divide-color\": [{\n        divide: [i]\n      }],\n      /**\n       * Outline Style\n       * @see https://tailwindcss.com/docs/outline-style\n       */\n      \"outline-style\": [{\n        outline: [\"\", ...k()]\n      }],\n      /**\n       * Outline Offset\n       * @see https://tailwindcss.com/docs/outline-offset\n       */\n      \"outline-offset\": [{\n        \"outline-offset\": [pn, fe]\n      }],\n      /**\n       * Outline Width\n       * @see https://tailwindcss.com/docs/outline-width\n       */\n      \"outline-w\": [{\n        outline: [pn, Tn]\n      }],\n      /**\n       * Outline Color\n       * @see https://tailwindcss.com/docs/outline-color\n       */\n      \"outline-color\": [{\n        outline: [e]\n      }],\n      /**\n       * Ring Width\n       * @see https://tailwindcss.com/docs/ring-width\n       */\n      \"ring-w\": [{\n        ring: j()\n      }],\n      /**\n       * Ring Width Inset\n       * @see https://tailwindcss.com/docs/ring-width\n       */\n      \"ring-w-inset\": [\"ring-inset\"],\n      /**\n       * Ring Color\n       * @see https://tailwindcss.com/docs/ring-color\n       */\n      \"ring-color\": [{\n        ring: [e]\n      }],\n      /**\n       * Ring Opacity\n       * @see https://tailwindcss.com/docs/ring-opacity\n       */\n      \"ring-opacity\": [{\n        \"ring-opacity\": [w]\n      }],\n      /**\n       * Ring Offset Width\n       * @see https://tailwindcss.com/docs/ring-offset-width\n       */\n      \"ring-offset-w\": [{\n        \"ring-offset\": [pn, Tn]\n      }],\n      /**\n       * Ring Offset Color\n       * @see https://tailwindcss.com/docs/ring-offset-color\n       */\n      \"ring-offset-color\": [{\n        \"ring-offset\": [e]\n      }],\n      // Effects\n      /**\n       * Box Shadow\n       * @see https://tailwindcss.com/docs/box-shadow\n       */\n      shadow: [{\n        shadow: [\"\", \"inner\", \"none\", Mn, r1]\n      }],\n      /**\n       * Box Shadow Color\n       * @see https://tailwindcss.com/docs/box-shadow-color\n       */\n      \"shadow-color\": [{\n        shadow: [Ei]\n      }],\n      /**\n       * Opacity\n       * @see https://tailwindcss.com/docs/opacity\n       */\n      opacity: [{\n        opacity: [w]\n      }],\n      /**\n       * Mix Blend Mode\n       * @see https://tailwindcss.com/docs/mix-blend-mode\n       */\n      \"mix-blend\": [{\n        \"mix-blend\": [...F(), \"plus-lighter\", \"plus-darker\"]\n      }],\n      /**\n       * Background Blend Mode\n       * @see https://tailwindcss.com/docs/background-blend-mode\n       */\n      \"bg-blend\": [{\n        \"bg-blend\": F()\n      }],\n      // Filters\n      /**\n       * Filter\n       * @deprecated since Tailwind CSS v3.0.0\n       * @see https://tailwindcss.com/docs/filter\n       */\n      filter: [{\n        filter: [\"\", \"none\"]\n      }],\n      /**\n       * Blur\n       * @see https://tailwindcss.com/docs/blur\n       */\n      blur: [{\n        blur: [n]\n      }],\n      /**\n       * Brightness\n       * @see https://tailwindcss.com/docs/brightness\n       */\n      brightness: [{\n        brightness: [r]\n      }],\n      /**\n       * Contrast\n       * @see https://tailwindcss.com/docs/contrast\n       */\n      contrast: [{\n        contrast: [u]\n      }],\n      /**\n       * Drop Shadow\n       * @see https://tailwindcss.com/docs/drop-shadow\n       */\n      \"drop-shadow\": [{\n        \"drop-shadow\": [\"\", \"none\", Mn, fe]\n      }],\n      /**\n       * Grayscale\n       * @see https://tailwindcss.com/docs/grayscale\n       */\n      grayscale: [{\n        grayscale: [c]\n      }],\n      /**\n       * Hue Rotate\n       * @see https://tailwindcss.com/docs/hue-rotate\n       */\n      \"hue-rotate\": [{\n        \"hue-rotate\": [f]\n      }],\n      /**\n       * Invert\n       * @see https://tailwindcss.com/docs/invert\n       */\n      invert: [{\n        invert: [l]\n      }],\n      /**\n       * Saturate\n       * @see https://tailwindcss.com/docs/saturate\n       */\n      saturate: [{\n        saturate: [x]\n      }],\n      /**\n       * Sepia\n       * @see https://tailwindcss.com/docs/sepia\n       */\n      sepia: [{\n        sepia: [y]\n      }],\n      /**\n       * Backdrop Filter\n       * @deprecated since Tailwind CSS v3.0.0\n       * @see https://tailwindcss.com/docs/backdrop-filter\n       */\n      \"backdrop-filter\": [{\n        \"backdrop-filter\": [\"\", \"none\"]\n      }],\n      /**\n       * Backdrop Blur\n       * @see https://tailwindcss.com/docs/backdrop-blur\n       */\n      \"backdrop-blur\": [{\n        \"backdrop-blur\": [n]\n      }],\n      /**\n       * Backdrop Brightness\n       * @see https://tailwindcss.com/docs/backdrop-brightness\n       */\n      \"backdrop-brightness\": [{\n        \"backdrop-brightness\": [r]\n      }],\n      /**\n       * Backdrop Contrast\n       * @see https://tailwindcss.com/docs/backdrop-contrast\n       */\n      \"backdrop-contrast\": [{\n        \"backdrop-contrast\": [u]\n      }],\n      /**\n       * Backdrop Grayscale\n       * @see https://tailwindcss.com/docs/backdrop-grayscale\n       */\n      \"backdrop-grayscale\": [{\n        \"backdrop-grayscale\": [c]\n      }],\n      /**\n       * Backdrop Hue Rotate\n       * @see https://tailwindcss.com/docs/backdrop-hue-rotate\n       */\n      \"backdrop-hue-rotate\": [{\n        \"backdrop-hue-rotate\": [f]\n      }],\n      /**\n       * Backdrop Invert\n       * @see https://tailwindcss.com/docs/backdrop-invert\n       */\n      \"backdrop-invert\": [{\n        \"backdrop-invert\": [l]\n      }],\n      /**\n       * Backdrop Opacity\n       * @see https://tailwindcss.com/docs/backdrop-opacity\n       */\n      \"backdrop-opacity\": [{\n        \"backdrop-opacity\": [w]\n      }],\n      /**\n       * Backdrop Saturate\n       * @see https://tailwindcss.com/docs/backdrop-saturate\n       */\n      \"backdrop-saturate\": [{\n        \"backdrop-saturate\": [x]\n      }],\n      /**\n       * Backdrop Sepia\n       * @see https://tailwindcss.com/docs/backdrop-sepia\n       */\n      \"backdrop-sepia\": [{\n        \"backdrop-sepia\": [y]\n      }],\n      // Tables\n      /**\n       * Border Collapse\n       * @see https://tailwindcss.com/docs/border-collapse\n       */\n      \"border-collapse\": [{\n        border: [\"collapse\", \"separate\"]\n      }],\n      /**\n       * Border Spacing\n       * @see https://tailwindcss.com/docs/border-spacing\n       */\n      \"border-spacing\": [{\n        \"border-spacing\": [a]\n      }],\n      /**\n       * Border Spacing X\n       * @see https://tailwindcss.com/docs/border-spacing\n       */\n      \"border-spacing-x\": [{\n        \"border-spacing-x\": [a]\n      }],\n      /**\n       * Border Spacing Y\n       * @see https://tailwindcss.com/docs/border-spacing\n       */\n      \"border-spacing-y\": [{\n        \"border-spacing-y\": [a]\n      }],\n      /**\n       * Table Layout\n       * @see https://tailwindcss.com/docs/table-layout\n       */\n      \"table-layout\": [{\n        table: [\"auto\", \"fixed\"]\n      }],\n      /**\n       * Caption Side\n       * @see https://tailwindcss.com/docs/caption-side\n       */\n      caption: [{\n        caption: [\"top\", \"bottom\"]\n      }],\n      // Transitions and Animation\n      /**\n       * Tranisition Property\n       * @see https://tailwindcss.com/docs/transition-property\n       */\n      transition: [{\n        transition: [\"none\", \"all\", \"\", \"colors\", \"opacity\", \"shadow\", \"transform\", fe]\n      }],\n      /**\n       * Transition Duration\n       * @see https://tailwindcss.com/docs/transition-duration\n       */\n      duration: [{\n        duration: G()\n      }],\n      /**\n       * Transition Timing Function\n       * @see https://tailwindcss.com/docs/transition-timing-function\n       */\n      ease: [{\n        ease: [\"linear\", \"in\", \"out\", \"in-out\", fe]\n      }],\n      /**\n       * Transition Delay\n       * @see https://tailwindcss.com/docs/transition-delay\n       */\n      delay: [{\n        delay: G()\n      }],\n      /**\n       * Animation\n       * @see https://tailwindcss.com/docs/animation\n       */\n      animate: [{\n        animate: [\"none\", \"spin\", \"ping\", \"pulse\", \"bounce\", fe]\n      }],\n      // Transforms\n      /**\n       * Transform\n       * @see https://tailwindcss.com/docs/transform\n       */\n      transform: [{\n        transform: [\"\", \"gpu\", \"none\"]\n      }],\n      /**\n       * Scale\n       * @see https://tailwindcss.com/docs/scale\n       */\n      scale: [{\n        scale: [m]\n      }],\n      /**\n       * Scale X\n       * @see https://tailwindcss.com/docs/scale\n       */\n      \"scale-x\": [{\n        \"scale-x\": [m]\n      }],\n      /**\n       * Scale Y\n       * @see https://tailwindcss.com/docs/scale\n       */\n      \"scale-y\": [{\n        \"scale-y\": [m]\n      }],\n      /**\n       * Rotate\n       * @see https://tailwindcss.com/docs/rotate\n       */\n      rotate: [{\n        rotate: [Ci, fe]\n      }],\n      /**\n       * Translate X\n       * @see https://tailwindcss.com/docs/translate\n       */\n      \"translate-x\": [{\n        \"translate-x\": [O]\n      }],\n      /**\n       * Translate Y\n       * @see https://tailwindcss.com/docs/translate\n       */\n      \"translate-y\": [{\n        \"translate-y\": [O]\n      }],\n      /**\n       * Skew X\n       * @see https://tailwindcss.com/docs/skew\n       */\n      \"skew-x\": [{\n        \"skew-x\": [S]\n      }],\n      /**\n       * Skew Y\n       * @see https://tailwindcss.com/docs/skew\n       */\n      \"skew-y\": [{\n        \"skew-y\": [S]\n      }],\n      /**\n       * Transform Origin\n       * @see https://tailwindcss.com/docs/transform-origin\n       */\n      \"transform-origin\": [{\n        origin: [\"center\", \"top\", \"top-right\", \"right\", \"bottom-right\", \"bottom\", \"bottom-left\", \"left\", \"top-left\", fe]\n      }],\n      // Interactivity\n      /**\n       * Accent Color\n       * @see https://tailwindcss.com/docs/accent-color\n       */\n      accent: [{\n        accent: [\"auto\", e]\n      }],\n      /**\n       * Appearance\n       * @see https://tailwindcss.com/docs/appearance\n       */\n      appearance: [{\n        appearance: [\"none\", \"auto\"]\n      }],\n      /**\n       * Cursor\n       * @see https://tailwindcss.com/docs/cursor\n       */\n      cursor: [{\n        cursor: [\"auto\", \"default\", \"pointer\", \"wait\", \"text\", \"move\", \"help\", \"not-allowed\", \"none\", \"context-menu\", \"progress\", \"cell\", \"crosshair\", \"vertical-text\", \"alias\", \"copy\", \"no-drop\", \"grab\", \"grabbing\", \"all-scroll\", \"col-resize\", \"row-resize\", \"n-resize\", \"e-resize\", \"s-resize\", \"w-resize\", \"ne-resize\", \"nw-resize\", \"se-resize\", \"sw-resize\", \"ew-resize\", \"ns-resize\", \"nesw-resize\", \"nwse-resize\", \"zoom-in\", \"zoom-out\", fe]\n      }],\n      /**\n       * Caret Color\n       * @see https://tailwindcss.com/docs/just-in-time-mode#caret-color-utilities\n       */\n      \"caret-color\": [{\n        caret: [e]\n      }],\n      /**\n       * Pointer Events\n       * @see https://tailwindcss.com/docs/pointer-events\n       */\n      \"pointer-events\": [{\n        \"pointer-events\": [\"none\", \"auto\"]\n      }],\n      /**\n       * Resize\n       * @see https://tailwindcss.com/docs/resize\n       */\n      resize: [{\n        resize: [\"none\", \"y\", \"x\", \"\"]\n      }],\n      /**\n       * Scroll Behavior\n       * @see https://tailwindcss.com/docs/scroll-behavior\n       */\n      \"scroll-behavior\": [{\n        scroll: [\"auto\", \"smooth\"]\n      }],\n      /**\n       * Scroll Margin\n       * @see https://tailwindcss.com/docs/scroll-margin\n       */\n      \"scroll-m\": [{\n        \"scroll-m\": A()\n      }],\n      /**\n       * Scroll Margin X\n       * @see https://tailwindcss.com/docs/scroll-margin\n       */\n      \"scroll-mx\": [{\n        \"scroll-mx\": A()\n      }],\n      /**\n       * Scroll Margin Y\n       * @see https://tailwindcss.com/docs/scroll-margin\n       */\n      \"scroll-my\": [{\n        \"scroll-my\": A()\n      }],\n      /**\n       * Scroll Margin Start\n       * @see https://tailwindcss.com/docs/scroll-margin\n       */\n      \"scroll-ms\": [{\n        \"scroll-ms\": A()\n      }],\n      /**\n       * Scroll Margin End\n       * @see https://tailwindcss.com/docs/scroll-margin\n       */\n      \"scroll-me\": [{\n        \"scroll-me\": A()\n      }],\n      /**\n       * Scroll Margin Top\n       * @see https://tailwindcss.com/docs/scroll-margin\n       */\n      \"scroll-mt\": [{\n        \"scroll-mt\": A()\n      }],\n      /**\n       * Scroll Margin Right\n       * @see https://tailwindcss.com/docs/scroll-margin\n       */\n      \"scroll-mr\": [{\n        \"scroll-mr\": A()\n      }],\n      /**\n       * Scroll Margin Bottom\n       * @see https://tailwindcss.com/docs/scroll-margin\n       */\n      \"scroll-mb\": [{\n        \"scroll-mb\": A()\n      }],\n      /**\n       * Scroll Margin Left\n       * @see https://tailwindcss.com/docs/scroll-margin\n       */\n      \"scroll-ml\": [{\n        \"scroll-ml\": A()\n      }],\n      /**\n       * Scroll Padding\n       * @see https://tailwindcss.com/docs/scroll-padding\n       */\n      \"scroll-p\": [{\n        \"scroll-p\": A()\n      }],\n      /**\n       * Scroll Padding X\n       * @see https://tailwindcss.com/docs/scroll-padding\n       */\n      \"scroll-px\": [{\n        \"scroll-px\": A()\n      }],\n      /**\n       * Scroll Padding Y\n       * @see https://tailwindcss.com/docs/scroll-padding\n       */\n      \"scroll-py\": [{\n        \"scroll-py\": A()\n      }],\n      /**\n       * Scroll Padding Start\n       * @see https://tailwindcss.com/docs/scroll-padding\n       */\n      \"scroll-ps\": [{\n        \"scroll-ps\": A()\n      }],\n      /**\n       * Scroll Padding End\n       * @see https://tailwindcss.com/docs/scroll-padding\n       */\n      \"scroll-pe\": [{\n        \"scroll-pe\": A()\n      }],\n      /**\n       * Scroll Padding Top\n       * @see https://tailwindcss.com/docs/scroll-padding\n       */\n      \"scroll-pt\": [{\n        \"scroll-pt\": A()\n      }],\n      /**\n       * Scroll Padding Right\n       * @see https://tailwindcss.com/docs/scroll-padding\n       */\n      \"scroll-pr\": [{\n        \"scroll-pr\": A()\n      }],\n      /**\n       * Scroll Padding Bottom\n       * @see https://tailwindcss.com/docs/scroll-padding\n       */\n      \"scroll-pb\": [{\n        \"scroll-pb\": A()\n      }],\n      /**\n       * Scroll Padding Left\n       * @see https://tailwindcss.com/docs/scroll-padding\n       */\n      \"scroll-pl\": [{\n        \"scroll-pl\": A()\n      }],\n      /**\n       * Scroll Snap Align\n       * @see https://tailwindcss.com/docs/scroll-snap-align\n       */\n      \"snap-align\": [{\n        snap: [\"start\", \"end\", \"center\", \"align-none\"]\n      }],\n      /**\n       * Scroll Snap Stop\n       * @see https://tailwindcss.com/docs/scroll-snap-stop\n       */\n      \"snap-stop\": [{\n        snap: [\"normal\", \"always\"]\n      }],\n      /**\n       * Scroll Snap Type\n       * @see https://tailwindcss.com/docs/scroll-snap-type\n       */\n      \"snap-type\": [{\n        snap: [\"none\", \"x\", \"y\", \"both\"]\n      }],\n      /**\n       * Scroll Snap Type Strictness\n       * @see https://tailwindcss.com/docs/scroll-snap-type\n       */\n      \"snap-strictness\": [{\n        snap: [\"mandatory\", \"proximity\"]\n      }],\n      /**\n       * Touch Action\n       * @see https://tailwindcss.com/docs/touch-action\n       */\n      touch: [{\n        touch: [\"auto\", \"none\", \"manipulation\"]\n      }],\n      /**\n       * Touch Action X\n       * @see https://tailwindcss.com/docs/touch-action\n       */\n      \"touch-x\": [{\n        \"touch-pan\": [\"x\", \"left\", \"right\"]\n      }],\n      /**\n       * Touch Action Y\n       * @see https://tailwindcss.com/docs/touch-action\n       */\n      \"touch-y\": [{\n        \"touch-pan\": [\"y\", \"up\", \"down\"]\n      }],\n      /**\n       * Touch Action Pinch Zoom\n       * @see https://tailwindcss.com/docs/touch-action\n       */\n      \"touch-pz\": [\"touch-pinch-zoom\"],\n      /**\n       * User Select\n       * @see https://tailwindcss.com/docs/user-select\n       */\n      select: [{\n        select: [\"none\", \"text\", \"all\", \"auto\"]\n      }],\n      /**\n       * Will Change\n       * @see https://tailwindcss.com/docs/will-change\n       */\n      \"will-change\": [{\n        \"will-change\": [\"auto\", \"scroll\", \"contents\", \"transform\", fe]\n      }],\n      // SVG\n      /**\n       * Fill\n       * @see https://tailwindcss.com/docs/fill\n       */\n      fill: [{\n        fill: [e, \"none\"]\n      }],\n      /**\n       * Stroke Width\n       * @see https://tailwindcss.com/docs/stroke-width\n       */\n      \"stroke-w\": [{\n        stroke: [pn, Tn, na]\n      }],\n      /**\n       * Stroke\n       * @see https://tailwindcss.com/docs/stroke\n       */\n      stroke: [{\n        stroke: [e, \"none\"]\n      }],\n      // Accessibility\n      /**\n       * Screen Readers\n       * @see https://tailwindcss.com/docs/screen-readers\n       */\n      sr: [\"sr-only\", \"not-sr-only\"],\n      /**\n       * Forced Color Adjust\n       * @see https://tailwindcss.com/docs/forced-color-adjust\n       */\n      \"forced-color-adjust\": [{\n        \"forced-color-adjust\": [\"auto\", \"none\"]\n      }]\n    },\n    conflictingClassGroups: {\n      overflow: [\"overflow-x\", \"overflow-y\"],\n      overscroll: [\"overscroll-x\", \"overscroll-y\"],\n      inset: [\"inset-x\", \"inset-y\", \"start\", \"end\", \"top\", \"right\", \"bottom\", \"left\"],\n      \"inset-x\": [\"right\", \"left\"],\n      \"inset-y\": [\"top\", \"bottom\"],\n      flex: [\"basis\", \"grow\", \"shrink\"],\n      gap: [\"gap-x\", \"gap-y\"],\n      p: [\"px\", \"py\", \"ps\", \"pe\", \"pt\", \"pr\", \"pb\", \"pl\"],\n      px: [\"pr\", \"pl\"],\n      py: [\"pt\", \"pb\"],\n      m: [\"mx\", \"my\", \"ms\", \"me\", \"mt\", \"mr\", \"mb\", \"ml\"],\n      mx: [\"mr\", \"ml\"],\n      my: [\"mt\", \"mb\"],\n      size: [\"w\", \"h\"],\n      \"font-size\": [\"leading\"],\n      \"fvn-normal\": [\"fvn-ordinal\", \"fvn-slashed-zero\", \"fvn-figure\", \"fvn-spacing\", \"fvn-fraction\"],\n      \"fvn-ordinal\": [\"fvn-normal\"],\n      \"fvn-slashed-zero\": [\"fvn-normal\"],\n      \"fvn-figure\": [\"fvn-normal\"],\n      \"fvn-spacing\": [\"fvn-normal\"],\n      \"fvn-fraction\": [\"fvn-normal\"],\n      \"line-clamp\": [\"display\", \"overflow\"],\n      rounded: [\"rounded-s\", \"rounded-e\", \"rounded-t\", \"rounded-r\", \"rounded-b\", \"rounded-l\", \"rounded-ss\", \"rounded-se\", \"rounded-ee\", \"rounded-es\", \"rounded-tl\", \"rounded-tr\", \"rounded-br\", \"rounded-bl\"],\n      \"rounded-s\": [\"rounded-ss\", \"rounded-es\"],\n      \"rounded-e\": [\"rounded-se\", \"rounded-ee\"],\n      \"rounded-t\": [\"rounded-tl\", \"rounded-tr\"],\n      \"rounded-r\": [\"rounded-tr\", \"rounded-br\"],\n      \"rounded-b\": [\"rounded-br\", \"rounded-bl\"],\n      \"rounded-l\": [\"rounded-tl\", \"rounded-bl\"],\n      \"border-spacing\": [\"border-spacing-x\", \"border-spacing-y\"],\n      \"border-w\": [\"border-w-s\", \"border-w-e\", \"border-w-t\", \"border-w-r\", \"border-w-b\", \"border-w-l\"],\n      \"border-w-x\": [\"border-w-r\", \"border-w-l\"],\n      \"border-w-y\": [\"border-w-t\", \"border-w-b\"],\n      \"border-color\": [\"border-color-t\", \"border-color-r\", \"border-color-b\", \"border-color-l\"],\n      \"border-color-x\": [\"border-color-r\", \"border-color-l\"],\n      \"border-color-y\": [\"border-color-t\", \"border-color-b\"],\n      \"scroll-m\": [\"scroll-mx\", \"scroll-my\", \"scroll-ms\", \"scroll-me\", \"scroll-mt\", \"scroll-mr\", \"scroll-mb\", \"scroll-ml\"],\n      \"scroll-mx\": [\"scroll-mr\", \"scroll-ml\"],\n      \"scroll-my\": [\"scroll-mt\", \"scroll-mb\"],\n      \"scroll-p\": [\"scroll-px\", \"scroll-py\", \"scroll-ps\", \"scroll-pe\", \"scroll-pt\", \"scroll-pr\", \"scroll-pb\", \"scroll-pl\"],\n      \"scroll-px\": [\"scroll-pr\", \"scroll-pl\"],\n      \"scroll-py\": [\"scroll-pt\", \"scroll-pb\"],\n      touch: [\"touch-x\", \"touch-y\", \"touch-pz\"],\n      \"touch-x\": [\"touch\"],\n      \"touch-y\": [\"touch\"],\n      \"touch-pz\": [\"touch\"]\n    },\n    conflictingClassGroupModifiers: {\n      \"font-size\": [\"leading\"]\n    }\n  };\n}\nconst u1 = /* @__PURE__ */ Gx(s1);\nfunction Le(...e) {\n  return u1($e(e));\n}\nconst c1 = Tx(\n  \"inline-flex items-center justify-center whitespace-nowrap rounded-md text-sm font-medium ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50\",\n  {\n    variants: {\n      variant: {\n        default: \"bg-primary text-primary-foreground hover:bg-primary/90\",\n        destructive: \"bg-destructive text-destructive-foreground hover:bg-destructive/90\",\n        outline: \"border border-input bg-background hover:bg-accent hover:text-accent-foreground\",\n        secondary: \"bg-secondary text-secondary-foreground hover:bg-secondary/80\",\n        ghost: \"hover:bg-accent hover:text-accent-foreground\",\n        link: \"text-primary underline-offset-4 hover:underline\"\n      },\n      size: {\n        default: \"h-10 px-4 py-2\",\n        sm: \"h-9 rounded-md px-3\",\n        lg: \"h-11 rounded-md px-8\",\n        icon: \"h-10 w-10\"\n      }\n    },\n    defaultVariants: {\n      variant: \"default\",\n      size: \"default\"\n    }\n  }\n), ar = react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(\n  ({ className: e, variant: t, size: n, asChild: r = !1, ...i }, o) => /* @__PURE__ */ X(\n    r ? kr : \"button\",\n    {\n      className: Le(c1({ variant: t, size: n, className: e })),\n      ref: o,\n      ...i\n    }\n  )\n);\nar.displayName = \"Button\";\nconst KU = ({ title: e }) => /* @__PURE__ */ X(ar, { children: e });\n/**\n * @license lucide-react v0.390.0 - ISC\n *\n * This source code is licensed under the ISC license.\n * See the LICENSE file in the root directory of this source tree.\n */\nconst l1 = (e) => e.replace(/([a-z0-9])([A-Z])/g, \"$1-$2\").toLowerCase(), wm = (...e) => e.filter((t, n, r) => !!t && r.indexOf(t) === n).join(\" \");\n/**\n * @license lucide-react v0.390.0 - ISC\n *\n * This source code is licensed under the ISC license.\n * See the LICENSE file in the root directory of this source tree.\n */\nvar f1 = {\n  xmlns: \"http://www.w3.org/2000/svg\",\n  width: 24,\n  height: 24,\n  viewBox: \"0 0 24 24\",\n  fill: \"none\",\n  stroke: \"currentColor\",\n  strokeWidth: 2,\n  strokeLinecap: \"round\",\n  strokeLinejoin: \"round\"\n};\n/**\n * @license lucide-react v0.390.0 - ISC\n *\n * This source code is licensed under the ISC license.\n * See the LICENSE file in the root directory of this source tree.\n */\nconst d1 = (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(\n  ({\n    color: e = \"currentColor\",\n    size: t = 24,\n    strokeWidth: n = 2,\n    absoluteStrokeWidth: r,\n    className: i = \"\",\n    children: o,\n    iconNode: a,\n    ...s\n  }, u) => (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(\n    \"svg\",\n    {\n      ref: u,\n      ...f1,\n      width: t,\n      height: t,\n      stroke: e,\n      strokeWidth: r ? Number(n) * 24 / Number(t) : n,\n      className: wm(\"lucide\", i),\n      ...s\n    },\n    [\n      ...a.map(([c, f]) => (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(c, f)),\n      ...Array.isArray(o) ? o : [o]\n    ]\n  )\n);\n/**\n * @license lucide-react v0.390.0 - ISC\n *\n * This source code is licensed under the ISC license.\n * See the LICENSE file in the root directory of this source tree.\n */\nconst pr = (e, t) => {\n  const n = (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(\n    ({ className: r, ...i }, o) => (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(d1, {\n      ref: o,\n      iconNode: t,\n      className: wm(`lucide-${l1(e)}`, r),\n      ...i\n    })\n  );\n  return n.displayName = `${e}`, n;\n};\n/**\n * @license lucide-react v0.390.0 - ISC\n *\n * This source code is licensed under the ISC license.\n * See the LICENSE file in the root directory of this source tree.\n */\nconst p1 = pr(\"BellRing\", [\n  [\"path\", { d: \"M6 8a6 6 0 0 1 12 0c0 7 3 9 3 9H3s3-2 3-9\", key: \"1qo2s2\" }],\n  [\"path\", { d: \"M10.3 21a1.94 1.94 0 0 0 3.4 0\", key: \"qgo35s\" }],\n  [\"path\", { d: \"M4 2C2.8 3.7 2 5.7 2 8\", key: \"tap9e0\" }],\n  [\"path\", { d: \"M22 8c0-2.3-.8-4.3-2-6\", key: \"5bb3ad\" }]\n]);\n/**\n * @license lucide-react v0.390.0 - ISC\n *\n * This source code is licensed under the ISC license.\n * See the LICENSE file in the root directory of this source tree.\n */\nconst xm = pr(\"Check\", [[\"path\", { d: \"M20 6 9 17l-5-5\", key: \"1gmf2c\" }]]);\n/**\n * @license lucide-react v0.390.0 - ISC\n *\n * This source code is licensed under the ISC license.\n * See the LICENSE file in the root directory of this source tree.\n */\nconst h1 = pr(\"ChevronDown\", [\n  [\"path\", { d: \"m6 9 6 6 6-6\", key: \"qrunsl\" }]\n]);\n/**\n * @license lucide-react v0.390.0 - ISC\n *\n * This source code is licensed under the ISC license.\n * See the LICENSE file in the root directory of this source tree.\n */\nconst g1 = pr(\"ChevronRight\", [\n  [\"path\", { d: \"m9 18 6-6-6-6\", key: \"mthhwq\" }]\n]);\n/**\n * @license lucide-react v0.390.0 - ISC\n *\n * This source code is licensed under the ISC license.\n * See the LICENSE file in the root directory of this source tree.\n */\nconst v1 = pr(\"Circle\", [\n  [\"circle\", { cx: \"12\", cy: \"12\", r: \"10\", key: \"1mglay\" }]\n]);\n/**\n * @license lucide-react v0.390.0 - ISC\n *\n * This source code is licensed under the ISC license.\n * See the LICENSE file in the root directory of this source tree.\n */\nconst m1 = pr(\"Moon\", [\n  [\"path\", { d: \"M12 3a6 6 0 0 0 9 9 9 9 0 1 1-9-9Z\", key: \"a7tn18\" }]\n]);\n/**\n * @license lucide-react v0.390.0 - ISC\n *\n * This source code is licensed under the ISC license.\n * See the LICENSE file in the root directory of this source tree.\n */\nconst y1 = pr(\"Sun\", [\n  [\"circle\", { cx: \"12\", cy: \"12\", r: \"4\", key: \"4exip2\" }],\n  [\"path\", { d: \"M12 2v2\", key: \"tus03m\" }],\n  [\"path\", { d: \"M12 20v2\", key: \"1lh1kg\" }],\n  [\"path\", { d: \"m4.93 4.93 1.41 1.41\", key: \"149t6j\" }],\n  [\"path\", { d: \"m17.66 17.66 1.41 1.41\", key: \"ptbguv\" }],\n  [\"path\", { d: \"M2 12h2\", key: \"1t8f8n\" }],\n  [\"path\", { d: \"M20 12h2\", key: \"1q8mjw\" }],\n  [\"path\", { d: \"m6.34 17.66-1.41 1.41\", key: \"1m8zz5\" }],\n  [\"path\", { d: \"m19.07 4.93-1.41 1.41\", key: \"1shlcs\" }]\n]), Sm = react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(({ className: e, ...t }, n) => /* @__PURE__ */ X(\n  \"div\",\n  {\n    ref: n,\n    className: Le(\n      \"rounded-lg border bg-card text-card-foreground shadow-sm\",\n      e\n    ),\n    ...t\n  }\n));\nSm.displayName = \"Card\";\nconst $m = react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(({ className: e, ...t }, n) => /* @__PURE__ */ X(\n  \"div\",\n  {\n    ref: n,\n    className: Le(\"flex flex-col space-y-1.5 p-6\", e),\n    ...t\n  }\n));\n$m.displayName = \"CardHeader\";\nconst Om = react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(({ className: e, ...t }, n) => /* @__PURE__ */ X(\n  \"h3\",\n  {\n    ref: n,\n    className: Le(\n      \"text-2xl font-semibold leading-none tracking-tight\",\n      e\n    ),\n    ...t\n  }\n));\nOm.displayName = \"CardTitle\";\nconst _m = react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(({ className: e, ...t }, n) => /* @__PURE__ */ X(\n  \"p\",\n  {\n    ref: n,\n    className: Le(\"text-sm text-muted-foreground\", e),\n    ...t\n  }\n));\n_m.displayName = \"CardDescription\";\nconst Am = react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(({ className: e, ...t }, n) => /* @__PURE__ */ X(\"div\", { ref: n, className: Le(\"p-6 pt-0\", e), ...t }));\nAm.displayName = \"CardContent\";\nconst Pm = react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(({ className: e, ...t }, n) => /* @__PURE__ */ X(\n  \"div\",\n  {\n    ref: n,\n    className: Le(\"flex items-center p-6 pt-0\", e),\n    ...t\n  }\n));\nPm.displayName = \"CardFooter\";\nconst b1 = [\n  {\n    title: \"Your call has been confirmed.\",\n    description: \"1 hour ago\"\n  },\n  {\n    title: \"You have a new message!\",\n    description: \"1 hour ago\"\n  },\n  {\n    title: \"Your subscription is expiring soon!\",\n    description: \"2 hours ago\"\n  }\n];\nfunction YU({ className: e, ...t }) {\n  return /* @__PURE__ */ ze(Sm, { className: Le(\"w-[380px]\", e), ...t, children: [\n    /* @__PURE__ */ ze($m, { children: [\n      /* @__PURE__ */ X(Om, { children: \"Notifications\" }),\n      /* @__PURE__ */ X(_m, { children: \"You have 3 unread messages.\" })\n    ] }),\n    /* @__PURE__ */ ze(Am, { className: \"grid gap-4\", children: [\n      /* @__PURE__ */ ze(\"div\", { className: \" flex items-center space-x-4 rounded-md border p-4\", children: [\n        /* @__PURE__ */ X(p1, {}),\n        /* @__PURE__ */ ze(\"div\", { className: \"flex-1 space-y-1\", children: [\n          /* @__PURE__ */ X(\"p\", { className: \"text-sm font-medium leading-none\", children: \"Push Notifications\" }),\n          /* @__PURE__ */ X(\"p\", { className: \"text-sm text-muted-foreground\", children: \"Send notifications to device.\" })\n        ] })\n      ] }),\n      /* @__PURE__ */ X(\"div\", { children: b1.map((n, r) => /* @__PURE__ */ ze(\n        \"div\",\n        {\n          className: \"mb-4 grid grid-cols-[25px_1fr] items-start pb-4 last:mb-0 last:pb-0\",\n          children: [\n            /* @__PURE__ */ X(\"span\", { className: \"flex h-2 w-2 translate-y-1 rounded-full bg-sky-500\" }),\n            /* @__PURE__ */ ze(\"div\", { className: \"space-y-1\", children: [\n              /* @__PURE__ */ X(\"p\", { className: \"text-sm font-medium leading-none\", children: n.title }),\n              /* @__PURE__ */ X(\"p\", { className: \"text-sm text-muted-foreground\", children: n.description })\n            ] })\n          ]\n        },\n        r\n      )) })\n    ] }),\n    /* @__PURE__ */ X(Pm, { children: /* @__PURE__ */ ze(ar, { className: \"w-full\", children: [\n      /* @__PURE__ */ X(xm, { className: \"mr-2 h-4 w-4\" }),\n      \" Mark all as read\"\n    ] }) })\n  ] });\n}\nfunction we(e, t, { checkForDefaultPrevented: n = !0 } = {}) {\n  return function(i) {\n    if (e == null || e(i), n === !1 || !i.defaultPrevented)\n      return t == null ? void 0 : t(i);\n  };\n}\nfunction Fo(e, t = []) {\n  let n = [];\n  function r(o, a) {\n    const s = /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(a), u = n.length;\n    n = [\n      ...n,\n      a\n    ];\n    function c(l) {\n      const { scope: d, children: p, ...g } = l, h = (d == null ? void 0 : d[e][u]) || s, v = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(\n        () => g,\n        Object.values(g)\n      );\n      return /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(h.Provider, {\n        value: v\n      }, p);\n    }\n    function f(l, d) {\n      const p = (d == null ? void 0 : d[e][u]) || s, g = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(p);\n      if (g)\n        return g;\n      if (a !== void 0)\n        return a;\n      throw new Error(`\\`${l}\\` must be used within \\`${o}\\``);\n    }\n    return c.displayName = o + \"Provider\", [\n      c,\n      f\n    ];\n  }\n  const i = () => {\n    const o = n.map((a) => /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(a));\n    return function(s) {\n      const u = (s == null ? void 0 : s[e]) || o;\n      return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(\n        () => ({\n          [`__scope${e}`]: {\n            ...s,\n            [e]: u\n          }\n        }),\n        [\n          s,\n          u\n        ]\n      );\n    };\n  };\n  return i.scopeName = e, [\n    r,\n    w1(i, ...t)\n  ];\n}\nfunction w1(...e) {\n  const t = e[0];\n  if (e.length === 1)\n    return t;\n  const n = () => {\n    const r = e.map(\n      (i) => ({\n        useScope: i(),\n        scopeName: i.scopeName\n      })\n    );\n    return function(o) {\n      const a = r.reduce((s, { useScope: u, scopeName: c }) => {\n        const l = u(o)[`__scope${c}`];\n        return {\n          ...s,\n          ...l\n        };\n      }, {});\n      return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(\n        () => ({\n          [`__scope${t.scopeName}`]: a\n        }),\n        [\n          a\n        ]\n      );\n    };\n  };\n  return n.scopeName = t.scopeName, n;\n}\nfunction un(e) {\n  const t = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(e);\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    t.current = e;\n  }), (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(\n    () => (...n) => {\n      var r;\n      return (r = t.current) === null || r === void 0 ? void 0 : r.call(t, ...n);\n    },\n    []\n  );\n}\nfunction Cm({ prop: e, defaultProp: t, onChange: n = () => {\n} }) {\n  const [r, i] = x1({\n    defaultProp: t,\n    onChange: n\n  }), o = e !== void 0, a = o ? e : r, s = un(n), u = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((c) => {\n    if (o) {\n      const l = typeof c == \"function\" ? c(e) : c;\n      l !== e && s(l);\n    } else\n      i(c);\n  }, [\n    o,\n    e,\n    i,\n    s\n  ]);\n  return [\n    a,\n    u\n  ];\n}\nfunction x1({ defaultProp: e, onChange: t }) {\n  const n = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(e), [r] = n, i = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(r), o = un(t);\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    i.current !== r && (o(r), i.current = r);\n  }, [\n    r,\n    i,\n    o\n  ]), n;\n}\nconst S1 = [\n  \"a\",\n  \"button\",\n  \"div\",\n  \"form\",\n  \"h2\",\n  \"h3\",\n  \"img\",\n  \"input\",\n  \"label\",\n  \"li\",\n  \"nav\",\n  \"ol\",\n  \"p\",\n  \"span\",\n  \"svg\",\n  \"ul\"\n], Ft = S1.reduce((e, t) => {\n  const n = /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)((r, i) => {\n    const { asChild: o, ...a } = r, s = o ? kr : t;\n    return (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n      window[Symbol.for(\"radix-ui\")] = !0;\n    }, []), /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(s, ce({}, a, {\n      ref: i\n    }));\n  });\n  return n.displayName = `Primitive.${t}`, {\n    ...e,\n    [t]: n\n  };\n}, {});\nfunction Em(e, t) {\n  e && (0,react_dom__WEBPACK_IMPORTED_MODULE_1__.flushSync)(\n    () => e.dispatchEvent(t)\n  );\n}\nfunction Tm(e) {\n  const t = e + \"CollectionProvider\", [n, r] = Fo(t), [i, o] = n(t, {\n    collectionRef: {\n      current: null\n    },\n    itemMap: /* @__PURE__ */ new Map()\n  }), a = (p) => {\n    const { scope: g, children: h } = p, v = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null), w = react__WEBPACK_IMPORTED_MODULE_0__.useRef(/* @__PURE__ */ new Map()).current;\n    return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(i, {\n      scope: g,\n      itemMap: w,\n      collectionRef: v\n    }, h);\n  }, s = e + \"CollectionSlot\", u = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.forwardRef((p, g) => {\n    const { scope: h, children: v } = p, w = o(s, h), b = _t(g, w.collectionRef);\n    return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(kr, {\n      ref: b\n    }, v);\n  }), c = e + \"CollectionItemSlot\", f = \"data-radix-collection-item\", l = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.forwardRef((p, g) => {\n    const { scope: h, children: v, ...w } = p, b = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null), x = _t(g, b), m = o(c, h);\n    return react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => (m.itemMap.set(b, {\n      ref: b,\n      ...w\n    }), () => void m.itemMap.delete(b))), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(kr, {\n      [f]: \"\",\n      ref: x\n    }, v);\n  });\n  function d(p) {\n    const g = o(e + \"CollectionConsumer\", p);\n    return react__WEBPACK_IMPORTED_MODULE_0__.useCallback(() => {\n      const v = g.collectionRef.current;\n      if (!v)\n        return [];\n      const w = Array.from(v.querySelectorAll(`[${f}]`));\n      return Array.from(g.itemMap.values()).sort(\n        (m, y) => w.indexOf(m.ref.current) - w.indexOf(y.ref.current)\n      );\n    }, [\n      g.collectionRef,\n      g.itemMap\n    ]);\n  }\n  return [\n    {\n      Provider: a,\n      Slot: u,\n      ItemSlot: l\n    },\n    d,\n    r\n  ];\n}\nconst $1 = /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(void 0);\nfunction Mm(e) {\n  const t = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)($1);\n  return e || t || \"ltr\";\n}\nfunction O1(e, t = globalThis == null ? void 0 : globalThis.document) {\n  const n = un(e);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    const r = (i) => {\n      i.key === \"Escape\" && n(i);\n    };\n    return t.addEventListener(\"keydown\", r), () => t.removeEventListener(\"keydown\", r);\n  }, [\n    n,\n    t\n  ]);\n}\nconst mc = \"dismissableLayer.update\", _1 = \"dismissableLayer.pointerDownOutside\", A1 = \"dismissableLayer.focusOutside\";\nlet zd;\nconst P1 = /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)({\n  layers: /* @__PURE__ */ new Set(),\n  layersWithOutsidePointerEventsDisabled: /* @__PURE__ */ new Set(),\n  branches: /* @__PURE__ */ new Set()\n}), C1 = /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)((e, t) => {\n  var n;\n  const { disableOutsidePointerEvents: r = !1, onEscapeKeyDown: i, onPointerDownOutside: o, onFocusOutside: a, onInteractOutside: s, onDismiss: u, ...c } = e, f = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(P1), [l, d] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null), p = (n = l == null ? void 0 : l.ownerDocument) !== null && n !== void 0 ? n : globalThis == null ? void 0 : globalThis.document, [, g] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({}), h = _t(\n    t,\n    (O) => d(O)\n  ), v = Array.from(f.layers), [w] = [\n    ...f.layersWithOutsidePointerEventsDisabled\n  ].slice(-1), b = v.indexOf(w), x = l ? v.indexOf(l) : -1, m = f.layersWithOutsidePointerEventsDisabled.size > 0, y = x >= b, S = E1((O) => {\n    const T = O.target, M = [\n      ...f.branches\n    ].some(\n      (E) => E.contains(T)\n    );\n    !y || M || (o == null || o(O), s == null || s(O), O.defaultPrevented || u == null || u());\n  }, p), $ = T1((O) => {\n    const T = O.target;\n    [\n      ...f.branches\n    ].some(\n      (E) => E.contains(T)\n    ) || (a == null || a(O), s == null || s(O), O.defaultPrevented || u == null || u());\n  }, p);\n  return O1((O) => {\n    x === f.layers.size - 1 && (i == null || i(O), !O.defaultPrevented && u && (O.preventDefault(), u()));\n  }, p), (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    if (l)\n      return r && (f.layersWithOutsidePointerEventsDisabled.size === 0 && (zd = p.body.style.pointerEvents, p.body.style.pointerEvents = \"none\"), f.layersWithOutsidePointerEventsDisabled.add(l)), f.layers.add(l), Vd(), () => {\n        r && f.layersWithOutsidePointerEventsDisabled.size === 1 && (p.body.style.pointerEvents = zd);\n      };\n  }, [\n    l,\n    p,\n    r,\n    f\n  ]), (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => () => {\n    l && (f.layers.delete(l), f.layersWithOutsidePointerEventsDisabled.delete(l), Vd());\n  }, [\n    l,\n    f\n  ]), (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    const O = () => g({});\n    return document.addEventListener(mc, O), () => document.removeEventListener(mc, O);\n  }, []), /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(Ft.div, ce({}, c, {\n    ref: h,\n    style: {\n      pointerEvents: m ? y ? \"auto\" : \"none\" : void 0,\n      ...e.style\n    },\n    onFocusCapture: we(e.onFocusCapture, $.onFocusCapture),\n    onBlurCapture: we(e.onBlurCapture, $.onBlurCapture),\n    onPointerDownCapture: we(e.onPointerDownCapture, S.onPointerDownCapture)\n  }));\n});\nfunction E1(e, t = globalThis == null ? void 0 : globalThis.document) {\n  const n = un(e), r = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(!1), i = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(() => {\n  });\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    const o = (s) => {\n      if (s.target && !r.current) {\n        let c = function() {\n          Rm(_1, n, u, {\n            discrete: !0\n          });\n        };\n        const u = {\n          originalEvent: s\n        };\n        s.pointerType === \"touch\" ? (t.removeEventListener(\"click\", i.current), i.current = c, t.addEventListener(\"click\", i.current, {\n          once: !0\n        })) : c();\n      } else\n        t.removeEventListener(\"click\", i.current);\n      r.current = !1;\n    }, a = window.setTimeout(() => {\n      t.addEventListener(\"pointerdown\", o);\n    }, 0);\n    return () => {\n      window.clearTimeout(a), t.removeEventListener(\"pointerdown\", o), t.removeEventListener(\"click\", i.current);\n    };\n  }, [\n    t,\n    n\n  ]), {\n    // ensures we check React component tree (not just DOM tree)\n    onPointerDownCapture: () => r.current = !0\n  };\n}\nfunction T1(e, t = globalThis == null ? void 0 : globalThis.document) {\n  const n = un(e), r = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(!1);\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    const i = (o) => {\n      o.target && !r.current && Rm(A1, n, {\n        originalEvent: o\n      }, {\n        discrete: !1\n      });\n    };\n    return t.addEventListener(\"focusin\", i), () => t.removeEventListener(\"focusin\", i);\n  }, [\n    t,\n    n\n  ]), {\n    onFocusCapture: () => r.current = !0,\n    onBlurCapture: () => r.current = !1\n  };\n}\nfunction Vd() {\n  const e = new CustomEvent(mc);\n  document.dispatchEvent(e);\n}\nfunction Rm(e, t, n, { discrete: r }) {\n  const i = n.originalEvent.target, o = new CustomEvent(e, {\n    bubbles: !1,\n    cancelable: !0,\n    detail: n\n  });\n  t && i.addEventListener(e, t, {\n    once: !0\n  }), r ? Em(i, o) : i.dispatchEvent(o);\n}\nlet vu = 0;\nfunction M1() {\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    var e, t;\n    const n = document.querySelectorAll(\"[data-radix-focus-guard]\");\n    return document.body.insertAdjacentElement(\"afterbegin\", (e = n[0]) !== null && e !== void 0 ? e : Gd()), document.body.insertAdjacentElement(\"beforeend\", (t = n[1]) !== null && t !== void 0 ? t : Gd()), vu++, () => {\n      vu === 1 && document.querySelectorAll(\"[data-radix-focus-guard]\").forEach(\n        (r) => r.remove()\n      ), vu--;\n    };\n  }, []);\n}\nfunction Gd() {\n  const e = document.createElement(\"span\");\n  return e.setAttribute(\"data-radix-focus-guard\", \"\"), e.tabIndex = 0, e.style.cssText = \"outline: none; opacity: 0; position: fixed; pointer-events: none\", e;\n}\nconst mu = \"focusScope.autoFocusOnMount\", yu = \"focusScope.autoFocusOnUnmount\", Wd = {\n  bubbles: !1,\n  cancelable: !0\n}, R1 = /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)((e, t) => {\n  const { loop: n = !1, trapped: r = !1, onMountAutoFocus: i, onUnmountAutoFocus: o, ...a } = e, [s, u] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null), c = un(i), f = un(o), l = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null), d = _t(\n    t,\n    (h) => u(h)\n  ), p = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)({\n    paused: !1,\n    pause() {\n      this.paused = !0;\n    },\n    resume() {\n      this.paused = !1;\n    }\n  }).current;\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    if (r) {\n      let h = function(x) {\n        if (p.paused || !s)\n          return;\n        const m = x.target;\n        s.contains(m) ? l.current = m : Rn(l.current, {\n          select: !0\n        });\n      }, v = function(x) {\n        if (p.paused || !s)\n          return;\n        const m = x.relatedTarget;\n        m !== null && (s.contains(m) || Rn(l.current, {\n          select: !0\n        }));\n      }, w = function(x) {\n        if (document.activeElement === document.body)\n          for (const y of x)\n            y.removedNodes.length > 0 && Rn(s);\n      };\n      document.addEventListener(\"focusin\", h), document.addEventListener(\"focusout\", v);\n      const b = new MutationObserver(w);\n      return s && b.observe(s, {\n        childList: !0,\n        subtree: !0\n      }), () => {\n        document.removeEventListener(\"focusin\", h), document.removeEventListener(\"focusout\", v), b.disconnect();\n      };\n    }\n  }, [\n    r,\n    s,\n    p.paused\n  ]), (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    if (s) {\n      Hd.add(p);\n      const h = document.activeElement;\n      if (!s.contains(h)) {\n        const w = new CustomEvent(mu, Wd);\n        s.addEventListener(mu, c), s.dispatchEvent(w), w.defaultPrevented || (I1(F1(Im(s)), {\n          select: !0\n        }), document.activeElement === h && Rn(s));\n      }\n      return () => {\n        s.removeEventListener(mu, c), setTimeout(() => {\n          const w = new CustomEvent(yu, Wd);\n          s.addEventListener(yu, f), s.dispatchEvent(w), w.defaultPrevented || Rn(h ?? document.body, {\n            select: !0\n          }), s.removeEventListener(yu, f), Hd.remove(p);\n        }, 0);\n      };\n    }\n  }, [\n    s,\n    c,\n    f,\n    p\n  ]);\n  const g = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((h) => {\n    if (!n && !r || p.paused)\n      return;\n    const v = h.key === \"Tab\" && !h.altKey && !h.ctrlKey && !h.metaKey, w = document.activeElement;\n    if (v && w) {\n      const b = h.currentTarget, [x, m] = j1(b);\n      x && m ? !h.shiftKey && w === m ? (h.preventDefault(), n && Rn(x, {\n        select: !0\n      })) : h.shiftKey && w === x && (h.preventDefault(), n && Rn(m, {\n        select: !0\n      })) : w === b && h.preventDefault();\n    }\n  }, [\n    n,\n    r,\n    p.paused\n  ]);\n  return /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(Ft.div, ce({\n    tabIndex: -1\n  }, a, {\n    ref: d,\n    onKeyDown: g\n  }));\n});\nfunction I1(e, { select: t = !1 } = {}) {\n  const n = document.activeElement;\n  for (const r of e)\n    if (Rn(r, {\n      select: t\n    }), document.activeElement !== n)\n      return;\n}\nfunction j1(e) {\n  const t = Im(e), n = Ud(t, e), r = Ud(t.reverse(), e);\n  return [\n    n,\n    r\n  ];\n}\nfunction Im(e) {\n  const t = [], n = document.createTreeWalker(e, NodeFilter.SHOW_ELEMENT, {\n    acceptNode: (r) => {\n      const i = r.tagName === \"INPUT\" && r.type === \"hidden\";\n      return r.disabled || r.hidden || i ? NodeFilter.FILTER_SKIP : r.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;\n    }\n  });\n  for (; n.nextNode(); )\n    t.push(n.currentNode);\n  return t;\n}\nfunction Ud(e, t) {\n  for (const n of e)\n    if (!k1(n, {\n      upTo: t\n    }))\n      return n;\n}\nfunction k1(e, { upTo: t }) {\n  if (getComputedStyle(e).visibility === \"hidden\")\n    return !0;\n  for (; e; ) {\n    if (t !== void 0 && e === t)\n      return !1;\n    if (getComputedStyle(e).display === \"none\")\n      return !0;\n    e = e.parentElement;\n  }\n  return !1;\n}\nfunction D1(e) {\n  return e instanceof HTMLInputElement && \"select\" in e;\n}\nfunction Rn(e, { select: t = !1 } = {}) {\n  if (e && e.focus) {\n    const n = document.activeElement;\n    e.focus({\n      preventScroll: !0\n    }), e !== n && D1(e) && t && e.select();\n  }\n}\nconst Hd = N1();\nfunction N1() {\n  let e = [];\n  return {\n    add(t) {\n      const n = e[0];\n      t !== n && (n == null || n.pause()), e = qd(e, t), e.unshift(t);\n    },\n    remove(t) {\n      var n;\n      e = qd(e, t), (n = e[0]) === null || n === void 0 || n.resume();\n    }\n  };\n}\nfunction qd(e, t) {\n  const n = [\n    ...e\n  ], r = n.indexOf(t);\n  return r !== -1 && n.splice(r, 1), n;\n}\nfunction F1(e) {\n  return e.filter(\n    (t) => t.tagName !== \"A\"\n  );\n}\nconst Dr = globalThis != null && globalThis.document ? react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect : () => {\n}, L1 = react__WEBPACK_IMPORTED_MODULE_0__.useId || (() => {\n});\nlet B1 = 0;\nfunction yc(e) {\n  const [t, n] = react__WEBPACK_IMPORTED_MODULE_0__.useState(L1());\n  return Dr(() => {\n    e || n(\n      (r) => r ?? String(B1++)\n    );\n  }, [\n    e\n  ]), e || (t ? `radix-${t}` : \"\");\n}\nconst z1 = [\"top\", \"right\", \"bottom\", \"left\"], rn = Math.min, xt = Math.max, Ma = Math.round, ra = Math.floor, zn = (e) => ({\n  x: e,\n  y: e\n}), V1 = {\n  left: \"right\",\n  right: \"left\",\n  bottom: \"top\",\n  top: \"bottom\"\n}, G1 = {\n  start: \"end\",\n  end: \"start\"\n};\nfunction bc(e, t, n) {\n  return xt(e, rn(t, n));\n}\nfunction wn(e, t) {\n  return typeof e == \"function\" ? e(t) : e;\n}\nfunction xn(e) {\n  return e.split(\"-\")[0];\n}\nfunction oi(e) {\n  return e.split(\"-\")[1];\n}\nfunction tf(e) {\n  return e === \"x\" ? \"y\" : \"x\";\n}\nfunction nf(e) {\n  return e === \"y\" ? \"height\" : \"width\";\n}\nfunction ai(e) {\n  return [\"top\", \"bottom\"].includes(xn(e)) ? \"y\" : \"x\";\n}\nfunction rf(e) {\n  return tf(ai(e));\n}\nfunction W1(e, t, n) {\n  n === void 0 && (n = !1);\n  const r = oi(e), i = rf(e), o = nf(i);\n  let a = i === \"x\" ? r === (n ? \"end\" : \"start\") ? \"right\" : \"left\" : r === \"start\" ? \"bottom\" : \"top\";\n  return t.reference[o] > t.floating[o] && (a = Ra(a)), [a, Ra(a)];\n}\nfunction U1(e) {\n  const t = Ra(e);\n  return [wc(e), t, wc(t)];\n}\nfunction wc(e) {\n  return e.replace(/start|end/g, (t) => G1[t]);\n}\nfunction H1(e, t, n) {\n  const r = [\"left\", \"right\"], i = [\"right\", \"left\"], o = [\"top\", \"bottom\"], a = [\"bottom\", \"top\"];\n  switch (e) {\n    case \"top\":\n    case \"bottom\":\n      return n ? t ? i : r : t ? r : i;\n    case \"left\":\n    case \"right\":\n      return t ? o : a;\n    default:\n      return [];\n  }\n}\nfunction q1(e, t, n, r) {\n  const i = oi(e);\n  let o = H1(xn(e), n === \"start\", r);\n  return i && (o = o.map((a) => a + \"-\" + i), t && (o = o.concat(o.map(wc)))), o;\n}\nfunction Ra(e) {\n  return e.replace(/left|right|bottom|top/g, (t) => V1[t]);\n}\nfunction K1(e) {\n  return {\n    top: 0,\n    right: 0,\n    bottom: 0,\n    left: 0,\n    ...e\n  };\n}\nfunction jm(e) {\n  return typeof e != \"number\" ? K1(e) : {\n    top: e,\n    right: e,\n    bottom: e,\n    left: e\n  };\n}\nfunction Ia(e) {\n  const {\n    x: t,\n    y: n,\n    width: r,\n    height: i\n  } = e;\n  return {\n    width: r,\n    height: i,\n    top: n,\n    left: t,\n    right: t + r,\n    bottom: n + i,\n    x: t,\n    y: n\n  };\n}\nfunction Kd(e, t, n) {\n  let {\n    reference: r,\n    floating: i\n  } = e;\n  const o = ai(t), a = rf(t), s = nf(a), u = xn(t), c = o === \"y\", f = r.x + r.width / 2 - i.width / 2, l = r.y + r.height / 2 - i.height / 2, d = r[s] / 2 - i[s] / 2;\n  let p;\n  switch (u) {\n    case \"top\":\n      p = {\n        x: f,\n        y: r.y - i.height\n      };\n      break;\n    case \"bottom\":\n      p = {\n        x: f,\n        y: r.y + r.height\n      };\n      break;\n    case \"right\":\n      p = {\n        x: r.x + r.width,\n        y: l\n      };\n      break;\n    case \"left\":\n      p = {\n        x: r.x - i.width,\n        y: l\n      };\n      break;\n    default:\n      p = {\n        x: r.x,\n        y: r.y\n      };\n  }\n  switch (oi(t)) {\n    case \"start\":\n      p[a] -= d * (n && c ? -1 : 1);\n      break;\n    case \"end\":\n      p[a] += d * (n && c ? -1 : 1);\n      break;\n  }\n  return p;\n}\nconst Y1 = async (e, t, n) => {\n  const {\n    placement: r = \"bottom\",\n    strategy: i = \"absolute\",\n    middleware: o = [],\n    platform: a\n  } = n, s = o.filter(Boolean), u = await (a.isRTL == null ? void 0 : a.isRTL(t));\n  let c = await a.getElementRects({\n    reference: e,\n    floating: t,\n    strategy: i\n  }), {\n    x: f,\n    y: l\n  } = Kd(c, r, u), d = r, p = {}, g = 0;\n  for (let h = 0; h < s.length; h++) {\n    const {\n      name: v,\n      fn: w\n    } = s[h], {\n      x: b,\n      y: x,\n      data: m,\n      reset: y\n    } = await w({\n      x: f,\n      y: l,\n      initialPlacement: r,\n      placement: d,\n      strategy: i,\n      middlewareData: p,\n      rects: c,\n      platform: a,\n      elements: {\n        reference: e,\n        floating: t\n      }\n    });\n    f = b ?? f, l = x ?? l, p = {\n      ...p,\n      [v]: {\n        ...p[v],\n        ...m\n      }\n    }, y && g <= 50 && (g++, typeof y == \"object\" && (y.placement && (d = y.placement), y.rects && (c = y.rects === !0 ? await a.getElementRects({\n      reference: e,\n      floating: t,\n      strategy: i\n    }) : y.rects), {\n      x: f,\n      y: l\n    } = Kd(c, d, u)), h = -1);\n  }\n  return {\n    x: f,\n    y: l,\n    placement: d,\n    strategy: i,\n    middlewareData: p\n  };\n};\nasync function Zi(e, t) {\n  var n;\n  t === void 0 && (t = {});\n  const {\n    x: r,\n    y: i,\n    platform: o,\n    rects: a,\n    elements: s,\n    strategy: u\n  } = e, {\n    boundary: c = \"clippingAncestors\",\n    rootBoundary: f = \"viewport\",\n    elementContext: l = \"floating\",\n    altBoundary: d = !1,\n    padding: p = 0\n  } = wn(t, e), g = jm(p), v = s[d ? l === \"floating\" ? \"reference\" : \"floating\" : l], w = Ia(await o.getClippingRect({\n    element: (n = await (o.isElement == null ? void 0 : o.isElement(v))) == null || n ? v : v.contextElement || await (o.getDocumentElement == null ? void 0 : o.getDocumentElement(s.floating)),\n    boundary: c,\n    rootBoundary: f,\n    strategy: u\n  })), b = l === \"floating\" ? {\n    x: r,\n    y: i,\n    width: a.floating.width,\n    height: a.floating.height\n  } : a.reference, x = await (o.getOffsetParent == null ? void 0 : o.getOffsetParent(s.floating)), m = await (o.isElement == null ? void 0 : o.isElement(x)) ? await (o.getScale == null ? void 0 : o.getScale(x)) || {\n    x: 1,\n    y: 1\n  } : {\n    x: 1,\n    y: 1\n  }, y = Ia(o.convertOffsetParentRelativeRectToViewportRelativeRect ? await o.convertOffsetParentRelativeRectToViewportRelativeRect({\n    elements: s,\n    rect: b,\n    offsetParent: x,\n    strategy: u\n  }) : b);\n  return {\n    top: (w.top - y.top + g.top) / m.y,\n    bottom: (y.bottom - w.bottom + g.bottom) / m.y,\n    left: (w.left - y.left + g.left) / m.x,\n    right: (y.right - w.right + g.right) / m.x\n  };\n}\nconst X1 = (e) => ({\n  name: \"arrow\",\n  options: e,\n  async fn(t) {\n    const {\n      x: n,\n      y: r,\n      placement: i,\n      rects: o,\n      platform: a,\n      elements: s,\n      middlewareData: u\n    } = t, {\n      element: c,\n      padding: f = 0\n    } = wn(e, t) || {};\n    if (c == null)\n      return {};\n    const l = jm(f), d = {\n      x: n,\n      y: r\n    }, p = rf(i), g = nf(p), h = await a.getDimensions(c), v = p === \"y\", w = v ? \"top\" : \"left\", b = v ? \"bottom\" : \"right\", x = v ? \"clientHeight\" : \"clientWidth\", m = o.reference[g] + o.reference[p] - d[p] - o.floating[g], y = d[p] - o.reference[p], S = await (a.getOffsetParent == null ? void 0 : a.getOffsetParent(c));\n    let $ = S ? S[x] : 0;\n    (!$ || !await (a.isElement == null ? void 0 : a.isElement(S))) && ($ = s.floating[x] || o.floating[g]);\n    const O = m / 2 - y / 2, T = $ / 2 - h[g] / 2 - 1, M = rn(l[w], T), E = rn(l[b], T), A = M, j = $ - h[g] - E, R = $ / 2 - h[g] / 2 + O, N = bc(A, R, j), k = !u.arrow && oi(i) != null && R !== N && o.reference[g] / 2 - (R < A ? M : E) - h[g] / 2 < 0, F = k ? R < A ? R - A : R - j : 0;\n    return {\n      [p]: d[p] + F,\n      data: {\n        [p]: N,\n        centerOffset: R - N - F,\n        ...k && {\n          alignmentOffset: F\n        }\n      },\n      reset: k\n    };\n  }\n}), Z1 = function(e) {\n  return e === void 0 && (e = {}), {\n    name: \"flip\",\n    options: e,\n    async fn(t) {\n      var n, r;\n      const {\n        placement: i,\n        middlewareData: o,\n        rects: a,\n        initialPlacement: s,\n        platform: u,\n        elements: c\n      } = t, {\n        mainAxis: f = !0,\n        crossAxis: l = !0,\n        fallbackPlacements: d,\n        fallbackStrategy: p = \"bestFit\",\n        fallbackAxisSideDirection: g = \"none\",\n        flipAlignment: h = !0,\n        ...v\n      } = wn(e, t);\n      if ((n = o.arrow) != null && n.alignmentOffset)\n        return {};\n      const w = xn(i), b = xn(s) === s, x = await (u.isRTL == null ? void 0 : u.isRTL(c.floating)), m = d || (b || !h ? [Ra(s)] : U1(s));\n      !d && g !== \"none\" && m.push(...q1(s, h, g, x));\n      const y = [s, ...m], S = await Zi(t, v), $ = [];\n      let O = ((r = o.flip) == null ? void 0 : r.overflows) || [];\n      if (f && $.push(S[w]), l) {\n        const A = W1(i, a, x);\n        $.push(S[A[0]], S[A[1]]);\n      }\n      if (O = [...O, {\n        placement: i,\n        overflows: $\n      }], !$.every((A) => A <= 0)) {\n        var T, M;\n        const A = (((T = o.flip) == null ? void 0 : T.index) || 0) + 1, j = y[A];\n        if (j)\n          return {\n            data: {\n              index: A,\n              overflows: O\n            },\n            reset: {\n              placement: j\n            }\n          };\n        let R = (M = O.filter((N) => N.overflows[0] <= 0).sort((N, k) => N.overflows[1] - k.overflows[1])[0]) == null ? void 0 : M.placement;\n        if (!R)\n          switch (p) {\n            case \"bestFit\": {\n              var E;\n              const N = (E = O.map((k) => [k.placement, k.overflows.filter((F) => F > 0).reduce((F, V) => F + V, 0)]).sort((k, F) => k[1] - F[1])[0]) == null ? void 0 : E[0];\n              N && (R = N);\n              break;\n            }\n            case \"initialPlacement\":\n              R = s;\n              break;\n          }\n        if (i !== R)\n          return {\n            reset: {\n              placement: R\n            }\n          };\n      }\n      return {};\n    }\n  };\n};\nfunction Yd(e, t) {\n  return {\n    top: e.top - t.height,\n    right: e.right - t.width,\n    bottom: e.bottom - t.height,\n    left: e.left - t.width\n  };\n}\nfunction Xd(e) {\n  return z1.some((t) => e[t] >= 0);\n}\nconst J1 = function(e) {\n  return e === void 0 && (e = {}), {\n    name: \"hide\",\n    options: e,\n    async fn(t) {\n      const {\n        rects: n\n      } = t, {\n        strategy: r = \"referenceHidden\",\n        ...i\n      } = wn(e, t);\n      switch (r) {\n        case \"referenceHidden\": {\n          const o = await Zi(t, {\n            ...i,\n            elementContext: \"reference\"\n          }), a = Yd(o, n.reference);\n          return {\n            data: {\n              referenceHiddenOffsets: a,\n              referenceHidden: Xd(a)\n            }\n          };\n        }\n        case \"escaped\": {\n          const o = await Zi(t, {\n            ...i,\n            altBoundary: !0\n          }), a = Yd(o, n.floating);\n          return {\n            data: {\n              escapedOffsets: a,\n              escaped: Xd(a)\n            }\n          };\n        }\n        default:\n          return {};\n      }\n    }\n  };\n};\nasync function Q1(e, t) {\n  const {\n    placement: n,\n    platform: r,\n    elements: i\n  } = e, o = await (r.isRTL == null ? void 0 : r.isRTL(i.floating)), a = xn(n), s = oi(n), u = ai(n) === \"y\", c = [\"left\", \"top\"].includes(a) ? -1 : 1, f = o && u ? -1 : 1, l = wn(t, e);\n  let {\n    mainAxis: d,\n    crossAxis: p,\n    alignmentAxis: g\n  } = typeof l == \"number\" ? {\n    mainAxis: l,\n    crossAxis: 0,\n    alignmentAxis: null\n  } : {\n    mainAxis: 0,\n    crossAxis: 0,\n    alignmentAxis: null,\n    ...l\n  };\n  return s && typeof g == \"number\" && (p = s === \"end\" ? g * -1 : g), u ? {\n    x: p * f,\n    y: d * c\n  } : {\n    x: d * c,\n    y: p * f\n  };\n}\nconst eS = function(e) {\n  return e === void 0 && (e = 0), {\n    name: \"offset\",\n    options: e,\n    async fn(t) {\n      var n, r;\n      const {\n        x: i,\n        y: o,\n        placement: a,\n        middlewareData: s\n      } = t, u = await Q1(t, e);\n      return a === ((n = s.offset) == null ? void 0 : n.placement) && (r = s.arrow) != null && r.alignmentOffset ? {} : {\n        x: i + u.x,\n        y: o + u.y,\n        data: {\n          ...u,\n          placement: a\n        }\n      };\n    }\n  };\n}, tS = function(e) {\n  return e === void 0 && (e = {}), {\n    name: \"shift\",\n    options: e,\n    async fn(t) {\n      const {\n        x: n,\n        y: r,\n        placement: i\n      } = t, {\n        mainAxis: o = !0,\n        crossAxis: a = !1,\n        limiter: s = {\n          fn: (v) => {\n            let {\n              x: w,\n              y: b\n            } = v;\n            return {\n              x: w,\n              y: b\n            };\n          }\n        },\n        ...u\n      } = wn(e, t), c = {\n        x: n,\n        y: r\n      }, f = await Zi(t, u), l = ai(xn(i)), d = tf(l);\n      let p = c[d], g = c[l];\n      if (o) {\n        const v = d === \"y\" ? \"top\" : \"left\", w = d === \"y\" ? \"bottom\" : \"right\", b = p + f[v], x = p - f[w];\n        p = bc(b, p, x);\n      }\n      if (a) {\n        const v = l === \"y\" ? \"top\" : \"left\", w = l === \"y\" ? \"bottom\" : \"right\", b = g + f[v], x = g - f[w];\n        g = bc(b, g, x);\n      }\n      const h = s.fn({\n        ...t,\n        [d]: p,\n        [l]: g\n      });\n      return {\n        ...h,\n        data: {\n          x: h.x - n,\n          y: h.y - r\n        }\n      };\n    }\n  };\n}, nS = function(e) {\n  return e === void 0 && (e = {}), {\n    options: e,\n    fn(t) {\n      const {\n        x: n,\n        y: r,\n        placement: i,\n        rects: o,\n        middlewareData: a\n      } = t, {\n        offset: s = 0,\n        mainAxis: u = !0,\n        crossAxis: c = !0\n      } = wn(e, t), f = {\n        x: n,\n        y: r\n      }, l = ai(i), d = tf(l);\n      let p = f[d], g = f[l];\n      const h = wn(s, t), v = typeof h == \"number\" ? {\n        mainAxis: h,\n        crossAxis: 0\n      } : {\n        mainAxis: 0,\n        crossAxis: 0,\n        ...h\n      };\n      if (u) {\n        const x = d === \"y\" ? \"height\" : \"width\", m = o.reference[d] - o.floating[x] + v.mainAxis, y = o.reference[d] + o.reference[x] - v.mainAxis;\n        p < m ? p = m : p > y && (p = y);\n      }\n      if (c) {\n        var w, b;\n        const x = d === \"y\" ? \"width\" : \"height\", m = [\"top\", \"left\"].includes(xn(i)), y = o.reference[l] - o.floating[x] + (m && ((w = a.offset) == null ? void 0 : w[l]) || 0) + (m ? 0 : v.crossAxis), S = o.reference[l] + o.reference[x] + (m ? 0 : ((b = a.offset) == null ? void 0 : b[l]) || 0) - (m ? v.crossAxis : 0);\n        g < y ? g = y : g > S && (g = S);\n      }\n      return {\n        [d]: p,\n        [l]: g\n      };\n    }\n  };\n}, rS = function(e) {\n  return e === void 0 && (e = {}), {\n    name: \"size\",\n    options: e,\n    async fn(t) {\n      const {\n        placement: n,\n        rects: r,\n        platform: i,\n        elements: o\n      } = t, {\n        apply: a = () => {\n        },\n        ...s\n      } = wn(e, t), u = await Zi(t, s), c = xn(n), f = oi(n), l = ai(n) === \"y\", {\n        width: d,\n        height: p\n      } = r.floating;\n      let g, h;\n      c === \"top\" || c === \"bottom\" ? (g = c, h = f === (await (i.isRTL == null ? void 0 : i.isRTL(o.floating)) ? \"start\" : \"end\") ? \"left\" : \"right\") : (h = c, g = f === \"end\" ? \"top\" : \"bottom\");\n      const v = p - u.top - u.bottom, w = d - u.left - u.right, b = rn(p - u[g], v), x = rn(d - u[h], w), m = !t.middlewareData.shift;\n      let y = b, S = x;\n      if (l ? S = f || m ? rn(x, w) : w : y = f || m ? rn(b, v) : v, m && !f) {\n        const O = xt(u.left, 0), T = xt(u.right, 0), M = xt(u.top, 0), E = xt(u.bottom, 0);\n        l ? S = d - 2 * (O !== 0 || T !== 0 ? O + T : xt(u.left, u.right)) : y = p - 2 * (M !== 0 || E !== 0 ? M + E : xt(u.top, u.bottom));\n      }\n      await a({\n        ...t,\n        availableWidth: S,\n        availableHeight: y\n      });\n      const $ = await i.getDimensions(o.floating);\n      return d !== $.width || p !== $.height ? {\n        reset: {\n          rects: !0\n        }\n      } : {};\n    }\n  };\n};\nfunction si(e) {\n  return km(e) ? (e.nodeName || \"\").toLowerCase() : \"#document\";\n}\nfunction Ot(e) {\n  var t;\n  return (e == null || (t = e.ownerDocument) == null ? void 0 : t.defaultView) || window;\n}\nfunction An(e) {\n  var t;\n  return (t = (km(e) ? e.ownerDocument : e.document) || window.document) == null ? void 0 : t.documentElement;\n}\nfunction km(e) {\n  return e instanceof Node || e instanceof Ot(e).Node;\n}\nfunction cn(e) {\n  return e instanceof Element || e instanceof Ot(e).Element;\n}\nfunction ln(e) {\n  return e instanceof HTMLElement || e instanceof Ot(e).HTMLElement;\n}\nfunction Zd(e) {\n  return typeof ShadowRoot > \"u\" ? !1 : e instanceof ShadowRoot || e instanceof Ot(e).ShadowRoot;\n}\nfunction Lo(e) {\n  const {\n    overflow: t,\n    overflowX: n,\n    overflowY: r,\n    display: i\n  } = Jt(e);\n  return /auto|scroll|overlay|hidden|clip/.test(t + r + n) && ![\"inline\", \"contents\"].includes(i);\n}\nfunction iS(e) {\n  return [\"table\", \"td\", \"th\"].includes(si(e));\n}\nfunction of(e) {\n  const t = af(), n = Jt(e);\n  return n.transform !== \"none\" || n.perspective !== \"none\" || (n.containerType ? n.containerType !== \"normal\" : !1) || !t && (n.backdropFilter ? n.backdropFilter !== \"none\" : !1) || !t && (n.filter ? n.filter !== \"none\" : !1) || [\"transform\", \"perspective\", \"filter\"].some((r) => (n.willChange || \"\").includes(r)) || [\"paint\", \"layout\", \"strict\", \"content\"].some((r) => (n.contain || \"\").includes(r));\n}\nfunction oS(e) {\n  let t = Vn(e);\n  for (; ln(t) && !Nr(t); ) {\n    if (of(t))\n      return t;\n    t = Vn(t);\n  }\n  return null;\n}\nfunction af() {\n  return typeof CSS > \"u\" || !CSS.supports ? !1 : CSS.supports(\"-webkit-backdrop-filter\", \"none\");\n}\nfunction Nr(e) {\n  return [\"html\", \"body\", \"#document\"].includes(si(e));\n}\nfunction Jt(e) {\n  return Ot(e).getComputedStyle(e);\n}\nfunction Rs(e) {\n  return cn(e) ? {\n    scrollLeft: e.scrollLeft,\n    scrollTop: e.scrollTop\n  } : {\n    scrollLeft: e.pageXOffset,\n    scrollTop: e.pageYOffset\n  };\n}\nfunction Vn(e) {\n  if (si(e) === \"html\")\n    return e;\n  const t = (\n    // Step into the shadow DOM of the parent of a slotted node.\n    e.assignedSlot || // DOM Element detected.\n    e.parentNode || // ShadowRoot detected.\n    Zd(e) && e.host || // Fallback.\n    An(e)\n  );\n  return Zd(t) ? t.host : t;\n}\nfunction Dm(e) {\n  const t = Vn(e);\n  return Nr(t) ? e.ownerDocument ? e.ownerDocument.body : e.body : ln(t) && Lo(t) ? t : Dm(t);\n}\nfunction Ji(e, t, n) {\n  var r;\n  t === void 0 && (t = []), n === void 0 && (n = !0);\n  const i = Dm(e), o = i === ((r = e.ownerDocument) == null ? void 0 : r.body), a = Ot(i);\n  return o ? t.concat(a, a.visualViewport || [], Lo(i) ? i : [], a.frameElement && n ? Ji(a.frameElement) : []) : t.concat(i, Ji(i, [], n));\n}\nfunction Nm(e) {\n  const t = Jt(e);\n  let n = parseFloat(t.width) || 0, r = parseFloat(t.height) || 0;\n  const i = ln(e), o = i ? e.offsetWidth : n, a = i ? e.offsetHeight : r, s = Ma(n) !== o || Ma(r) !== a;\n  return s && (n = o, r = a), {\n    width: n,\n    height: r,\n    $: s\n  };\n}\nfunction sf(e) {\n  return cn(e) ? e : e.contextElement;\n}\nfunction Tr(e) {\n  const t = sf(e);\n  if (!ln(t))\n    return zn(1);\n  const n = t.getBoundingClientRect(), {\n    width: r,\n    height: i,\n    $: o\n  } = Nm(t);\n  let a = (o ? Ma(n.width) : n.width) / r, s = (o ? Ma(n.height) : n.height) / i;\n  return (!a || !Number.isFinite(a)) && (a = 1), (!s || !Number.isFinite(s)) && (s = 1), {\n    x: a,\n    y: s\n  };\n}\nconst aS = /* @__PURE__ */ zn(0);\nfunction Fm(e) {\n  const t = Ot(e);\n  return !af() || !t.visualViewport ? aS : {\n    x: t.visualViewport.offsetLeft,\n    y: t.visualViewport.offsetTop\n  };\n}\nfunction sS(e, t, n) {\n  return t === void 0 && (t = !1), !n || t && n !== Ot(e) ? !1 : t;\n}\nfunction cr(e, t, n, r) {\n  t === void 0 && (t = !1), n === void 0 && (n = !1);\n  const i = e.getBoundingClientRect(), o = sf(e);\n  let a = zn(1);\n  t && (r ? cn(r) && (a = Tr(r)) : a = Tr(e));\n  const s = sS(o, n, r) ? Fm(o) : zn(0);\n  let u = (i.left + s.x) / a.x, c = (i.top + s.y) / a.y, f = i.width / a.x, l = i.height / a.y;\n  if (o) {\n    const d = Ot(o), p = r && cn(r) ? Ot(r) : r;\n    let g = d, h = g.frameElement;\n    for (; h && r && p !== g; ) {\n      const v = Tr(h), w = h.getBoundingClientRect(), b = Jt(h), x = w.left + (h.clientLeft + parseFloat(b.paddingLeft)) * v.x, m = w.top + (h.clientTop + parseFloat(b.paddingTop)) * v.y;\n      u *= v.x, c *= v.y, f *= v.x, l *= v.y, u += x, c += m, g = Ot(h), h = g.frameElement;\n    }\n  }\n  return Ia({\n    width: f,\n    height: l,\n    x: u,\n    y: c\n  });\n}\nconst uS = [\":popover-open\", \":modal\"];\nfunction uf(e) {\n  return uS.some((t) => {\n    try {\n      return e.matches(t);\n    } catch {\n      return !1;\n    }\n  });\n}\nfunction cS(e) {\n  let {\n    elements: t,\n    rect: n,\n    offsetParent: r,\n    strategy: i\n  } = e;\n  const o = i === \"fixed\", a = An(r), s = t ? uf(t.floating) : !1;\n  if (r === a || s && o)\n    return n;\n  let u = {\n    scrollLeft: 0,\n    scrollTop: 0\n  }, c = zn(1);\n  const f = zn(0), l = ln(r);\n  if ((l || !l && !o) && ((si(r) !== \"body\" || Lo(a)) && (u = Rs(r)), ln(r))) {\n    const d = cr(r);\n    c = Tr(r), f.x = d.x + r.clientLeft, f.y = d.y + r.clientTop;\n  }\n  return {\n    width: n.width * c.x,\n    height: n.height * c.y,\n    x: n.x * c.x - u.scrollLeft * c.x + f.x,\n    y: n.y * c.y - u.scrollTop * c.y + f.y\n  };\n}\nfunction lS(e) {\n  return Array.from(e.getClientRects());\n}\nfunction Lm(e) {\n  return cr(An(e)).left + Rs(e).scrollLeft;\n}\nfunction fS(e) {\n  const t = An(e), n = Rs(e), r = e.ownerDocument.body, i = xt(t.scrollWidth, t.clientWidth, r.scrollWidth, r.clientWidth), o = xt(t.scrollHeight, t.clientHeight, r.scrollHeight, r.clientHeight);\n  let a = -n.scrollLeft + Lm(e);\n  const s = -n.scrollTop;\n  return Jt(r).direction === \"rtl\" && (a += xt(t.clientWidth, r.clientWidth) - i), {\n    width: i,\n    height: o,\n    x: a,\n    y: s\n  };\n}\nfunction dS(e, t) {\n  const n = Ot(e), r = An(e), i = n.visualViewport;\n  let o = r.clientWidth, a = r.clientHeight, s = 0, u = 0;\n  if (i) {\n    o = i.width, a = i.height;\n    const c = af();\n    (!c || c && t === \"fixed\") && (s = i.offsetLeft, u = i.offsetTop);\n  }\n  return {\n    width: o,\n    height: a,\n    x: s,\n    y: u\n  };\n}\nfunction pS(e, t) {\n  const n = cr(e, !0, t === \"fixed\"), r = n.top + e.clientTop, i = n.left + e.clientLeft, o = ln(e) ? Tr(e) : zn(1), a = e.clientWidth * o.x, s = e.clientHeight * o.y, u = i * o.x, c = r * o.y;\n  return {\n    width: a,\n    height: s,\n    x: u,\n    y: c\n  };\n}\nfunction Jd(e, t, n) {\n  let r;\n  if (t === \"viewport\")\n    r = dS(e, n);\n  else if (t === \"document\")\n    r = fS(An(e));\n  else if (cn(t))\n    r = pS(t, n);\n  else {\n    const i = Fm(e);\n    r = {\n      ...t,\n      x: t.x - i.x,\n      y: t.y - i.y\n    };\n  }\n  return Ia(r);\n}\nfunction Bm(e, t) {\n  const n = Vn(e);\n  return n === t || !cn(n) || Nr(n) ? !1 : Jt(n).position === \"fixed\" || Bm(n, t);\n}\nfunction hS(e, t) {\n  const n = t.get(e);\n  if (n)\n    return n;\n  let r = Ji(e, [], !1).filter((s) => cn(s) && si(s) !== \"body\"), i = null;\n  const o = Jt(e).position === \"fixed\";\n  let a = o ? Vn(e) : e;\n  for (; cn(a) && !Nr(a); ) {\n    const s = Jt(a), u = of(a);\n    !u && s.position === \"fixed\" && (i = null), (o ? !u && !i : !u && s.position === \"static\" && !!i && [\"absolute\", \"fixed\"].includes(i.position) || Lo(a) && !u && Bm(e, a)) ? r = r.filter((f) => f !== a) : i = s, a = Vn(a);\n  }\n  return t.set(e, r), r;\n}\nfunction gS(e) {\n  let {\n    element: t,\n    boundary: n,\n    rootBoundary: r,\n    strategy: i\n  } = e;\n  const a = [...n === \"clippingAncestors\" ? uf(t) ? [] : hS(t, this._c) : [].concat(n), r], s = a[0], u = a.reduce((c, f) => {\n    const l = Jd(t, f, i);\n    return c.top = xt(l.top, c.top), c.right = rn(l.right, c.right), c.bottom = rn(l.bottom, c.bottom), c.left = xt(l.left, c.left), c;\n  }, Jd(t, s, i));\n  return {\n    width: u.right - u.left,\n    height: u.bottom - u.top,\n    x: u.left,\n    y: u.top\n  };\n}\nfunction vS(e) {\n  const {\n    width: t,\n    height: n\n  } = Nm(e);\n  return {\n    width: t,\n    height: n\n  };\n}\nfunction mS(e, t, n) {\n  const r = ln(t), i = An(t), o = n === \"fixed\", a = cr(e, !0, o, t);\n  let s = {\n    scrollLeft: 0,\n    scrollTop: 0\n  };\n  const u = zn(0);\n  if (r || !r && !o)\n    if ((si(t) !== \"body\" || Lo(i)) && (s = Rs(t)), r) {\n      const l = cr(t, !0, o, t);\n      u.x = l.x + t.clientLeft, u.y = l.y + t.clientTop;\n    } else\n      i && (u.x = Lm(i));\n  const c = a.left + s.scrollLeft - u.x, f = a.top + s.scrollTop - u.y;\n  return {\n    x: c,\n    y: f,\n    width: a.width,\n    height: a.height\n  };\n}\nfunction bu(e) {\n  return Jt(e).position === \"static\";\n}\nfunction Qd(e, t) {\n  return !ln(e) || Jt(e).position === \"fixed\" ? null : t ? t(e) : e.offsetParent;\n}\nfunction zm(e, t) {\n  const n = Ot(e);\n  if (uf(e))\n    return n;\n  if (!ln(e)) {\n    let i = Vn(e);\n    for (; i && !Nr(i); ) {\n      if (cn(i) && !bu(i))\n        return i;\n      i = Vn(i);\n    }\n    return n;\n  }\n  let r = Qd(e, t);\n  for (; r && iS(r) && bu(r); )\n    r = Qd(r, t);\n  return r && Nr(r) && bu(r) && !of(r) ? n : r || oS(e) || n;\n}\nconst yS = async function(e) {\n  const t = this.getOffsetParent || zm, n = this.getDimensions, r = await n(e.floating);\n  return {\n    reference: mS(e.reference, await t(e.floating), e.strategy),\n    floating: {\n      x: 0,\n      y: 0,\n      width: r.width,\n      height: r.height\n    }\n  };\n};\nfunction bS(e) {\n  return Jt(e).direction === \"rtl\";\n}\nconst wS = {\n  convertOffsetParentRelativeRectToViewportRelativeRect: cS,\n  getDocumentElement: An,\n  getClippingRect: gS,\n  getOffsetParent: zm,\n  getElementRects: yS,\n  getClientRects: lS,\n  getDimensions: vS,\n  getScale: Tr,\n  isElement: cn,\n  isRTL: bS\n};\nfunction xS(e, t) {\n  let n = null, r;\n  const i = An(e);\n  function o() {\n    var s;\n    clearTimeout(r), (s = n) == null || s.disconnect(), n = null;\n  }\n  function a(s, u) {\n    s === void 0 && (s = !1), u === void 0 && (u = 1), o();\n    const {\n      left: c,\n      top: f,\n      width: l,\n      height: d\n    } = e.getBoundingClientRect();\n    if (s || t(), !l || !d)\n      return;\n    const p = ra(f), g = ra(i.clientWidth - (c + l)), h = ra(i.clientHeight - (f + d)), v = ra(c), b = {\n      rootMargin: -p + \"px \" + -g + \"px \" + -h + \"px \" + -v + \"px\",\n      threshold: xt(0, rn(1, u)) || 1\n    };\n    let x = !0;\n    function m(y) {\n      const S = y[0].intersectionRatio;\n      if (S !== u) {\n        if (!x)\n          return a();\n        S ? a(!1, S) : r = setTimeout(() => {\n          a(!1, 1e-7);\n        }, 1e3);\n      }\n      x = !1;\n    }\n    try {\n      n = new IntersectionObserver(m, {\n        ...b,\n        // Handle <iframe>s\n        root: i.ownerDocument\n      });\n    } catch {\n      n = new IntersectionObserver(m, b);\n    }\n    n.observe(e);\n  }\n  return a(!0), o;\n}\nfunction SS(e, t, n, r) {\n  r === void 0 && (r = {});\n  const {\n    ancestorScroll: i = !0,\n    ancestorResize: o = !0,\n    elementResize: a = typeof ResizeObserver == \"function\",\n    layoutShift: s = typeof IntersectionObserver == \"function\",\n    animationFrame: u = !1\n  } = r, c = sf(e), f = i || o ? [...c ? Ji(c) : [], ...Ji(t)] : [];\n  f.forEach((w) => {\n    i && w.addEventListener(\"scroll\", n, {\n      passive: !0\n    }), o && w.addEventListener(\"resize\", n);\n  });\n  const l = c && s ? xS(c, n) : null;\n  let d = -1, p = null;\n  a && (p = new ResizeObserver((w) => {\n    let [b] = w;\n    b && b.target === c && p && (p.unobserve(t), cancelAnimationFrame(d), d = requestAnimationFrame(() => {\n      var x;\n      (x = p) == null || x.observe(t);\n    })), n();\n  }), c && !u && p.observe(c), p.observe(t));\n  let g, h = u ? cr(e) : null;\n  u && v();\n  function v() {\n    const w = cr(e);\n    h && (w.x !== h.x || w.y !== h.y || w.width !== h.width || w.height !== h.height) && n(), h = w, g = requestAnimationFrame(v);\n  }\n  return n(), () => {\n    var w;\n    f.forEach((b) => {\n      i && b.removeEventListener(\"scroll\", n), o && b.removeEventListener(\"resize\", n);\n    }), l == null || l(), (w = p) == null || w.disconnect(), p = null, u && cancelAnimationFrame(g);\n  };\n}\nconst $S = eS, OS = tS, _S = Z1, AS = rS, PS = J1, ep = X1, CS = nS, ES = (e, t, n) => {\n  const r = /* @__PURE__ */ new Map(), i = {\n    platform: wS,\n    ...n\n  }, o = {\n    ...i.platform,\n    _c: r\n  };\n  return Y1(e, t, {\n    ...i,\n    platform: o\n  });\n};\nvar Aa = typeof document < \"u\" ? react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect : react__WEBPACK_IMPORTED_MODULE_0__.useEffect;\nfunction ja(e, t) {\n  if (e === t)\n    return !0;\n  if (typeof e != typeof t)\n    return !1;\n  if (typeof e == \"function\" && e.toString() === t.toString())\n    return !0;\n  let n, r, i;\n  if (e && t && typeof e == \"object\") {\n    if (Array.isArray(e)) {\n      if (n = e.length, n !== t.length)\n        return !1;\n      for (r = n; r-- !== 0; )\n        if (!ja(e[r], t[r]))\n          return !1;\n      return !0;\n    }\n    if (i = Object.keys(e), n = i.length, n !== Object.keys(t).length)\n      return !1;\n    for (r = n; r-- !== 0; )\n      if (!{}.hasOwnProperty.call(t, i[r]))\n        return !1;\n    for (r = n; r-- !== 0; ) {\n      const o = i[r];\n      if (!(o === \"_owner\" && e.$$typeof) && !ja(e[o], t[o]))\n        return !1;\n    }\n    return !0;\n  }\n  return e !== e && t !== t;\n}\nfunction Vm(e) {\n  return typeof window > \"u\" ? 1 : (e.ownerDocument.defaultView || window).devicePixelRatio || 1;\n}\nfunction tp(e, t) {\n  const n = Vm(e);\n  return Math.round(t * n) / n;\n}\nfunction np(e) {\n  const t = react__WEBPACK_IMPORTED_MODULE_0__.useRef(e);\n  return Aa(() => {\n    t.current = e;\n  }), t;\n}\nfunction TS(e) {\n  e === void 0 && (e = {});\n  const {\n    placement: t = \"bottom\",\n    strategy: n = \"absolute\",\n    middleware: r = [],\n    platform: i,\n    elements: {\n      reference: o,\n      floating: a\n    } = {},\n    transform: s = !0,\n    whileElementsMounted: u,\n    open: c\n  } = e, [f, l] = react__WEBPACK_IMPORTED_MODULE_0__.useState({\n    x: 0,\n    y: 0,\n    strategy: n,\n    placement: t,\n    middlewareData: {},\n    isPositioned: !1\n  }), [d, p] = react__WEBPACK_IMPORTED_MODULE_0__.useState(r);\n  ja(d, r) || p(r);\n  const [g, h] = react__WEBPACK_IMPORTED_MODULE_0__.useState(null), [v, w] = react__WEBPACK_IMPORTED_MODULE_0__.useState(null), b = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((F) => {\n    F !== S.current && (S.current = F, h(F));\n  }, []), x = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((F) => {\n    F !== $.current && ($.current = F, w(F));\n  }, []), m = o || g, y = a || v, S = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null), $ = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null), O = react__WEBPACK_IMPORTED_MODULE_0__.useRef(f), T = u != null, M = np(u), E = np(i), A = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(() => {\n    if (!S.current || !$.current)\n      return;\n    const F = {\n      placement: t,\n      strategy: n,\n      middleware: d\n    };\n    E.current && (F.platform = E.current), ES(S.current, $.current, F).then((V) => {\n      const L = {\n        ...V,\n        isPositioned: !0\n      };\n      j.current && !ja(O.current, L) && (O.current = L, react_dom__WEBPACK_IMPORTED_MODULE_1__.flushSync(() => {\n        l(L);\n      }));\n    });\n  }, [d, t, n, E]);\n  Aa(() => {\n    c === !1 && O.current.isPositioned && (O.current.isPositioned = !1, l((F) => ({\n      ...F,\n      isPositioned: !1\n    })));\n  }, [c]);\n  const j = react__WEBPACK_IMPORTED_MODULE_0__.useRef(!1);\n  Aa(() => (j.current = !0, () => {\n    j.current = !1;\n  }), []), Aa(() => {\n    if (m && (S.current = m), y && ($.current = y), m && y) {\n      if (M.current)\n        return M.current(m, y, A);\n      A();\n    }\n  }, [m, y, A, M, T]);\n  const R = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => ({\n    reference: S,\n    floating: $,\n    setReference: b,\n    setFloating: x\n  }), [b, x]), N = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => ({\n    reference: m,\n    floating: y\n  }), [m, y]), k = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {\n    const F = {\n      position: n,\n      left: 0,\n      top: 0\n    };\n    if (!N.floating)\n      return F;\n    const V = tp(N.floating, f.x), L = tp(N.floating, f.y);\n    return s ? {\n      ...F,\n      transform: \"translate(\" + V + \"px, \" + L + \"px)\",\n      ...Vm(N.floating) >= 1.5 && {\n        willChange: \"transform\"\n      }\n    } : {\n      position: n,\n      left: V,\n      top: L\n    };\n  }, [n, s, N.floating, f.x, f.y]);\n  return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => ({\n    ...f,\n    update: A,\n    refs: R,\n    elements: N,\n    floatingStyles: k\n  }), [f, A, R, N, k]);\n}\nconst MS = (e) => {\n  function t(n) {\n    return {}.hasOwnProperty.call(n, \"current\");\n  }\n  return {\n    name: \"arrow\",\n    options: e,\n    fn(n) {\n      const {\n        element: r,\n        padding: i\n      } = typeof e == \"function\" ? e(n) : e;\n      return r && t(r) ? r.current != null ? ep({\n        element: r.current,\n        padding: i\n      }).fn(n) : {} : r ? ep({\n        element: r,\n        padding: i\n      }).fn(n) : {};\n    }\n  };\n}, RS = (e, t) => ({\n  ...$S(e),\n  options: [e, t]\n}), IS = (e, t) => ({\n  ...OS(e),\n  options: [e, t]\n}), jS = (e, t) => ({\n  ...CS(e),\n  options: [e, t]\n}), kS = (e, t) => ({\n  ..._S(e),\n  options: [e, t]\n}), DS = (e, t) => ({\n  ...AS(e),\n  options: [e, t]\n}), NS = (e, t) => ({\n  ...PS(e),\n  options: [e, t]\n}), FS = (e, t) => ({\n  ...MS(e),\n  options: [e, t]\n});\nfunction LS(e) {\n  const [t, n] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(void 0);\n  return Dr(() => {\n    if (e) {\n      n({\n        width: e.offsetWidth,\n        height: e.offsetHeight\n      });\n      const r = new ResizeObserver((i) => {\n        if (!Array.isArray(i) || !i.length)\n          return;\n        const o = i[0];\n        let a, s;\n        if (\"borderBoxSize\" in o) {\n          const u = o.borderBoxSize, c = Array.isArray(u) ? u[0] : u;\n          a = c.inlineSize, s = c.blockSize;\n        } else\n          a = e.offsetWidth, s = e.offsetHeight;\n        n({\n          width: a,\n          height: s\n        });\n      });\n      return r.observe(e, {\n        box: \"border-box\"\n      }), () => r.unobserve(e);\n    } else\n      n(void 0);\n  }, [\n    e\n  ]), t;\n}\nconst Gm = \"Popper\", [Wm, Um] = Fo(Gm), [BS, Hm] = Wm(Gm), zS = (e) => {\n  const { __scopePopper: t, children: n } = e, [r, i] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n  return /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(BS, {\n    scope: t,\n    anchor: r,\n    onAnchorChange: i\n  }, n);\n}, VS = \"PopperAnchor\", GS = /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)((e, t) => {\n  const { __scopePopper: n, virtualRef: r, ...i } = e, o = Hm(VS, n), a = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null), s = _t(t, a);\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    o.onAnchorChange((r == null ? void 0 : r.current) || a.current);\n  }), r ? null : /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(Ft.div, ce({}, i, {\n    ref: s\n  }));\n}), qm = \"PopperContent\", [WS, XU] = Wm(qm), US = /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)((e, t) => {\n  var n, r, i, o, a, s, u, c;\n  const { __scopePopper: f, side: l = \"bottom\", sideOffset: d = 0, align: p = \"center\", alignOffset: g = 0, arrowPadding: h = 0, avoidCollisions: v = !0, collisionBoundary: w = [], collisionPadding: b = 0, sticky: x = \"partial\", hideWhenDetached: m = !1, updatePositionStrategy: y = \"optimized\", onPlaced: S, ...$ } = e, O = Hm(qm, f), [T, M] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null), E = _t(\n    t,\n    (xe) => M(xe)\n  ), [A, j] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null), R = LS(A), N = (n = R == null ? void 0 : R.width) !== null && n !== void 0 ? n : 0, k = (r = R == null ? void 0 : R.height) !== null && r !== void 0 ? r : 0, F = l + (p !== \"center\" ? \"-\" + p : \"\"), V = typeof b == \"number\" ? b : {\n    top: 0,\n    right: 0,\n    bottom: 0,\n    left: 0,\n    ...b\n  }, L = Array.isArray(w) ? w : [\n    w\n  ], I = L.length > 0, D = {\n    padding: V,\n    boundary: L.filter(HS),\n    // with `strategy: 'fixed'`, this is the only way to get it to respect boundaries\n    altBoundary: I\n  }, { refs: G, floatingStyles: q, placement: J, isPositioned: ne, middlewareData: te } = TS({\n    // default to `fixed` strategy so users don't have to pick and we also avoid focus scroll issues\n    strategy: \"fixed\",\n    placement: F,\n    whileElementsMounted: (...xe) => SS(...xe, {\n      animationFrame: y === \"always\"\n    }),\n    elements: {\n      reference: O.anchor\n    },\n    middleware: [\n      RS({\n        mainAxis: d + k,\n        alignmentAxis: g\n      }),\n      v && IS({\n        mainAxis: !0,\n        crossAxis: !1,\n        limiter: x === \"partial\" ? jS() : void 0,\n        ...D\n      }),\n      v && kS({\n        ...D\n      }),\n      DS({\n        ...D,\n        apply: ({ elements: xe, rects: Ee, availableWidth: Ze, availableHeight: dt }) => {\n          const { width: zt, height: Vt } = Ee.reference, rt = xe.floating.style;\n          rt.setProperty(\"--radix-popper-available-width\", `${Ze}px`), rt.setProperty(\"--radix-popper-available-height\", `${dt}px`), rt.setProperty(\"--radix-popper-anchor-width\", `${zt}px`), rt.setProperty(\"--radix-popper-anchor-height\", `${Vt}px`);\n        }\n      }),\n      A && FS({\n        element: A,\n        padding: h\n      }),\n      qS({\n        arrowWidth: N,\n        arrowHeight: k\n      }),\n      m && NS({\n        strategy: \"referenceHidden\",\n        ...D\n      })\n    ]\n  }), [ee, ie] = Km(J), B = un(S);\n  Dr(() => {\n    ne && (B == null || B());\n  }, [\n    ne,\n    B\n  ]);\n  const U = (i = te.arrow) === null || i === void 0 ? void 0 : i.x, re = (o = te.arrow) === null || o === void 0 ? void 0 : o.y, C = ((a = te.arrow) === null || a === void 0 ? void 0 : a.centerOffset) !== 0, [ge, le] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)();\n  return Dr(() => {\n    T && le(window.getComputedStyle(T).zIndex);\n  }, [\n    T\n  ]), /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"div\", {\n    ref: G.setFloating,\n    \"data-radix-popper-content-wrapper\": \"\",\n    style: {\n      ...q,\n      transform: ne ? q.transform : \"translate(0, -200%)\",\n      // keep off the page when measuring\n      minWidth: \"max-content\",\n      zIndex: ge,\n      \"--radix-popper-transform-origin\": [\n        (s = te.transformOrigin) === null || s === void 0 ? void 0 : s.x,\n        (u = te.transformOrigin) === null || u === void 0 ? void 0 : u.y\n      ].join(\" \")\n    },\n    dir: e.dir\n  }, /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(WS, {\n    scope: f,\n    placedSide: ee,\n    onArrowChange: j,\n    arrowX: U,\n    arrowY: re,\n    shouldHideArrow: C\n  }, /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(Ft.div, ce({\n    \"data-side\": ee,\n    \"data-align\": ie\n  }, $, {\n    ref: E,\n    style: {\n      ...$.style,\n      // if the PopperContent hasn't been placed yet (not all measurements done)\n      // we prevent animations so that users's animation don't kick in too early referring wrong sides\n      animation: ne ? void 0 : \"none\",\n      // hide the content if using the hide middleware and should be hidden\n      opacity: (c = te.hide) !== null && c !== void 0 && c.referenceHidden ? 0 : void 0\n    }\n  }))));\n});\nfunction HS(e) {\n  return e !== null;\n}\nconst qS = (e) => ({\n  name: \"transformOrigin\",\n  options: e,\n  fn(t) {\n    var n, r, i, o, a;\n    const { placement: s, rects: u, middlewareData: c } = t, l = ((n = c.arrow) === null || n === void 0 ? void 0 : n.centerOffset) !== 0, d = l ? 0 : e.arrowWidth, p = l ? 0 : e.arrowHeight, [g, h] = Km(s), v = {\n      start: \"0%\",\n      center: \"50%\",\n      end: \"100%\"\n    }[h], w = ((r = (i = c.arrow) === null || i === void 0 ? void 0 : i.x) !== null && r !== void 0 ? r : 0) + d / 2, b = ((o = (a = c.arrow) === null || a === void 0 ? void 0 : a.y) !== null && o !== void 0 ? o : 0) + p / 2;\n    let x = \"\", m = \"\";\n    return g === \"bottom\" ? (x = l ? v : `${w}px`, m = `${-p}px`) : g === \"top\" ? (x = l ? v : `${w}px`, m = `${u.floating.height + p}px`) : g === \"right\" ? (x = `${-p}px`, m = l ? v : `${b}px`) : g === \"left\" && (x = `${u.floating.width + p}px`, m = l ? v : `${b}px`), {\n      data: {\n        x,\n        y: m\n      }\n    };\n  }\n});\nfunction Km(e) {\n  const [t, n = \"center\"] = e.split(\"-\");\n  return [\n    t,\n    n\n  ];\n}\nconst KS = zS, YS = GS, XS = US, ZS = /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)((e, t) => {\n  var n;\n  const { container: r = globalThis == null || (n = globalThis.document) === null || n === void 0 ? void 0 : n.body, ...i } = e;\n  return r ? /* @__PURE__ */ react_dom__WEBPACK_IMPORTED_MODULE_1__.createPortal(/* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(Ft.div, ce({}, i, {\n    ref: t\n  })), r) : null;\n});\nfunction JS(e, t) {\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useReducer)((n, r) => {\n    const i = t[n][r];\n    return i ?? n;\n  }, e);\n}\nconst Bo = (e) => {\n  const { present: t, children: n } = e, r = QS(t), i = typeof n == \"function\" ? n({\n    present: r.isPresent\n  }) : react__WEBPACK_IMPORTED_MODULE_0__.Children.only(n), o = _t(r.ref, i.ref);\n  return typeof n == \"function\" || r.isPresent ? /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.cloneElement)(i, {\n    ref: o\n  }) : null;\n};\nBo.displayName = \"Presence\";\nfunction QS(e) {\n  const [t, n] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(), r = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)({}), i = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(e), o = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(\"none\"), a = e ? \"mounted\" : \"unmounted\", [s, u] = JS(a, {\n    mounted: {\n      UNMOUNT: \"unmounted\",\n      ANIMATION_OUT: \"unmountSuspended\"\n    },\n    unmountSuspended: {\n      MOUNT: \"mounted\",\n      ANIMATION_END: \"unmounted\"\n    },\n    unmounted: {\n      MOUNT: \"mounted\"\n    }\n  });\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    const c = ia(r.current);\n    o.current = s === \"mounted\" ? c : \"none\";\n  }, [\n    s\n  ]), Dr(() => {\n    const c = r.current, f = i.current;\n    if (f !== e) {\n      const d = o.current, p = ia(c);\n      e ? u(\"MOUNT\") : p === \"none\" || (c == null ? void 0 : c.display) === \"none\" ? u(\"UNMOUNT\") : u(f && d !== p ? \"ANIMATION_OUT\" : \"UNMOUNT\"), i.current = e;\n    }\n  }, [\n    e,\n    u\n  ]), Dr(() => {\n    if (t) {\n      const c = (l) => {\n        const p = ia(r.current).includes(l.animationName);\n        l.target === t && p && (0,react_dom__WEBPACK_IMPORTED_MODULE_1__.flushSync)(\n          () => u(\"ANIMATION_END\")\n        );\n      }, f = (l) => {\n        l.target === t && (o.current = ia(r.current));\n      };\n      return t.addEventListener(\"animationstart\", f), t.addEventListener(\"animationcancel\", c), t.addEventListener(\"animationend\", c), () => {\n        t.removeEventListener(\"animationstart\", f), t.removeEventListener(\"animationcancel\", c), t.removeEventListener(\"animationend\", c);\n      };\n    } else\n      u(\"ANIMATION_END\");\n  }, [\n    t,\n    u\n  ]), {\n    isPresent: [\n      \"mounted\",\n      \"unmountSuspended\"\n    ].includes(s),\n    ref: (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((c) => {\n      c && (r.current = getComputedStyle(c)), n(c);\n    }, [])\n  };\n}\nfunction ia(e) {\n  return (e == null ? void 0 : e.animationName) || \"none\";\n}\nconst wu = \"rovingFocusGroup.onEntryFocus\", e$ = {\n  bubbles: !1,\n  cancelable: !0\n}, cf = \"RovingFocusGroup\", [xc, Ym, t$] = Tm(cf), [n$, Xm] = Fo(cf, [\n  t$\n]), [r$, i$] = n$(cf), o$ = /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)((e, t) => /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(xc.Provider, {\n  scope: e.__scopeRovingFocusGroup\n}, /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(xc.Slot, {\n  scope: e.__scopeRovingFocusGroup\n}, /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(a$, ce({}, e, {\n  ref: t\n}))))), a$ = /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)((e, t) => {\n  const { __scopeRovingFocusGroup: n, orientation: r, loop: i = !1, dir: o, currentTabStopId: a, defaultCurrentTabStopId: s, onCurrentTabStopIdChange: u, onEntryFocus: c, ...f } = e, l = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null), d = _t(t, l), p = Mm(o), [g = null, h] = Cm({\n    prop: a,\n    defaultProp: s,\n    onChange: u\n  }), [v, w] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(!1), b = un(c), x = Ym(n), m = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(!1), [y, S] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(0);\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    const $ = l.current;\n    if ($)\n      return $.addEventListener(wu, b), () => $.removeEventListener(wu, b);\n  }, [\n    b\n  ]), /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(r$, {\n    scope: n,\n    orientation: r,\n    dir: p,\n    loop: i,\n    currentTabStopId: g,\n    onItemFocus: (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n      ($) => h($),\n      [\n        h\n      ]\n    ),\n    onItemShiftTab: (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n      () => w(!0),\n      []\n    ),\n    onFocusableItemAdd: (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n      () => S(\n        ($) => $ + 1\n      ),\n      []\n    ),\n    onFocusableItemRemove: (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n      () => S(\n        ($) => $ - 1\n      ),\n      []\n    )\n  }, /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(Ft.div, ce({\n    tabIndex: v || y === 0 ? -1 : 0,\n    \"data-orientation\": r\n  }, f, {\n    ref: d,\n    style: {\n      outline: \"none\",\n      ...e.style\n    },\n    onMouseDown: we(e.onMouseDown, () => {\n      m.current = !0;\n    }),\n    onFocus: we(e.onFocus, ($) => {\n      const O = !m.current;\n      if ($.target === $.currentTarget && O && !v) {\n        const T = new CustomEvent(wu, e$);\n        if ($.currentTarget.dispatchEvent(T), !T.defaultPrevented) {\n          const M = x().filter(\n            (N) => N.focusable\n          ), E = M.find(\n            (N) => N.active\n          ), A = M.find(\n            (N) => N.id === g\n          ), R = [\n            E,\n            A,\n            ...M\n          ].filter(Boolean).map(\n            (N) => N.ref.current\n          );\n          Zm(R);\n        }\n      }\n      m.current = !1;\n    }),\n    onBlur: we(\n      e.onBlur,\n      () => w(!1)\n    )\n  })));\n}), s$ = \"RovingFocusGroupItem\", u$ = /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)((e, t) => {\n  const { __scopeRovingFocusGroup: n, focusable: r = !0, active: i = !1, tabStopId: o, ...a } = e, s = yc(), u = o || s, c = i$(s$, n), f = c.currentTabStopId === u, l = Ym(n), { onFocusableItemAdd: d, onFocusableItemRemove: p } = c;\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    if (r)\n      return d(), () => p();\n  }, [\n    r,\n    d,\n    p\n  ]), /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(xc.ItemSlot, {\n    scope: n,\n    id: u,\n    focusable: r,\n    active: i\n  }, /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(Ft.span, ce({\n    tabIndex: f ? 0 : -1,\n    \"data-orientation\": c.orientation\n  }, a, {\n    ref: t,\n    onMouseDown: we(e.onMouseDown, (g) => {\n      r ? c.onItemFocus(u) : g.preventDefault();\n    }),\n    onFocus: we(\n      e.onFocus,\n      () => c.onItemFocus(u)\n    ),\n    onKeyDown: we(e.onKeyDown, (g) => {\n      if (g.key === \"Tab\" && g.shiftKey) {\n        c.onItemShiftTab();\n        return;\n      }\n      if (g.target !== g.currentTarget)\n        return;\n      const h = f$(g, c.orientation, c.dir);\n      if (h !== void 0) {\n        g.preventDefault();\n        let w = l().filter(\n          (b) => b.focusable\n        ).map(\n          (b) => b.ref.current\n        );\n        if (h === \"last\")\n          w.reverse();\n        else if (h === \"prev\" || h === \"next\") {\n          h === \"prev\" && w.reverse();\n          const b = w.indexOf(g.currentTarget);\n          w = c.loop ? d$(w, b + 1) : w.slice(b + 1);\n        }\n        setTimeout(\n          () => Zm(w)\n        );\n      }\n    })\n  })));\n}), c$ = {\n  ArrowLeft: \"prev\",\n  ArrowUp: \"prev\",\n  ArrowRight: \"next\",\n  ArrowDown: \"next\",\n  PageUp: \"first\",\n  Home: \"first\",\n  PageDown: \"last\",\n  End: \"last\"\n};\nfunction l$(e, t) {\n  return t !== \"rtl\" ? e : e === \"ArrowLeft\" ? \"ArrowRight\" : e === \"ArrowRight\" ? \"ArrowLeft\" : e;\n}\nfunction f$(e, t, n) {\n  const r = l$(e.key, n);\n  if (!(t === \"vertical\" && [\n    \"ArrowLeft\",\n    \"ArrowRight\"\n  ].includes(r)) && !(t === \"horizontal\" && [\n    \"ArrowUp\",\n    \"ArrowDown\"\n  ].includes(r)))\n    return c$[r];\n}\nfunction Zm(e) {\n  const t = document.activeElement;\n  for (const n of e)\n    if (n === t || (n.focus(), document.activeElement !== t))\n      return;\n}\nfunction d$(e, t) {\n  return e.map(\n    (n, r) => e[(t + r) % e.length]\n  );\n}\nconst p$ = o$, h$ = u$;\nvar g$ = function(e) {\n  if (typeof document > \"u\")\n    return null;\n  var t = Array.isArray(e) ? e[0] : e;\n  return t.ownerDocument.body;\n}, xr = /* @__PURE__ */ new WeakMap(), oa = /* @__PURE__ */ new WeakMap(), aa = {}, xu = 0, Jm = function(e) {\n  return e && (e.host || Jm(e.parentNode));\n}, v$ = function(e, t) {\n  return t.map(function(n) {\n    if (e.contains(n))\n      return n;\n    var r = Jm(n);\n    return r && e.contains(r) ? r : (console.error(\"aria-hidden\", n, \"in not contained inside\", e, \". Doing nothing\"), null);\n  }).filter(function(n) {\n    return !!n;\n  });\n}, m$ = function(e, t, n, r) {\n  var i = v$(t, Array.isArray(e) ? e : [e]);\n  aa[n] || (aa[n] = /* @__PURE__ */ new WeakMap());\n  var o = aa[n], a = [], s = /* @__PURE__ */ new Set(), u = new Set(i), c = function(l) {\n    !l || s.has(l) || (s.add(l), c(l.parentNode));\n  };\n  i.forEach(c);\n  var f = function(l) {\n    !l || u.has(l) || Array.prototype.forEach.call(l.children, function(d) {\n      if (s.has(d))\n        f(d);\n      else\n        try {\n          var p = d.getAttribute(r), g = p !== null && p !== \"false\", h = (xr.get(d) || 0) + 1, v = (o.get(d) || 0) + 1;\n          xr.set(d, h), o.set(d, v), a.push(d), h === 1 && g && oa.set(d, !0), v === 1 && d.setAttribute(n, \"true\"), g || d.setAttribute(r, \"true\");\n        } catch (w) {\n          console.error(\"aria-hidden: cannot operate on \", d, w);\n        }\n    });\n  };\n  return f(t), s.clear(), xu++, function() {\n    a.forEach(function(l) {\n      var d = xr.get(l) - 1, p = o.get(l) - 1;\n      xr.set(l, d), o.set(l, p), d || (oa.has(l) || l.removeAttribute(r), oa.delete(l)), p || l.removeAttribute(n);\n    }), xu--, xu || (xr = /* @__PURE__ */ new WeakMap(), xr = /* @__PURE__ */ new WeakMap(), oa = /* @__PURE__ */ new WeakMap(), aa = {});\n  };\n}, y$ = function(e, t, n) {\n  n === void 0 && (n = \"data-aria-hidden\");\n  var r = Array.from(Array.isArray(e) ? e : [e]), i = g$(e);\n  return i ? (r.push.apply(r, Array.from(i.querySelectorAll(\"[aria-live]\"))), m$(r, i, n, \"aria-hidden\")) : function() {\n    return null;\n  };\n}, nn = function() {\n  return nn = Object.assign || function(t) {\n    for (var n, r = 1, i = arguments.length; r < i; r++) {\n      n = arguments[r];\n      for (var o in n)\n        Object.prototype.hasOwnProperty.call(n, o) && (t[o] = n[o]);\n    }\n    return t;\n  }, nn.apply(this, arguments);\n};\nfunction Qm(e, t) {\n  var n = {};\n  for (var r in e)\n    Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);\n  if (e != null && typeof Object.getOwnPropertySymbols == \"function\")\n    for (var i = 0, r = Object.getOwnPropertySymbols(e); i < r.length; i++)\n      t.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[i]) && (n[r[i]] = e[r[i]]);\n  return n;\n}\nfunction b$(e, t, n) {\n  if (n || arguments.length === 2)\n    for (var r = 0, i = t.length, o; r < i; r++)\n      (o || !(r in t)) && (o || (o = Array.prototype.slice.call(t, 0, r)), o[r] = t[r]);\n  return e.concat(o || Array.prototype.slice.call(t));\n}\nvar Pa = \"right-scroll-bar-position\", Ca = \"width-before-scroll-bar\", w$ = \"with-scroll-bars-hidden\", x$ = \"--removed-body-scroll-bar-size\";\nfunction Su(e, t) {\n  return typeof e == \"function\" ? e(t) : e && (e.current = t), e;\n}\nfunction S$(e, t) {\n  var n = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(function() {\n    return {\n      // value\n      value: e,\n      // last callback\n      callback: t,\n      // \"memoized\" public interface\n      facade: {\n        get current() {\n          return n.value;\n        },\n        set current(r) {\n          var i = n.value;\n          i !== r && (n.value = r, n.callback(r, i));\n        }\n      }\n    };\n  })[0];\n  return n.callback = t, n.facade;\n}\nvar $$ = typeof window < \"u\" ? react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect : react__WEBPACK_IMPORTED_MODULE_0__.useEffect, rp = /* @__PURE__ */ new WeakMap();\nfunction O$(e, t) {\n  var n = S$(null, function(r) {\n    return e.forEach(function(i) {\n      return Su(i, r);\n    });\n  });\n  return $$(function() {\n    var r = rp.get(n);\n    if (r) {\n      var i = new Set(r), o = new Set(e), a = n.current;\n      i.forEach(function(s) {\n        o.has(s) || Su(s, null);\n      }), o.forEach(function(s) {\n        i.has(s) || Su(s, a);\n      });\n    }\n    rp.set(n, e);\n  }, [e]), n;\n}\nfunction _$(e) {\n  return e;\n}\nfunction A$(e, t) {\n  t === void 0 && (t = _$);\n  var n = [], r = !1, i = {\n    read: function() {\n      if (r)\n        throw new Error(\"Sidecar: could not `read` from an `assigned` medium. `read` could be used only with `useMedium`.\");\n      return n.length ? n[n.length - 1] : e;\n    },\n    useMedium: function(o) {\n      var a = t(o, r);\n      return n.push(a), function() {\n        n = n.filter(function(s) {\n          return s !== a;\n        });\n      };\n    },\n    assignSyncMedium: function(o) {\n      for (r = !0; n.length; ) {\n        var a = n;\n        n = [], a.forEach(o);\n      }\n      n = {\n        push: function(s) {\n          return o(s);\n        },\n        filter: function() {\n          return n;\n        }\n      };\n    },\n    assignMedium: function(o) {\n      r = !0;\n      var a = [];\n      if (n.length) {\n        var s = n;\n        n = [], s.forEach(o), a = n;\n      }\n      var u = function() {\n        var f = a;\n        a = [], f.forEach(o);\n      }, c = function() {\n        return Promise.resolve().then(u);\n      };\n      c(), n = {\n        push: function(f) {\n          a.push(f), c();\n        },\n        filter: function(f) {\n          return a = a.filter(f), n;\n        }\n      };\n    }\n  };\n  return i;\n}\nfunction P$(e) {\n  e === void 0 && (e = {});\n  var t = A$(null);\n  return t.options = nn({ async: !0, ssr: !1 }, e), t;\n}\nvar ey = function(e) {\n  var t = e.sideCar, n = Qm(e, [\"sideCar\"]);\n  if (!t)\n    throw new Error(\"Sidecar: please provide `sideCar` property to import the right car\");\n  var r = t.read();\n  if (!r)\n    throw new Error(\"Sidecar medium not found\");\n  return react__WEBPACK_IMPORTED_MODULE_0__.createElement(r, nn({}, n));\n};\ney.isSideCarExport = !0;\nfunction C$(e, t) {\n  return e.useMedium(t), ey;\n}\nvar ty = P$(), $u = function() {\n}, Is = react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(function(e, t) {\n  var n = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null), r = react__WEBPACK_IMPORTED_MODULE_0__.useState({\n    onScrollCapture: $u,\n    onWheelCapture: $u,\n    onTouchMoveCapture: $u\n  }), i = r[0], o = r[1], a = e.forwardProps, s = e.children, u = e.className, c = e.removeScrollBar, f = e.enabled, l = e.shards, d = e.sideCar, p = e.noIsolation, g = e.inert, h = e.allowPinchZoom, v = e.as, w = v === void 0 ? \"div\" : v, b = Qm(e, [\"forwardProps\", \"children\", \"className\", \"removeScrollBar\", \"enabled\", \"shards\", \"sideCar\", \"noIsolation\", \"inert\", \"allowPinchZoom\", \"as\"]), x = d, m = O$([n, t]), y = nn(nn({}, b), i);\n  return react__WEBPACK_IMPORTED_MODULE_0__.createElement(\n    react__WEBPACK_IMPORTED_MODULE_0__.Fragment,\n    null,\n    f && react__WEBPACK_IMPORTED_MODULE_0__.createElement(x, { sideCar: ty, removeScrollBar: c, shards: l, noIsolation: p, inert: g, setCallbacks: o, allowPinchZoom: !!h, lockRef: n }),\n    a ? react__WEBPACK_IMPORTED_MODULE_0__.cloneElement(react__WEBPACK_IMPORTED_MODULE_0__.Children.only(s), nn(nn({}, y), { ref: m })) : react__WEBPACK_IMPORTED_MODULE_0__.createElement(w, nn({}, y, { className: u, ref: m }), s)\n  );\n});\nIs.defaultProps = {\n  enabled: !0,\n  removeScrollBar: !0,\n  inert: !1\n};\nIs.classNames = {\n  fullWidth: Ca,\n  zeroRight: Pa\n};\nvar E$ = function() {\n  if (true)\n    return __webpack_require__.nc;\n};\nfunction T$() {\n  if (!document)\n    return null;\n  var e = document.createElement(\"style\");\n  e.type = \"text/css\";\n  var t = E$();\n  return t && e.setAttribute(\"nonce\", t), e;\n}\nfunction M$(e, t) {\n  e.styleSheet ? e.styleSheet.cssText = t : e.appendChild(document.createTextNode(t));\n}\nfunction R$(e) {\n  var t = document.head || document.getElementsByTagName(\"head\")[0];\n  t.appendChild(e);\n}\nvar I$ = function() {\n  var e = 0, t = null;\n  return {\n    add: function(n) {\n      e == 0 && (t = T$()) && (M$(t, n), R$(t)), e++;\n    },\n    remove: function() {\n      e--, !e && t && (t.parentNode && t.parentNode.removeChild(t), t = null);\n    }\n  };\n}, j$ = function() {\n  var e = I$();\n  return function(t, n) {\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(function() {\n      return e.add(t), function() {\n        e.remove();\n      };\n    }, [t && n]);\n  };\n}, ny = function() {\n  var e = j$(), t = function(n) {\n    var r = n.styles, i = n.dynamic;\n    return e(r, i), null;\n  };\n  return t;\n}, k$ = {\n  left: 0,\n  top: 0,\n  right: 0,\n  gap: 0\n}, Ou = function(e) {\n  return parseInt(e || \"\", 10) || 0;\n}, D$ = function(e) {\n  var t = window.getComputedStyle(document.body), n = t[e === \"padding\" ? \"paddingLeft\" : \"marginLeft\"], r = t[e === \"padding\" ? \"paddingTop\" : \"marginTop\"], i = t[e === \"padding\" ? \"paddingRight\" : \"marginRight\"];\n  return [Ou(n), Ou(r), Ou(i)];\n}, N$ = function(e) {\n  if (e === void 0 && (e = \"margin\"), typeof window > \"u\")\n    return k$;\n  var t = D$(e), n = document.documentElement.clientWidth, r = window.innerWidth;\n  return {\n    left: t[0],\n    top: t[1],\n    right: t[2],\n    gap: Math.max(0, r - n + t[2] - t[0])\n  };\n}, F$ = ny(), Mr = \"data-scroll-locked\", L$ = function(e, t, n, r) {\n  var i = e.left, o = e.top, a = e.right, s = e.gap;\n  return n === void 0 && (n = \"margin\"), `\n  .`.concat(w$, ` {\n   overflow: hidden `).concat(r, `;\n   padding-right: `).concat(s, \"px \").concat(r, `;\n  }\n  body[`).concat(Mr, `] {\n    overflow: hidden `).concat(r, `;\n    overscroll-behavior: contain;\n    `).concat([\n    t && \"position: relative \".concat(r, \";\"),\n    n === \"margin\" && `\n    padding-left: `.concat(i, `px;\n    padding-top: `).concat(o, `px;\n    padding-right: `).concat(a, `px;\n    margin-left:0;\n    margin-top:0;\n    margin-right: `).concat(s, \"px \").concat(r, `;\n    `),\n    n === \"padding\" && \"padding-right: \".concat(s, \"px \").concat(r, \";\")\n  ].filter(Boolean).join(\"\"), `\n  }\n  \n  .`).concat(Pa, ` {\n    right: `).concat(s, \"px \").concat(r, `;\n  }\n  \n  .`).concat(Ca, ` {\n    margin-right: `).concat(s, \"px \").concat(r, `;\n  }\n  \n  .`).concat(Pa, \" .\").concat(Pa, ` {\n    right: 0 `).concat(r, `;\n  }\n  \n  .`).concat(Ca, \" .\").concat(Ca, ` {\n    margin-right: 0 `).concat(r, `;\n  }\n  \n  body[`).concat(Mr, `] {\n    `).concat(x$, \": \").concat(s, `px;\n  }\n`);\n}, ip = function() {\n  var e = parseInt(document.body.getAttribute(Mr) || \"0\", 10);\n  return isFinite(e) ? e : 0;\n}, B$ = function() {\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(function() {\n    return document.body.setAttribute(Mr, (ip() + 1).toString()), function() {\n      var e = ip() - 1;\n      e <= 0 ? document.body.removeAttribute(Mr) : document.body.setAttribute(Mr, e.toString());\n    };\n  }, []);\n}, z$ = function(e) {\n  var t = e.noRelative, n = e.noImportant, r = e.gapMode, i = r === void 0 ? \"margin\" : r;\n  B$();\n  var o = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(function() {\n    return N$(i);\n  }, [i]);\n  return react__WEBPACK_IMPORTED_MODULE_0__.createElement(F$, { styles: L$(o, !t, i, n ? \"\" : \"!important\") });\n}, Sc = !1;\nif (typeof window < \"u\")\n  try {\n    var sa = Object.defineProperty({}, \"passive\", {\n      get: function() {\n        return Sc = !0, !0;\n      }\n    });\n    window.addEventListener(\"test\", sa, sa), window.removeEventListener(\"test\", sa, sa);\n  } catch {\n    Sc = !1;\n  }\nvar Sr = Sc ? { passive: !1 } : !1, V$ = function(e) {\n  return e.tagName === \"TEXTAREA\";\n}, ry = function(e, t) {\n  var n = window.getComputedStyle(e);\n  return (\n    // not-not-scrollable\n    n[t] !== \"hidden\" && // contains scroll inside self\n    !(n.overflowY === n.overflowX && !V$(e) && n[t] === \"visible\")\n  );\n}, G$ = function(e) {\n  return ry(e, \"overflowY\");\n}, W$ = function(e) {\n  return ry(e, \"overflowX\");\n}, op = function(e, t) {\n  var n = t;\n  do {\n    typeof ShadowRoot < \"u\" && n instanceof ShadowRoot && (n = n.host);\n    var r = iy(e, n);\n    if (r) {\n      var i = oy(e, n), o = i[1], a = i[2];\n      if (o > a)\n        return !0;\n    }\n    n = n.parentNode;\n  } while (n && n !== document.body);\n  return !1;\n}, U$ = function(e) {\n  var t = e.scrollTop, n = e.scrollHeight, r = e.clientHeight;\n  return [\n    t,\n    n,\n    r\n  ];\n}, H$ = function(e) {\n  var t = e.scrollLeft, n = e.scrollWidth, r = e.clientWidth;\n  return [\n    t,\n    n,\n    r\n  ];\n}, iy = function(e, t) {\n  return e === \"v\" ? G$(t) : W$(t);\n}, oy = function(e, t) {\n  return e === \"v\" ? U$(t) : H$(t);\n}, q$ = function(e, t) {\n  return e === \"h\" && t === \"rtl\" ? -1 : 1;\n}, K$ = function(e, t, n, r, i) {\n  var o = q$(e, window.getComputedStyle(t).direction), a = o * r, s = n.target, u = t.contains(s), c = !1, f = a > 0, l = 0, d = 0;\n  do {\n    var p = oy(e, s), g = p[0], h = p[1], v = p[2], w = h - v - o * g;\n    (g || w) && iy(e, s) && (l += w, d += g), s = s.parentNode;\n  } while (\n    // portaled content\n    !u && s !== document.body || // self content\n    u && (t.contains(s) || t === s)\n  );\n  return (f && (l === 0 || !i) || !f && (d === 0 || !i)) && (c = !0), c;\n}, ua = function(e) {\n  return \"changedTouches\" in e ? [e.changedTouches[0].clientX, e.changedTouches[0].clientY] : [0, 0];\n}, ap = function(e) {\n  return [e.deltaX, e.deltaY];\n}, sp = function(e) {\n  return e && \"current\" in e ? e.current : e;\n}, Y$ = function(e, t) {\n  return e[0] === t[0] && e[1] === t[1];\n}, X$ = function(e) {\n  return `\n  .block-interactivity-`.concat(e, ` {pointer-events: none;}\n  .allow-interactivity-`).concat(e, ` {pointer-events: all;}\n`);\n}, Z$ = 0, $r = [];\nfunction J$(e) {\n  var t = react__WEBPACK_IMPORTED_MODULE_0__.useRef([]), n = react__WEBPACK_IMPORTED_MODULE_0__.useRef([0, 0]), r = react__WEBPACK_IMPORTED_MODULE_0__.useRef(), i = react__WEBPACK_IMPORTED_MODULE_0__.useState(Z$++)[0], o = react__WEBPACK_IMPORTED_MODULE_0__.useState(function() {\n    return ny();\n  })[0], a = react__WEBPACK_IMPORTED_MODULE_0__.useRef(e);\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(function() {\n    a.current = e;\n  }, [e]), react__WEBPACK_IMPORTED_MODULE_0__.useEffect(function() {\n    if (e.inert) {\n      document.body.classList.add(\"block-interactivity-\".concat(i));\n      var h = b$([e.lockRef.current], (e.shards || []).map(sp), !0).filter(Boolean);\n      return h.forEach(function(v) {\n        return v.classList.add(\"allow-interactivity-\".concat(i));\n      }), function() {\n        document.body.classList.remove(\"block-interactivity-\".concat(i)), h.forEach(function(v) {\n          return v.classList.remove(\"allow-interactivity-\".concat(i));\n        });\n      };\n    }\n  }, [e.inert, e.lockRef.current, e.shards]);\n  var s = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(function(h, v) {\n    if (\"touches\" in h && h.touches.length === 2)\n      return !a.current.allowPinchZoom;\n    var w = ua(h), b = n.current, x = \"deltaX\" in h ? h.deltaX : b[0] - w[0], m = \"deltaY\" in h ? h.deltaY : b[1] - w[1], y, S = h.target, $ = Math.abs(x) > Math.abs(m) ? \"h\" : \"v\";\n    if (\"touches\" in h && $ === \"h\" && S.type === \"range\")\n      return !1;\n    var O = op($, S);\n    if (!O)\n      return !0;\n    if (O ? y = $ : (y = $ === \"v\" ? \"h\" : \"v\", O = op($, S)), !O)\n      return !1;\n    if (!r.current && \"changedTouches\" in h && (x || m) && (r.current = y), !y)\n      return !0;\n    var T = r.current || y;\n    return K$(T, v, h, T === \"h\" ? x : m, !0);\n  }, []), u = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(function(h) {\n    var v = h;\n    if (!(!$r.length || $r[$r.length - 1] !== o)) {\n      var w = \"deltaY\" in v ? ap(v) : ua(v), b = t.current.filter(function(y) {\n        return y.name === v.type && y.target === v.target && Y$(y.delta, w);\n      })[0];\n      if (b && b.should) {\n        v.cancelable && v.preventDefault();\n        return;\n      }\n      if (!b) {\n        var x = (a.current.shards || []).map(sp).filter(Boolean).filter(function(y) {\n          return y.contains(v.target);\n        }), m = x.length > 0 ? s(v, x[0]) : !a.current.noIsolation;\n        m && v.cancelable && v.preventDefault();\n      }\n    }\n  }, []), c = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(function(h, v, w, b) {\n    var x = { name: h, delta: v, target: w, should: b };\n    t.current.push(x), setTimeout(function() {\n      t.current = t.current.filter(function(m) {\n        return m !== x;\n      });\n    }, 1);\n  }, []), f = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(function(h) {\n    n.current = ua(h), r.current = void 0;\n  }, []), l = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(function(h) {\n    c(h.type, ap(h), h.target, s(h, e.lockRef.current));\n  }, []), d = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(function(h) {\n    c(h.type, ua(h), h.target, s(h, e.lockRef.current));\n  }, []);\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(function() {\n    return $r.push(o), e.setCallbacks({\n      onScrollCapture: l,\n      onWheelCapture: l,\n      onTouchMoveCapture: d\n    }), document.addEventListener(\"wheel\", u, Sr), document.addEventListener(\"touchmove\", u, Sr), document.addEventListener(\"touchstart\", f, Sr), function() {\n      $r = $r.filter(function(h) {\n        return h !== o;\n      }), document.removeEventListener(\"wheel\", u, Sr), document.removeEventListener(\"touchmove\", u, Sr), document.removeEventListener(\"touchstart\", f, Sr);\n    };\n  }, []);\n  var p = e.removeScrollBar, g = e.inert;\n  return react__WEBPACK_IMPORTED_MODULE_0__.createElement(\n    react__WEBPACK_IMPORTED_MODULE_0__.Fragment,\n    null,\n    g ? react__WEBPACK_IMPORTED_MODULE_0__.createElement(o, { styles: X$(i) }) : null,\n    p ? react__WEBPACK_IMPORTED_MODULE_0__.createElement(z$, { gapMode: \"margin\" }) : null\n  );\n}\nconst Q$ = C$(ty, J$);\nvar ay = react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(function(e, t) {\n  return react__WEBPACK_IMPORTED_MODULE_0__.createElement(Is, nn({}, e, { ref: t, sideCar: Q$ }));\n});\nay.classNames = Is.classNames;\nconst $c = [\n  \"Enter\",\n  \" \"\n], eO = [\n  \"ArrowDown\",\n  \"PageUp\",\n  \"Home\"\n], sy = [\n  \"ArrowUp\",\n  \"PageDown\",\n  \"End\"\n], tO = [\n  ...eO,\n  ...sy\n], nO = {\n  ltr: [\n    ...$c,\n    \"ArrowRight\"\n  ],\n  rtl: [\n    ...$c,\n    \"ArrowLeft\"\n  ]\n}, rO = {\n  ltr: [\n    \"ArrowLeft\"\n  ],\n  rtl: [\n    \"ArrowRight\"\n  ]\n}, js = \"Menu\", [Qi, iO, oO] = Tm(js), [hr, uy] = Fo(js, [\n  oO,\n  Um,\n  Xm\n]), lf = Um(), cy = Xm(), [aO, gr] = hr(js), [sO, zo] = hr(js), uO = (e) => {\n  const { __scopeMenu: t, open: n = !1, children: r, dir: i, onOpenChange: o, modal: a = !0 } = e, s = lf(t), [u, c] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null), f = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(!1), l = un(o), d = Mm(i);\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    const p = () => {\n      f.current = !0, document.addEventListener(\"pointerdown\", g, {\n        capture: !0,\n        once: !0\n      }), document.addEventListener(\"pointermove\", g, {\n        capture: !0,\n        once: !0\n      });\n    }, g = () => f.current = !1;\n    return document.addEventListener(\"keydown\", p, {\n      capture: !0\n    }), () => {\n      document.removeEventListener(\"keydown\", p, {\n        capture: !0\n      }), document.removeEventListener(\"pointerdown\", g, {\n        capture: !0\n      }), document.removeEventListener(\"pointermove\", g, {\n        capture: !0\n      });\n    };\n  }, []), /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(KS, s, /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(aO, {\n    scope: t,\n    open: n,\n    onOpenChange: l,\n    content: u,\n    onContentChange: c\n  }, /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(sO, {\n    scope: t,\n    onClose: (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n      () => l(!1),\n      [\n        l\n      ]\n    ),\n    isUsingKeyboardRef: f,\n    dir: d,\n    modal: a\n  }, r)));\n}, ly = /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)((e, t) => {\n  const { __scopeMenu: n, ...r } = e, i = lf(n);\n  return /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(YS, ce({}, i, r, {\n    ref: t\n  }));\n}), fy = \"MenuPortal\", [cO, dy] = hr(fy, {\n  forceMount: void 0\n}), lO = (e) => {\n  const { __scopeMenu: t, forceMount: n, children: r, container: i } = e, o = gr(fy, t);\n  return /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(cO, {\n    scope: t,\n    forceMount: n\n  }, /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(Bo, {\n    present: n || o.open\n  }, /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(ZS, {\n    asChild: !0,\n    container: i\n  }, r)));\n}, Yt = \"MenuContent\", [fO, ff] = hr(Yt), dO = /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)((e, t) => {\n  const n = dy(Yt, e.__scopeMenu), { forceMount: r = n.forceMount, ...i } = e, o = gr(Yt, e.__scopeMenu), a = zo(Yt, e.__scopeMenu);\n  return /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(Qi.Provider, {\n    scope: e.__scopeMenu\n  }, /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(Bo, {\n    present: r || o.open\n  }, /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(Qi.Slot, {\n    scope: e.__scopeMenu\n  }, a.modal ? /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(pO, ce({}, i, {\n    ref: t\n  })) : /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(hO, ce({}, i, {\n    ref: t\n  })))));\n}), pO = /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)((e, t) => {\n  const n = gr(Yt, e.__scopeMenu), r = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null), i = _t(t, r);\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    const o = r.current;\n    if (o)\n      return y$(o);\n  }, []), /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(df, ce({}, e, {\n    ref: i,\n    trapFocus: n.open,\n    disableOutsidePointerEvents: n.open,\n    disableOutsideScroll: !0,\n    onFocusOutside: we(\n      e.onFocusOutside,\n      (o) => o.preventDefault(),\n      {\n        checkForDefaultPrevented: !1\n      }\n    ),\n    onDismiss: () => n.onOpenChange(!1)\n  }));\n}), hO = /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)((e, t) => {\n  const n = gr(Yt, e.__scopeMenu);\n  return /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(df, ce({}, e, {\n    ref: t,\n    trapFocus: !1,\n    disableOutsidePointerEvents: !1,\n    disableOutsideScroll: !1,\n    onDismiss: () => n.onOpenChange(!1)\n  }));\n}), df = /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)((e, t) => {\n  const { __scopeMenu: n, loop: r = !1, trapFocus: i, onOpenAutoFocus: o, onCloseAutoFocus: a, disableOutsidePointerEvents: s, onEntryFocus: u, onEscapeKeyDown: c, onPointerDownOutside: f, onFocusOutside: l, onInteractOutside: d, onDismiss: p, disableOutsideScroll: g, ...h } = e, v = gr(Yt, n), w = zo(Yt, n), b = lf(n), x = cy(n), m = iO(n), [y, S] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null), $ = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null), O = _t(t, $, v.onContentChange), T = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(0), M = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(\"\"), E = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(0), A = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null), j = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(\"right\"), R = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(0), N = g ? ay : react__WEBPACK_IMPORTED_MODULE_0__.Fragment, k = g ? {\n    as: kr,\n    allowPinchZoom: !0\n  } : void 0, F = (L) => {\n    var I, D;\n    const G = M.current + L, q = m().filter(\n      (B) => !B.disabled\n    ), J = document.activeElement, ne = (I = q.find(\n      (B) => B.ref.current === J\n    )) === null || I === void 0 ? void 0 : I.textValue, te = q.map(\n      (B) => B.textValue\n    ), ee = TO(te, G, ne), ie = (D = q.find(\n      (B) => B.textValue === ee\n    )) === null || D === void 0 ? void 0 : D.ref.current;\n    (function B(U) {\n      M.current = U, window.clearTimeout(T.current), U !== \"\" && (T.current = window.setTimeout(\n        () => B(\"\"),\n        1e3\n      ));\n    })(G), ie && setTimeout(\n      () => ie.focus()\n    );\n  };\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => () => window.clearTimeout(T.current), []), M1();\n  const V = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((L) => {\n    var I, D;\n    return j.current === ((I = A.current) === null || I === void 0 ? void 0 : I.side) && RO(L, (D = A.current) === null || D === void 0 ? void 0 : D.area);\n  }, []);\n  return /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(fO, {\n    scope: n,\n    searchRef: M,\n    onItemEnter: (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((L) => {\n      V(L) && L.preventDefault();\n    }, [\n      V\n    ]),\n    onItemLeave: (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((L) => {\n      var I;\n      V(L) || ((I = $.current) === null || I === void 0 || I.focus(), S(null));\n    }, [\n      V\n    ]),\n    onTriggerLeave: (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((L) => {\n      V(L) && L.preventDefault();\n    }, [\n      V\n    ]),\n    pointerGraceTimerRef: E,\n    onPointerGraceIntentChange: (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((L) => {\n      A.current = L;\n    }, [])\n  }, /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(N, k, /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(R1, {\n    asChild: !0,\n    trapped: i,\n    onMountAutoFocus: we(o, (L) => {\n      var I;\n      L.preventDefault(), (I = $.current) === null || I === void 0 || I.focus();\n    }),\n    onUnmountAutoFocus: a\n  }, /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(C1, {\n    asChild: !0,\n    disableOutsidePointerEvents: s,\n    onEscapeKeyDown: c,\n    onPointerDownOutside: f,\n    onFocusOutside: l,\n    onInteractOutside: d,\n    onDismiss: p\n  }, /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(p$, ce({\n    asChild: !0\n  }, x, {\n    dir: w.dir,\n    orientation: \"vertical\",\n    loop: r,\n    currentTabStopId: y,\n    onCurrentTabStopIdChange: S,\n    onEntryFocus: we(u, (L) => {\n      w.isUsingKeyboardRef.current || L.preventDefault();\n    })\n  }), /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(XS, ce({\n    role: \"menu\",\n    \"aria-orientation\": \"vertical\",\n    \"data-state\": my(v.open),\n    \"data-radix-menu-content\": \"\",\n    dir: w.dir\n  }, b, h, {\n    ref: O,\n    style: {\n      outline: \"none\",\n      ...h.style\n    },\n    onKeyDown: we(h.onKeyDown, (L) => {\n      const D = L.target.closest(\"[data-radix-menu-content]\") === L.currentTarget, G = L.ctrlKey || L.altKey || L.metaKey, q = L.key.length === 1;\n      D && (L.key === \"Tab\" && L.preventDefault(), !G && q && F(L.key));\n      const J = $.current;\n      if (L.target !== J || !tO.includes(L.key))\n        return;\n      L.preventDefault();\n      const te = m().filter(\n        (ee) => !ee.disabled\n      ).map(\n        (ee) => ee.ref.current\n      );\n      sy.includes(L.key) && te.reverse(), CO(te);\n    }),\n    onBlur: we(e.onBlur, (L) => {\n      L.currentTarget.contains(L.target) || (window.clearTimeout(T.current), M.current = \"\");\n    }),\n    onPointerMove: we(e.onPointerMove, eo((L) => {\n      const I = L.target, D = R.current !== L.clientX;\n      if (L.currentTarget.contains(I) && D) {\n        const G = L.clientX > R.current ? \"right\" : \"left\";\n        j.current = G, R.current = L.clientX;\n      }\n    }))\n  })))))));\n}), gO = /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)((e, t) => {\n  const { __scopeMenu: n, ...r } = e;\n  return /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(Ft.div, ce({}, r, {\n    ref: t\n  }));\n}), Oc = \"MenuItem\", up = \"menu.itemSelect\", pf = /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)((e, t) => {\n  const { disabled: n = !1, onSelect: r, ...i } = e, o = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null), a = zo(Oc, e.__scopeMenu), s = ff(Oc, e.__scopeMenu), u = _t(t, o), c = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(!1), f = () => {\n    const l = o.current;\n    if (!n && l) {\n      const d = new CustomEvent(up, {\n        bubbles: !0,\n        cancelable: !0\n      });\n      l.addEventListener(\n        up,\n        (p) => r == null ? void 0 : r(p),\n        {\n          once: !0\n        }\n      ), Em(l, d), d.defaultPrevented ? c.current = !1 : a.onClose();\n    }\n  };\n  return /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(py, ce({}, i, {\n    ref: u,\n    disabled: n,\n    onClick: we(e.onClick, f),\n    onPointerDown: (l) => {\n      var d;\n      (d = e.onPointerDown) === null || d === void 0 || d.call(e, l), c.current = !0;\n    },\n    onPointerUp: we(e.onPointerUp, (l) => {\n      var d;\n      c.current || (d = l.currentTarget) === null || d === void 0 || d.click();\n    }),\n    onKeyDown: we(e.onKeyDown, (l) => {\n      const d = s.searchRef.current !== \"\";\n      n || d && l.key === \" \" || $c.includes(l.key) && (l.currentTarget.click(), l.preventDefault());\n    })\n  }));\n}), py = /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)((e, t) => {\n  const { __scopeMenu: n, disabled: r = !1, textValue: i, ...o } = e, a = ff(Oc, n), s = cy(n), u = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null), c = _t(t, u), [f, l] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(!1), [d, p] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(\"\");\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    const g = u.current;\n    if (g) {\n      var h;\n      p(((h = g.textContent) !== null && h !== void 0 ? h : \"\").trim());\n    }\n  }, [\n    o.children\n  ]), /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(Qi.ItemSlot, {\n    scope: n,\n    disabled: r,\n    textValue: i ?? d\n  }, /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(h$, ce({\n    asChild: !0\n  }, s, {\n    focusable: !r\n  }), /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(Ft.div, ce({\n    role: \"menuitem\",\n    \"data-highlighted\": f ? \"\" : void 0,\n    \"aria-disabled\": r || void 0,\n    \"data-disabled\": r ? \"\" : void 0\n  }, o, {\n    ref: c,\n    onPointerMove: we(e.onPointerMove, eo((g) => {\n      r ? a.onItemLeave(g) : (a.onItemEnter(g), g.defaultPrevented || g.currentTarget.focus());\n    })),\n    onPointerLeave: we(e.onPointerLeave, eo(\n      (g) => a.onItemLeave(g)\n    )),\n    onFocus: we(\n      e.onFocus,\n      () => l(!0)\n    ),\n    onBlur: we(\n      e.onBlur,\n      () => l(!1)\n    )\n  }))));\n}), vO = /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)((e, t) => {\n  const { checked: n = !1, onCheckedChange: r, ...i } = e;\n  return /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(gy, {\n    scope: e.__scopeMenu,\n    checked: n\n  }, /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(pf, ce({\n    role: \"menuitemcheckbox\",\n    \"aria-checked\": ka(n) ? \"mixed\" : n\n  }, i, {\n    ref: t,\n    \"data-state\": hf(n),\n    onSelect: we(\n      i.onSelect,\n      () => r == null ? void 0 : r(ka(n) ? !0 : !n),\n      {\n        checkForDefaultPrevented: !1\n      }\n    )\n  })));\n}), mO = \"MenuRadioGroup\", [ZU, yO] = hr(mO, {\n  value: void 0,\n  onValueChange: () => {\n  }\n}), bO = \"MenuRadioItem\", wO = /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)((e, t) => {\n  const { value: n, ...r } = e, i = yO(bO, e.__scopeMenu), o = n === i.value;\n  return /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(gy, {\n    scope: e.__scopeMenu,\n    checked: o\n  }, /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(pf, ce({\n    role: \"menuitemradio\",\n    \"aria-checked\": o\n  }, r, {\n    ref: t,\n    \"data-state\": hf(o),\n    onSelect: we(r.onSelect, () => {\n      var a;\n      return (a = i.onValueChange) === null || a === void 0 ? void 0 : a.call(i, n);\n    }, {\n      checkForDefaultPrevented: !1\n    })\n  })));\n}), hy = \"MenuItemIndicator\", [gy, xO] = hr(hy, {\n  checked: !1\n}), SO = /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)((e, t) => {\n  const { __scopeMenu: n, forceMount: r, ...i } = e, o = xO(hy, n);\n  return /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(Bo, {\n    present: r || ka(o.checked) || o.checked === !0\n  }, /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(Ft.span, ce({}, i, {\n    ref: t,\n    \"data-state\": hf(o.checked)\n  })));\n}), $O = /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)((e, t) => {\n  const { __scopeMenu: n, ...r } = e;\n  return /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(Ft.div, ce({\n    role: \"separator\",\n    \"aria-orientation\": \"horizontal\"\n  }, r, {\n    ref: t\n  }));\n}), OO = \"MenuSub\", [JU, vy] = hr(OO), ca = \"MenuSubTrigger\", _O = /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)((e, t) => {\n  const n = gr(ca, e.__scopeMenu), r = zo(ca, e.__scopeMenu), i = vy(ca, e.__scopeMenu), o = ff(ca, e.__scopeMenu), a = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null), { pointerGraceTimerRef: s, onPointerGraceIntentChange: u } = o, c = {\n    __scopeMenu: e.__scopeMenu\n  }, f = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(() => {\n    a.current && window.clearTimeout(a.current), a.current = null;\n  }, []);\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(\n    () => f,\n    [\n      f\n    ]\n  ), (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    const l = s.current;\n    return () => {\n      window.clearTimeout(l), u(null);\n    };\n  }, [\n    s,\n    u\n  ]), /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(ly, ce({\n    asChild: !0\n  }, c), /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(py, ce({\n    id: i.triggerId,\n    \"aria-haspopup\": \"menu\",\n    \"aria-expanded\": n.open,\n    \"aria-controls\": i.contentId,\n    \"data-state\": my(n.open)\n  }, e, {\n    ref: Ms(t, i.onTriggerChange),\n    onClick: (l) => {\n      var d;\n      (d = e.onClick) === null || d === void 0 || d.call(e, l), !(e.disabled || l.defaultPrevented) && (l.currentTarget.focus(), n.open || n.onOpenChange(!0));\n    },\n    onPointerMove: we(e.onPointerMove, eo((l) => {\n      o.onItemEnter(l), !l.defaultPrevented && !e.disabled && !n.open && !a.current && (o.onPointerGraceIntentChange(null), a.current = window.setTimeout(() => {\n        n.onOpenChange(!0), f();\n      }, 100));\n    })),\n    onPointerLeave: we(e.onPointerLeave, eo((l) => {\n      var d;\n      f();\n      const p = (d = n.content) === null || d === void 0 ? void 0 : d.getBoundingClientRect();\n      if (p) {\n        var g;\n        const h = (g = n.content) === null || g === void 0 ? void 0 : g.dataset.side, v = h === \"right\", w = v ? -5 : 5, b = p[v ? \"left\" : \"right\"], x = p[v ? \"right\" : \"left\"];\n        o.onPointerGraceIntentChange({\n          area: [\n            // consistently within polygon bounds\n            {\n              x: l.clientX + w,\n              y: l.clientY\n            },\n            {\n              x: b,\n              y: p.top\n            },\n            {\n              x,\n              y: p.top\n            },\n            {\n              x,\n              y: p.bottom\n            },\n            {\n              x: b,\n              y: p.bottom\n            }\n          ],\n          side: h\n        }), window.clearTimeout(s.current), s.current = window.setTimeout(\n          () => o.onPointerGraceIntentChange(null),\n          300\n        );\n      } else {\n        if (o.onTriggerLeave(l), l.defaultPrevented)\n          return;\n        o.onPointerGraceIntentChange(null);\n      }\n    })),\n    onKeyDown: we(e.onKeyDown, (l) => {\n      const d = o.searchRef.current !== \"\";\n      if (!(e.disabled || d && l.key === \" \") && nO[r.dir].includes(l.key)) {\n        var p;\n        n.onOpenChange(!0), (p = n.content) === null || p === void 0 || p.focus(), l.preventDefault();\n      }\n    })\n  })));\n}), AO = \"MenuSubContent\", PO = /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)((e, t) => {\n  const n = dy(Yt, e.__scopeMenu), { forceMount: r = n.forceMount, ...i } = e, o = gr(Yt, e.__scopeMenu), a = zo(Yt, e.__scopeMenu), s = vy(AO, e.__scopeMenu), u = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null), c = _t(t, u);\n  return /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(Qi.Provider, {\n    scope: e.__scopeMenu\n  }, /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(Bo, {\n    present: r || o.open\n  }, /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(Qi.Slot, {\n    scope: e.__scopeMenu\n  }, /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(df, ce({\n    id: s.contentId,\n    \"aria-labelledby\": s.triggerId\n  }, i, {\n    ref: c,\n    align: \"start\",\n    side: a.dir === \"rtl\" ? \"left\" : \"right\",\n    disableOutsidePointerEvents: !1,\n    disableOutsideScroll: !1,\n    trapFocus: !1,\n    onOpenAutoFocus: (f) => {\n      var l;\n      a.isUsingKeyboardRef.current && ((l = u.current) === null || l === void 0 || l.focus()), f.preventDefault();\n    },\n    onCloseAutoFocus: (f) => f.preventDefault(),\n    onFocusOutside: we(e.onFocusOutside, (f) => {\n      f.target !== s.trigger && o.onOpenChange(!1);\n    }),\n    onEscapeKeyDown: we(e.onEscapeKeyDown, (f) => {\n      a.onClose(), f.preventDefault();\n    }),\n    onKeyDown: we(e.onKeyDown, (f) => {\n      const l = f.currentTarget.contains(f.target), d = rO[a.dir].includes(f.key);\n      if (l && d) {\n        var p;\n        o.onOpenChange(!1), (p = s.trigger) === null || p === void 0 || p.focus(), f.preventDefault();\n      }\n    })\n  })))));\n});\nfunction my(e) {\n  return e ? \"open\" : \"closed\";\n}\nfunction ka(e) {\n  return e === \"indeterminate\";\n}\nfunction hf(e) {\n  return ka(e) ? \"indeterminate\" : e ? \"checked\" : \"unchecked\";\n}\nfunction CO(e) {\n  const t = document.activeElement;\n  for (const n of e)\n    if (n === t || (n.focus(), document.activeElement !== t))\n      return;\n}\nfunction EO(e, t) {\n  return e.map(\n    (n, r) => e[(t + r) % e.length]\n  );\n}\nfunction TO(e, t, n) {\n  const i = t.length > 1 && Array.from(t).every(\n    (c) => c === t[0]\n  ) ? t[0] : t, o = n ? e.indexOf(n) : -1;\n  let a = EO(e, Math.max(o, 0));\n  i.length === 1 && (a = a.filter(\n    (c) => c !== n\n  ));\n  const u = a.find(\n    (c) => c.toLowerCase().startsWith(i.toLowerCase())\n  );\n  return u !== n ? u : void 0;\n}\nfunction MO(e, t) {\n  const { x: n, y: r } = e;\n  let i = !1;\n  for (let o = 0, a = t.length - 1; o < t.length; a = o++) {\n    const s = t[o].x, u = t[o].y, c = t[a].x, f = t[a].y;\n    u > r != f > r && n < (c - s) * (r - u) / (f - u) + s && (i = !i);\n  }\n  return i;\n}\nfunction RO(e, t) {\n  if (!t)\n    return !1;\n  const n = {\n    x: e.clientX,\n    y: e.clientY\n  };\n  return MO(n, t);\n}\nfunction eo(e) {\n  return (t) => t.pointerType === \"mouse\" ? e(t) : void 0;\n}\nconst IO = uO, jO = ly, kO = lO, DO = dO, NO = gO, FO = pf, LO = vO, BO = wO, zO = SO, VO = $O, GO = _O, WO = PO, yy = \"DropdownMenu\", [UO, QU] = Fo(yy, [\n  uy\n]), Lt = uy(), [HO, by] = UO(yy), qO = (e) => {\n  const { __scopeDropdownMenu: t, children: n, dir: r, open: i, defaultOpen: o, onOpenChange: a, modal: s = !0 } = e, u = Lt(t), c = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null), [f = !1, l] = Cm({\n    prop: i,\n    defaultProp: o,\n    onChange: a\n  });\n  return /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(HO, {\n    scope: t,\n    triggerId: yc(),\n    triggerRef: c,\n    contentId: yc(),\n    open: f,\n    onOpenChange: l,\n    onOpenToggle: (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n      () => l(\n        (d) => !d\n      ),\n      [\n        l\n      ]\n    ),\n    modal: s\n  }, /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(IO, ce({}, u, {\n    open: f,\n    onOpenChange: l,\n    dir: r,\n    modal: s\n  }), n));\n}, KO = \"DropdownMenuTrigger\", YO = /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)((e, t) => {\n  const { __scopeDropdownMenu: n, disabled: r = !1, ...i } = e, o = by(KO, n), a = Lt(n);\n  return /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(jO, ce({\n    asChild: !0\n  }, a), /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(Ft.button, ce({\n    type: \"button\",\n    id: o.triggerId,\n    \"aria-haspopup\": \"menu\",\n    \"aria-expanded\": o.open,\n    \"aria-controls\": o.open ? o.contentId : void 0,\n    \"data-state\": o.open ? \"open\" : \"closed\",\n    \"data-disabled\": r ? \"\" : void 0,\n    disabled: r\n  }, i, {\n    ref: Ms(t, o.triggerRef),\n    onPointerDown: we(e.onPointerDown, (s) => {\n      !r && s.button === 0 && s.ctrlKey === !1 && (o.onOpenToggle(), o.open || s.preventDefault());\n    }),\n    onKeyDown: we(e.onKeyDown, (s) => {\n      r || ([\n        \"Enter\",\n        \" \"\n      ].includes(s.key) && o.onOpenToggle(), s.key === \"ArrowDown\" && o.onOpenChange(!0), [\n        \"Enter\",\n        \" \",\n        \"ArrowDown\"\n      ].includes(s.key) && s.preventDefault());\n    })\n  })));\n}), XO = (e) => {\n  const { __scopeDropdownMenu: t, ...n } = e, r = Lt(t);\n  return /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(kO, ce({}, r, n));\n}, ZO = \"DropdownMenuContent\", JO = /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)((e, t) => {\n  const { __scopeDropdownMenu: n, ...r } = e, i = by(ZO, n), o = Lt(n), a = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(!1);\n  return /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(DO, ce({\n    id: i.contentId,\n    \"aria-labelledby\": i.triggerId\n  }, o, r, {\n    ref: t,\n    onCloseAutoFocus: we(e.onCloseAutoFocus, (s) => {\n      var u;\n      a.current || (u = i.triggerRef.current) === null || u === void 0 || u.focus(), a.current = !1, s.preventDefault();\n    }),\n    onInteractOutside: we(e.onInteractOutside, (s) => {\n      const u = s.detail.originalEvent, c = u.button === 0 && u.ctrlKey === !0, f = u.button === 2 || c;\n      (!i.modal || f) && (a.current = !0);\n    }),\n    style: {\n      ...e.style,\n      \"--radix-dropdown-menu-content-transform-origin\": \"var(--radix-popper-transform-origin)\",\n      \"--radix-dropdown-menu-content-available-width\": \"var(--radix-popper-available-width)\",\n      \"--radix-dropdown-menu-content-available-height\": \"var(--radix-popper-available-height)\",\n      \"--radix-dropdown-menu-trigger-width\": \"var(--radix-popper-anchor-width)\",\n      \"--radix-dropdown-menu-trigger-height\": \"var(--radix-popper-anchor-height)\"\n    }\n  }));\n}), QO = /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)((e, t) => {\n  const { __scopeDropdownMenu: n, ...r } = e, i = Lt(n);\n  return /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(NO, ce({}, i, r, {\n    ref: t\n  }));\n}), e_ = /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)((e, t) => {\n  const { __scopeDropdownMenu: n, ...r } = e, i = Lt(n);\n  return /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(FO, ce({}, i, r, {\n    ref: t\n  }));\n}), t_ = /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)((e, t) => {\n  const { __scopeDropdownMenu: n, ...r } = e, i = Lt(n);\n  return /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(LO, ce({}, i, r, {\n    ref: t\n  }));\n}), n_ = /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)((e, t) => {\n  const { __scopeDropdownMenu: n, ...r } = e, i = Lt(n);\n  return /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(BO, ce({}, i, r, {\n    ref: t\n  }));\n}), r_ = /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)((e, t) => {\n  const { __scopeDropdownMenu: n, ...r } = e, i = Lt(n);\n  return /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(zO, ce({}, i, r, {\n    ref: t\n  }));\n}), i_ = /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)((e, t) => {\n  const { __scopeDropdownMenu: n, ...r } = e, i = Lt(n);\n  return /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(VO, ce({}, i, r, {\n    ref: t\n  }));\n}), o_ = /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)((e, t) => {\n  const { __scopeDropdownMenu: n, ...r } = e, i = Lt(n);\n  return /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(GO, ce({}, i, r, {\n    ref: t\n  }));\n}), a_ = /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)((e, t) => {\n  const { __scopeDropdownMenu: n, ...r } = e, i = Lt(n);\n  return /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(WO, ce({}, i, r, {\n    ref: t,\n    style: {\n      ...e.style,\n      \"--radix-dropdown-menu-content-transform-origin\": \"var(--radix-popper-transform-origin)\",\n      \"--radix-dropdown-menu-content-available-width\": \"var(--radix-popper-available-width)\",\n      \"--radix-dropdown-menu-content-available-height\": \"var(--radix-popper-available-height)\",\n      \"--radix-dropdown-menu-trigger-width\": \"var(--radix-popper-anchor-width)\",\n      \"--radix-dropdown-menu-trigger-height\": \"var(--radix-popper-anchor-height)\"\n    }\n  }));\n}), s_ = qO, u_ = YO, c_ = XO, wy = JO, xy = QO, Sy = e_, $y = t_, Oy = n_, _y = r_, Ay = i_, Py = o_, Cy = a_, Ey = s_, Ty = u_, l_ = react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(({ className: e, inset: t, children: n, ...r }, i) => /* @__PURE__ */ ze(\n  Py,\n  {\n    ref: i,\n    className: Le(\n      \"flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-accent data-[state=open]:bg-accent\",\n      t && \"pl-8\",\n      e\n    ),\n    ...r,\n    children: [\n      n,\n      /* @__PURE__ */ X(g1, { className: \"ml-auto h-4 w-4\" })\n    ]\n  }\n));\nl_.displayName = Py.displayName;\nconst f_ = react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(({ className: e, ...t }, n) => /* @__PURE__ */ X(\n  Cy,\n  {\n    ref: n,\n    className: Le(\n      \"z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-lg data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2\",\n      e\n    ),\n    ...t\n  }\n));\nf_.displayName = Cy.displayName;\nconst gf = react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(({ className: e, sideOffset: t = 4, ...n }, r) => /* @__PURE__ */ X(c_, { children: /* @__PURE__ */ X(\n  wy,\n  {\n    ref: r,\n    sideOffset: t,\n    className: Le(\n      \"z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2\",\n      e\n    ),\n    ...n\n  }\n) }));\ngf.displayName = wy.displayName;\nconst Ea = react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(({ className: e, inset: t, ...n }, r) => /* @__PURE__ */ X(\n  Sy,\n  {\n    ref: r,\n    className: Le(\n      \"relative flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50\",\n      t && \"pl-8\",\n      e\n    ),\n    ...n\n  }\n));\nEa.displayName = Sy.displayName;\nconst My = react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(({ className: e, children: t, checked: n, ...r }, i) => /* @__PURE__ */ ze(\n  $y,\n  {\n    ref: i,\n    className: Le(\n      \"relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50\",\n      e\n    ),\n    checked: n,\n    ...r,\n    children: [\n      /* @__PURE__ */ X(\"span\", { className: \"absolute left-2 flex h-3.5 w-3.5 items-center justify-center\", children: /* @__PURE__ */ X(_y, { children: /* @__PURE__ */ X(xm, { className: \"h-4 w-4\" }) }) }),\n      t\n    ]\n  }\n));\nMy.displayName = $y.displayName;\nconst d_ = react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(({ className: e, children: t, ...n }, r) => /* @__PURE__ */ ze(\n  Oy,\n  {\n    ref: r,\n    className: Le(\n      \"relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50\",\n      e\n    ),\n    ...n,\n    children: [\n      /* @__PURE__ */ X(\"span\", { className: \"absolute left-2 flex h-3.5 w-3.5 items-center justify-center\", children: /* @__PURE__ */ X(_y, { children: /* @__PURE__ */ X(v1, { className: \"h-2 w-2 fill-current\" }) }) }),\n      t\n    ]\n  }\n));\nd_.displayName = Oy.displayName;\nconst p_ = react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(({ className: e, inset: t, ...n }, r) => /* @__PURE__ */ X(\n  xy,\n  {\n    ref: r,\n    className: Le(\n      \"px-2 py-1.5 text-sm font-semibold\",\n      t && \"pl-8\",\n      e\n    ),\n    ...n\n  }\n));\np_.displayName = xy.displayName;\nconst h_ = react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(({ className: e, ...t }, n) => /* @__PURE__ */ X(\n  Ay,\n  {\n    ref: n,\n    className: Le(\"-mx-1 my-1 h-px bg-muted\", e),\n    ...t\n  }\n));\nh_.displayName = Ay.displayName;\nfunction eH({\n  setTheme: e,\n  darkButtonText: t,\n  lightButtonText: n,\n  systemButtonText: r\n}) {\n  return /* @__PURE__ */ ze(Ey, { children: [\n    /* @__PURE__ */ X(Ty, { asChild: !0, children: /* @__PURE__ */ ze(ar, { variant: \"outline\", size: \"icon\", children: [\n      /* @__PURE__ */ X(y1, { className: \"h-[1.2rem] w-[1.2rem] rotate-0 scale-100 transition-all dark:-rotate-90 dark:scale-0\" }),\n      /* @__PURE__ */ X(m1, { className: \"absolute h-[1.2rem] w-[1.2rem] rotate-90 scale-0 transition-all dark:rotate-0 dark:scale-100\" }),\n      /* @__PURE__ */ X(\"span\", { className: \"sr-only\", children: \"Toggle theme\" })\n    ] }) }),\n    /* @__PURE__ */ ze(gf, { align: \"end\", children: [\n      /* @__PURE__ */ X(Ea, { onClick: () => e(\"light\"), children: n }),\n      /* @__PURE__ */ X(Ea, { onClick: () => e(\"dark\"), children: t }),\n      /* @__PURE__ */ X(Ea, { onClick: () => e(\"system\"), children: r })\n    ] })\n  ] });\n}\nvar g_ = Array.isArray, mt = g_, v_ = typeof ta == \"object\" && ta && ta.Object === Object && ta, Ry = v_, m_ = Ry, y_ = typeof self == \"object\" && self && self.Object === Object && self, b_ = m_ || y_ || Function(\"return this\")(), dn = b_, w_ = dn, x_ = w_.Symbol, Vo = x_, cp = Vo, Iy = Object.prototype, S_ = Iy.hasOwnProperty, $_ = Iy.toString, Ti = cp ? cp.toStringTag : void 0;\nfunction O_(e) {\n  var t = S_.call(e, Ti), n = e[Ti];\n  try {\n    e[Ti] = void 0;\n    var r = !0;\n  } catch {\n  }\n  var i = $_.call(e);\n  return r && (t ? e[Ti] = n : delete e[Ti]), i;\n}\nvar __ = O_, A_ = Object.prototype, P_ = A_.toString;\nfunction C_(e) {\n  return P_.call(e);\n}\nvar E_ = C_, lp = Vo, T_ = __, M_ = E_, R_ = \"[object Null]\", I_ = \"[object Undefined]\", fp = lp ? lp.toStringTag : void 0;\nfunction j_(e) {\n  return e == null ? e === void 0 ? I_ : R_ : fp && fp in Object(e) ? T_(e) : M_(e);\n}\nvar Pn = j_;\nfunction k_(e) {\n  return e != null && typeof e == \"object\";\n}\nvar Cn = k_, D_ = Pn, N_ = Cn, F_ = \"[object Symbol]\";\nfunction L_(e) {\n  return typeof e == \"symbol\" || N_(e) && D_(e) == F_;\n}\nvar ui = L_, B_ = mt, z_ = ui, V_ = /\\.|\\[(?:[^[\\]]*|([\"'])(?:(?!\\1)[^\\\\]|\\\\.)*?\\1)\\]/, G_ = /^\\w*$/;\nfunction W_(e, t) {\n  if (B_(e))\n    return !1;\n  var n = typeof e;\n  return n == \"number\" || n == \"symbol\" || n == \"boolean\" || e == null || z_(e) ? !0 : G_.test(e) || !V_.test(e) || t != null && e in Object(t);\n}\nvar vf = W_;\nfunction U_(e) {\n  var t = typeof e;\n  return e != null && (t == \"object\" || t == \"function\");\n}\nvar Un = U_;\nconst ci = /* @__PURE__ */ je(Un);\nvar H_ = Pn, q_ = Un, K_ = \"[object AsyncFunction]\", Y_ = \"[object Function]\", X_ = \"[object GeneratorFunction]\", Z_ = \"[object Proxy]\";\nfunction J_(e) {\n  if (!q_(e))\n    return !1;\n  var t = H_(e);\n  return t == Y_ || t == X_ || t == K_ || t == Z_;\n}\nvar mf = J_;\nconst pe = /* @__PURE__ */ je(mf);\nvar Q_ = dn, eA = Q_[\"__core-js_shared__\"], tA = eA, _u = tA, dp = function() {\n  var e = /[^.]+$/.exec(_u && _u.keys && _u.keys.IE_PROTO || \"\");\n  return e ? \"Symbol(src)_1.\" + e : \"\";\n}();\nfunction nA(e) {\n  return !!dp && dp in e;\n}\nvar rA = nA, iA = Function.prototype, oA = iA.toString;\nfunction aA(e) {\n  if (e != null) {\n    try {\n      return oA.call(e);\n    } catch {\n    }\n    try {\n      return e + \"\";\n    } catch {\n    }\n  }\n  return \"\";\n}\nvar jy = aA, sA = mf, uA = rA, cA = Un, lA = jy, fA = /[\\\\^$.*+?()[\\]{}|]/g, dA = /^\\[object .+?Constructor\\]$/, pA = Function.prototype, hA = Object.prototype, gA = pA.toString, vA = hA.hasOwnProperty, mA = RegExp(\n  \"^\" + gA.call(vA).replace(fA, \"\\\\$&\").replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, \"$1.*?\") + \"$\"\n);\nfunction yA(e) {\n  if (!cA(e) || uA(e))\n    return !1;\n  var t = sA(e) ? mA : dA;\n  return t.test(lA(e));\n}\nvar bA = yA;\nfunction wA(e, t) {\n  return e == null ? void 0 : e[t];\n}\nvar xA = wA, SA = bA, $A = xA;\nfunction OA(e, t) {\n  var n = $A(e, t);\n  return SA(n) ? n : void 0;\n}\nvar vr = OA, _A = vr, AA = _A(Object, \"create\"), ks = AA, pp = ks;\nfunction PA() {\n  this.__data__ = pp ? pp(null) : {}, this.size = 0;\n}\nvar CA = PA;\nfunction EA(e) {\n  var t = this.has(e) && delete this.__data__[e];\n  return this.size -= t ? 1 : 0, t;\n}\nvar TA = EA, MA = ks, RA = \"__lodash_hash_undefined__\", IA = Object.prototype, jA = IA.hasOwnProperty;\nfunction kA(e) {\n  var t = this.__data__;\n  if (MA) {\n    var n = t[e];\n    return n === RA ? void 0 : n;\n  }\n  return jA.call(t, e) ? t[e] : void 0;\n}\nvar DA = kA, NA = ks, FA = Object.prototype, LA = FA.hasOwnProperty;\nfunction BA(e) {\n  var t = this.__data__;\n  return NA ? t[e] !== void 0 : LA.call(t, e);\n}\nvar zA = BA, VA = ks, GA = \"__lodash_hash_undefined__\";\nfunction WA(e, t) {\n  var n = this.__data__;\n  return this.size += this.has(e) ? 0 : 1, n[e] = VA && t === void 0 ? GA : t, this;\n}\nvar UA = WA, HA = CA, qA = TA, KA = DA, YA = zA, XA = UA;\nfunction li(e) {\n  var t = -1, n = e == null ? 0 : e.length;\n  for (this.clear(); ++t < n; ) {\n    var r = e[t];\n    this.set(r[0], r[1]);\n  }\n}\nli.prototype.clear = HA;\nli.prototype.delete = qA;\nli.prototype.get = KA;\nli.prototype.has = YA;\nli.prototype.set = XA;\nvar ZA = li;\nfunction JA() {\n  this.__data__ = [], this.size = 0;\n}\nvar QA = JA;\nfunction eP(e, t) {\n  return e === t || e !== e && t !== t;\n}\nvar yf = eP, tP = yf;\nfunction nP(e, t) {\n  for (var n = e.length; n--; )\n    if (tP(e[n][0], t))\n      return n;\n  return -1;\n}\nvar Ds = nP, rP = Ds, iP = Array.prototype, oP = iP.splice;\nfunction aP(e) {\n  var t = this.__data__, n = rP(t, e);\n  if (n < 0)\n    return !1;\n  var r = t.length - 1;\n  return n == r ? t.pop() : oP.call(t, n, 1), --this.size, !0;\n}\nvar sP = aP, uP = Ds;\nfunction cP(e) {\n  var t = this.__data__, n = uP(t, e);\n  return n < 0 ? void 0 : t[n][1];\n}\nvar lP = cP, fP = Ds;\nfunction dP(e) {\n  return fP(this.__data__, e) > -1;\n}\nvar pP = dP, hP = Ds;\nfunction gP(e, t) {\n  var n = this.__data__, r = hP(n, e);\n  return r < 0 ? (++this.size, n.push([e, t])) : n[r][1] = t, this;\n}\nvar vP = gP, mP = QA, yP = sP, bP = lP, wP = pP, xP = vP;\nfunction fi(e) {\n  var t = -1, n = e == null ? 0 : e.length;\n  for (this.clear(); ++t < n; ) {\n    var r = e[t];\n    this.set(r[0], r[1]);\n  }\n}\nfi.prototype.clear = mP;\nfi.prototype.delete = yP;\nfi.prototype.get = bP;\nfi.prototype.has = wP;\nfi.prototype.set = xP;\nvar Ns = fi, SP = vr, $P = dn, OP = SP($P, \"Map\"), bf = OP, hp = ZA, _P = Ns, AP = bf;\nfunction PP() {\n  this.size = 0, this.__data__ = {\n    hash: new hp(),\n    map: new (AP || _P)(),\n    string: new hp()\n  };\n}\nvar CP = PP;\nfunction EP(e) {\n  var t = typeof e;\n  return t == \"string\" || t == \"number\" || t == \"symbol\" || t == \"boolean\" ? e !== \"__proto__\" : e === null;\n}\nvar TP = EP, MP = TP;\nfunction RP(e, t) {\n  var n = e.__data__;\n  return MP(t) ? n[typeof t == \"string\" ? \"string\" : \"hash\"] : n.map;\n}\nvar Fs = RP, IP = Fs;\nfunction jP(e) {\n  var t = IP(this, e).delete(e);\n  return this.size -= t ? 1 : 0, t;\n}\nvar kP = jP, DP = Fs;\nfunction NP(e) {\n  return DP(this, e).get(e);\n}\nvar FP = NP, LP = Fs;\nfunction BP(e) {\n  return LP(this, e).has(e);\n}\nvar zP = BP, VP = Fs;\nfunction GP(e, t) {\n  var n = VP(this, e), r = n.size;\n  return n.set(e, t), this.size += n.size == r ? 0 : 1, this;\n}\nvar WP = GP, UP = CP, HP = kP, qP = FP, KP = zP, YP = WP;\nfunction di(e) {\n  var t = -1, n = e == null ? 0 : e.length;\n  for (this.clear(); ++t < n; ) {\n    var r = e[t];\n    this.set(r[0], r[1]);\n  }\n}\ndi.prototype.clear = UP;\ndi.prototype.delete = HP;\ndi.prototype.get = qP;\ndi.prototype.has = KP;\ndi.prototype.set = YP;\nvar wf = di, ky = wf, XP = \"Expected a function\";\nfunction xf(e, t) {\n  if (typeof e != \"function\" || t != null && typeof t != \"function\")\n    throw new TypeError(XP);\n  var n = function() {\n    var r = arguments, i = t ? t.apply(this, r) : r[0], o = n.cache;\n    if (o.has(i))\n      return o.get(i);\n    var a = e.apply(this, r);\n    return n.cache = o.set(i, a) || o, a;\n  };\n  return n.cache = new (xf.Cache || ky)(), n;\n}\nxf.Cache = ky;\nvar Dy = xf;\nconst ZP = /* @__PURE__ */ je(Dy);\nvar JP = Dy, QP = 500;\nfunction eC(e) {\n  var t = JP(e, function(r) {\n    return n.size === QP && n.clear(), r;\n  }), n = t.cache;\n  return t;\n}\nvar tC = eC, nC = tC, rC = /[^.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|$))/g, iC = /\\\\(\\\\)?/g, oC = nC(function(e) {\n  var t = [];\n  return e.charCodeAt(0) === 46 && t.push(\"\"), e.replace(rC, function(n, r, i, o) {\n    t.push(i ? o.replace(iC, \"$1\") : r || n);\n  }), t;\n}), aC = oC;\nfunction sC(e, t) {\n  for (var n = -1, r = e == null ? 0 : e.length, i = Array(r); ++n < r; )\n    i[n] = t(e[n], n, e);\n  return i;\n}\nvar Sf = sC, gp = Vo, uC = Sf, cC = mt, lC = ui, fC = 1 / 0, vp = gp ? gp.prototype : void 0, mp = vp ? vp.toString : void 0;\nfunction Ny(e) {\n  if (typeof e == \"string\")\n    return e;\n  if (cC(e))\n    return uC(e, Ny) + \"\";\n  if (lC(e))\n    return mp ? mp.call(e) : \"\";\n  var t = e + \"\";\n  return t == \"0\" && 1 / e == -fC ? \"-0\" : t;\n}\nvar dC = Ny, pC = dC;\nfunction hC(e) {\n  return e == null ? \"\" : pC(e);\n}\nvar Fy = hC, gC = mt, vC = vf, mC = aC, yC = Fy;\nfunction bC(e, t) {\n  return gC(e) ? e : vC(e, t) ? [e] : mC(yC(e));\n}\nvar Ly = bC, wC = ui, xC = 1 / 0;\nfunction SC(e) {\n  if (typeof e == \"string\" || wC(e))\n    return e;\n  var t = e + \"\";\n  return t == \"0\" && 1 / e == -xC ? \"-0\" : t;\n}\nvar Ls = SC, $C = Ly, OC = Ls;\nfunction _C(e, t) {\n  t = $C(t, e);\n  for (var n = 0, r = t.length; e != null && n < r; )\n    e = e[OC(t[n++])];\n  return n && n == r ? e : void 0;\n}\nvar $f = _C, AC = $f;\nfunction PC(e, t, n) {\n  var r = e == null ? void 0 : AC(e, t);\n  return r === void 0 ? n : r;\n}\nvar By = PC;\nconst jt = /* @__PURE__ */ je(By);\nfunction CC(e) {\n  return e == null;\n}\nvar EC = CC;\nconst me = /* @__PURE__ */ je(EC);\nvar TC = Pn, MC = mt, RC = Cn, IC = \"[object String]\";\nfunction jC(e) {\n  return typeof e == \"string\" || !MC(e) && RC(e) && TC(e) == IC;\n}\nvar kC = jC;\nconst Go = /* @__PURE__ */ je(kC);\nvar _c = { exports: {} }, Pe = {};\n/** @license React v16.13.1\n * react-is.production.min.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nvar yp;\nfunction DC() {\n  if (yp)\n    return Pe;\n  yp = 1;\n  var e = typeof Symbol == \"function\" && Symbol.for, t = e ? Symbol.for(\"react.element\") : 60103, n = e ? Symbol.for(\"react.portal\") : 60106, r = e ? Symbol.for(\"react.fragment\") : 60107, i = e ? Symbol.for(\"react.strict_mode\") : 60108, o = e ? Symbol.for(\"react.profiler\") : 60114, a = e ? Symbol.for(\"react.provider\") : 60109, s = e ? Symbol.for(\"react.context\") : 60110, u = e ? Symbol.for(\"react.async_mode\") : 60111, c = e ? Symbol.for(\"react.concurrent_mode\") : 60111, f = e ? Symbol.for(\"react.forward_ref\") : 60112, l = e ? Symbol.for(\"react.suspense\") : 60113, d = e ? Symbol.for(\"react.suspense_list\") : 60120, p = e ? Symbol.for(\"react.memo\") : 60115, g = e ? Symbol.for(\"react.lazy\") : 60116, h = e ? Symbol.for(\"react.block\") : 60121, v = e ? Symbol.for(\"react.fundamental\") : 60117, w = e ? Symbol.for(\"react.responder\") : 60118, b = e ? Symbol.for(\"react.scope\") : 60119;\n  function x(y) {\n    if (typeof y == \"object\" && y !== null) {\n      var S = y.$$typeof;\n      switch (S) {\n        case t:\n          switch (y = y.type, y) {\n            case u:\n            case c:\n            case r:\n            case o:\n            case i:\n            case l:\n              return y;\n            default:\n              switch (y = y && y.$$typeof, y) {\n                case s:\n                case f:\n                case g:\n                case p:\n                case a:\n                  return y;\n                default:\n                  return S;\n              }\n          }\n        case n:\n          return S;\n      }\n    }\n  }\n  function m(y) {\n    return x(y) === c;\n  }\n  return Pe.AsyncMode = u, Pe.ConcurrentMode = c, Pe.ContextConsumer = s, Pe.ContextProvider = a, Pe.Element = t, Pe.ForwardRef = f, Pe.Fragment = r, Pe.Lazy = g, Pe.Memo = p, Pe.Portal = n, Pe.Profiler = o, Pe.StrictMode = i, Pe.Suspense = l, Pe.isAsyncMode = function(y) {\n    return m(y) || x(y) === u;\n  }, Pe.isConcurrentMode = m, Pe.isContextConsumer = function(y) {\n    return x(y) === s;\n  }, Pe.isContextProvider = function(y) {\n    return x(y) === a;\n  }, Pe.isElement = function(y) {\n    return typeof y == \"object\" && y !== null && y.$$typeof === t;\n  }, Pe.isForwardRef = function(y) {\n    return x(y) === f;\n  }, Pe.isFragment = function(y) {\n    return x(y) === r;\n  }, Pe.isLazy = function(y) {\n    return x(y) === g;\n  }, Pe.isMemo = function(y) {\n    return x(y) === p;\n  }, Pe.isPortal = function(y) {\n    return x(y) === n;\n  }, Pe.isProfiler = function(y) {\n    return x(y) === o;\n  }, Pe.isStrictMode = function(y) {\n    return x(y) === i;\n  }, Pe.isSuspense = function(y) {\n    return x(y) === l;\n  }, Pe.isValidElementType = function(y) {\n    return typeof y == \"string\" || typeof y == \"function\" || y === r || y === c || y === o || y === i || y === l || y === d || typeof y == \"object\" && y !== null && (y.$$typeof === g || y.$$typeof === p || y.$$typeof === a || y.$$typeof === s || y.$$typeof === f || y.$$typeof === v || y.$$typeof === w || y.$$typeof === b || y.$$typeof === h);\n  }, Pe.typeOf = x, Pe;\n}\nvar Ce = {};\n/** @license React v16.13.1\n * react-is.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nvar bp;\nfunction NC() {\n  return bp || (bp = 1,  true && function() {\n    var e = typeof Symbol == \"function\" && Symbol.for, t = e ? Symbol.for(\"react.element\") : 60103, n = e ? Symbol.for(\"react.portal\") : 60106, r = e ? Symbol.for(\"react.fragment\") : 60107, i = e ? Symbol.for(\"react.strict_mode\") : 60108, o = e ? Symbol.for(\"react.profiler\") : 60114, a = e ? Symbol.for(\"react.provider\") : 60109, s = e ? Symbol.for(\"react.context\") : 60110, u = e ? Symbol.for(\"react.async_mode\") : 60111, c = e ? Symbol.for(\"react.concurrent_mode\") : 60111, f = e ? Symbol.for(\"react.forward_ref\") : 60112, l = e ? Symbol.for(\"react.suspense\") : 60113, d = e ? Symbol.for(\"react.suspense_list\") : 60120, p = e ? Symbol.for(\"react.memo\") : 60115, g = e ? Symbol.for(\"react.lazy\") : 60116, h = e ? Symbol.for(\"react.block\") : 60121, v = e ? Symbol.for(\"react.fundamental\") : 60117, w = e ? Symbol.for(\"react.responder\") : 60118, b = e ? Symbol.for(\"react.scope\") : 60119;\n    function x(C) {\n      return typeof C == \"string\" || typeof C == \"function\" || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.\n      C === r || C === c || C === o || C === i || C === l || C === d || typeof C == \"object\" && C !== null && (C.$$typeof === g || C.$$typeof === p || C.$$typeof === a || C.$$typeof === s || C.$$typeof === f || C.$$typeof === v || C.$$typeof === w || C.$$typeof === b || C.$$typeof === h);\n    }\n    function m(C) {\n      if (typeof C == \"object\" && C !== null) {\n        var ge = C.$$typeof;\n        switch (ge) {\n          case t:\n            var le = C.type;\n            switch (le) {\n              case u:\n              case c:\n              case r:\n              case o:\n              case i:\n              case l:\n                return le;\n              default:\n                var xe = le && le.$$typeof;\n                switch (xe) {\n                  case s:\n                  case f:\n                  case g:\n                  case p:\n                  case a:\n                    return xe;\n                  default:\n                    return ge;\n                }\n            }\n          case n:\n            return ge;\n        }\n      }\n    }\n    var y = u, S = c, $ = s, O = a, T = t, M = f, E = r, A = g, j = p, R = n, N = o, k = i, F = l, V = !1;\n    function L(C) {\n      return V || (V = !0, console.warn(\"The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.\")), I(C) || m(C) === u;\n    }\n    function I(C) {\n      return m(C) === c;\n    }\n    function D(C) {\n      return m(C) === s;\n    }\n    function G(C) {\n      return m(C) === a;\n    }\n    function q(C) {\n      return typeof C == \"object\" && C !== null && C.$$typeof === t;\n    }\n    function J(C) {\n      return m(C) === f;\n    }\n    function ne(C) {\n      return m(C) === r;\n    }\n    function te(C) {\n      return m(C) === g;\n    }\n    function ee(C) {\n      return m(C) === p;\n    }\n    function ie(C) {\n      return m(C) === n;\n    }\n    function B(C) {\n      return m(C) === o;\n    }\n    function U(C) {\n      return m(C) === i;\n    }\n    function re(C) {\n      return m(C) === l;\n    }\n    Ce.AsyncMode = y, Ce.ConcurrentMode = S, Ce.ContextConsumer = $, Ce.ContextProvider = O, Ce.Element = T, Ce.ForwardRef = M, Ce.Fragment = E, Ce.Lazy = A, Ce.Memo = j, Ce.Portal = R, Ce.Profiler = N, Ce.StrictMode = k, Ce.Suspense = F, Ce.isAsyncMode = L, Ce.isConcurrentMode = I, Ce.isContextConsumer = D, Ce.isContextProvider = G, Ce.isElement = q, Ce.isForwardRef = J, Ce.isFragment = ne, Ce.isLazy = te, Ce.isMemo = ee, Ce.isPortal = ie, Ce.isProfiler = B, Ce.isStrictMode = U, Ce.isSuspense = re, Ce.isValidElementType = x, Ce.typeOf = m;\n  }()), Ce;\n}\n false ? 0 : _c.exports = NC();\nvar Of = _c.exports, FC = Pn, LC = Cn, BC = \"[object Number]\";\nfunction zC(e) {\n  return typeof e == \"number\" || LC(e) && FC(e) == BC;\n}\nvar zy = zC;\nconst VC = /* @__PURE__ */ je(zy);\nvar GC = zy;\nfunction WC(e) {\n  return GC(e) && e != +e;\n}\nvar UC = WC;\nconst Wo = /* @__PURE__ */ je(UC);\nvar Kt = function(t) {\n  return t === 0 ? 0 : t > 0 ? 1 : -1;\n}, Ac = function(t) {\n  return Go(t) && t.indexOf(\"%\") === t.length - 1;\n}, K = function(t) {\n  return VC(t) && !Wo(t);\n}, Ke = function(t) {\n  return K(t) || Go(t);\n}, HC = 0, Uo = function(t) {\n  var n = ++HC;\n  return \"\".concat(t || \"\").concat(n);\n}, lr = function(t, n) {\n  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0, i = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : !1;\n  if (!K(t) && !Go(t))\n    return r;\n  var o;\n  if (Ac(t)) {\n    var a = t.indexOf(\"%\");\n    o = n * parseFloat(t.slice(0, a)) / 100;\n  } else\n    o = +t;\n  return Wo(o) && (o = r), i && o > n && (o = n), o;\n}, kn = function(t) {\n  if (!t)\n    return null;\n  var n = Object.keys(t);\n  return n && n.length ? t[n[0]] : null;\n}, qC = function(t) {\n  if (!Array.isArray(t))\n    return !1;\n  for (var n = t.length, r = {}, i = 0; i < n; i++)\n    if (!r[t[i]])\n      r[t[i]] = !0;\n    else\n      return !0;\n  return !1;\n}, Ht = function(t, n) {\n  return K(t) && K(n) ? function(r) {\n    return t + r * (n - t);\n  } : function() {\n    return n;\n  };\n};\nfunction Da(e, t, n) {\n  return !e || !e.length ? null : e.find(function(r) {\n    return r && (typeof t == \"function\" ? t(r) : jt(r, t)) === n;\n  });\n}\nfunction Rr(e, t) {\n  for (var n in e)\n    if ({}.hasOwnProperty.call(e, n) && (!{}.hasOwnProperty.call(t, n) || e[n] !== t[n]))\n      return !1;\n  for (var r in t)\n    if ({}.hasOwnProperty.call(t, r) && !{}.hasOwnProperty.call(e, r))\n      return !1;\n  return !0;\n}\nfunction Pc(e) {\n  \"@babel/helpers - typeof\";\n  return Pc = typeof Symbol == \"function\" && typeof Symbol.iterator == \"symbol\" ? function(t) {\n    return typeof t;\n  } : function(t) {\n    return t && typeof Symbol == \"function\" && t.constructor === Symbol && t !== Symbol.prototype ? \"symbol\" : typeof t;\n  }, Pc(e);\n}\nvar KC = [\"viewBox\", \"children\"], YC = [\n  \"aria-activedescendant\",\n  \"aria-atomic\",\n  \"aria-autocomplete\",\n  \"aria-busy\",\n  \"aria-checked\",\n  \"aria-colcount\",\n  \"aria-colindex\",\n  \"aria-colspan\",\n  \"aria-controls\",\n  \"aria-current\",\n  \"aria-describedby\",\n  \"aria-details\",\n  \"aria-disabled\",\n  \"aria-errormessage\",\n  \"aria-expanded\",\n  \"aria-flowto\",\n  \"aria-haspopup\",\n  \"aria-hidden\",\n  \"aria-invalid\",\n  \"aria-keyshortcuts\",\n  \"aria-label\",\n  \"aria-labelledby\",\n  \"aria-level\",\n  \"aria-live\",\n  \"aria-modal\",\n  \"aria-multiline\",\n  \"aria-multiselectable\",\n  \"aria-orientation\",\n  \"aria-owns\",\n  \"aria-placeholder\",\n  \"aria-posinset\",\n  \"aria-pressed\",\n  \"aria-readonly\",\n  \"aria-relevant\",\n  \"aria-required\",\n  \"aria-roledescription\",\n  \"aria-rowcount\",\n  \"aria-rowindex\",\n  \"aria-rowspan\",\n  \"aria-selected\",\n  \"aria-setsize\",\n  \"aria-sort\",\n  \"aria-valuemax\",\n  \"aria-valuemin\",\n  \"aria-valuenow\",\n  \"aria-valuetext\",\n  \"className\",\n  \"color\",\n  \"height\",\n  \"id\",\n  \"lang\",\n  \"max\",\n  \"media\",\n  \"method\",\n  \"min\",\n  \"name\",\n  \"style\",\n  /*\n   * removed 'type' SVGElementPropKey because we do not currently use any SVG elements\n   * that can use it and it conflicts with the recharts prop 'type'\n   * https://github.com/recharts/recharts/pull/3327\n   * https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/type\n   */\n  // 'type',\n  \"target\",\n  \"width\",\n  \"role\",\n  \"tabIndex\",\n  \"accentHeight\",\n  \"accumulate\",\n  \"additive\",\n  \"alignmentBaseline\",\n  \"allowReorder\",\n  \"alphabetic\",\n  \"amplitude\",\n  \"arabicForm\",\n  \"ascent\",\n  \"attributeName\",\n  \"attributeType\",\n  \"autoReverse\",\n  \"azimuth\",\n  \"baseFrequency\",\n  \"baselineShift\",\n  \"baseProfile\",\n  \"bbox\",\n  \"begin\",\n  \"bias\",\n  \"by\",\n  \"calcMode\",\n  \"capHeight\",\n  \"clip\",\n  \"clipPath\",\n  \"clipPathUnits\",\n  \"clipRule\",\n  \"colorInterpolation\",\n  \"colorInterpolationFilters\",\n  \"colorProfile\",\n  \"colorRendering\",\n  \"contentScriptType\",\n  \"contentStyleType\",\n  \"cursor\",\n  \"cx\",\n  \"cy\",\n  \"d\",\n  \"decelerate\",\n  \"descent\",\n  \"diffuseConstant\",\n  \"direction\",\n  \"display\",\n  \"divisor\",\n  \"dominantBaseline\",\n  \"dur\",\n  \"dx\",\n  \"dy\",\n  \"edgeMode\",\n  \"elevation\",\n  \"enableBackground\",\n  \"end\",\n  \"exponent\",\n  \"externalResourcesRequired\",\n  \"fill\",\n  \"fillOpacity\",\n  \"fillRule\",\n  \"filter\",\n  \"filterRes\",\n  \"filterUnits\",\n  \"floodColor\",\n  \"floodOpacity\",\n  \"focusable\",\n  \"fontFamily\",\n  \"fontSize\",\n  \"fontSizeAdjust\",\n  \"fontStretch\",\n  \"fontStyle\",\n  \"fontVariant\",\n  \"fontWeight\",\n  \"format\",\n  \"from\",\n  \"fx\",\n  \"fy\",\n  \"g1\",\n  \"g2\",\n  \"glyphName\",\n  \"glyphOrientationHorizontal\",\n  \"glyphOrientationVertical\",\n  \"glyphRef\",\n  \"gradientTransform\",\n  \"gradientUnits\",\n  \"hanging\",\n  \"horizAdvX\",\n  \"horizOriginX\",\n  \"href\",\n  \"ideographic\",\n  \"imageRendering\",\n  \"in2\",\n  \"in\",\n  \"intercept\",\n  \"k1\",\n  \"k2\",\n  \"k3\",\n  \"k4\",\n  \"k\",\n  \"kernelMatrix\",\n  \"kernelUnitLength\",\n  \"kerning\",\n  \"keyPoints\",\n  \"keySplines\",\n  \"keyTimes\",\n  \"lengthAdjust\",\n  \"letterSpacing\",\n  \"lightingColor\",\n  \"limitingConeAngle\",\n  \"local\",\n  \"markerEnd\",\n  \"markerHeight\",\n  \"markerMid\",\n  \"markerStart\",\n  \"markerUnits\",\n  \"markerWidth\",\n  \"mask\",\n  \"maskContentUnits\",\n  \"maskUnits\",\n  \"mathematical\",\n  \"mode\",\n  \"numOctaves\",\n  \"offset\",\n  \"opacity\",\n  \"operator\",\n  \"order\",\n  \"orient\",\n  \"orientation\",\n  \"origin\",\n  \"overflow\",\n  \"overlinePosition\",\n  \"overlineThickness\",\n  \"paintOrder\",\n  \"panose1\",\n  \"pathLength\",\n  \"patternContentUnits\",\n  \"patternTransform\",\n  \"patternUnits\",\n  \"pointerEvents\",\n  \"pointsAtX\",\n  \"pointsAtY\",\n  \"pointsAtZ\",\n  \"preserveAlpha\",\n  \"preserveAspectRatio\",\n  \"primitiveUnits\",\n  \"r\",\n  \"radius\",\n  \"refX\",\n  \"refY\",\n  \"renderingIntent\",\n  \"repeatCount\",\n  \"repeatDur\",\n  \"requiredExtensions\",\n  \"requiredFeatures\",\n  \"restart\",\n  \"result\",\n  \"rotate\",\n  \"rx\",\n  \"ry\",\n  \"seed\",\n  \"shapeRendering\",\n  \"slope\",\n  \"spacing\",\n  \"specularConstant\",\n  \"specularExponent\",\n  \"speed\",\n  \"spreadMethod\",\n  \"startOffset\",\n  \"stdDeviation\",\n  \"stemh\",\n  \"stemv\",\n  \"stitchTiles\",\n  \"stopColor\",\n  \"stopOpacity\",\n  \"strikethroughPosition\",\n  \"strikethroughThickness\",\n  \"string\",\n  \"stroke\",\n  \"strokeDasharray\",\n  \"strokeDashoffset\",\n  \"strokeLinecap\",\n  \"strokeLinejoin\",\n  \"strokeMiterlimit\",\n  \"strokeOpacity\",\n  \"strokeWidth\",\n  \"surfaceScale\",\n  \"systemLanguage\",\n  \"tableValues\",\n  \"targetX\",\n  \"targetY\",\n  \"textAnchor\",\n  \"textDecoration\",\n  \"textLength\",\n  \"textRendering\",\n  \"to\",\n  \"transform\",\n  \"u1\",\n  \"u2\",\n  \"underlinePosition\",\n  \"underlineThickness\",\n  \"unicode\",\n  \"unicodeBidi\",\n  \"unicodeRange\",\n  \"unitsPerEm\",\n  \"vAlphabetic\",\n  \"values\",\n  \"vectorEffect\",\n  \"version\",\n  \"vertAdvY\",\n  \"vertOriginX\",\n  \"vertOriginY\",\n  \"vHanging\",\n  \"vIdeographic\",\n  \"viewTarget\",\n  \"visibility\",\n  \"vMathematical\",\n  \"widths\",\n  \"wordSpacing\",\n  \"writingMode\",\n  \"x1\",\n  \"x2\",\n  \"x\",\n  \"xChannelSelector\",\n  \"xHeight\",\n  \"xlinkActuate\",\n  \"xlinkArcrole\",\n  \"xlinkHref\",\n  \"xlinkRole\",\n  \"xlinkShow\",\n  \"xlinkTitle\",\n  \"xlinkType\",\n  \"xmlBase\",\n  \"xmlLang\",\n  \"xmlns\",\n  \"xmlnsXlink\",\n  \"xmlSpace\",\n  \"y1\",\n  \"y2\",\n  \"y\",\n  \"yChannelSelector\",\n  \"z\",\n  \"zoomAndPan\",\n  \"ref\",\n  \"key\",\n  \"angle\"\n], wp = [\"points\", \"pathLength\"], Au = {\n  svg: KC,\n  polygon: wp,\n  polyline: wp\n}, _f = [\"dangerouslySetInnerHTML\", \"onCopy\", \"onCopyCapture\", \"onCut\", \"onCutCapture\", \"onPaste\", \"onPasteCapture\", \"onCompositionEnd\", \"onCompositionEndCapture\", \"onCompositionStart\", \"onCompositionStartCapture\", \"onCompositionUpdate\", \"onCompositionUpdateCapture\", \"onFocus\", \"onFocusCapture\", \"onBlur\", \"onBlurCapture\", \"onChange\", \"onChangeCapture\", \"onBeforeInput\", \"onBeforeInputCapture\", \"onInput\", \"onInputCapture\", \"onReset\", \"onResetCapture\", \"onSubmit\", \"onSubmitCapture\", \"onInvalid\", \"onInvalidCapture\", \"onLoad\", \"onLoadCapture\", \"onError\", \"onErrorCapture\", \"onKeyDown\", \"onKeyDownCapture\", \"onKeyPress\", \"onKeyPressCapture\", \"onKeyUp\", \"onKeyUpCapture\", \"onAbort\", \"onAbortCapture\", \"onCanPlay\", \"onCanPlayCapture\", \"onCanPlayThrough\", \"onCanPlayThroughCapture\", \"onDurationChange\", \"onDurationChangeCapture\", \"onEmptied\", \"onEmptiedCapture\", \"onEncrypted\", \"onEncryptedCapture\", \"onEnded\", \"onEndedCapture\", \"onLoadedData\", \"onLoadedDataCapture\", \"onLoadedMetadata\", \"onLoadedMetadataCapture\", \"onLoadStart\", \"onLoadStartCapture\", \"onPause\", \"onPauseCapture\", \"onPlay\", \"onPlayCapture\", \"onPlaying\", \"onPlayingCapture\", \"onProgress\", \"onProgressCapture\", \"onRateChange\", \"onRateChangeCapture\", \"onSeeked\", \"onSeekedCapture\", \"onSeeking\", \"onSeekingCapture\", \"onStalled\", \"onStalledCapture\", \"onSuspend\", \"onSuspendCapture\", \"onTimeUpdate\", \"onTimeUpdateCapture\", \"onVolumeChange\", \"onVolumeChangeCapture\", \"onWaiting\", \"onWaitingCapture\", \"onAuxClick\", \"onAuxClickCapture\", \"onClick\", \"onClickCapture\", \"onContextMenu\", \"onContextMenuCapture\", \"onDoubleClick\", \"onDoubleClickCapture\", \"onDrag\", \"onDragCapture\", \"onDragEnd\", \"onDragEndCapture\", \"onDragEnter\", \"onDragEnterCapture\", \"onDragExit\", \"onDragExitCapture\", \"onDragLeave\", \"onDragLeaveCapture\", \"onDragOver\", \"onDragOverCapture\", \"onDragStart\", \"onDragStartCapture\", \"onDrop\", \"onDropCapture\", \"onMouseDown\", \"onMouseDownCapture\", \"onMouseEnter\", \"onMouseLeave\", \"onMouseMove\", \"onMouseMoveCapture\", \"onMouseOut\", \"onMouseOutCapture\", \"onMouseOver\", \"onMouseOverCapture\", \"onMouseUp\", \"onMouseUpCapture\", \"onSelect\", \"onSelectCapture\", \"onTouchCancel\", \"onTouchCancelCapture\", \"onTouchEnd\", \"onTouchEndCapture\", \"onTouchMove\", \"onTouchMoveCapture\", \"onTouchStart\", \"onTouchStartCapture\", \"onPointerDown\", \"onPointerDownCapture\", \"onPointerMove\", \"onPointerMoveCapture\", \"onPointerUp\", \"onPointerUpCapture\", \"onPointerCancel\", \"onPointerCancelCapture\", \"onPointerEnter\", \"onPointerEnterCapture\", \"onPointerLeave\", \"onPointerLeaveCapture\", \"onPointerOver\", \"onPointerOverCapture\", \"onPointerOut\", \"onPointerOutCapture\", \"onGotPointerCapture\", \"onGotPointerCaptureCapture\", \"onLostPointerCapture\", \"onLostPointerCaptureCapture\", \"onScroll\", \"onScrollCapture\", \"onWheel\", \"onWheelCapture\", \"onAnimationStart\", \"onAnimationStartCapture\", \"onAnimationEnd\", \"onAnimationEndCapture\", \"onAnimationIteration\", \"onAnimationIterationCapture\", \"onTransitionEnd\", \"onTransitionEndCapture\"], Na = function(t, n) {\n  if (!t || typeof t == \"function\" || typeof t == \"boolean\")\n    return null;\n  var r = t;\n  if (/* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.isValidElement)(t) && (r = t.props), !ci(r))\n    return null;\n  var i = {};\n  return Object.keys(r).forEach(function(o) {\n    _f.includes(o) && (i[o] = n || function(a) {\n      return r[o](r, a);\n    });\n  }), i;\n}, XC = function(t, n, r) {\n  return function(i) {\n    return t(n, r, i), null;\n  };\n}, Fa = function(t, n, r) {\n  if (!ci(t) || Pc(t) !== \"object\")\n    return null;\n  var i = null;\n  return Object.keys(t).forEach(function(o) {\n    var a = t[o];\n    _f.includes(o) && typeof a == \"function\" && (i || (i = {}), i[o] = XC(a, n, r));\n  }), i;\n}, ZC = [\"children\"], JC = [\"children\"];\nfunction xp(e, t) {\n  if (e == null)\n    return {};\n  var n = QC(e, t), r, i;\n  if (Object.getOwnPropertySymbols) {\n    var o = Object.getOwnPropertySymbols(e);\n    for (i = 0; i < o.length; i++)\n      r = o[i], !(t.indexOf(r) >= 0) && Object.prototype.propertyIsEnumerable.call(e, r) && (n[r] = e[r]);\n  }\n  return n;\n}\nfunction QC(e, t) {\n  if (e == null)\n    return {};\n  var n = {}, r = Object.keys(e), i, o;\n  for (o = 0; o < r.length; o++)\n    i = r[o], !(t.indexOf(i) >= 0) && (n[i] = e[i]);\n  return n;\n}\nfunction Cc(e) {\n  \"@babel/helpers - typeof\";\n  return Cc = typeof Symbol == \"function\" && typeof Symbol.iterator == \"symbol\" ? function(t) {\n    return typeof t;\n  } : function(t) {\n    return t && typeof Symbol == \"function\" && t.constructor === Symbol && t !== Symbol.prototype ? \"symbol\" : typeof t;\n  }, Cc(e);\n}\nvar Sp = {\n  click: \"onClick\",\n  mousedown: \"onMouseDown\",\n  mouseup: \"onMouseUp\",\n  mouseover: \"onMouseOver\",\n  mousemove: \"onMouseMove\",\n  mouseout: \"onMouseOut\",\n  mouseenter: \"onMouseEnter\",\n  mouseleave: \"onMouseLeave\",\n  touchcancel: \"onTouchCancel\",\n  touchend: \"onTouchEnd\",\n  touchmove: \"onTouchMove\",\n  touchstart: \"onTouchStart\"\n}, Fn = function(t) {\n  return typeof t == \"string\" ? t : t ? t.displayName || t.name || \"Component\" : \"\";\n}, $p = null, Pu = null, Af = function e(t) {\n  if (t === $p && Array.isArray(Pu))\n    return Pu;\n  var n = [];\n  return react__WEBPACK_IMPORTED_MODULE_0__.Children.forEach(t, function(r) {\n    me(r) || (Of.isFragment(r) ? n = n.concat(e(r.props.children)) : n.push(r));\n  }), Pu = n, $p = t, n;\n};\nfunction kt(e, t) {\n  var n = [], r = [];\n  return Array.isArray(t) ? r = t.map(function(i) {\n    return Fn(i);\n  }) : r = [Fn(t)], Af(e).forEach(function(i) {\n    var o = jt(i, \"type.displayName\") || jt(i, \"type.name\");\n    r.indexOf(o) !== -1 && n.push(i);\n  }), n;\n}\nfunction wt(e, t) {\n  var n = kt(e, t);\n  return n && n[0];\n}\nvar Op = function(t) {\n  if (!t || !t.props)\n    return !1;\n  var n = t.props, r = n.width, i = n.height;\n  return !(!K(r) || r <= 0 || !K(i) || i <= 0);\n}, eE = [\"a\", \"altGlyph\", \"altGlyphDef\", \"altGlyphItem\", \"animate\", \"animateColor\", \"animateMotion\", \"animateTransform\", \"circle\", \"clipPath\", \"color-profile\", \"cursor\", \"defs\", \"desc\", \"ellipse\", \"feBlend\", \"feColormatrix\", \"feComponentTransfer\", \"feComposite\", \"feConvolveMatrix\", \"feDiffuseLighting\", \"feDisplacementMap\", \"feDistantLight\", \"feFlood\", \"feFuncA\", \"feFuncB\", \"feFuncG\", \"feFuncR\", \"feGaussianBlur\", \"feImage\", \"feMerge\", \"feMergeNode\", \"feMorphology\", \"feOffset\", \"fePointLight\", \"feSpecularLighting\", \"feSpotLight\", \"feTile\", \"feTurbulence\", \"filter\", \"font\", \"font-face\", \"font-face-format\", \"font-face-name\", \"font-face-url\", \"foreignObject\", \"g\", \"glyph\", \"glyphRef\", \"hkern\", \"image\", \"line\", \"lineGradient\", \"marker\", \"mask\", \"metadata\", \"missing-glyph\", \"mpath\", \"path\", \"pattern\", \"polygon\", \"polyline\", \"radialGradient\", \"rect\", \"script\", \"set\", \"stop\", \"style\", \"svg\", \"switch\", \"symbol\", \"text\", \"textPath\", \"title\", \"tref\", \"tspan\", \"use\", \"view\", \"vkern\"], tE = function(t) {\n  return t && t.type && Go(t.type) && eE.indexOf(t.type) >= 0;\n}, nE = function(t) {\n  return t && Cc(t) === \"object\" && \"cx\" in t && \"cy\" in t && \"r\" in t;\n}, rE = function(t, n, r, i) {\n  var o, a = (o = Au == null ? void 0 : Au[i]) !== null && o !== void 0 ? o : [];\n  return !pe(t) && (i && a.includes(n) || YC.includes(n)) || r && _f.includes(n);\n}, ye = function(t, n, r) {\n  if (!t || typeof t == \"function\" || typeof t == \"boolean\")\n    return null;\n  var i = t;\n  if (/* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.isValidElement)(t) && (i = t.props), !ci(i))\n    return null;\n  var o = {};\n  return Object.keys(i).forEach(function(a) {\n    var s;\n    rE((s = i) === null || s === void 0 ? void 0 : s[a], a, n, r) && (o[a] = i[a]);\n  }), o;\n}, Ec = function e(t, n) {\n  if (t === n)\n    return !0;\n  var r = react__WEBPACK_IMPORTED_MODULE_0__.Children.count(t);\n  if (r !== react__WEBPACK_IMPORTED_MODULE_0__.Children.count(n))\n    return !1;\n  if (r === 0)\n    return !0;\n  if (r === 1)\n    return _p(Array.isArray(t) ? t[0] : t, Array.isArray(n) ? n[0] : n);\n  for (var i = 0; i < r; i++) {\n    var o = t[i], a = n[i];\n    if (Array.isArray(o) || Array.isArray(a)) {\n      if (!e(o, a))\n        return !1;\n    } else if (!_p(o, a))\n      return !1;\n  }\n  return !0;\n}, _p = function(t, n) {\n  if (me(t) && me(n))\n    return !0;\n  if (!me(t) && !me(n)) {\n    var r = t.props || {}, i = r.children, o = xp(r, ZC), a = n.props || {}, s = a.children, u = xp(a, JC);\n    return i && s ? Rr(o, u) && Ec(i, s) : !i && !s ? Rr(o, u) : !1;\n  }\n  return !1;\n}, Ap = function(t, n) {\n  var r = [], i = {};\n  return Af(t).forEach(function(o, a) {\n    if (tE(o))\n      r.push(o);\n    else if (o) {\n      var s = Fn(o.type), u = n[s] || {}, c = u.handler, f = u.once;\n      if (c && (!f || !i[s])) {\n        var l = c(o, s, a);\n        r.push(l), i[s] = !0;\n      }\n    }\n  }), r;\n}, iE = function(t) {\n  var n = t && t.type;\n  return n && Sp[n] ? Sp[n] : null;\n}, oE = function(t, n) {\n  return Af(n).indexOf(t);\n}, aE = [\"children\", \"width\", \"height\", \"viewBox\", \"className\", \"style\", \"title\", \"desc\"];\nfunction Tc() {\n  return Tc = Object.assign ? Object.assign.bind() : function(e) {\n    for (var t = 1; t < arguments.length; t++) {\n      var n = arguments[t];\n      for (var r in n)\n        Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);\n    }\n    return e;\n  }, Tc.apply(this, arguments);\n}\nfunction sE(e, t) {\n  if (e == null)\n    return {};\n  var n = uE(e, t), r, i;\n  if (Object.getOwnPropertySymbols) {\n    var o = Object.getOwnPropertySymbols(e);\n    for (i = 0; i < o.length; i++)\n      r = o[i], !(t.indexOf(r) >= 0) && Object.prototype.propertyIsEnumerable.call(e, r) && (n[r] = e[r]);\n  }\n  return n;\n}\nfunction uE(e, t) {\n  if (e == null)\n    return {};\n  var n = {}, r = Object.keys(e), i, o;\n  for (o = 0; o < r.length; o++)\n    i = r[o], !(t.indexOf(i) >= 0) && (n[i] = e[i]);\n  return n;\n}\nfunction Mc(e) {\n  var t = e.children, n = e.width, r = e.height, i = e.viewBox, o = e.className, a = e.style, s = e.title, u = e.desc, c = sE(e, aE), f = i || {\n    width: n,\n    height: r,\n    x: 0,\n    y: 0\n  }, l = $e(\"recharts-surface\", o);\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"svg\", Tc({}, ye(c, !0, \"svg\"), {\n    className: l,\n    width: n,\n    height: r,\n    style: a,\n    viewBox: \"\".concat(f.x, \" \").concat(f.y, \" \").concat(f.width, \" \").concat(f.height)\n  }), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"title\", null, s), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"desc\", null, u), t);\n}\nvar cE = [\"children\", \"className\"];\nfunction Rc() {\n  return Rc = Object.assign ? Object.assign.bind() : function(e) {\n    for (var t = 1; t < arguments.length; t++) {\n      var n = arguments[t];\n      for (var r in n)\n        Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);\n    }\n    return e;\n  }, Rc.apply(this, arguments);\n}\nfunction lE(e, t) {\n  if (e == null)\n    return {};\n  var n = fE(e, t), r, i;\n  if (Object.getOwnPropertySymbols) {\n    var o = Object.getOwnPropertySymbols(e);\n    for (i = 0; i < o.length; i++)\n      r = o[i], !(t.indexOf(r) >= 0) && Object.prototype.propertyIsEnumerable.call(e, r) && (n[r] = e[r]);\n  }\n  return n;\n}\nfunction fE(e, t) {\n  if (e == null)\n    return {};\n  var n = {}, r = Object.keys(e), i, o;\n  for (o = 0; o < r.length; o++)\n    i = r[o], !(t.indexOf(i) >= 0) && (n[i] = e[i]);\n  return n;\n}\nvar We = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(function(e, t) {\n  var n = e.children, r = e.className, i = lE(e, cE), o = $e(\"recharts-layer\", r);\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"g\", Rc({\n    className: o\n  }, ye(i, !0), {\n    ref: t\n  }), n);\n}), dE = \"development\" !== \"production\", Fr = function(t, n) {\n  for (var r = arguments.length, i = new Array(r > 2 ? r - 2 : 0), o = 2; o < r; o++)\n    i[o - 2] = arguments[o];\n  if (dE && typeof console < \"u\" && console.warn && (n === void 0 && console.warn(\"LogUtils requires an error message argument\"), !t))\n    if (n === void 0)\n      console.warn(\"Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings.\");\n    else {\n      var a = 0;\n      console.warn(n.replace(/%s/g, function() {\n        return i[a++];\n      }));\n    }\n};\nfunction pE(e, t, n) {\n  var r = -1, i = e.length;\n  t < 0 && (t = -t > i ? 0 : i + t), n = n > i ? i : n, n < 0 && (n += i), i = t > n ? 0 : n - t >>> 0, t >>>= 0;\n  for (var o = Array(i); ++r < i; )\n    o[r] = e[r + t];\n  return o;\n}\nvar hE = pE, gE = hE;\nfunction vE(e, t, n) {\n  var r = e.length;\n  return n = n === void 0 ? r : n, !t && n >= r ? e : gE(e, t, n);\n}\nvar mE = vE, yE = \"\\\\ud800-\\\\udfff\", bE = \"\\\\u0300-\\\\u036f\", wE = \"\\\\ufe20-\\\\ufe2f\", xE = \"\\\\u20d0-\\\\u20ff\", SE = bE + wE + xE, $E = \"\\\\ufe0e\\\\ufe0f\", OE = \"\\\\u200d\", _E = RegExp(\"[\" + OE + yE + SE + $E + \"]\");\nfunction AE(e) {\n  return _E.test(e);\n}\nvar Vy = AE;\nfunction PE(e) {\n  return e.split(\"\");\n}\nvar CE = PE, Gy = \"\\\\ud800-\\\\udfff\", EE = \"\\\\u0300-\\\\u036f\", TE = \"\\\\ufe20-\\\\ufe2f\", ME = \"\\\\u20d0-\\\\u20ff\", RE = EE + TE + ME, IE = \"\\\\ufe0e\\\\ufe0f\", jE = \"[\" + Gy + \"]\", Ic = \"[\" + RE + \"]\", jc = \"\\\\ud83c[\\\\udffb-\\\\udfff]\", kE = \"(?:\" + Ic + \"|\" + jc + \")\", Wy = \"[^\" + Gy + \"]\", Uy = \"(?:\\\\ud83c[\\\\udde6-\\\\uddff]){2}\", Hy = \"[\\\\ud800-\\\\udbff][\\\\udc00-\\\\udfff]\", DE = \"\\\\u200d\", qy = kE + \"?\", Ky = \"[\" + IE + \"]?\", NE = \"(?:\" + DE + \"(?:\" + [Wy, Uy, Hy].join(\"|\") + \")\" + Ky + qy + \")*\", FE = Ky + qy + NE, LE = \"(?:\" + [Wy + Ic + \"?\", Ic, Uy, Hy, jE].join(\"|\") + \")\", BE = RegExp(jc + \"(?=\" + jc + \")|\" + LE + FE, \"g\");\nfunction zE(e) {\n  return e.match(BE) || [];\n}\nvar VE = zE, GE = CE, WE = Vy, UE = VE;\nfunction HE(e) {\n  return WE(e) ? UE(e) : GE(e);\n}\nvar qE = HE, KE = mE, YE = Vy, XE = qE, ZE = Fy;\nfunction JE(e) {\n  return function(t) {\n    t = ZE(t);\n    var n = YE(t) ? XE(t) : void 0, r = n ? n[0] : t.charAt(0), i = n ? KE(n, 1).join(\"\") : t.slice(1);\n    return r[e]() + i;\n  };\n}\nvar QE = JE, eT = QE, tT = eT(\"toUpperCase\"), nT = tT;\nconst Bs = /* @__PURE__ */ je(nT);\nfunction Ie(e) {\n  return function() {\n    return e;\n  };\n}\nconst Yy = Math.cos, La = Math.sin, Qt = Math.sqrt, Ba = Math.PI, zs = 2 * Ba, kc = Math.PI, Dc = 2 * kc, Qn = 1e-6, rT = Dc - Qn;\nfunction Xy(e) {\n  this._ += e[0];\n  for (let t = 1, n = e.length; t < n; ++t)\n    this._ += arguments[t] + e[t];\n}\nfunction iT(e) {\n  let t = Math.floor(e);\n  if (!(t >= 0))\n    throw new Error(`invalid digits: ${e}`);\n  if (t > 15)\n    return Xy;\n  const n = 10 ** t;\n  return function(r) {\n    this._ += r[0];\n    for (let i = 1, o = r.length; i < o; ++i)\n      this._ += Math.round(arguments[i] * n) / n + r[i];\n  };\n}\nclass oT {\n  constructor(t) {\n    this._x0 = this._y0 = // start of current subpath\n    this._x1 = this._y1 = null, this._ = \"\", this._append = t == null ? Xy : iT(t);\n  }\n  moveTo(t, n) {\n    this._append`M${this._x0 = this._x1 = +t},${this._y0 = this._y1 = +n}`;\n  }\n  closePath() {\n    this._x1 !== null && (this._x1 = this._x0, this._y1 = this._y0, this._append`Z`);\n  }\n  lineTo(t, n) {\n    this._append`L${this._x1 = +t},${this._y1 = +n}`;\n  }\n  quadraticCurveTo(t, n, r, i) {\n    this._append`Q${+t},${+n},${this._x1 = +r},${this._y1 = +i}`;\n  }\n  bezierCurveTo(t, n, r, i, o, a) {\n    this._append`C${+t},${+n},${+r},${+i},${this._x1 = +o},${this._y1 = +a}`;\n  }\n  arcTo(t, n, r, i, o) {\n    if (t = +t, n = +n, r = +r, i = +i, o = +o, o < 0)\n      throw new Error(`negative radius: ${o}`);\n    let a = this._x1, s = this._y1, u = r - t, c = i - n, f = a - t, l = s - n, d = f * f + l * l;\n    if (this._x1 === null)\n      this._append`M${this._x1 = t},${this._y1 = n}`;\n    else if (d > Qn)\n      if (!(Math.abs(l * u - c * f) > Qn) || !o)\n        this._append`L${this._x1 = t},${this._y1 = n}`;\n      else {\n        let p = r - a, g = i - s, h = u * u + c * c, v = p * p + g * g, w = Math.sqrt(h), b = Math.sqrt(d), x = o * Math.tan((kc - Math.acos((h + d - v) / (2 * w * b))) / 2), m = x / b, y = x / w;\n        Math.abs(m - 1) > Qn && this._append`L${t + m * f},${n + m * l}`, this._append`A${o},${o},0,0,${+(l * p > f * g)},${this._x1 = t + y * u},${this._y1 = n + y * c}`;\n      }\n  }\n  arc(t, n, r, i, o, a) {\n    if (t = +t, n = +n, r = +r, a = !!a, r < 0)\n      throw new Error(`negative radius: ${r}`);\n    let s = r * Math.cos(i), u = r * Math.sin(i), c = t + s, f = n + u, l = 1 ^ a, d = a ? i - o : o - i;\n    this._x1 === null ? this._append`M${c},${f}` : (Math.abs(this._x1 - c) > Qn || Math.abs(this._y1 - f) > Qn) && this._append`L${c},${f}`, r && (d < 0 && (d = d % Dc + Dc), d > rT ? this._append`A${r},${r},0,1,${l},${t - s},${n - u}A${r},${r},0,1,${l},${this._x1 = c},${this._y1 = f}` : d > Qn && this._append`A${r},${r},0,${+(d >= kc)},${l},${this._x1 = t + r * Math.cos(o)},${this._y1 = n + r * Math.sin(o)}`);\n  }\n  rect(t, n, r, i) {\n    this._append`M${this._x0 = this._x1 = +t},${this._y0 = this._y1 = +n}h${r = +r}v${+i}h${-r}Z`;\n  }\n  toString() {\n    return this._;\n  }\n}\nfunction Pf(e) {\n  let t = 3;\n  return e.digits = function(n) {\n    if (!arguments.length)\n      return t;\n    if (n == null)\n      t = null;\n    else {\n      const r = Math.floor(n);\n      if (!(r >= 0))\n        throw new RangeError(`invalid digits: ${n}`);\n      t = r;\n    }\n    return e;\n  }, () => new oT(t);\n}\nfunction Cf(e) {\n  return typeof e == \"object\" && \"length\" in e ? e : Array.from(e);\n}\nfunction Zy(e) {\n  this._context = e;\n}\nZy.prototype = {\n  areaStart: function() {\n    this._line = 0;\n  },\n  areaEnd: function() {\n    this._line = NaN;\n  },\n  lineStart: function() {\n    this._point = 0;\n  },\n  lineEnd: function() {\n    (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line;\n  },\n  point: function(e, t) {\n    switch (e = +e, t = +t, this._point) {\n      case 0:\n        this._point = 1, this._line ? this._context.lineTo(e, t) : this._context.moveTo(e, t);\n        break;\n      case 1:\n        this._point = 2;\n      default:\n        this._context.lineTo(e, t);\n        break;\n    }\n  }\n};\nfunction Vs(e) {\n  return new Zy(e);\n}\nfunction Jy(e) {\n  return e[0];\n}\nfunction Qy(e) {\n  return e[1];\n}\nfunction eb(e, t) {\n  var n = Ie(!0), r = null, i = Vs, o = null, a = Pf(s);\n  e = typeof e == \"function\" ? e : e === void 0 ? Jy : Ie(e), t = typeof t == \"function\" ? t : t === void 0 ? Qy : Ie(t);\n  function s(u) {\n    var c, f = (u = Cf(u)).length, l, d = !1, p;\n    for (r == null && (o = i(p = a())), c = 0; c <= f; ++c)\n      !(c < f && n(l = u[c], c, u)) === d && ((d = !d) ? o.lineStart() : o.lineEnd()), d && o.point(+e(l, c, u), +t(l, c, u));\n    if (p)\n      return o = null, p + \"\" || null;\n  }\n  return s.x = function(u) {\n    return arguments.length ? (e = typeof u == \"function\" ? u : Ie(+u), s) : e;\n  }, s.y = function(u) {\n    return arguments.length ? (t = typeof u == \"function\" ? u : Ie(+u), s) : t;\n  }, s.defined = function(u) {\n    return arguments.length ? (n = typeof u == \"function\" ? u : Ie(!!u), s) : n;\n  }, s.curve = function(u) {\n    return arguments.length ? (i = u, r != null && (o = i(r)), s) : i;\n  }, s.context = function(u) {\n    return arguments.length ? (u == null ? r = o = null : o = i(r = u), s) : r;\n  }, s;\n}\nfunction la(e, t, n) {\n  var r = null, i = Ie(!0), o = null, a = Vs, s = null, u = Pf(c);\n  e = typeof e == \"function\" ? e : e === void 0 ? Jy : Ie(+e), t = typeof t == \"function\" ? t : Ie(t === void 0 ? 0 : +t), n = typeof n == \"function\" ? n : n === void 0 ? Qy : Ie(+n);\n  function c(l) {\n    var d, p, g, h = (l = Cf(l)).length, v, w = !1, b, x = new Array(h), m = new Array(h);\n    for (o == null && (s = a(b = u())), d = 0; d <= h; ++d) {\n      if (!(d < h && i(v = l[d], d, l)) === w)\n        if (w = !w)\n          p = d, s.areaStart(), s.lineStart();\n        else {\n          for (s.lineEnd(), s.lineStart(), g = d - 1; g >= p; --g)\n            s.point(x[g], m[g]);\n          s.lineEnd(), s.areaEnd();\n        }\n      w && (x[d] = +e(v, d, l), m[d] = +t(v, d, l), s.point(r ? +r(v, d, l) : x[d], n ? +n(v, d, l) : m[d]));\n    }\n    if (b)\n      return s = null, b + \"\" || null;\n  }\n  function f() {\n    return eb().defined(i).curve(a).context(o);\n  }\n  return c.x = function(l) {\n    return arguments.length ? (e = typeof l == \"function\" ? l : Ie(+l), r = null, c) : e;\n  }, c.x0 = function(l) {\n    return arguments.length ? (e = typeof l == \"function\" ? l : Ie(+l), c) : e;\n  }, c.x1 = function(l) {\n    return arguments.length ? (r = l == null ? null : typeof l == \"function\" ? l : Ie(+l), c) : r;\n  }, c.y = function(l) {\n    return arguments.length ? (t = typeof l == \"function\" ? l : Ie(+l), n = null, c) : t;\n  }, c.y0 = function(l) {\n    return arguments.length ? (t = typeof l == \"function\" ? l : Ie(+l), c) : t;\n  }, c.y1 = function(l) {\n    return arguments.length ? (n = l == null ? null : typeof l == \"function\" ? l : Ie(+l), c) : n;\n  }, c.lineX0 = c.lineY0 = function() {\n    return f().x(e).y(t);\n  }, c.lineY1 = function() {\n    return f().x(e).y(n);\n  }, c.lineX1 = function() {\n    return f().x(r).y(t);\n  }, c.defined = function(l) {\n    return arguments.length ? (i = typeof l == \"function\" ? l : Ie(!!l), c) : i;\n  }, c.curve = function(l) {\n    return arguments.length ? (a = l, o != null && (s = a(o)), c) : a;\n  }, c.context = function(l) {\n    return arguments.length ? (l == null ? o = s = null : s = a(o = l), c) : o;\n  }, c;\n}\nclass tb {\n  constructor(t, n) {\n    this._context = t, this._x = n;\n  }\n  areaStart() {\n    this._line = 0;\n  }\n  areaEnd() {\n    this._line = NaN;\n  }\n  lineStart() {\n    this._point = 0;\n  }\n  lineEnd() {\n    (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line;\n  }\n  point(t, n) {\n    switch (t = +t, n = +n, this._point) {\n      case 0: {\n        this._point = 1, this._line ? this._context.lineTo(t, n) : this._context.moveTo(t, n);\n        break;\n      }\n      case 1:\n        this._point = 2;\n      default: {\n        this._x ? this._context.bezierCurveTo(this._x0 = (this._x0 + t) / 2, this._y0, this._x0, n, t, n) : this._context.bezierCurveTo(this._x0, this._y0 = (this._y0 + n) / 2, t, this._y0, t, n);\n        break;\n      }\n    }\n    this._x0 = t, this._y0 = n;\n  }\n}\nfunction aT(e) {\n  return new tb(e, !0);\n}\nfunction sT(e) {\n  return new tb(e, !1);\n}\nconst Ef = {\n  draw(e, t) {\n    const n = Qt(t / Ba);\n    e.moveTo(n, 0), e.arc(0, 0, n, 0, zs);\n  }\n}, uT = {\n  draw(e, t) {\n    const n = Qt(t / 5) / 2;\n    e.moveTo(-3 * n, -n), e.lineTo(-n, -n), e.lineTo(-n, -3 * n), e.lineTo(n, -3 * n), e.lineTo(n, -n), e.lineTo(3 * n, -n), e.lineTo(3 * n, n), e.lineTo(n, n), e.lineTo(n, 3 * n), e.lineTo(-n, 3 * n), e.lineTo(-n, n), e.lineTo(-3 * n, n), e.closePath();\n  }\n}, nb = Qt(1 / 3), cT = nb * 2, lT = {\n  draw(e, t) {\n    const n = Qt(t / cT), r = n * nb;\n    e.moveTo(0, -n), e.lineTo(r, 0), e.lineTo(0, n), e.lineTo(-r, 0), e.closePath();\n  }\n}, fT = {\n  draw(e, t) {\n    const n = Qt(t), r = -n / 2;\n    e.rect(r, r, n, n);\n  }\n}, dT = 0.8908130915292852, rb = La(Ba / 10) / La(7 * Ba / 10), pT = La(zs / 10) * rb, hT = -Yy(zs / 10) * rb, gT = {\n  draw(e, t) {\n    const n = Qt(t * dT), r = pT * n, i = hT * n;\n    e.moveTo(0, -n), e.lineTo(r, i);\n    for (let o = 1; o < 5; ++o) {\n      const a = zs * o / 5, s = Yy(a), u = La(a);\n      e.lineTo(u * n, -s * n), e.lineTo(s * r - u * i, u * r + s * i);\n    }\n    e.closePath();\n  }\n}, Cu = Qt(3), vT = {\n  draw(e, t) {\n    const n = -Qt(t / (Cu * 3));\n    e.moveTo(0, n * 2), e.lineTo(-Cu * n, -n), e.lineTo(Cu * n, -n), e.closePath();\n  }\n}, Et = -0.5, Tt = Qt(3) / 2, Nc = 1 / Qt(12), mT = (Nc / 2 + 1) * 3, yT = {\n  draw(e, t) {\n    const n = Qt(t / mT), r = n / 2, i = n * Nc, o = r, a = n * Nc + n, s = -o, u = a;\n    e.moveTo(r, i), e.lineTo(o, a), e.lineTo(s, u), e.lineTo(Et * r - Tt * i, Tt * r + Et * i), e.lineTo(Et * o - Tt * a, Tt * o + Et * a), e.lineTo(Et * s - Tt * u, Tt * s + Et * u), e.lineTo(Et * r + Tt * i, Et * i - Tt * r), e.lineTo(Et * o + Tt * a, Et * a - Tt * o), e.lineTo(Et * s + Tt * u, Et * u - Tt * s), e.closePath();\n  }\n};\nfunction bT(e, t) {\n  let n = null, r = Pf(i);\n  e = typeof e == \"function\" ? e : Ie(e || Ef), t = typeof t == \"function\" ? t : Ie(t === void 0 ? 64 : +t);\n  function i() {\n    let o;\n    if (n || (n = o = r()), e.apply(this, arguments).draw(n, +t.apply(this, arguments)), o)\n      return n = null, o + \"\" || null;\n  }\n  return i.type = function(o) {\n    return arguments.length ? (e = typeof o == \"function\" ? o : Ie(o), i) : e;\n  }, i.size = function(o) {\n    return arguments.length ? (t = typeof o == \"function\" ? o : Ie(+o), i) : t;\n  }, i.context = function(o) {\n    return arguments.length ? (n = o ?? null, i) : n;\n  }, i;\n}\nfunction za() {\n}\nfunction Va(e, t, n) {\n  e._context.bezierCurveTo(\n    (2 * e._x0 + e._x1) / 3,\n    (2 * e._y0 + e._y1) / 3,\n    (e._x0 + 2 * e._x1) / 3,\n    (e._y0 + 2 * e._y1) / 3,\n    (e._x0 + 4 * e._x1 + t) / 6,\n    (e._y0 + 4 * e._y1 + n) / 6\n  );\n}\nfunction ib(e) {\n  this._context = e;\n}\nib.prototype = {\n  areaStart: function() {\n    this._line = 0;\n  },\n  areaEnd: function() {\n    this._line = NaN;\n  },\n  lineStart: function() {\n    this._x0 = this._x1 = this._y0 = this._y1 = NaN, this._point = 0;\n  },\n  lineEnd: function() {\n    switch (this._point) {\n      case 3:\n        Va(this, this._x1, this._y1);\n      case 2:\n        this._context.lineTo(this._x1, this._y1);\n        break;\n    }\n    (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line;\n  },\n  point: function(e, t) {\n    switch (e = +e, t = +t, this._point) {\n      case 0:\n        this._point = 1, this._line ? this._context.lineTo(e, t) : this._context.moveTo(e, t);\n        break;\n      case 1:\n        this._point = 2;\n        break;\n      case 2:\n        this._point = 3, this._context.lineTo((5 * this._x0 + this._x1) / 6, (5 * this._y0 + this._y1) / 6);\n      default:\n        Va(this, e, t);\n        break;\n    }\n    this._x0 = this._x1, this._x1 = e, this._y0 = this._y1, this._y1 = t;\n  }\n};\nfunction wT(e) {\n  return new ib(e);\n}\nfunction ob(e) {\n  this._context = e;\n}\nob.prototype = {\n  areaStart: za,\n  areaEnd: za,\n  lineStart: function() {\n    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = NaN, this._point = 0;\n  },\n  lineEnd: function() {\n    switch (this._point) {\n      case 1: {\n        this._context.moveTo(this._x2, this._y2), this._context.closePath();\n        break;\n      }\n      case 2: {\n        this._context.moveTo((this._x2 + 2 * this._x3) / 3, (this._y2 + 2 * this._y3) / 3), this._context.lineTo((this._x3 + 2 * this._x2) / 3, (this._y3 + 2 * this._y2) / 3), this._context.closePath();\n        break;\n      }\n      case 3: {\n        this.point(this._x2, this._y2), this.point(this._x3, this._y3), this.point(this._x4, this._y4);\n        break;\n      }\n    }\n  },\n  point: function(e, t) {\n    switch (e = +e, t = +t, this._point) {\n      case 0:\n        this._point = 1, this._x2 = e, this._y2 = t;\n        break;\n      case 1:\n        this._point = 2, this._x3 = e, this._y3 = t;\n        break;\n      case 2:\n        this._point = 3, this._x4 = e, this._y4 = t, this._context.moveTo((this._x0 + 4 * this._x1 + e) / 6, (this._y0 + 4 * this._y1 + t) / 6);\n        break;\n      default:\n        Va(this, e, t);\n        break;\n    }\n    this._x0 = this._x1, this._x1 = e, this._y0 = this._y1, this._y1 = t;\n  }\n};\nfunction xT(e) {\n  return new ob(e);\n}\nfunction ab(e) {\n  this._context = e;\n}\nab.prototype = {\n  areaStart: function() {\n    this._line = 0;\n  },\n  areaEnd: function() {\n    this._line = NaN;\n  },\n  lineStart: function() {\n    this._x0 = this._x1 = this._y0 = this._y1 = NaN, this._point = 0;\n  },\n  lineEnd: function() {\n    (this._line || this._line !== 0 && this._point === 3) && this._context.closePath(), this._line = 1 - this._line;\n  },\n  point: function(e, t) {\n    switch (e = +e, t = +t, this._point) {\n      case 0:\n        this._point = 1;\n        break;\n      case 1:\n        this._point = 2;\n        break;\n      case 2:\n        this._point = 3;\n        var n = (this._x0 + 4 * this._x1 + e) / 6, r = (this._y0 + 4 * this._y1 + t) / 6;\n        this._line ? this._context.lineTo(n, r) : this._context.moveTo(n, r);\n        break;\n      case 3:\n        this._point = 4;\n      default:\n        Va(this, e, t);\n        break;\n    }\n    this._x0 = this._x1, this._x1 = e, this._y0 = this._y1, this._y1 = t;\n  }\n};\nfunction ST(e) {\n  return new ab(e);\n}\nfunction sb(e) {\n  this._context = e;\n}\nsb.prototype = {\n  areaStart: za,\n  areaEnd: za,\n  lineStart: function() {\n    this._point = 0;\n  },\n  lineEnd: function() {\n    this._point && this._context.closePath();\n  },\n  point: function(e, t) {\n    e = +e, t = +t, this._point ? this._context.lineTo(e, t) : (this._point = 1, this._context.moveTo(e, t));\n  }\n};\nfunction $T(e) {\n  return new sb(e);\n}\nfunction Pp(e) {\n  return e < 0 ? -1 : 1;\n}\nfunction Cp(e, t, n) {\n  var r = e._x1 - e._x0, i = t - e._x1, o = (e._y1 - e._y0) / (r || i < 0 && -0), a = (n - e._y1) / (i || r < 0 && -0), s = (o * i + a * r) / (r + i);\n  return (Pp(o) + Pp(a)) * Math.min(Math.abs(o), Math.abs(a), 0.5 * Math.abs(s)) || 0;\n}\nfunction Ep(e, t) {\n  var n = e._x1 - e._x0;\n  return n ? (3 * (e._y1 - e._y0) / n - t) / 2 : t;\n}\nfunction Eu(e, t, n) {\n  var r = e._x0, i = e._y0, o = e._x1, a = e._y1, s = (o - r) / 3;\n  e._context.bezierCurveTo(r + s, i + s * t, o - s, a - s * n, o, a);\n}\nfunction Ga(e) {\n  this._context = e;\n}\nGa.prototype = {\n  areaStart: function() {\n    this._line = 0;\n  },\n  areaEnd: function() {\n    this._line = NaN;\n  },\n  lineStart: function() {\n    this._x0 = this._x1 = this._y0 = this._y1 = this._t0 = NaN, this._point = 0;\n  },\n  lineEnd: function() {\n    switch (this._point) {\n      case 2:\n        this._context.lineTo(this._x1, this._y1);\n        break;\n      case 3:\n        Eu(this, this._t0, Ep(this, this._t0));\n        break;\n    }\n    (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line;\n  },\n  point: function(e, t) {\n    var n = NaN;\n    if (e = +e, t = +t, !(e === this._x1 && t === this._y1)) {\n      switch (this._point) {\n        case 0:\n          this._point = 1, this._line ? this._context.lineTo(e, t) : this._context.moveTo(e, t);\n          break;\n        case 1:\n          this._point = 2;\n          break;\n        case 2:\n          this._point = 3, Eu(this, Ep(this, n = Cp(this, e, t)), n);\n          break;\n        default:\n          Eu(this, this._t0, n = Cp(this, e, t));\n          break;\n      }\n      this._x0 = this._x1, this._x1 = e, this._y0 = this._y1, this._y1 = t, this._t0 = n;\n    }\n  }\n};\nfunction ub(e) {\n  this._context = new cb(e);\n}\n(ub.prototype = Object.create(Ga.prototype)).point = function(e, t) {\n  Ga.prototype.point.call(this, t, e);\n};\nfunction cb(e) {\n  this._context = e;\n}\ncb.prototype = {\n  moveTo: function(e, t) {\n    this._context.moveTo(t, e);\n  },\n  closePath: function() {\n    this._context.closePath();\n  },\n  lineTo: function(e, t) {\n    this._context.lineTo(t, e);\n  },\n  bezierCurveTo: function(e, t, n, r, i, o) {\n    this._context.bezierCurveTo(t, e, r, n, o, i);\n  }\n};\nfunction OT(e) {\n  return new Ga(e);\n}\nfunction _T(e) {\n  return new ub(e);\n}\nfunction lb(e) {\n  this._context = e;\n}\nlb.prototype = {\n  areaStart: function() {\n    this._line = 0;\n  },\n  areaEnd: function() {\n    this._line = NaN;\n  },\n  lineStart: function() {\n    this._x = [], this._y = [];\n  },\n  lineEnd: function() {\n    var e = this._x, t = this._y, n = e.length;\n    if (n)\n      if (this._line ? this._context.lineTo(e[0], t[0]) : this._context.moveTo(e[0], t[0]), n === 2)\n        this._context.lineTo(e[1], t[1]);\n      else\n        for (var r = Tp(e), i = Tp(t), o = 0, a = 1; a < n; ++o, ++a)\n          this._context.bezierCurveTo(r[0][o], i[0][o], r[1][o], i[1][o], e[a], t[a]);\n    (this._line || this._line !== 0 && n === 1) && this._context.closePath(), this._line = 1 - this._line, this._x = this._y = null;\n  },\n  point: function(e, t) {\n    this._x.push(+e), this._y.push(+t);\n  }\n};\nfunction Tp(e) {\n  var t, n = e.length - 1, r, i = new Array(n), o = new Array(n), a = new Array(n);\n  for (i[0] = 0, o[0] = 2, a[0] = e[0] + 2 * e[1], t = 1; t < n - 1; ++t)\n    i[t] = 1, o[t] = 4, a[t] = 4 * e[t] + 2 * e[t + 1];\n  for (i[n - 1] = 2, o[n - 1] = 7, a[n - 1] = 8 * e[n - 1] + e[n], t = 1; t < n; ++t)\n    r = i[t] / o[t - 1], o[t] -= r, a[t] -= r * a[t - 1];\n  for (i[n - 1] = a[n - 1] / o[n - 1], t = n - 2; t >= 0; --t)\n    i[t] = (a[t] - i[t + 1]) / o[t];\n  for (o[n - 1] = (e[n] + i[n - 1]) / 2, t = 0; t < n - 1; ++t)\n    o[t] = 2 * e[t + 1] - i[t + 1];\n  return [i, o];\n}\nfunction AT(e) {\n  return new lb(e);\n}\nfunction Gs(e, t) {\n  this._context = e, this._t = t;\n}\nGs.prototype = {\n  areaStart: function() {\n    this._line = 0;\n  },\n  areaEnd: function() {\n    this._line = NaN;\n  },\n  lineStart: function() {\n    this._x = this._y = NaN, this._point = 0;\n  },\n  lineEnd: function() {\n    0 < this._t && this._t < 1 && this._point === 2 && this._context.lineTo(this._x, this._y), (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line >= 0 && (this._t = 1 - this._t, this._line = 1 - this._line);\n  },\n  point: function(e, t) {\n    switch (e = +e, t = +t, this._point) {\n      case 0:\n        this._point = 1, this._line ? this._context.lineTo(e, t) : this._context.moveTo(e, t);\n        break;\n      case 1:\n        this._point = 2;\n      default: {\n        if (this._t <= 0)\n          this._context.lineTo(this._x, t), this._context.lineTo(e, t);\n        else {\n          var n = this._x * (1 - this._t) + e * this._t;\n          this._context.lineTo(n, this._y), this._context.lineTo(n, t);\n        }\n        break;\n      }\n    }\n    this._x = e, this._y = t;\n  }\n};\nfunction PT(e) {\n  return new Gs(e, 0.5);\n}\nfunction CT(e) {\n  return new Gs(e, 0);\n}\nfunction ET(e) {\n  return new Gs(e, 1);\n}\nfunction Lr(e, t) {\n  if ((a = e.length) > 1)\n    for (var n = 1, r, i, o = e[t[0]], a, s = o.length; n < a; ++n)\n      for (i = o, o = e[t[n]], r = 0; r < s; ++r)\n        o[r][1] += o[r][0] = isNaN(i[r][1]) ? i[r][0] : i[r][1];\n}\nfunction Fc(e) {\n  for (var t = e.length, n = new Array(t); --t >= 0; )\n    n[t] = t;\n  return n;\n}\nfunction TT(e, t) {\n  return e[t];\n}\nfunction MT(e) {\n  const t = [];\n  return t.key = e, t;\n}\nfunction RT() {\n  var e = Ie([]), t = Fc, n = Lr, r = TT;\n  function i(o) {\n    var a = Array.from(e.apply(this, arguments), MT), s, u = a.length, c = -1, f;\n    for (const l of o)\n      for (s = 0, ++c; s < u; ++s)\n        (a[s][c] = [0, +r(l, a[s].key, c, o)]).data = l;\n    for (s = 0, f = Cf(t(a)); s < u; ++s)\n      a[f[s]].index = s;\n    return n(a, f), a;\n  }\n  return i.keys = function(o) {\n    return arguments.length ? (e = typeof o == \"function\" ? o : Ie(Array.from(o)), i) : e;\n  }, i.value = function(o) {\n    return arguments.length ? (r = typeof o == \"function\" ? o : Ie(+o), i) : r;\n  }, i.order = function(o) {\n    return arguments.length ? (t = o == null ? Fc : typeof o == \"function\" ? o : Ie(Array.from(o)), i) : t;\n  }, i.offset = function(o) {\n    return arguments.length ? (n = o ?? Lr, i) : n;\n  }, i;\n}\nfunction IT(e, t) {\n  if ((r = e.length) > 0) {\n    for (var n, r, i = 0, o = e[0].length, a; i < o; ++i) {\n      for (a = n = 0; n < r; ++n)\n        a += e[n][i][1] || 0;\n      if (a)\n        for (n = 0; n < r; ++n)\n          e[n][i][1] /= a;\n    }\n    Lr(e, t);\n  }\n}\nfunction jT(e, t) {\n  if ((i = e.length) > 0) {\n    for (var n = 0, r = e[t[0]], i, o = r.length; n < o; ++n) {\n      for (var a = 0, s = 0; a < i; ++a)\n        s += e[a][n][1] || 0;\n      r[n][1] += r[n][0] = -s / 2;\n    }\n    Lr(e, t);\n  }\n}\nfunction kT(e, t) {\n  if (!(!((a = e.length) > 0) || !((o = (i = e[t[0]]).length) > 0))) {\n    for (var n = 0, r = 1, i, o, a; r < o; ++r) {\n      for (var s = 0, u = 0, c = 0; s < a; ++s) {\n        for (var f = e[t[s]], l = f[r][1] || 0, d = f[r - 1][1] || 0, p = (l - d) / 2, g = 0; g < s; ++g) {\n          var h = e[t[g]], v = h[r][1] || 0, w = h[r - 1][1] || 0;\n          p += v - w;\n        }\n        u += l, c += p * l;\n      }\n      i[r - 1][1] += i[r - 1][0] = n, u && (n -= c / u);\n    }\n    i[r - 1][1] += i[r - 1][0] = n, Lr(e, t);\n  }\n}\nfunction to(e) {\n  \"@babel/helpers - typeof\";\n  return to = typeof Symbol == \"function\" && typeof Symbol.iterator == \"symbol\" ? function(t) {\n    return typeof t;\n  } : function(t) {\n    return t && typeof Symbol == \"function\" && t.constructor === Symbol && t !== Symbol.prototype ? \"symbol\" : typeof t;\n  }, to(e);\n}\nvar DT = [\"type\", \"size\", \"sizeType\"];\nfunction Lc() {\n  return Lc = Object.assign ? Object.assign.bind() : function(e) {\n    for (var t = 1; t < arguments.length; t++) {\n      var n = arguments[t];\n      for (var r in n)\n        Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);\n    }\n    return e;\n  }, Lc.apply(this, arguments);\n}\nfunction Mp(e, t) {\n  var n = Object.keys(e);\n  if (Object.getOwnPropertySymbols) {\n    var r = Object.getOwnPropertySymbols(e);\n    t && (r = r.filter(function(i) {\n      return Object.getOwnPropertyDescriptor(e, i).enumerable;\n    })), n.push.apply(n, r);\n  }\n  return n;\n}\nfunction Rp(e) {\n  for (var t = 1; t < arguments.length; t++) {\n    var n = arguments[t] != null ? arguments[t] : {};\n    t % 2 ? Mp(Object(n), !0).forEach(function(r) {\n      NT(e, r, n[r]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Mp(Object(n)).forEach(function(r) {\n      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));\n    });\n  }\n  return e;\n}\nfunction NT(e, t, n) {\n  return t = FT(t), t in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;\n}\nfunction FT(e) {\n  var t = LT(e, \"string\");\n  return to(t) == \"symbol\" ? t : String(t);\n}\nfunction LT(e, t) {\n  if (to(e) != \"object\" || !e)\n    return e;\n  var n = e[Symbol.toPrimitive];\n  if (n !== void 0) {\n    var r = n.call(e, t || \"default\");\n    if (to(r) != \"object\")\n      return r;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (t === \"string\" ? String : Number)(e);\n}\nfunction BT(e, t) {\n  if (e == null)\n    return {};\n  var n = zT(e, t), r, i;\n  if (Object.getOwnPropertySymbols) {\n    var o = Object.getOwnPropertySymbols(e);\n    for (i = 0; i < o.length; i++)\n      r = o[i], !(t.indexOf(r) >= 0) && Object.prototype.propertyIsEnumerable.call(e, r) && (n[r] = e[r]);\n  }\n  return n;\n}\nfunction zT(e, t) {\n  if (e == null)\n    return {};\n  var n = {}, r = Object.keys(e), i, o;\n  for (o = 0; o < r.length; o++)\n    i = r[o], !(t.indexOf(i) >= 0) && (n[i] = e[i]);\n  return n;\n}\nvar fb = {\n  symbolCircle: Ef,\n  symbolCross: uT,\n  symbolDiamond: lT,\n  symbolSquare: fT,\n  symbolStar: gT,\n  symbolTriangle: vT,\n  symbolWye: yT\n}, VT = Math.PI / 180, GT = function(t) {\n  var n = \"symbol\".concat(Bs(t));\n  return fb[n] || Ef;\n}, WT = function(t, n, r) {\n  if (n === \"area\")\n    return t;\n  switch (r) {\n    case \"cross\":\n      return 5 * t * t / 9;\n    case \"diamond\":\n      return 0.5 * t * t / Math.sqrt(3);\n    case \"square\":\n      return t * t;\n    case \"star\": {\n      var i = 18 * VT;\n      return 1.25 * t * t * (Math.tan(i) - Math.tan(i * 2) * Math.pow(Math.tan(i), 2));\n    }\n    case \"triangle\":\n      return Math.sqrt(3) * t * t / 4;\n    case \"wye\":\n      return (21 - 10 * Math.sqrt(3)) * t * t / 8;\n    default:\n      return Math.PI * t * t / 4;\n  }\n}, UT = function(t, n) {\n  fb[\"symbol\".concat(Bs(t))] = n;\n}, Tf = function(t) {\n  var n = t.type, r = n === void 0 ? \"circle\" : n, i = t.size, o = i === void 0 ? 64 : i, a = t.sizeType, s = a === void 0 ? \"area\" : a, u = BT(t, DT), c = Rp(Rp({}, u), {}, {\n    type: r,\n    size: o,\n    sizeType: s\n  }), f = function() {\n    var v = GT(r), w = bT().type(v).size(WT(o, s, r));\n    return w();\n  }, l = c.className, d = c.cx, p = c.cy, g = ye(c, !0);\n  return d === +d && p === +p && o === +o ? /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"path\", Lc({}, g, {\n    className: $e(\"recharts-symbols\", l),\n    transform: \"translate(\".concat(d, \", \").concat(p, \")\"),\n    d: f()\n  })) : null;\n};\nTf.registerSymbol = UT;\nfunction Br(e) {\n  \"@babel/helpers - typeof\";\n  return Br = typeof Symbol == \"function\" && typeof Symbol.iterator == \"symbol\" ? function(t) {\n    return typeof t;\n  } : function(t) {\n    return t && typeof Symbol == \"function\" && t.constructor === Symbol && t !== Symbol.prototype ? \"symbol\" : typeof t;\n  }, Br(e);\n}\nfunction Bc() {\n  return Bc = Object.assign ? Object.assign.bind() : function(e) {\n    for (var t = 1; t < arguments.length; t++) {\n      var n = arguments[t];\n      for (var r in n)\n        Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);\n    }\n    return e;\n  }, Bc.apply(this, arguments);\n}\nfunction Ip(e, t) {\n  var n = Object.keys(e);\n  if (Object.getOwnPropertySymbols) {\n    var r = Object.getOwnPropertySymbols(e);\n    t && (r = r.filter(function(i) {\n      return Object.getOwnPropertyDescriptor(e, i).enumerable;\n    })), n.push.apply(n, r);\n  }\n  return n;\n}\nfunction HT(e) {\n  for (var t = 1; t < arguments.length; t++) {\n    var n = arguments[t] != null ? arguments[t] : {};\n    t % 2 ? Ip(Object(n), !0).forEach(function(r) {\n      no(e, r, n[r]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Ip(Object(n)).forEach(function(r) {\n      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));\n    });\n  }\n  return e;\n}\nfunction qT(e, t) {\n  if (!(e instanceof t))\n    throw new TypeError(\"Cannot call a class as a function\");\n}\nfunction KT(e, t) {\n  for (var n = 0; n < t.length; n++) {\n    var r = t[n];\n    r.enumerable = r.enumerable || !1, r.configurable = !0, \"value\" in r && (r.writable = !0), Object.defineProperty(e, pb(r.key), r);\n  }\n}\nfunction YT(e, t, n) {\n  return t && KT(e.prototype, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e;\n}\nfunction XT(e, t, n) {\n  return t = Wa(t), ZT(e, db() ? Reflect.construct(t, n || [], Wa(e).constructor) : t.apply(e, n));\n}\nfunction ZT(e, t) {\n  if (t && (Br(t) === \"object\" || typeof t == \"function\"))\n    return t;\n  if (t !== void 0)\n    throw new TypeError(\"Derived constructors may only return object or undefined\");\n  return JT(e);\n}\nfunction JT(e) {\n  if (e === void 0)\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  return e;\n}\nfunction db() {\n  try {\n    var e = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {\n    }));\n  } catch {\n  }\n  return (db = function() {\n    return !!e;\n  })();\n}\nfunction Wa(e) {\n  return Wa = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(n) {\n    return n.__proto__ || Object.getPrototypeOf(n);\n  }, Wa(e);\n}\nfunction QT(e, t) {\n  if (typeof t != \"function\" && t !== null)\n    throw new TypeError(\"Super expression must either be null or a function\");\n  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, writable: !0, configurable: !0 } }), Object.defineProperty(e, \"prototype\", { writable: !1 }), t && zc(e, t);\n}\nfunction zc(e, t) {\n  return zc = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(r, i) {\n    return r.__proto__ = i, r;\n  }, zc(e, t);\n}\nfunction no(e, t, n) {\n  return t = pb(t), t in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;\n}\nfunction pb(e) {\n  var t = eM(e, \"string\");\n  return Br(t) == \"symbol\" ? t : String(t);\n}\nfunction eM(e, t) {\n  if (Br(e) != \"object\" || !e)\n    return e;\n  var n = e[Symbol.toPrimitive];\n  if (n !== void 0) {\n    var r = n.call(e, t || \"default\");\n    if (Br(r) != \"object\")\n      return r;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (t === \"string\" ? String : Number)(e);\n}\nvar Mt = 32, Mf = /* @__PURE__ */ function(e) {\n  QT(t, e);\n  function t() {\n    return qT(this, t), XT(this, t, arguments);\n  }\n  return YT(t, [{\n    key: \"renderIcon\",\n    value: (\n      /**\n       * Render the path of icon\n       * @param {Object} data Data of each legend item\n       * @return {String} Path element\n       */\n      function(r) {\n        var i = this.props.inactiveColor, o = Mt / 2, a = Mt / 6, s = Mt / 3, u = r.inactive ? i : r.color;\n        if (r.type === \"plainline\")\n          return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"line\", {\n            strokeWidth: 4,\n            fill: \"none\",\n            stroke: u,\n            strokeDasharray: r.payload.strokeDasharray,\n            x1: 0,\n            y1: o,\n            x2: Mt,\n            y2: o,\n            className: \"recharts-legend-icon\"\n          });\n        if (r.type === \"line\")\n          return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"path\", {\n            strokeWidth: 4,\n            fill: \"none\",\n            stroke: u,\n            d: \"M0,\".concat(o, \"h\").concat(s, `\n            A`).concat(a, \",\").concat(a, \",0,1,1,\").concat(2 * s, \",\").concat(o, `\n            H`).concat(Mt, \"M\").concat(2 * s, \",\").concat(o, `\n            A`).concat(a, \",\").concat(a, \",0,1,1,\").concat(s, \",\").concat(o),\n            className: \"recharts-legend-icon\"\n          });\n        if (r.type === \"rect\")\n          return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"path\", {\n            stroke: \"none\",\n            fill: u,\n            d: \"M0,\".concat(Mt / 8, \"h\").concat(Mt, \"v\").concat(Mt * 3 / 4, \"h\").concat(-Mt, \"z\"),\n            className: \"recharts-legend-icon\"\n          });\n        if (/* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.isValidElement(r.legendIcon)) {\n          var c = HT({}, r);\n          return delete c.legendIcon, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.cloneElement(r.legendIcon, c);\n        }\n        return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(Tf, {\n          fill: u,\n          cx: o,\n          cy: o,\n          size: Mt,\n          sizeType: \"diameter\",\n          type: r.type\n        });\n      }\n    )\n    /**\n     * Draw items of legend\n     * @return {ReactElement} Items\n     */\n  }, {\n    key: \"renderItems\",\n    value: function() {\n      var r = this, i = this.props, o = i.payload, a = i.iconSize, s = i.layout, u = i.formatter, c = i.inactiveColor, f = {\n        x: 0,\n        y: 0,\n        width: Mt,\n        height: Mt\n      }, l = {\n        display: s === \"horizontal\" ? \"inline-block\" : \"block\",\n        marginRight: 10\n      }, d = {\n        display: \"inline-block\",\n        verticalAlign: \"middle\",\n        marginRight: 4\n      };\n      return o.map(function(p, g) {\n        var h = p.formatter || u, v = $e(no(no({\n          \"recharts-legend-item\": !0\n        }, \"legend-item-\".concat(g), !0), \"inactive\", p.inactive));\n        if (p.type === \"none\")\n          return null;\n        var w = pe(p.value) ? null : p.value;\n        Fr(\n          !pe(p.value),\n          `The name property is also required when using a function for the dataKey of a chart's cartesian components. Ex: <Bar name=\"Name of my Data\"/>`\n          // eslint-disable-line max-len\n        );\n        var b = p.inactive ? c : p.color;\n        return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"li\", Bc({\n          className: v,\n          style: l,\n          key: \"legend-item-\".concat(g)\n        }, Fa(r.props, p, g)), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(Mc, {\n          width: a,\n          height: a,\n          viewBox: f,\n          style: d\n        }, r.renderIcon(p)), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"span\", {\n          className: \"recharts-legend-item-text\",\n          style: {\n            color: b\n          }\n        }, h ? h(w, p, g) : w));\n      });\n    }\n  }, {\n    key: \"render\",\n    value: function() {\n      var r = this.props, i = r.payload, o = r.layout, a = r.align;\n      if (!i || !i.length)\n        return null;\n      var s = {\n        padding: 0,\n        margin: 0,\n        textAlign: o === \"horizontal\" ? a : \"left\"\n      };\n      return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"ul\", {\n        className: \"recharts-default-legend\",\n        style: s\n      }, this.renderItems());\n    }\n  }]), t;\n}(react__WEBPACK_IMPORTED_MODULE_0__.PureComponent);\nno(Mf, \"displayName\", \"Legend\");\nno(Mf, \"defaultProps\", {\n  iconSize: 14,\n  layout: \"horizontal\",\n  align: \"center\",\n  verticalAlign: \"middle\",\n  inactiveColor: \"#ccc\"\n});\nvar tM = Ns;\nfunction nM() {\n  this.__data__ = new tM(), this.size = 0;\n}\nvar rM = nM;\nfunction iM(e) {\n  var t = this.__data__, n = t.delete(e);\n  return this.size = t.size, n;\n}\nvar oM = iM;\nfunction aM(e) {\n  return this.__data__.get(e);\n}\nvar sM = aM;\nfunction uM(e) {\n  return this.__data__.has(e);\n}\nvar cM = uM, lM = Ns, fM = bf, dM = wf, pM = 200;\nfunction hM(e, t) {\n  var n = this.__data__;\n  if (n instanceof lM) {\n    var r = n.__data__;\n    if (!fM || r.length < pM - 1)\n      return r.push([e, t]), this.size = ++n.size, this;\n    n = this.__data__ = new dM(r);\n  }\n  return n.set(e, t), this.size = n.size, this;\n}\nvar gM = hM, vM = Ns, mM = rM, yM = oM, bM = sM, wM = cM, xM = gM;\nfunction pi(e) {\n  var t = this.__data__ = new vM(e);\n  this.size = t.size;\n}\npi.prototype.clear = mM;\npi.prototype.delete = yM;\npi.prototype.get = bM;\npi.prototype.has = wM;\npi.prototype.set = xM;\nvar hb = pi, SM = \"__lodash_hash_undefined__\";\nfunction $M(e) {\n  return this.__data__.set(e, SM), this;\n}\nvar OM = $M;\nfunction _M(e) {\n  return this.__data__.has(e);\n}\nvar AM = _M, PM = wf, CM = OM, EM = AM;\nfunction Ua(e) {\n  var t = -1, n = e == null ? 0 : e.length;\n  for (this.__data__ = new PM(); ++t < n; )\n    this.add(e[t]);\n}\nUa.prototype.add = Ua.prototype.push = CM;\nUa.prototype.has = EM;\nvar gb = Ua;\nfunction TM(e, t) {\n  for (var n = -1, r = e == null ? 0 : e.length; ++n < r; )\n    if (t(e[n], n, e))\n      return !0;\n  return !1;\n}\nvar vb = TM;\nfunction MM(e, t) {\n  return e.has(t);\n}\nvar mb = MM, RM = gb, IM = vb, jM = mb, kM = 1, DM = 2;\nfunction NM(e, t, n, r, i, o) {\n  var a = n & kM, s = e.length, u = t.length;\n  if (s != u && !(a && u > s))\n    return !1;\n  var c = o.get(e), f = o.get(t);\n  if (c && f)\n    return c == t && f == e;\n  var l = -1, d = !0, p = n & DM ? new RM() : void 0;\n  for (o.set(e, t), o.set(t, e); ++l < s; ) {\n    var g = e[l], h = t[l];\n    if (r)\n      var v = a ? r(h, g, l, t, e, o) : r(g, h, l, e, t, o);\n    if (v !== void 0) {\n      if (v)\n        continue;\n      d = !1;\n      break;\n    }\n    if (p) {\n      if (!IM(t, function(w, b) {\n        if (!jM(p, b) && (g === w || i(g, w, n, r, o)))\n          return p.push(b);\n      })) {\n        d = !1;\n        break;\n      }\n    } else if (!(g === h || i(g, h, n, r, o))) {\n      d = !1;\n      break;\n    }\n  }\n  return o.delete(e), o.delete(t), d;\n}\nvar yb = NM, FM = dn, LM = FM.Uint8Array, BM = LM;\nfunction zM(e) {\n  var t = -1, n = Array(e.size);\n  return e.forEach(function(r, i) {\n    n[++t] = [i, r];\n  }), n;\n}\nvar VM = zM;\nfunction GM(e) {\n  var t = -1, n = Array(e.size);\n  return e.forEach(function(r) {\n    n[++t] = r;\n  }), n;\n}\nvar Rf = GM, jp = Vo, kp = BM, WM = yf, UM = yb, HM = VM, qM = Rf, KM = 1, YM = 2, XM = \"[object Boolean]\", ZM = \"[object Date]\", JM = \"[object Error]\", QM = \"[object Map]\", eR = \"[object Number]\", tR = \"[object RegExp]\", nR = \"[object Set]\", rR = \"[object String]\", iR = \"[object Symbol]\", oR = \"[object ArrayBuffer]\", aR = \"[object DataView]\", Dp = jp ? jp.prototype : void 0, Tu = Dp ? Dp.valueOf : void 0;\nfunction sR(e, t, n, r, i, o, a) {\n  switch (n) {\n    case aR:\n      if (e.byteLength != t.byteLength || e.byteOffset != t.byteOffset)\n        return !1;\n      e = e.buffer, t = t.buffer;\n    case oR:\n      return !(e.byteLength != t.byteLength || !o(new kp(e), new kp(t)));\n    case XM:\n    case ZM:\n    case eR:\n      return WM(+e, +t);\n    case JM:\n      return e.name == t.name && e.message == t.message;\n    case tR:\n    case rR:\n      return e == t + \"\";\n    case QM:\n      var s = HM;\n    case nR:\n      var u = r & KM;\n      if (s || (s = qM), e.size != t.size && !u)\n        return !1;\n      var c = a.get(e);\n      if (c)\n        return c == t;\n      r |= YM, a.set(e, t);\n      var f = UM(s(e), s(t), r, i, o, a);\n      return a.delete(e), f;\n    case iR:\n      if (Tu)\n        return Tu.call(e) == Tu.call(t);\n  }\n  return !1;\n}\nvar uR = sR;\nfunction cR(e, t) {\n  for (var n = -1, r = t.length, i = e.length; ++n < r; )\n    e[i + n] = t[n];\n  return e;\n}\nvar bb = cR, lR = bb, fR = mt;\nfunction dR(e, t, n) {\n  var r = t(e);\n  return fR(e) ? r : lR(r, n(e));\n}\nvar pR = dR;\nfunction hR(e, t) {\n  for (var n = -1, r = e == null ? 0 : e.length, i = 0, o = []; ++n < r; ) {\n    var a = e[n];\n    t(a, n, e) && (o[i++] = a);\n  }\n  return o;\n}\nvar gR = hR;\nfunction vR() {\n  return [];\n}\nvar mR = vR, yR = gR, bR = mR, wR = Object.prototype, xR = wR.propertyIsEnumerable, Np = Object.getOwnPropertySymbols, SR = Np ? function(e) {\n  return e == null ? [] : (e = Object(e), yR(Np(e), function(t) {\n    return xR.call(e, t);\n  }));\n} : bR, $R = SR;\nfunction OR(e, t) {\n  for (var n = -1, r = Array(e); ++n < e; )\n    r[n] = t(n);\n  return r;\n}\nvar _R = OR, AR = Pn, PR = Cn, CR = \"[object Arguments]\";\nfunction ER(e) {\n  return PR(e) && AR(e) == CR;\n}\nvar TR = ER, Fp = TR, MR = Cn, wb = Object.prototype, RR = wb.hasOwnProperty, IR = wb.propertyIsEnumerable, jR = Fp(/* @__PURE__ */ function() {\n  return arguments;\n}()) ? Fp : function(e) {\n  return MR(e) && RR.call(e, \"callee\") && !IR.call(e, \"callee\");\n}, If = jR, Ha = { exports: {} };\nfunction kR() {\n  return !1;\n}\nvar DR = kR;\nHa.exports;\n(function(e, t) {\n  var n = dn, r = DR, i = t && !t.nodeType && t, o = i && !0 && e && !e.nodeType && e, a = o && o.exports === i, s = a ? n.Buffer : void 0, u = s ? s.isBuffer : void 0, c = u || r;\n  e.exports = c;\n})(Ha, Ha.exports);\nvar xb = Ha.exports, NR = 9007199254740991, FR = /^(?:0|[1-9]\\d*)$/;\nfunction LR(e, t) {\n  var n = typeof e;\n  return t = t ?? NR, !!t && (n == \"number\" || n != \"symbol\" && FR.test(e)) && e > -1 && e % 1 == 0 && e < t;\n}\nvar jf = LR, BR = 9007199254740991;\nfunction zR(e) {\n  return typeof e == \"number\" && e > -1 && e % 1 == 0 && e <= BR;\n}\nvar kf = zR, VR = Pn, GR = kf, WR = Cn, UR = \"[object Arguments]\", HR = \"[object Array]\", qR = \"[object Boolean]\", KR = \"[object Date]\", YR = \"[object Error]\", XR = \"[object Function]\", ZR = \"[object Map]\", JR = \"[object Number]\", QR = \"[object Object]\", eI = \"[object RegExp]\", tI = \"[object Set]\", nI = \"[object String]\", rI = \"[object WeakMap]\", iI = \"[object ArrayBuffer]\", oI = \"[object DataView]\", aI = \"[object Float32Array]\", sI = \"[object Float64Array]\", uI = \"[object Int8Array]\", cI = \"[object Int16Array]\", lI = \"[object Int32Array]\", fI = \"[object Uint8Array]\", dI = \"[object Uint8ClampedArray]\", pI = \"[object Uint16Array]\", hI = \"[object Uint32Array]\", De = {};\nDe[aI] = De[sI] = De[uI] = De[cI] = De[lI] = De[fI] = De[dI] = De[pI] = De[hI] = !0;\nDe[UR] = De[HR] = De[iI] = De[qR] = De[oI] = De[KR] = De[YR] = De[XR] = De[ZR] = De[JR] = De[QR] = De[eI] = De[tI] = De[nI] = De[rI] = !1;\nfunction gI(e) {\n  return WR(e) && GR(e.length) && !!De[VR(e)];\n}\nvar vI = gI;\nfunction mI(e) {\n  return function(t) {\n    return e(t);\n  };\n}\nvar Sb = mI, qa = { exports: {} };\nqa.exports;\n(function(e, t) {\n  var n = Ry, r = t && !t.nodeType && t, i = r && !0 && e && !e.nodeType && e, o = i && i.exports === r, a = o && n.process, s = function() {\n    try {\n      var u = i && i.require && i.require(\"util\").types;\n      return u || a && a.binding && a.binding(\"util\");\n    } catch {\n    }\n  }();\n  e.exports = s;\n})(qa, qa.exports);\nvar yI = qa.exports, bI = vI, wI = Sb, Lp = yI, Bp = Lp && Lp.isTypedArray, xI = Bp ? wI(Bp) : bI, $b = xI, SI = _R, $I = If, OI = mt, _I = xb, AI = jf, PI = $b, CI = Object.prototype, EI = CI.hasOwnProperty;\nfunction TI(e, t) {\n  var n = OI(e), r = !n && $I(e), i = !n && !r && _I(e), o = !n && !r && !i && PI(e), a = n || r || i || o, s = a ? SI(e.length, String) : [], u = s.length;\n  for (var c in e)\n    (t || EI.call(e, c)) && !(a && // Safari 9 has enumerable `arguments.length` in strict mode.\n    (c == \"length\" || // Node.js 0.10 has enumerable non-index properties on buffers.\n    i && (c == \"offset\" || c == \"parent\") || // PhantomJS 2 has enumerable non-index properties on typed arrays.\n    o && (c == \"buffer\" || c == \"byteLength\" || c == \"byteOffset\") || // Skip index properties.\n    AI(c, u))) && s.push(c);\n  return s;\n}\nvar MI = TI, RI = Object.prototype;\nfunction II(e) {\n  var t = e && e.constructor, n = typeof t == \"function\" && t.prototype || RI;\n  return e === n;\n}\nvar jI = II;\nfunction kI(e, t) {\n  return function(n) {\n    return e(t(n));\n  };\n}\nvar Ob = kI, DI = Ob, NI = DI(Object.keys, Object), FI = NI, LI = jI, BI = FI, zI = Object.prototype, VI = zI.hasOwnProperty;\nfunction GI(e) {\n  if (!LI(e))\n    return BI(e);\n  var t = [];\n  for (var n in Object(e))\n    VI.call(e, n) && n != \"constructor\" && t.push(n);\n  return t;\n}\nvar WI = GI, UI = mf, HI = kf;\nfunction qI(e) {\n  return e != null && HI(e.length) && !UI(e);\n}\nvar Ho = qI, KI = MI, YI = WI, XI = Ho;\nfunction ZI(e) {\n  return XI(e) ? KI(e) : YI(e);\n}\nvar Ws = ZI, JI = pR, QI = $R, e2 = Ws;\nfunction t2(e) {\n  return JI(e, e2, QI);\n}\nvar n2 = t2, zp = n2, r2 = 1, i2 = Object.prototype, o2 = i2.hasOwnProperty;\nfunction a2(e, t, n, r, i, o) {\n  var a = n & r2, s = zp(e), u = s.length, c = zp(t), f = c.length;\n  if (u != f && !a)\n    return !1;\n  for (var l = u; l--; ) {\n    var d = s[l];\n    if (!(a ? d in t : o2.call(t, d)))\n      return !1;\n  }\n  var p = o.get(e), g = o.get(t);\n  if (p && g)\n    return p == t && g == e;\n  var h = !0;\n  o.set(e, t), o.set(t, e);\n  for (var v = a; ++l < u; ) {\n    d = s[l];\n    var w = e[d], b = t[d];\n    if (r)\n      var x = a ? r(b, w, d, t, e, o) : r(w, b, d, e, t, o);\n    if (!(x === void 0 ? w === b || i(w, b, n, r, o) : x)) {\n      h = !1;\n      break;\n    }\n    v || (v = d == \"constructor\");\n  }\n  if (h && !v) {\n    var m = e.constructor, y = t.constructor;\n    m != y && \"constructor\" in e && \"constructor\" in t && !(typeof m == \"function\" && m instanceof m && typeof y == \"function\" && y instanceof y) && (h = !1);\n  }\n  return o.delete(e), o.delete(t), h;\n}\nvar s2 = a2, u2 = vr, c2 = dn, l2 = u2(c2, \"DataView\"), f2 = l2, d2 = vr, p2 = dn, h2 = d2(p2, \"Promise\"), g2 = h2, v2 = vr, m2 = dn, y2 = v2(m2, \"Set\"), _b = y2, b2 = vr, w2 = dn, x2 = b2(w2, \"WeakMap\"), S2 = x2, Vc = f2, Gc = bf, Wc = g2, Uc = _b, Hc = S2, Ab = Pn, hi = jy, Vp = \"[object Map]\", $2 = \"[object Object]\", Gp = \"[object Promise]\", Wp = \"[object Set]\", Up = \"[object WeakMap]\", Hp = \"[object DataView]\", O2 = hi(Vc), _2 = hi(Gc), A2 = hi(Wc), P2 = hi(Uc), C2 = hi(Hc), er = Ab;\n(Vc && er(new Vc(new ArrayBuffer(1))) != Hp || Gc && er(new Gc()) != Vp || Wc && er(Wc.resolve()) != Gp || Uc && er(new Uc()) != Wp || Hc && er(new Hc()) != Up) && (er = function(e) {\n  var t = Ab(e), n = t == $2 ? e.constructor : void 0, r = n ? hi(n) : \"\";\n  if (r)\n    switch (r) {\n      case O2:\n        return Hp;\n      case _2:\n        return Vp;\n      case A2:\n        return Gp;\n      case P2:\n        return Wp;\n      case C2:\n        return Up;\n    }\n  return t;\n});\nvar E2 = er, Mu = hb, T2 = yb, M2 = uR, R2 = s2, qp = E2, Kp = mt, Yp = xb, I2 = $b, j2 = 1, Xp = \"[object Arguments]\", Zp = \"[object Array]\", fa = \"[object Object]\", k2 = Object.prototype, Jp = k2.hasOwnProperty;\nfunction D2(e, t, n, r, i, o) {\n  var a = Kp(e), s = Kp(t), u = a ? Zp : qp(e), c = s ? Zp : qp(t);\n  u = u == Xp ? fa : u, c = c == Xp ? fa : c;\n  var f = u == fa, l = c == fa, d = u == c;\n  if (d && Yp(e)) {\n    if (!Yp(t))\n      return !1;\n    a = !0, f = !1;\n  }\n  if (d && !f)\n    return o || (o = new Mu()), a || I2(e) ? T2(e, t, n, r, i, o) : M2(e, t, u, n, r, i, o);\n  if (!(n & j2)) {\n    var p = f && Jp.call(e, \"__wrapped__\"), g = l && Jp.call(t, \"__wrapped__\");\n    if (p || g) {\n      var h = p ? e.value() : e, v = g ? t.value() : t;\n      return o || (o = new Mu()), i(h, v, n, r, o);\n    }\n  }\n  return d ? (o || (o = new Mu()), R2(e, t, n, r, i, o)) : !1;\n}\nvar N2 = D2, F2 = N2, Qp = Cn;\nfunction Pb(e, t, n, r, i) {\n  return e === t ? !0 : e == null || t == null || !Qp(e) && !Qp(t) ? e !== e && t !== t : F2(e, t, n, r, Pb, i);\n}\nvar Df = Pb, L2 = hb, B2 = Df, z2 = 1, V2 = 2;\nfunction G2(e, t, n, r) {\n  var i = n.length, o = i, a = !r;\n  if (e == null)\n    return !o;\n  for (e = Object(e); i--; ) {\n    var s = n[i];\n    if (a && s[2] ? s[1] !== e[s[0]] : !(s[0] in e))\n      return !1;\n  }\n  for (; ++i < o; ) {\n    s = n[i];\n    var u = s[0], c = e[u], f = s[1];\n    if (a && s[2]) {\n      if (c === void 0 && !(u in e))\n        return !1;\n    } else {\n      var l = new L2();\n      if (r)\n        var d = r(c, f, u, e, t, l);\n      if (!(d === void 0 ? B2(f, c, z2 | V2, r, l) : d))\n        return !1;\n    }\n  }\n  return !0;\n}\nvar W2 = G2, U2 = Un;\nfunction H2(e) {\n  return e === e && !U2(e);\n}\nvar Cb = H2, q2 = Cb, K2 = Ws;\nfunction Y2(e) {\n  for (var t = K2(e), n = t.length; n--; ) {\n    var r = t[n], i = e[r];\n    t[n] = [r, i, q2(i)];\n  }\n  return t;\n}\nvar X2 = Y2;\nfunction Z2(e, t) {\n  return function(n) {\n    return n == null ? !1 : n[e] === t && (t !== void 0 || e in Object(n));\n  };\n}\nvar Eb = Z2, J2 = W2, Q2 = X2, ej = Eb;\nfunction tj(e) {\n  var t = Q2(e);\n  return t.length == 1 && t[0][2] ? ej(t[0][0], t[0][1]) : function(n) {\n    return n === e || J2(n, e, t);\n  };\n}\nvar nj = tj;\nfunction rj(e, t) {\n  return e != null && t in Object(e);\n}\nvar ij = rj, oj = Ly, aj = If, sj = mt, uj = jf, cj = kf, lj = Ls;\nfunction fj(e, t, n) {\n  t = oj(t, e);\n  for (var r = -1, i = t.length, o = !1; ++r < i; ) {\n    var a = lj(t[r]);\n    if (!(o = e != null && n(e, a)))\n      break;\n    e = e[a];\n  }\n  return o || ++r != i ? o : (i = e == null ? 0 : e.length, !!i && cj(i) && uj(a, i) && (sj(e) || aj(e)));\n}\nvar dj = fj, pj = ij, hj = dj;\nfunction gj(e, t) {\n  return e != null && hj(e, t, pj);\n}\nvar vj = gj, mj = Df, yj = By, bj = vj, wj = vf, xj = Cb, Sj = Eb, $j = Ls, Oj = 1, _j = 2;\nfunction Aj(e, t) {\n  return wj(e) && xj(t) ? Sj($j(e), t) : function(n) {\n    var r = yj(n, e);\n    return r === void 0 && r === t ? bj(n, e) : mj(t, r, Oj | _j);\n  };\n}\nvar Pj = Aj;\nfunction Cj(e) {\n  return e;\n}\nvar gi = Cj;\nfunction Ej(e) {\n  return function(t) {\n    return t == null ? void 0 : t[e];\n  };\n}\nvar Tj = Ej, Mj = $f;\nfunction Rj(e) {\n  return function(t) {\n    return Mj(t, e);\n  };\n}\nvar Ij = Rj, jj = Tj, kj = Ij, Dj = vf, Nj = Ls;\nfunction Fj(e) {\n  return Dj(e) ? jj(Nj(e)) : kj(e);\n}\nvar Lj = Fj, Bj = nj, zj = Pj, Vj = gi, Gj = mt, Wj = Lj;\nfunction Uj(e) {\n  return typeof e == \"function\" ? e : e == null ? Vj : typeof e == \"object\" ? Gj(e) ? zj(e[0], e[1]) : Bj(e) : Wj(e);\n}\nvar Hn = Uj;\nfunction Hj(e, t, n, r) {\n  for (var i = e.length, o = n + (r ? 1 : -1); r ? o-- : ++o < i; )\n    if (t(e[o], o, e))\n      return o;\n  return -1;\n}\nvar Tb = Hj;\nfunction qj(e) {\n  return e !== e;\n}\nvar Kj = qj;\nfunction Yj(e, t, n) {\n  for (var r = n - 1, i = e.length; ++r < i; )\n    if (e[r] === t)\n      return r;\n  return -1;\n}\nvar Xj = Yj, Zj = Tb, Jj = Kj, Qj = Xj;\nfunction ek(e, t, n) {\n  return t === t ? Qj(e, t, n) : Zj(e, Jj, n);\n}\nvar tk = ek, nk = tk;\nfunction rk(e, t) {\n  var n = e == null ? 0 : e.length;\n  return !!n && nk(e, t, 0) > -1;\n}\nvar ik = rk;\nfunction ok(e, t, n) {\n  for (var r = -1, i = e == null ? 0 : e.length; ++r < i; )\n    if (n(t, e[r]))\n      return !0;\n  return !1;\n}\nvar ak = ok;\nfunction sk() {\n}\nvar uk = sk, Ru = _b, ck = uk, lk = Rf, fk = 1 / 0, dk = Ru && 1 / lk(new Ru([, -0]))[1] == fk ? function(e) {\n  return new Ru(e);\n} : ck, pk = dk, hk = gb, gk = ik, vk = ak, mk = mb, yk = pk, bk = Rf, wk = 200;\nfunction xk(e, t, n) {\n  var r = -1, i = gk, o = e.length, a = !0, s = [], u = s;\n  if (n)\n    a = !1, i = vk;\n  else if (o >= wk) {\n    var c = t ? null : yk(e);\n    if (c)\n      return bk(c);\n    a = !1, i = mk, u = new hk();\n  } else\n    u = t ? [] : s;\n  e:\n    for (; ++r < o; ) {\n      var f = e[r], l = t ? t(f) : f;\n      if (f = n || f !== 0 ? f : 0, a && l === l) {\n        for (var d = u.length; d--; )\n          if (u[d] === l)\n            continue e;\n        t && u.push(l), s.push(f);\n      } else\n        i(u, l, n) || (u !== s && u.push(l), s.push(f));\n    }\n  return s;\n}\nvar Sk = xk, $k = Hn, Ok = Sk;\nfunction _k(e, t) {\n  return e && e.length ? Ok(e, $k(t)) : [];\n}\nvar Ak = _k;\nconst eh = /* @__PURE__ */ je(Ak);\nfunction Mb(e, t, n) {\n  return t === !0 ? eh(e, n) : pe(t) ? eh(e, t) : e;\n}\nfunction zr(e) {\n  \"@babel/helpers - typeof\";\n  return zr = typeof Symbol == \"function\" && typeof Symbol.iterator == \"symbol\" ? function(t) {\n    return typeof t;\n  } : function(t) {\n    return t && typeof Symbol == \"function\" && t.constructor === Symbol && t !== Symbol.prototype ? \"symbol\" : typeof t;\n  }, zr(e);\n}\nvar Pk = [\"ref\"];\nfunction th(e, t) {\n  var n = Object.keys(e);\n  if (Object.getOwnPropertySymbols) {\n    var r = Object.getOwnPropertySymbols(e);\n    t && (r = r.filter(function(i) {\n      return Object.getOwnPropertyDescriptor(e, i).enumerable;\n    })), n.push.apply(n, r);\n  }\n  return n;\n}\nfunction Jn(e) {\n  for (var t = 1; t < arguments.length; t++) {\n    var n = arguments[t] != null ? arguments[t] : {};\n    t % 2 ? th(Object(n), !0).forEach(function(r) {\n      Us(e, r, n[r]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : th(Object(n)).forEach(function(r) {\n      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));\n    });\n  }\n  return e;\n}\nfunction Ck(e, t) {\n  if (!(e instanceof t))\n    throw new TypeError(\"Cannot call a class as a function\");\n}\nfunction nh(e, t) {\n  for (var n = 0; n < t.length; n++) {\n    var r = t[n];\n    r.enumerable = r.enumerable || !1, r.configurable = !0, \"value\" in r && (r.writable = !0), Object.defineProperty(e, jb(r.key), r);\n  }\n}\nfunction Ek(e, t, n) {\n  return t && nh(e.prototype, t), n && nh(e, n), Object.defineProperty(e, \"prototype\", { writable: !1 }), e;\n}\nfunction Tk(e, t, n) {\n  return t = Ka(t), Mk(e, Rb() ? Reflect.construct(t, n || [], Ka(e).constructor) : t.apply(e, n));\n}\nfunction Mk(e, t) {\n  if (t && (zr(t) === \"object\" || typeof t == \"function\"))\n    return t;\n  if (t !== void 0)\n    throw new TypeError(\"Derived constructors may only return object or undefined\");\n  return Ib(e);\n}\nfunction Rb() {\n  try {\n    var e = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {\n    }));\n  } catch {\n  }\n  return (Rb = function() {\n    return !!e;\n  })();\n}\nfunction Ka(e) {\n  return Ka = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(n) {\n    return n.__proto__ || Object.getPrototypeOf(n);\n  }, Ka(e);\n}\nfunction Ib(e) {\n  if (e === void 0)\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  return e;\n}\nfunction Rk(e, t) {\n  if (typeof t != \"function\" && t !== null)\n    throw new TypeError(\"Super expression must either be null or a function\");\n  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, writable: !0, configurable: !0 } }), Object.defineProperty(e, \"prototype\", { writable: !1 }), t && qc(e, t);\n}\nfunction qc(e, t) {\n  return qc = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(r, i) {\n    return r.__proto__ = i, r;\n  }, qc(e, t);\n}\nfunction Us(e, t, n) {\n  return t = jb(t), t in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;\n}\nfunction jb(e) {\n  var t = Ik(e, \"string\");\n  return zr(t) == \"symbol\" ? t : String(t);\n}\nfunction Ik(e, t) {\n  if (zr(e) != \"object\" || !e)\n    return e;\n  var n = e[Symbol.toPrimitive];\n  if (n !== void 0) {\n    var r = n.call(e, t || \"default\");\n    if (zr(r) != \"object\")\n      return r;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (t === \"string\" ? String : Number)(e);\n}\nfunction jk(e, t) {\n  if (e == null)\n    return {};\n  var n = kk(e, t), r, i;\n  if (Object.getOwnPropertySymbols) {\n    var o = Object.getOwnPropertySymbols(e);\n    for (i = 0; i < o.length; i++)\n      r = o[i], !(t.indexOf(r) >= 0) && Object.prototype.propertyIsEnumerable.call(e, r) && (n[r] = e[r]);\n  }\n  return n;\n}\nfunction kk(e, t) {\n  if (e == null)\n    return {};\n  var n = {}, r = Object.keys(e), i, o;\n  for (o = 0; o < r.length; o++)\n    i = r[o], !(t.indexOf(i) >= 0) && (n[i] = e[i]);\n  return n;\n}\nfunction Dk(e) {\n  return e.value;\n}\nfunction Nk(e, t) {\n  if (/* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.isValidElement(e))\n    return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.cloneElement(e, t);\n  if (typeof e == \"function\")\n    return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(e, t);\n  t.ref;\n  var n = jk(t, Pk);\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(Mf, n);\n}\nvar rh = 1, Vr = /* @__PURE__ */ function(e) {\n  Rk(t, e);\n  function t() {\n    var n;\n    Ck(this, t);\n    for (var r = arguments.length, i = new Array(r), o = 0; o < r; o++)\n      i[o] = arguments[o];\n    return n = Tk(this, t, [].concat(i)), Us(Ib(n), \"lastBoundingBox\", {\n      width: -1,\n      height: -1\n    }), n;\n  }\n  return Ek(t, [{\n    key: \"componentDidMount\",\n    value: function() {\n      this.updateBBox();\n    }\n  }, {\n    key: \"componentDidUpdate\",\n    value: function() {\n      this.updateBBox();\n    }\n  }, {\n    key: \"getBBox\",\n    value: function() {\n      if (this.wrapperNode && this.wrapperNode.getBoundingClientRect) {\n        var r = this.wrapperNode.getBoundingClientRect();\n        return r.height = this.wrapperNode.offsetHeight, r.width = this.wrapperNode.offsetWidth, r;\n      }\n      return null;\n    }\n  }, {\n    key: \"updateBBox\",\n    value: function() {\n      var r = this.props.onBBoxUpdate, i = this.getBBox();\n      i ? (Math.abs(i.width - this.lastBoundingBox.width) > rh || Math.abs(i.height - this.lastBoundingBox.height) > rh) && (this.lastBoundingBox.width = i.width, this.lastBoundingBox.height = i.height, r && r(i)) : (this.lastBoundingBox.width !== -1 || this.lastBoundingBox.height !== -1) && (this.lastBoundingBox.width = -1, this.lastBoundingBox.height = -1, r && r(null));\n    }\n  }, {\n    key: \"getBBoxSnapshot\",\n    value: function() {\n      return this.lastBoundingBox.width >= 0 && this.lastBoundingBox.height >= 0 ? Jn({}, this.lastBoundingBox) : {\n        width: 0,\n        height: 0\n      };\n    }\n  }, {\n    key: \"getDefaultPosition\",\n    value: function(r) {\n      var i = this.props, o = i.layout, a = i.align, s = i.verticalAlign, u = i.margin, c = i.chartWidth, f = i.chartHeight, l, d;\n      if (!r || (r.left === void 0 || r.left === null) && (r.right === void 0 || r.right === null))\n        if (a === \"center\" && o === \"vertical\") {\n          var p = this.getBBoxSnapshot();\n          l = {\n            left: ((c || 0) - p.width) / 2\n          };\n        } else\n          l = a === \"right\" ? {\n            right: u && u.right || 0\n          } : {\n            left: u && u.left || 0\n          };\n      if (!r || (r.top === void 0 || r.top === null) && (r.bottom === void 0 || r.bottom === null))\n        if (s === \"middle\") {\n          var g = this.getBBoxSnapshot();\n          d = {\n            top: ((f || 0) - g.height) / 2\n          };\n        } else\n          d = s === \"bottom\" ? {\n            bottom: u && u.bottom || 0\n          } : {\n            top: u && u.top || 0\n          };\n      return Jn(Jn({}, l), d);\n    }\n  }, {\n    key: \"render\",\n    value: function() {\n      var r = this, i = this.props, o = i.content, a = i.width, s = i.height, u = i.wrapperStyle, c = i.payloadUniqBy, f = i.payload, l = Jn(Jn({\n        position: \"absolute\",\n        width: a || \"auto\",\n        height: s || \"auto\"\n      }, this.getDefaultPosition(u)), u);\n      return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n        className: \"recharts-legend-wrapper\",\n        style: l,\n        ref: function(p) {\n          r.wrapperNode = p;\n        }\n      }, Nk(o, Jn(Jn({}, this.props), {}, {\n        payload: Mb(f, c, Dk)\n      })));\n    }\n  }], [{\n    key: \"getWithHeight\",\n    value: function(r, i) {\n      var o = r.props.layout;\n      return o === \"vertical\" && K(r.props.height) ? {\n        height: r.props.height\n      } : o === \"horizontal\" ? {\n        width: r.props.width || i\n      } : null;\n    }\n  }]), t;\n}(react__WEBPACK_IMPORTED_MODULE_0__.PureComponent);\nUs(Vr, \"displayName\", \"Legend\");\nUs(Vr, \"defaultProps\", {\n  iconSize: 14,\n  layout: \"horizontal\",\n  align: \"center\",\n  verticalAlign: \"bottom\"\n});\nvar ih = Vo, Fk = If, Lk = mt, oh = ih ? ih.isConcatSpreadable : void 0;\nfunction Bk(e) {\n  return Lk(e) || Fk(e) || !!(oh && e && e[oh]);\n}\nvar zk = Bk, Vk = bb, Gk = zk;\nfunction kb(e, t, n, r, i) {\n  var o = -1, a = e.length;\n  for (n || (n = Gk), i || (i = []); ++o < a; ) {\n    var s = e[o];\n    t > 0 && n(s) ? t > 1 ? kb(s, t - 1, n, r, i) : Vk(i, s) : r || (i[i.length] = s);\n  }\n  return i;\n}\nvar Db = kb;\nfunction Wk(e) {\n  return function(t, n, r) {\n    for (var i = -1, o = Object(t), a = r(t), s = a.length; s--; ) {\n      var u = a[e ? s : ++i];\n      if (n(o[u], u, o) === !1)\n        break;\n    }\n    return t;\n  };\n}\nvar Uk = Wk, Hk = Uk, qk = Hk(), Kk = qk, Yk = Kk, Xk = Ws;\nfunction Zk(e, t) {\n  return e && Yk(e, t, Xk);\n}\nvar Nb = Zk, Jk = Ho;\nfunction Qk(e, t) {\n  return function(n, r) {\n    if (n == null)\n      return n;\n    if (!Jk(n))\n      return e(n, r);\n    for (var i = n.length, o = t ? i : -1, a = Object(n); (t ? o-- : ++o < i) && r(a[o], o, a) !== !1; )\n      ;\n    return n;\n  };\n}\nvar eD = Qk, tD = Nb, nD = eD, rD = nD(tD), Nf = rD, iD = Nf, oD = Ho;\nfunction aD(e, t) {\n  var n = -1, r = oD(e) ? Array(e.length) : [];\n  return iD(e, function(i, o, a) {\n    r[++n] = t(i, o, a);\n  }), r;\n}\nvar Fb = aD;\nfunction sD(e, t) {\n  var n = e.length;\n  for (e.sort(t); n--; )\n    e[n] = e[n].value;\n  return e;\n}\nvar uD = sD, ah = ui;\nfunction cD(e, t) {\n  if (e !== t) {\n    var n = e !== void 0, r = e === null, i = e === e, o = ah(e), a = t !== void 0, s = t === null, u = t === t, c = ah(t);\n    if (!s && !c && !o && e > t || o && a && u && !s && !c || r && a && u || !n && u || !i)\n      return 1;\n    if (!r && !o && !c && e < t || c && n && i && !r && !o || s && n && i || !a && i || !u)\n      return -1;\n  }\n  return 0;\n}\nvar lD = cD, fD = lD;\nfunction dD(e, t, n) {\n  for (var r = -1, i = e.criteria, o = t.criteria, a = i.length, s = n.length; ++r < a; ) {\n    var u = fD(i[r], o[r]);\n    if (u) {\n      if (r >= s)\n        return u;\n      var c = n[r];\n      return u * (c == \"desc\" ? -1 : 1);\n    }\n  }\n  return e.index - t.index;\n}\nvar pD = dD, Iu = Sf, hD = $f, gD = Hn, vD = Fb, mD = uD, yD = Sb, bD = pD, wD = gi, xD = mt;\nfunction SD(e, t, n) {\n  t.length ? t = Iu(t, function(o) {\n    return xD(o) ? function(a) {\n      return hD(a, o.length === 1 ? o[0] : o);\n    } : o;\n  }) : t = [wD];\n  var r = -1;\n  t = Iu(t, yD(gD));\n  var i = vD(e, function(o, a, s) {\n    var u = Iu(t, function(c) {\n      return c(o);\n    });\n    return { criteria: u, index: ++r, value: o };\n  });\n  return mD(i, function(o, a) {\n    return bD(o, a, n);\n  });\n}\nvar $D = SD;\nfunction OD(e, t, n) {\n  switch (n.length) {\n    case 0:\n      return e.call(t);\n    case 1:\n      return e.call(t, n[0]);\n    case 2:\n      return e.call(t, n[0], n[1]);\n    case 3:\n      return e.call(t, n[0], n[1], n[2]);\n  }\n  return e.apply(t, n);\n}\nvar _D = OD, AD = _D, sh = Math.max;\nfunction PD(e, t, n) {\n  return t = sh(t === void 0 ? e.length - 1 : t, 0), function() {\n    for (var r = arguments, i = -1, o = sh(r.length - t, 0), a = Array(o); ++i < o; )\n      a[i] = r[t + i];\n    i = -1;\n    for (var s = Array(t + 1); ++i < t; )\n      s[i] = r[i];\n    return s[t] = n(a), AD(e, this, s);\n  };\n}\nvar CD = PD;\nfunction ED(e) {\n  return function() {\n    return e;\n  };\n}\nvar TD = ED, MD = vr, RD = function() {\n  try {\n    var e = MD(Object, \"defineProperty\");\n    return e({}, \"\", {}), e;\n  } catch {\n  }\n}(), Lb = RD, ID = TD, uh = Lb, jD = gi, kD = uh ? function(e, t) {\n  return uh(e, \"toString\", {\n    configurable: !0,\n    enumerable: !1,\n    value: ID(t),\n    writable: !0\n  });\n} : jD, DD = kD, ND = 800, FD = 16, LD = Date.now;\nfunction BD(e) {\n  var t = 0, n = 0;\n  return function() {\n    var r = LD(), i = FD - (r - n);\n    if (n = r, i > 0) {\n      if (++t >= ND)\n        return arguments[0];\n    } else\n      t = 0;\n    return e.apply(void 0, arguments);\n  };\n}\nvar zD = BD, VD = DD, GD = zD, WD = GD(VD), UD = WD, HD = gi, qD = CD, KD = UD;\nfunction YD(e, t) {\n  return KD(qD(e, t, HD), e + \"\");\n}\nvar XD = YD, ZD = yf, JD = Ho, QD = jf, eN = Un;\nfunction tN(e, t, n) {\n  if (!eN(n))\n    return !1;\n  var r = typeof t;\n  return (r == \"number\" ? JD(n) && QD(t, n.length) : r == \"string\" && t in n) ? ZD(n[t], e) : !1;\n}\nvar Hs = tN, nN = Db, rN = $D, iN = XD, ch = Hs, oN = iN(function(e, t) {\n  if (e == null)\n    return [];\n  var n = t.length;\n  return n > 1 && ch(e, t[0], t[1]) ? t = [] : n > 2 && ch(t[0], t[1], t[2]) && (t = [t[0]]), rN(e, nN(t, 1), []);\n}), aN = oN;\nconst Ff = /* @__PURE__ */ je(aN);\nfunction ro(e) {\n  \"@babel/helpers - typeof\";\n  return ro = typeof Symbol == \"function\" && typeof Symbol.iterator == \"symbol\" ? function(t) {\n    return typeof t;\n  } : function(t) {\n    return t && typeof Symbol == \"function\" && t.constructor === Symbol && t !== Symbol.prototype ? \"symbol\" : typeof t;\n  }, ro(e);\n}\nfunction Kc() {\n  return Kc = Object.assign ? Object.assign.bind() : function(e) {\n    for (var t = 1; t < arguments.length; t++) {\n      var n = arguments[t];\n      for (var r in n)\n        Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);\n    }\n    return e;\n  }, Kc.apply(this, arguments);\n}\nfunction sN(e, t) {\n  return fN(e) || lN(e, t) || cN(e, t) || uN();\n}\nfunction uN() {\n  throw new TypeError(`Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);\n}\nfunction cN(e, t) {\n  if (e) {\n    if (typeof e == \"string\")\n      return lh(e, t);\n    var n = Object.prototype.toString.call(e).slice(8, -1);\n    if (n === \"Object\" && e.constructor && (n = e.constructor.name), n === \"Map\" || n === \"Set\")\n      return Array.from(e);\n    if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))\n      return lh(e, t);\n  }\n}\nfunction lh(e, t) {\n  (t == null || t > e.length) && (t = e.length);\n  for (var n = 0, r = new Array(t); n < t; n++)\n    r[n] = e[n];\n  return r;\n}\nfunction lN(e, t) {\n  var n = e == null ? null : typeof Symbol < \"u\" && e[Symbol.iterator] || e[\"@@iterator\"];\n  if (n != null) {\n    var r, i, o, a, s = [], u = !0, c = !1;\n    try {\n      if (o = (n = n.call(e)).next, t !== 0)\n        for (; !(u = (r = o.call(n)).done) && (s.push(r.value), s.length !== t); u = !0)\n          ;\n    } catch (f) {\n      c = !0, i = f;\n    } finally {\n      try {\n        if (!u && n.return != null && (a = n.return(), Object(a) !== a))\n          return;\n      } finally {\n        if (c)\n          throw i;\n      }\n    }\n    return s;\n  }\n}\nfunction fN(e) {\n  if (Array.isArray(e))\n    return e;\n}\nfunction fh(e, t) {\n  var n = Object.keys(e);\n  if (Object.getOwnPropertySymbols) {\n    var r = Object.getOwnPropertySymbols(e);\n    t && (r = r.filter(function(i) {\n      return Object.getOwnPropertyDescriptor(e, i).enumerable;\n    })), n.push.apply(n, r);\n  }\n  return n;\n}\nfunction ju(e) {\n  for (var t = 1; t < arguments.length; t++) {\n    var n = arguments[t] != null ? arguments[t] : {};\n    t % 2 ? fh(Object(n), !0).forEach(function(r) {\n      dN(e, r, n[r]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : fh(Object(n)).forEach(function(r) {\n      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));\n    });\n  }\n  return e;\n}\nfunction dN(e, t, n) {\n  return t = pN(t), t in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;\n}\nfunction pN(e) {\n  var t = hN(e, \"string\");\n  return ro(t) == \"symbol\" ? t : String(t);\n}\nfunction hN(e, t) {\n  if (ro(e) != \"object\" || !e)\n    return e;\n  var n = e[Symbol.toPrimitive];\n  if (n !== void 0) {\n    var r = n.call(e, t || \"default\");\n    if (ro(r) != \"object\")\n      return r;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (t === \"string\" ? String : Number)(e);\n}\nfunction gN(e) {\n  return Array.isArray(e) && Ke(e[0]) && Ke(e[1]) ? e.join(\" ~ \") : e;\n}\nvar vN = function(t) {\n  var n = t.separator, r = n === void 0 ? \" : \" : n, i = t.contentStyle, o = i === void 0 ? {} : i, a = t.itemStyle, s = a === void 0 ? {} : a, u = t.labelStyle, c = u === void 0 ? {} : u, f = t.payload, l = t.formatter, d = t.itemSorter, p = t.wrapperClassName, g = t.labelClassName, h = t.label, v = t.labelFormatter, w = t.accessibilityLayer, b = w === void 0 ? !1 : w, x = function() {\n    if (f && f.length) {\n      var A = {\n        padding: 0,\n        margin: 0\n      }, j = (d ? Ff(f, d) : f).map(function(R, N) {\n        if (R.type === \"none\")\n          return null;\n        var k = ju({\n          display: \"block\",\n          paddingTop: 4,\n          paddingBottom: 4,\n          color: R.color || \"#000\"\n        }, s), F = R.formatter || l || gN, V = R.value, L = R.name, I = V, D = L;\n        if (F && I != null && D != null) {\n          var G = F(V, L, R, N, f);\n          if (Array.isArray(G)) {\n            var q = sN(G, 2);\n            I = q[0], D = q[1];\n          } else\n            I = G;\n        }\n        return (\n          // eslint-disable-next-line react/no-array-index-key\n          /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"li\", {\n            className: \"recharts-tooltip-item\",\n            key: \"tooltip-item-\".concat(N),\n            style: k\n          }, Ke(D) ? /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"span\", {\n            className: \"recharts-tooltip-item-name\"\n          }, D) : null, Ke(D) ? /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"span\", {\n            className: \"recharts-tooltip-item-separator\"\n          }, r) : null, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"span\", {\n            className: \"recharts-tooltip-item-value\"\n          }, I), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"span\", {\n            className: \"recharts-tooltip-item-unit\"\n          }, R.unit || \"\"))\n        );\n      });\n      return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"ul\", {\n        className: \"recharts-tooltip-item-list\",\n        style: A\n      }, j);\n    }\n    return null;\n  }, m = ju({\n    margin: 0,\n    padding: 10,\n    backgroundColor: \"#fff\",\n    border: \"1px solid #ccc\",\n    whiteSpace: \"nowrap\"\n  }, o), y = ju({\n    margin: 0\n  }, c), S = !me(h), $ = S ? h : \"\", O = $e(\"recharts-default-tooltip\", p), T = $e(\"recharts-tooltip-label\", g);\n  S && v && f !== void 0 && f !== null && ($ = v(h, f));\n  var M = b ? {\n    role: \"status\",\n    \"aria-live\": \"assertive\"\n  } : {};\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", Kc({\n    className: O,\n    style: m\n  }, M), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"p\", {\n    className: T,\n    style: y\n  }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.isValidElement($) ? $ : \"\".concat($)), x());\n};\nfunction io(e) {\n  \"@babel/helpers - typeof\";\n  return io = typeof Symbol == \"function\" && typeof Symbol.iterator == \"symbol\" ? function(t) {\n    return typeof t;\n  } : function(t) {\n    return t && typeof Symbol == \"function\" && t.constructor === Symbol && t !== Symbol.prototype ? \"symbol\" : typeof t;\n  }, io(e);\n}\nfunction da(e, t, n) {\n  return t = mN(t), t in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;\n}\nfunction mN(e) {\n  var t = yN(e, \"string\");\n  return io(t) == \"symbol\" ? t : String(t);\n}\nfunction yN(e, t) {\n  if (io(e) != \"object\" || !e)\n    return e;\n  var n = e[Symbol.toPrimitive];\n  if (n !== void 0) {\n    var r = n.call(e, t || \"default\");\n    if (io(r) != \"object\")\n      return r;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (t === \"string\" ? String : Number)(e);\n}\nvar Mi = \"recharts-tooltip-wrapper\", bN = {\n  visibility: \"hidden\"\n};\nfunction wN(e) {\n  var t = e.coordinate, n = e.translateX, r = e.translateY;\n  return $e(Mi, da(da(da(da({}, \"\".concat(Mi, \"-right\"), K(n) && t && K(t.x) && n >= t.x), \"\".concat(Mi, \"-left\"), K(n) && t && K(t.x) && n < t.x), \"\".concat(Mi, \"-bottom\"), K(r) && t && K(t.y) && r >= t.y), \"\".concat(Mi, \"-top\"), K(r) && t && K(t.y) && r < t.y));\n}\nfunction dh(e) {\n  var t = e.allowEscapeViewBox, n = e.coordinate, r = e.key, i = e.offsetTopLeft, o = e.position, a = e.reverseDirection, s = e.tooltipDimension, u = e.viewBox, c = e.viewBoxDimension;\n  if (o && K(o[r]))\n    return o[r];\n  var f = n[r] - s - i, l = n[r] + i;\n  if (t[r])\n    return a[r] ? f : l;\n  if (a[r]) {\n    var d = f, p = u[r];\n    return d < p ? Math.max(l, u[r]) : Math.max(f, u[r]);\n  }\n  var g = l + s, h = u[r] + c;\n  return g > h ? Math.max(f, u[r]) : Math.max(l, u[r]);\n}\nfunction xN(e) {\n  var t = e.translateX, n = e.translateY, r = e.useTranslate3d;\n  return {\n    transform: r ? \"translate3d(\".concat(t, \"px, \").concat(n, \"px, 0)\") : \"translate(\".concat(t, \"px, \").concat(n, \"px)\")\n  };\n}\nfunction SN(e) {\n  var t = e.allowEscapeViewBox, n = e.coordinate, r = e.offsetTopLeft, i = e.position, o = e.reverseDirection, a = e.tooltipBox, s = e.useTranslate3d, u = e.viewBox, c, f, l;\n  return a.height > 0 && a.width > 0 && n ? (f = dh({\n    allowEscapeViewBox: t,\n    coordinate: n,\n    key: \"x\",\n    offsetTopLeft: r,\n    position: i,\n    reverseDirection: o,\n    tooltipDimension: a.width,\n    viewBox: u,\n    viewBoxDimension: u.width\n  }), l = dh({\n    allowEscapeViewBox: t,\n    coordinate: n,\n    key: \"y\",\n    offsetTopLeft: r,\n    position: i,\n    reverseDirection: o,\n    tooltipDimension: a.height,\n    viewBox: u,\n    viewBoxDimension: u.height\n  }), c = xN({\n    translateX: f,\n    translateY: l,\n    useTranslate3d: s\n  })) : c = bN, {\n    cssProperties: c,\n    cssClasses: wN({\n      translateX: f,\n      translateY: l,\n      coordinate: n\n    })\n  };\n}\nfunction Gr(e) {\n  \"@babel/helpers - typeof\";\n  return Gr = typeof Symbol == \"function\" && typeof Symbol.iterator == \"symbol\" ? function(t) {\n    return typeof t;\n  } : function(t) {\n    return t && typeof Symbol == \"function\" && t.constructor === Symbol && t !== Symbol.prototype ? \"symbol\" : typeof t;\n  }, Gr(e);\n}\nfunction ph(e, t) {\n  var n = Object.keys(e);\n  if (Object.getOwnPropertySymbols) {\n    var r = Object.getOwnPropertySymbols(e);\n    t && (r = r.filter(function(i) {\n      return Object.getOwnPropertyDescriptor(e, i).enumerable;\n    })), n.push.apply(n, r);\n  }\n  return n;\n}\nfunction hh(e) {\n  for (var t = 1; t < arguments.length; t++) {\n    var n = arguments[t] != null ? arguments[t] : {};\n    t % 2 ? ph(Object(n), !0).forEach(function(r) {\n      Zc(e, r, n[r]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : ph(Object(n)).forEach(function(r) {\n      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));\n    });\n  }\n  return e;\n}\nfunction $N(e, t) {\n  if (!(e instanceof t))\n    throw new TypeError(\"Cannot call a class as a function\");\n}\nfunction ON(e, t) {\n  for (var n = 0; n < t.length; n++) {\n    var r = t[n];\n    r.enumerable = r.enumerable || !1, r.configurable = !0, \"value\" in r && (r.writable = !0), Object.defineProperty(e, zb(r.key), r);\n  }\n}\nfunction _N(e, t, n) {\n  return t && ON(e.prototype, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e;\n}\nfunction AN(e, t, n) {\n  return t = Ya(t), PN(e, Bb() ? Reflect.construct(t, n || [], Ya(e).constructor) : t.apply(e, n));\n}\nfunction PN(e, t) {\n  if (t && (Gr(t) === \"object\" || typeof t == \"function\"))\n    return t;\n  if (t !== void 0)\n    throw new TypeError(\"Derived constructors may only return object or undefined\");\n  return Yc(e);\n}\nfunction Bb() {\n  try {\n    var e = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {\n    }));\n  } catch {\n  }\n  return (Bb = function() {\n    return !!e;\n  })();\n}\nfunction Ya(e) {\n  return Ya = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(n) {\n    return n.__proto__ || Object.getPrototypeOf(n);\n  }, Ya(e);\n}\nfunction Yc(e) {\n  if (e === void 0)\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  return e;\n}\nfunction CN(e, t) {\n  if (typeof t != \"function\" && t !== null)\n    throw new TypeError(\"Super expression must either be null or a function\");\n  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, writable: !0, configurable: !0 } }), Object.defineProperty(e, \"prototype\", { writable: !1 }), t && Xc(e, t);\n}\nfunction Xc(e, t) {\n  return Xc = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(r, i) {\n    return r.__proto__ = i, r;\n  }, Xc(e, t);\n}\nfunction Zc(e, t, n) {\n  return t = zb(t), t in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;\n}\nfunction zb(e) {\n  var t = EN(e, \"string\");\n  return Gr(t) == \"symbol\" ? t : String(t);\n}\nfunction EN(e, t) {\n  if (Gr(e) != \"object\" || !e)\n    return e;\n  var n = e[Symbol.toPrimitive];\n  if (n !== void 0) {\n    var r = n.call(e, t || \"default\");\n    if (Gr(r) != \"object\")\n      return r;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (t === \"string\" ? String : Number)(e);\n}\nvar gh = 1, TN = /* @__PURE__ */ function(e) {\n  CN(t, e);\n  function t() {\n    var n;\n    $N(this, t);\n    for (var r = arguments.length, i = new Array(r), o = 0; o < r; o++)\n      i[o] = arguments[o];\n    return n = AN(this, t, [].concat(i)), Zc(Yc(n), \"state\", {\n      dismissed: !1,\n      dismissedAtCoordinate: {\n        x: 0,\n        y: 0\n      },\n      lastBoundingBox: {\n        width: -1,\n        height: -1\n      }\n    }), Zc(Yc(n), \"handleKeyDown\", function(a) {\n      if (a.key === \"Escape\") {\n        var s, u, c, f;\n        n.setState({\n          dismissed: !0,\n          dismissedAtCoordinate: {\n            x: (s = (u = n.props.coordinate) === null || u === void 0 ? void 0 : u.x) !== null && s !== void 0 ? s : 0,\n            y: (c = (f = n.props.coordinate) === null || f === void 0 ? void 0 : f.y) !== null && c !== void 0 ? c : 0\n          }\n        });\n      }\n    }), n;\n  }\n  return _N(t, [{\n    key: \"updateBBox\",\n    value: function() {\n      if (this.wrapperNode && this.wrapperNode.getBoundingClientRect) {\n        var r = this.wrapperNode.getBoundingClientRect();\n        (Math.abs(r.width - this.state.lastBoundingBox.width) > gh || Math.abs(r.height - this.state.lastBoundingBox.height) > gh) && this.setState({\n          lastBoundingBox: {\n            width: r.width,\n            height: r.height\n          }\n        });\n      } else\n        (this.state.lastBoundingBox.width !== -1 || this.state.lastBoundingBox.height !== -1) && this.setState({\n          lastBoundingBox: {\n            width: -1,\n            height: -1\n          }\n        });\n    }\n  }, {\n    key: \"componentDidMount\",\n    value: function() {\n      document.addEventListener(\"keydown\", this.handleKeyDown), this.updateBBox();\n    }\n  }, {\n    key: \"componentWillUnmount\",\n    value: function() {\n      document.removeEventListener(\"keydown\", this.handleKeyDown);\n    }\n  }, {\n    key: \"componentDidUpdate\",\n    value: function() {\n      var r, i;\n      this.props.active && this.updateBBox(), this.state.dismissed && (((r = this.props.coordinate) === null || r === void 0 ? void 0 : r.x) !== this.state.dismissedAtCoordinate.x || ((i = this.props.coordinate) === null || i === void 0 ? void 0 : i.y) !== this.state.dismissedAtCoordinate.y) && (this.state.dismissed = !1);\n    }\n  }, {\n    key: \"render\",\n    value: function() {\n      var r = this, i = this.props, o = i.active, a = i.allowEscapeViewBox, s = i.animationDuration, u = i.animationEasing, c = i.children, f = i.coordinate, l = i.hasPayload, d = i.isAnimationActive, p = i.offset, g = i.position, h = i.reverseDirection, v = i.useTranslate3d, w = i.viewBox, b = i.wrapperStyle, x = SN({\n        allowEscapeViewBox: a,\n        coordinate: f,\n        offsetTopLeft: p,\n        position: g,\n        reverseDirection: h,\n        tooltipBox: this.state.lastBoundingBox,\n        useTranslate3d: v,\n        viewBox: w\n      }), m = x.cssClasses, y = x.cssProperties, S = hh(hh({\n        transition: d && o ? \"transform \".concat(s, \"ms \").concat(u) : void 0\n      }, y), {}, {\n        pointerEvents: \"none\",\n        visibility: !this.state.dismissed && o && l ? \"visible\" : \"hidden\",\n        position: \"absolute\",\n        top: 0,\n        left: 0\n      }, b);\n      return (\n        // This element allow listening to the `Escape` key.\n        // See https://github.com/recharts/recharts/pull/2925\n        /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n          tabIndex: -1,\n          className: m,\n          style: S,\n          ref: function(O) {\n            r.wrapperNode = O;\n          }\n        }, c)\n      );\n    }\n  }]), t;\n}(react__WEBPACK_IMPORTED_MODULE_0__.PureComponent), MN = function() {\n  return !(typeof window < \"u\" && window.document && window.document.createElement && window.setTimeout);\n}, yn = {\n  isSsr: MN(),\n  get: function(t) {\n    return yn[t];\n  },\n  set: function(t, n) {\n    if (typeof t == \"string\")\n      yn[t] = n;\n    else {\n      var r = Object.keys(t);\n      r && r.length && r.forEach(function(i) {\n        yn[i] = t[i];\n      });\n    }\n  }\n};\nfunction Wr(e) {\n  \"@babel/helpers - typeof\";\n  return Wr = typeof Symbol == \"function\" && typeof Symbol.iterator == \"symbol\" ? function(t) {\n    return typeof t;\n  } : function(t) {\n    return t && typeof Symbol == \"function\" && t.constructor === Symbol && t !== Symbol.prototype ? \"symbol\" : typeof t;\n  }, Wr(e);\n}\nfunction vh(e, t) {\n  var n = Object.keys(e);\n  if (Object.getOwnPropertySymbols) {\n    var r = Object.getOwnPropertySymbols(e);\n    t && (r = r.filter(function(i) {\n      return Object.getOwnPropertyDescriptor(e, i).enumerable;\n    })), n.push.apply(n, r);\n  }\n  return n;\n}\nfunction mh(e) {\n  for (var t = 1; t < arguments.length; t++) {\n    var n = arguments[t] != null ? arguments[t] : {};\n    t % 2 ? vh(Object(n), !0).forEach(function(r) {\n      Lf(e, r, n[r]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : vh(Object(n)).forEach(function(r) {\n      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));\n    });\n  }\n  return e;\n}\nfunction RN(e, t) {\n  if (!(e instanceof t))\n    throw new TypeError(\"Cannot call a class as a function\");\n}\nfunction IN(e, t) {\n  for (var n = 0; n < t.length; n++) {\n    var r = t[n];\n    r.enumerable = r.enumerable || !1, r.configurable = !0, \"value\" in r && (r.writable = !0), Object.defineProperty(e, Gb(r.key), r);\n  }\n}\nfunction jN(e, t, n) {\n  return t && IN(e.prototype, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e;\n}\nfunction kN(e, t, n) {\n  return t = Xa(t), DN(e, Vb() ? Reflect.construct(t, n || [], Xa(e).constructor) : t.apply(e, n));\n}\nfunction DN(e, t) {\n  if (t && (Wr(t) === \"object\" || typeof t == \"function\"))\n    return t;\n  if (t !== void 0)\n    throw new TypeError(\"Derived constructors may only return object or undefined\");\n  return NN(e);\n}\nfunction NN(e) {\n  if (e === void 0)\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  return e;\n}\nfunction Vb() {\n  try {\n    var e = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {\n    }));\n  } catch {\n  }\n  return (Vb = function() {\n    return !!e;\n  })();\n}\nfunction Xa(e) {\n  return Xa = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(n) {\n    return n.__proto__ || Object.getPrototypeOf(n);\n  }, Xa(e);\n}\nfunction FN(e, t) {\n  if (typeof t != \"function\" && t !== null)\n    throw new TypeError(\"Super expression must either be null or a function\");\n  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, writable: !0, configurable: !0 } }), Object.defineProperty(e, \"prototype\", { writable: !1 }), t && Jc(e, t);\n}\nfunction Jc(e, t) {\n  return Jc = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(r, i) {\n    return r.__proto__ = i, r;\n  }, Jc(e, t);\n}\nfunction Lf(e, t, n) {\n  return t = Gb(t), t in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;\n}\nfunction Gb(e) {\n  var t = LN(e, \"string\");\n  return Wr(t) == \"symbol\" ? t : String(t);\n}\nfunction LN(e, t) {\n  if (Wr(e) != \"object\" || !e)\n    return e;\n  var n = e[Symbol.toPrimitive];\n  if (n !== void 0) {\n    var r = n.call(e, t || \"default\");\n    if (Wr(r) != \"object\")\n      return r;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (t === \"string\" ? String : Number)(e);\n}\nfunction BN(e) {\n  return e.dataKey;\n}\nfunction zN(e, t) {\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.isValidElement(e) ? /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.cloneElement(e, t) : typeof e == \"function\" ? /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(e, t) : /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(vN, t);\n}\nvar tn = /* @__PURE__ */ function(e) {\n  FN(t, e);\n  function t() {\n    return RN(this, t), kN(this, t, arguments);\n  }\n  return jN(t, [{\n    key: \"render\",\n    value: function() {\n      var r = this, i = this.props, o = i.active, a = i.allowEscapeViewBox, s = i.animationDuration, u = i.animationEasing, c = i.content, f = i.coordinate, l = i.filterNull, d = i.isAnimationActive, p = i.offset, g = i.payload, h = i.payloadUniqBy, v = i.position, w = i.reverseDirection, b = i.useTranslate3d, x = i.viewBox, m = i.wrapperStyle, y = g ?? [];\n      l && y.length && (y = Mb(g.filter(function($) {\n        return $.value != null && ($.hide !== !0 || r.props.includeHidden);\n      }), h, BN));\n      var S = y.length > 0;\n      return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(TN, {\n        allowEscapeViewBox: a,\n        animationDuration: s,\n        animationEasing: u,\n        isAnimationActive: d,\n        active: o,\n        coordinate: f,\n        hasPayload: S,\n        offset: p,\n        position: v,\n        reverseDirection: w,\n        useTranslate3d: b,\n        viewBox: x,\n        wrapperStyle: m\n      }, zN(c, mh(mh({}, this.props), {}, {\n        payload: y\n      })));\n    }\n  }]), t;\n}(react__WEBPACK_IMPORTED_MODULE_0__.PureComponent);\nLf(tn, \"displayName\", \"Tooltip\");\nLf(tn, \"defaultProps\", {\n  accessibilityLayer: !1,\n  allowEscapeViewBox: {\n    x: !1,\n    y: !1\n  },\n  animationDuration: 400,\n  animationEasing: \"ease\",\n  contentStyle: {},\n  coordinate: {\n    x: 0,\n    y: 0\n  },\n  cursor: !0,\n  cursorStyle: {},\n  filterNull: !0,\n  isAnimationActive: !yn.isSsr,\n  itemStyle: {},\n  labelStyle: {},\n  offset: 10,\n  reverseDirection: {\n    x: !1,\n    y: !1\n  },\n  separator: \" : \",\n  trigger: \"hover\",\n  useTranslate3d: !1,\n  viewBox: {\n    x: 0,\n    y: 0,\n    height: 0,\n    width: 0\n  },\n  wrapperStyle: {}\n});\nvar VN = dn, GN = function() {\n  return VN.Date.now();\n}, WN = GN, UN = /\\s/;\nfunction HN(e) {\n  for (var t = e.length; t-- && UN.test(e.charAt(t)); )\n    ;\n  return t;\n}\nvar qN = HN, KN = qN, YN = /^\\s+/;\nfunction XN(e) {\n  return e && e.slice(0, KN(e) + 1).replace(YN, \"\");\n}\nvar ZN = XN, JN = ZN, yh = Un, QN = ui, bh = NaN, eF = /^[-+]0x[0-9a-f]+$/i, tF = /^0b[01]+$/i, nF = /^0o[0-7]+$/i, rF = parseInt;\nfunction iF(e) {\n  if (typeof e == \"number\")\n    return e;\n  if (QN(e))\n    return bh;\n  if (yh(e)) {\n    var t = typeof e.valueOf == \"function\" ? e.valueOf() : e;\n    e = yh(t) ? t + \"\" : t;\n  }\n  if (typeof e != \"string\")\n    return e === 0 ? e : +e;\n  e = JN(e);\n  var n = tF.test(e);\n  return n || nF.test(e) ? rF(e.slice(2), n ? 2 : 8) : eF.test(e) ? bh : +e;\n}\nvar Wb = iF, oF = Un, ku = WN, wh = Wb, aF = \"Expected a function\", sF = Math.max, uF = Math.min;\nfunction cF(e, t, n) {\n  var r, i, o, a, s, u, c = 0, f = !1, l = !1, d = !0;\n  if (typeof e != \"function\")\n    throw new TypeError(aF);\n  t = wh(t) || 0, oF(n) && (f = !!n.leading, l = \"maxWait\" in n, o = l ? sF(wh(n.maxWait) || 0, t) : o, d = \"trailing\" in n ? !!n.trailing : d);\n  function p(S) {\n    var $ = r, O = i;\n    return r = i = void 0, c = S, a = e.apply(O, $), a;\n  }\n  function g(S) {\n    return c = S, s = setTimeout(w, t), f ? p(S) : a;\n  }\n  function h(S) {\n    var $ = S - u, O = S - c, T = t - $;\n    return l ? uF(T, o - O) : T;\n  }\n  function v(S) {\n    var $ = S - u, O = S - c;\n    return u === void 0 || $ >= t || $ < 0 || l && O >= o;\n  }\n  function w() {\n    var S = ku();\n    if (v(S))\n      return b(S);\n    s = setTimeout(w, h(S));\n  }\n  function b(S) {\n    return s = void 0, d && r ? p(S) : (r = i = void 0, a);\n  }\n  function x() {\n    s !== void 0 && clearTimeout(s), c = 0, r = u = i = s = void 0;\n  }\n  function m() {\n    return s === void 0 ? a : b(ku());\n  }\n  function y() {\n    var S = ku(), $ = v(S);\n    if (r = arguments, i = this, u = S, $) {\n      if (s === void 0)\n        return g(u);\n      if (l)\n        return clearTimeout(s), s = setTimeout(w, t), p(u);\n    }\n    return s === void 0 && (s = setTimeout(w, t)), a;\n  }\n  return y.cancel = x, y.flush = m, y;\n}\nvar lF = cF, fF = lF, dF = Un, pF = \"Expected a function\";\nfunction hF(e, t, n) {\n  var r = !0, i = !0;\n  if (typeof e != \"function\")\n    throw new TypeError(pF);\n  return dF(n) && (r = \"leading\" in n ? !!n.leading : r, i = \"trailing\" in n ? !!n.trailing : i), fF(e, t, {\n    leading: r,\n    maxWait: t,\n    trailing: i\n  });\n}\nvar gF = hF;\nconst vF = /* @__PURE__ */ je(gF);\nvar Ub = function(t) {\n  return null;\n};\nUb.displayName = \"Cell\";\nfunction oo(e) {\n  \"@babel/helpers - typeof\";\n  return oo = typeof Symbol == \"function\" && typeof Symbol.iterator == \"symbol\" ? function(t) {\n    return typeof t;\n  } : function(t) {\n    return t && typeof Symbol == \"function\" && t.constructor === Symbol && t !== Symbol.prototype ? \"symbol\" : typeof t;\n  }, oo(e);\n}\nfunction xh(e, t) {\n  var n = Object.keys(e);\n  if (Object.getOwnPropertySymbols) {\n    var r = Object.getOwnPropertySymbols(e);\n    t && (r = r.filter(function(i) {\n      return Object.getOwnPropertyDescriptor(e, i).enumerable;\n    })), n.push.apply(n, r);\n  }\n  return n;\n}\nfunction Qc(e) {\n  for (var t = 1; t < arguments.length; t++) {\n    var n = arguments[t] != null ? arguments[t] : {};\n    t % 2 ? xh(Object(n), !0).forEach(function(r) {\n      mF(e, r, n[r]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : xh(Object(n)).forEach(function(r) {\n      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));\n    });\n  }\n  return e;\n}\nfunction mF(e, t, n) {\n  return t = yF(t), t in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;\n}\nfunction yF(e) {\n  var t = bF(e, \"string\");\n  return oo(t) == \"symbol\" ? t : String(t);\n}\nfunction bF(e, t) {\n  if (oo(e) != \"object\" || !e)\n    return e;\n  var n = e[Symbol.toPrimitive];\n  if (n !== void 0) {\n    var r = n.call(e, t || \"default\");\n    if (oo(r) != \"object\")\n      return r;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (t === \"string\" ? String : Number)(e);\n}\nvar Or = {\n  widthCache: {},\n  cacheCount: 0\n}, wF = 2e3, xF = {\n  position: \"absolute\",\n  top: \"-20000px\",\n  left: 0,\n  padding: 0,\n  margin: 0,\n  border: \"none\",\n  whiteSpace: \"pre\"\n}, Sh = \"recharts_measurement_span\";\nfunction SF(e) {\n  var t = Qc({}, e);\n  return Object.keys(t).forEach(function(n) {\n    t[n] || delete t[n];\n  }), t;\n}\nvar Gi = function(t) {\n  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n  if (t == null || yn.isSsr)\n    return {\n      width: 0,\n      height: 0\n    };\n  var r = SF(n), i = JSON.stringify({\n    text: t,\n    copyStyle: r\n  });\n  if (Or.widthCache[i])\n    return Or.widthCache[i];\n  try {\n    var o = document.getElementById(Sh);\n    o || (o = document.createElement(\"span\"), o.setAttribute(\"id\", Sh), o.setAttribute(\"aria-hidden\", \"true\"), document.body.appendChild(o));\n    var a = Qc(Qc({}, xF), r);\n    Object.assign(o.style, a), o.textContent = \"\".concat(t);\n    var s = o.getBoundingClientRect(), u = {\n      width: s.width,\n      height: s.height\n    };\n    return Or.widthCache[i] = u, ++Or.cacheCount > wF && (Or.cacheCount = 0, Or.widthCache = {}), u;\n  } catch {\n    return {\n      width: 0,\n      height: 0\n    };\n  }\n}, $F = function(t) {\n  return {\n    top: t.top + window.scrollY - document.documentElement.clientTop,\n    left: t.left + window.scrollX - document.documentElement.clientLeft\n  };\n};\nfunction ao(e) {\n  \"@babel/helpers - typeof\";\n  return ao = typeof Symbol == \"function\" && typeof Symbol.iterator == \"symbol\" ? function(t) {\n    return typeof t;\n  } : function(t) {\n    return t && typeof Symbol == \"function\" && t.constructor === Symbol && t !== Symbol.prototype ? \"symbol\" : typeof t;\n  }, ao(e);\n}\nfunction Za(e, t) {\n  return PF(e) || AF(e, t) || _F(e, t) || OF();\n}\nfunction OF() {\n  throw new TypeError(`Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);\n}\nfunction _F(e, t) {\n  if (e) {\n    if (typeof e == \"string\")\n      return $h(e, t);\n    var n = Object.prototype.toString.call(e).slice(8, -1);\n    if (n === \"Object\" && e.constructor && (n = e.constructor.name), n === \"Map\" || n === \"Set\")\n      return Array.from(e);\n    if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))\n      return $h(e, t);\n  }\n}\nfunction $h(e, t) {\n  (t == null || t > e.length) && (t = e.length);\n  for (var n = 0, r = new Array(t); n < t; n++)\n    r[n] = e[n];\n  return r;\n}\nfunction AF(e, t) {\n  var n = e == null ? null : typeof Symbol < \"u\" && e[Symbol.iterator] || e[\"@@iterator\"];\n  if (n != null) {\n    var r, i, o, a, s = [], u = !0, c = !1;\n    try {\n      if (o = (n = n.call(e)).next, t === 0) {\n        if (Object(n) !== n)\n          return;\n        u = !1;\n      } else\n        for (; !(u = (r = o.call(n)).done) && (s.push(r.value), s.length !== t); u = !0)\n          ;\n    } catch (f) {\n      c = !0, i = f;\n    } finally {\n      try {\n        if (!u && n.return != null && (a = n.return(), Object(a) !== a))\n          return;\n      } finally {\n        if (c)\n          throw i;\n      }\n    }\n    return s;\n  }\n}\nfunction PF(e) {\n  if (Array.isArray(e))\n    return e;\n}\nfunction CF(e, t) {\n  if (!(e instanceof t))\n    throw new TypeError(\"Cannot call a class as a function\");\n}\nfunction Oh(e, t) {\n  for (var n = 0; n < t.length; n++) {\n    var r = t[n];\n    r.enumerable = r.enumerable || !1, r.configurable = !0, \"value\" in r && (r.writable = !0), Object.defineProperty(e, TF(r.key), r);\n  }\n}\nfunction EF(e, t, n) {\n  return t && Oh(e.prototype, t), n && Oh(e, n), Object.defineProperty(e, \"prototype\", { writable: !1 }), e;\n}\nfunction TF(e) {\n  var t = MF(e, \"string\");\n  return ao(t) == \"symbol\" ? t : String(t);\n}\nfunction MF(e, t) {\n  if (ao(e) != \"object\" || !e)\n    return e;\n  var n = e[Symbol.toPrimitive];\n  if (n !== void 0) {\n    var r = n.call(e, t);\n    if (ao(r) != \"object\")\n      return r;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return String(e);\n}\nvar _h = /(-?\\d+(?:\\.\\d+)?[a-zA-Z%]*)([*/])(-?\\d+(?:\\.\\d+)?[a-zA-Z%]*)/, Ah = /(-?\\d+(?:\\.\\d+)?[a-zA-Z%]*)([+-])(-?\\d+(?:\\.\\d+)?[a-zA-Z%]*)/, RF = /^px|cm|vh|vw|em|rem|%|mm|in|pt|pc|ex|ch|vmin|vmax|Q$/, IF = /(-?\\d+(?:\\.\\d+)?)([a-zA-Z%]+)?/, Hb = {\n  cm: 96 / 2.54,\n  mm: 96 / 25.4,\n  pt: 96 / 72,\n  pc: 96 / 6,\n  in: 96,\n  Q: 96 / (2.54 * 40),\n  px: 1\n}, jF = Object.keys(Hb), Cr = \"NaN\";\nfunction kF(e, t) {\n  return e * Hb[t];\n}\nvar pa = /* @__PURE__ */ function() {\n  function e(t, n) {\n    CF(this, e), this.num = t, this.unit = n, this.num = t, this.unit = n, Number.isNaN(t) && (this.unit = \"\"), n !== \"\" && !RF.test(n) && (this.num = NaN, this.unit = \"\"), jF.includes(n) && (this.num = kF(t, n), this.unit = \"px\");\n  }\n  return EF(e, [{\n    key: \"add\",\n    value: function(n) {\n      return this.unit !== n.unit ? new e(NaN, \"\") : new e(this.num + n.num, this.unit);\n    }\n  }, {\n    key: \"subtract\",\n    value: function(n) {\n      return this.unit !== n.unit ? new e(NaN, \"\") : new e(this.num - n.num, this.unit);\n    }\n  }, {\n    key: \"multiply\",\n    value: function(n) {\n      return this.unit !== \"\" && n.unit !== \"\" && this.unit !== n.unit ? new e(NaN, \"\") : new e(this.num * n.num, this.unit || n.unit);\n    }\n  }, {\n    key: \"divide\",\n    value: function(n) {\n      return this.unit !== \"\" && n.unit !== \"\" && this.unit !== n.unit ? new e(NaN, \"\") : new e(this.num / n.num, this.unit || n.unit);\n    }\n  }, {\n    key: \"toString\",\n    value: function() {\n      return \"\".concat(this.num).concat(this.unit);\n    }\n  }, {\n    key: \"isNaN\",\n    value: function() {\n      return Number.isNaN(this.num);\n    }\n  }], [{\n    key: \"parse\",\n    value: function(n) {\n      var r, i = (r = IF.exec(n)) !== null && r !== void 0 ? r : [], o = Za(i, 3), a = o[1], s = o[2];\n      return new e(parseFloat(a), s ?? \"\");\n    }\n  }]), e;\n}();\nfunction qb(e) {\n  if (e.includes(Cr))\n    return Cr;\n  for (var t = e; t.includes(\"*\") || t.includes(\"/\"); ) {\n    var n, r = (n = _h.exec(t)) !== null && n !== void 0 ? n : [], i = Za(r, 4), o = i[1], a = i[2], s = i[3], u = pa.parse(o ?? \"\"), c = pa.parse(s ?? \"\"), f = a === \"*\" ? u.multiply(c) : u.divide(c);\n    if (f.isNaN())\n      return Cr;\n    t = t.replace(_h, f.toString());\n  }\n  for (; t.includes(\"+\") || /.-\\d+(?:\\.\\d+)?/.test(t); ) {\n    var l, d = (l = Ah.exec(t)) !== null && l !== void 0 ? l : [], p = Za(d, 4), g = p[1], h = p[2], v = p[3], w = pa.parse(g ?? \"\"), b = pa.parse(v ?? \"\"), x = h === \"+\" ? w.add(b) : w.subtract(b);\n    if (x.isNaN())\n      return Cr;\n    t = t.replace(Ah, x.toString());\n  }\n  return t;\n}\nvar Ph = /\\(([^()]*)\\)/;\nfunction DF(e) {\n  for (var t = e; t.includes(\"(\"); ) {\n    var n = Ph.exec(t), r = Za(n, 2), i = r[1];\n    t = t.replace(Ph, qb(i));\n  }\n  return t;\n}\nfunction NF(e) {\n  var t = e.replace(/\\s+/g, \"\");\n  return t = DF(t), t = qb(t), t;\n}\nfunction FF(e) {\n  try {\n    return NF(e);\n  } catch {\n    return Cr;\n  }\n}\nfunction Du(e) {\n  var t = FF(e.slice(5, -1));\n  return t === Cr ? \"\" : t;\n}\nvar LF = [\"x\", \"y\", \"lineHeight\", \"capHeight\", \"scaleToFit\", \"textAnchor\", \"verticalAnchor\", \"fill\"], BF = [\"dx\", \"dy\", \"angle\", \"className\", \"breakAll\"];\nfunction el() {\n  return el = Object.assign ? Object.assign.bind() : function(e) {\n    for (var t = 1; t < arguments.length; t++) {\n      var n = arguments[t];\n      for (var r in n)\n        Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);\n    }\n    return e;\n  }, el.apply(this, arguments);\n}\nfunction Ch(e, t) {\n  if (e == null)\n    return {};\n  var n = zF(e, t), r, i;\n  if (Object.getOwnPropertySymbols) {\n    var o = Object.getOwnPropertySymbols(e);\n    for (i = 0; i < o.length; i++)\n      r = o[i], !(t.indexOf(r) >= 0) && Object.prototype.propertyIsEnumerable.call(e, r) && (n[r] = e[r]);\n  }\n  return n;\n}\nfunction zF(e, t) {\n  if (e == null)\n    return {};\n  var n = {}, r = Object.keys(e), i, o;\n  for (o = 0; o < r.length; o++)\n    i = r[o], !(t.indexOf(i) >= 0) && (n[i] = e[i]);\n  return n;\n}\nfunction Eh(e, t) {\n  return UF(e) || WF(e, t) || GF(e, t) || VF();\n}\nfunction VF() {\n  throw new TypeError(`Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);\n}\nfunction GF(e, t) {\n  if (e) {\n    if (typeof e == \"string\")\n      return Th(e, t);\n    var n = Object.prototype.toString.call(e).slice(8, -1);\n    if (n === \"Object\" && e.constructor && (n = e.constructor.name), n === \"Map\" || n === \"Set\")\n      return Array.from(e);\n    if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))\n      return Th(e, t);\n  }\n}\nfunction Th(e, t) {\n  (t == null || t > e.length) && (t = e.length);\n  for (var n = 0, r = new Array(t); n < t; n++)\n    r[n] = e[n];\n  return r;\n}\nfunction WF(e, t) {\n  var n = e == null ? null : typeof Symbol < \"u\" && e[Symbol.iterator] || e[\"@@iterator\"];\n  if (n != null) {\n    var r, i, o, a, s = [], u = !0, c = !1;\n    try {\n      if (o = (n = n.call(e)).next, t === 0) {\n        if (Object(n) !== n)\n          return;\n        u = !1;\n      } else\n        for (; !(u = (r = o.call(n)).done) && (s.push(r.value), s.length !== t); u = !0)\n          ;\n    } catch (f) {\n      c = !0, i = f;\n    } finally {\n      try {\n        if (!u && n.return != null && (a = n.return(), Object(a) !== a))\n          return;\n      } finally {\n        if (c)\n          throw i;\n      }\n    }\n    return s;\n  }\n}\nfunction UF(e) {\n  if (Array.isArray(e))\n    return e;\n}\nvar Kb = /[ \\f\\n\\r\\t\\v\\u2028\\u2029]+/, Yb = function(t) {\n  var n = t.children, r = t.breakAll, i = t.style;\n  try {\n    var o = [];\n    me(n) || (r ? o = n.toString().split(\"\") : o = n.toString().split(Kb));\n    var a = o.map(function(u) {\n      return {\n        word: u,\n        width: Gi(u, i).width\n      };\n    }), s = r ? 0 : Gi(\"\", i).width;\n    return {\n      wordsWithComputedWidth: a,\n      spaceWidth: s\n    };\n  } catch {\n    return null;\n  }\n}, HF = function(t, n, r, i, o) {\n  var a = t.maxLines, s = t.children, u = t.style, c = t.breakAll, f = K(a), l = s, d = function() {\n    var N = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];\n    return N.reduce(function(k, F) {\n      var V = F.word, L = F.width, I = k[k.length - 1];\n      if (I && (i == null || o || I.width + L + r < Number(i)))\n        I.words.push(V), I.width += L + r;\n      else {\n        var D = {\n          words: [V],\n          width: L\n        };\n        k.push(D);\n      }\n      return k;\n    }, []);\n  }, p = d(n), g = function(N) {\n    return N.reduce(function(k, F) {\n      return k.width > F.width ? k : F;\n    });\n  };\n  if (!f)\n    return p;\n  for (var h = \"\", v = function(N) {\n    var k = l.slice(0, N), F = Yb({\n      breakAll: c,\n      style: u,\n      children: k + h\n    }).wordsWithComputedWidth, V = d(F), L = V.length > a || g(V).width > Number(i);\n    return [L, V];\n  }, w = 0, b = l.length - 1, x = 0, m; w <= b && x <= l.length - 1; ) {\n    var y = Math.floor((w + b) / 2), S = y - 1, $ = v(S), O = Eh($, 2), T = O[0], M = O[1], E = v(y), A = Eh(E, 1), j = A[0];\n    if (!T && !j && (w = y + 1), T && j && (b = y - 1), !T && j) {\n      m = M;\n      break;\n    }\n    x++;\n  }\n  return m || p;\n}, Mh = function(t) {\n  var n = me(t) ? [] : t.toString().split(Kb);\n  return [{\n    words: n\n  }];\n}, qF = function(t) {\n  var n = t.width, r = t.scaleToFit, i = t.children, o = t.style, a = t.breakAll, s = t.maxLines;\n  if ((n || r) && !yn.isSsr) {\n    var u, c, f = Yb({\n      breakAll: a,\n      children: i,\n      style: o\n    });\n    if (f) {\n      var l = f.wordsWithComputedWidth, d = f.spaceWidth;\n      u = l, c = d;\n    } else\n      return Mh(i);\n    return HF({\n      breakAll: a,\n      children: i,\n      maxLines: s,\n      style: o\n    }, u, c, n, r);\n  }\n  return Mh(i);\n}, Rh = \"#808080\", Ja = function(t) {\n  var n = t.x, r = n === void 0 ? 0 : n, i = t.y, o = i === void 0 ? 0 : i, a = t.lineHeight, s = a === void 0 ? \"1em\" : a, u = t.capHeight, c = u === void 0 ? \"0.71em\" : u, f = t.scaleToFit, l = f === void 0 ? !1 : f, d = t.textAnchor, p = d === void 0 ? \"start\" : d, g = t.verticalAnchor, h = g === void 0 ? \"end\" : g, v = t.fill, w = v === void 0 ? Rh : v, b = Ch(t, LF), x = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(function() {\n    return qF({\n      breakAll: b.breakAll,\n      children: b.children,\n      maxLines: b.maxLines,\n      scaleToFit: l,\n      style: b.style,\n      width: b.width\n    });\n  }, [b.breakAll, b.children, b.maxLines, l, b.style, b.width]), m = b.dx, y = b.dy, S = b.angle, $ = b.className, O = b.breakAll, T = Ch(b, BF);\n  if (!Ke(r) || !Ke(o))\n    return null;\n  var M = r + (K(m) ? m : 0), E = o + (K(y) ? y : 0), A;\n  switch (h) {\n    case \"start\":\n      A = Du(\"calc(\".concat(c, \")\"));\n      break;\n    case \"middle\":\n      A = Du(\"calc(\".concat((x.length - 1) / 2, \" * -\").concat(s, \" + (\").concat(c, \" / 2))\"));\n      break;\n    default:\n      A = Du(\"calc(\".concat(x.length - 1, \" * -\").concat(s, \")\"));\n      break;\n  }\n  var j = [];\n  if (l) {\n    var R = x[0].width, N = b.width;\n    j.push(\"scale(\".concat((K(N) ? N / R : 1) / R, \")\"));\n  }\n  return S && j.push(\"rotate(\".concat(S, \", \").concat(M, \", \").concat(E, \")\")), j.length && (T.transform = j.join(\" \")), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"text\", el({}, ye(T, !0), {\n    x: M,\n    y: E,\n    className: $e(\"recharts-text\", $),\n    textAnchor: p,\n    fill: w.includes(\"url\") ? Rh : w\n  }), x.map(function(k, F) {\n    var V = k.words.join(O ? \"\" : \" \");\n    return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"tspan\", {\n      x: M,\n      dy: F === 0 ? A : s,\n      key: V\n    }, V);\n  }));\n};\nfunction Ln(e, t) {\n  return e == null || t == null ? NaN : e < t ? -1 : e > t ? 1 : e >= t ? 0 : NaN;\n}\nfunction KF(e, t) {\n  return e == null || t == null ? NaN : t < e ? -1 : t > e ? 1 : t >= e ? 0 : NaN;\n}\nfunction Bf(e) {\n  let t, n, r;\n  e.length !== 2 ? (t = Ln, n = (s, u) => Ln(e(s), u), r = (s, u) => e(s) - u) : (t = e === Ln || e === KF ? e : YF, n = e, r = e);\n  function i(s, u, c = 0, f = s.length) {\n    if (c < f) {\n      if (t(u, u) !== 0)\n        return f;\n      do {\n        const l = c + f >>> 1;\n        n(s[l], u) < 0 ? c = l + 1 : f = l;\n      } while (c < f);\n    }\n    return c;\n  }\n  function o(s, u, c = 0, f = s.length) {\n    if (c < f) {\n      if (t(u, u) !== 0)\n        return f;\n      do {\n        const l = c + f >>> 1;\n        n(s[l], u) <= 0 ? c = l + 1 : f = l;\n      } while (c < f);\n    }\n    return c;\n  }\n  function a(s, u, c = 0, f = s.length) {\n    const l = i(s, u, c, f - 1);\n    return l > c && r(s[l - 1], u) > -r(s[l], u) ? l - 1 : l;\n  }\n  return { left: i, center: a, right: o };\n}\nfunction YF() {\n  return 0;\n}\nfunction Xb(e) {\n  return e === null ? NaN : +e;\n}\nfunction* XF(e, t) {\n  for (let n of e)\n    n != null && (n = +n) >= n && (yield n);\n}\nconst ZF = Bf(Ln), qo = ZF.right;\nBf(Xb).center;\nclass Ih extends Map {\n  constructor(t, n = eL) {\n    if (super(), Object.defineProperties(this, { _intern: { value: /* @__PURE__ */ new Map() }, _key: { value: n } }), t != null)\n      for (const [r, i] of t)\n        this.set(r, i);\n  }\n  get(t) {\n    return super.get(jh(this, t));\n  }\n  has(t) {\n    return super.has(jh(this, t));\n  }\n  set(t, n) {\n    return super.set(JF(this, t), n);\n  }\n  delete(t) {\n    return super.delete(QF(this, t));\n  }\n}\nfunction jh({ _intern: e, _key: t }, n) {\n  const r = t(n);\n  return e.has(r) ? e.get(r) : n;\n}\nfunction JF({ _intern: e, _key: t }, n) {\n  const r = t(n);\n  return e.has(r) ? e.get(r) : (e.set(r, n), n);\n}\nfunction QF({ _intern: e, _key: t }, n) {\n  const r = t(n);\n  return e.has(r) && (n = e.get(r), e.delete(r)), n;\n}\nfunction eL(e) {\n  return e !== null && typeof e == \"object\" ? e.valueOf() : e;\n}\nfunction tL(e = Ln) {\n  if (e === Ln)\n    return Zb;\n  if (typeof e != \"function\")\n    throw new TypeError(\"compare is not a function\");\n  return (t, n) => {\n    const r = e(t, n);\n    return r || r === 0 ? r : (e(n, n) === 0) - (e(t, t) === 0);\n  };\n}\nfunction Zb(e, t) {\n  return (e == null || !(e >= e)) - (t == null || !(t >= t)) || (e < t ? -1 : e > t ? 1 : 0);\n}\nconst nL = Math.sqrt(50), rL = Math.sqrt(10), iL = Math.sqrt(2);\nfunction Qa(e, t, n) {\n  const r = (t - e) / Math.max(0, n), i = Math.floor(Math.log10(r)), o = r / Math.pow(10, i), a = o >= nL ? 10 : o >= rL ? 5 : o >= iL ? 2 : 1;\n  let s, u, c;\n  return i < 0 ? (c = Math.pow(10, -i) / a, s = Math.round(e * c), u = Math.round(t * c), s / c < e && ++s, u / c > t && --u, c = -c) : (c = Math.pow(10, i) * a, s = Math.round(e / c), u = Math.round(t / c), s * c < e && ++s, u * c > t && --u), u < s && 0.5 <= n && n < 2 ? Qa(e, t, n * 2) : [s, u, c];\n}\nfunction tl(e, t, n) {\n  if (t = +t, e = +e, n = +n, !(n > 0))\n    return [];\n  if (e === t)\n    return [e];\n  const r = t < e, [i, o, a] = r ? Qa(t, e, n) : Qa(e, t, n);\n  if (!(o >= i))\n    return [];\n  const s = o - i + 1, u = new Array(s);\n  if (r)\n    if (a < 0)\n      for (let c = 0; c < s; ++c)\n        u[c] = (o - c) / -a;\n    else\n      for (let c = 0; c < s; ++c)\n        u[c] = (o - c) * a;\n  else if (a < 0)\n    for (let c = 0; c < s; ++c)\n      u[c] = (i + c) / -a;\n  else\n    for (let c = 0; c < s; ++c)\n      u[c] = (i + c) * a;\n  return u;\n}\nfunction nl(e, t, n) {\n  return t = +t, e = +e, n = +n, Qa(e, t, n)[2];\n}\nfunction rl(e, t, n) {\n  t = +t, e = +e, n = +n;\n  const r = t < e, i = r ? nl(t, e, n) : nl(e, t, n);\n  return (r ? -1 : 1) * (i < 0 ? 1 / -i : i);\n}\nfunction kh(e, t) {\n  let n;\n  for (const r of e)\n    r != null && (n < r || n === void 0 && r >= r) && (n = r);\n  return n;\n}\nfunction Dh(e, t) {\n  let n;\n  for (const r of e)\n    r != null && (n > r || n === void 0 && r >= r) && (n = r);\n  return n;\n}\nfunction Jb(e, t, n = 0, r = 1 / 0, i) {\n  if (t = Math.floor(t), n = Math.floor(Math.max(0, n)), r = Math.floor(Math.min(e.length - 1, r)), !(n <= t && t <= r))\n    return e;\n  for (i = i === void 0 ? Zb : tL(i); r > n; ) {\n    if (r - n > 600) {\n      const u = r - n + 1, c = t - n + 1, f = Math.log(u), l = 0.5 * Math.exp(2 * f / 3), d = 0.5 * Math.sqrt(f * l * (u - l) / u) * (c - u / 2 < 0 ? -1 : 1), p = Math.max(n, Math.floor(t - c * l / u + d)), g = Math.min(r, Math.floor(t + (u - c) * l / u + d));\n      Jb(e, t, p, g, i);\n    }\n    const o = e[t];\n    let a = n, s = r;\n    for (Ri(e, n, t), i(e[r], o) > 0 && Ri(e, n, r); a < s; ) {\n      for (Ri(e, a, s), ++a, --s; i(e[a], o) < 0; )\n        ++a;\n      for (; i(e[s], o) > 0; )\n        --s;\n    }\n    i(e[n], o) === 0 ? Ri(e, n, s) : (++s, Ri(e, s, r)), s <= t && (n = s + 1), t <= s && (r = s - 1);\n  }\n  return e;\n}\nfunction Ri(e, t, n) {\n  const r = e[t];\n  e[t] = e[n], e[n] = r;\n}\nfunction oL(e, t, n) {\n  if (e = Float64Array.from(XF(e)), !(!(r = e.length) || isNaN(t = +t))) {\n    if (t <= 0 || r < 2)\n      return Dh(e);\n    if (t >= 1)\n      return kh(e);\n    var r, i = (r - 1) * t, o = Math.floor(i), a = kh(Jb(e, o).subarray(0, o + 1)), s = Dh(e.subarray(o + 1));\n    return a + (s - a) * (i - o);\n  }\n}\nfunction aL(e, t, n = Xb) {\n  if (!(!(r = e.length) || isNaN(t = +t))) {\n    if (t <= 0 || r < 2)\n      return +n(e[0], 0, e);\n    if (t >= 1)\n      return +n(e[r - 1], r - 1, e);\n    var r, i = (r - 1) * t, o = Math.floor(i), a = +n(e[o], o, e), s = +n(e[o + 1], o + 1, e);\n    return a + (s - a) * (i - o);\n  }\n}\nfunction sL(e, t, n) {\n  e = +e, t = +t, n = (i = arguments.length) < 2 ? (t = e, e = 0, 1) : i < 3 ? 1 : +n;\n  for (var r = -1, i = Math.max(0, Math.ceil((t - e) / n)) | 0, o = new Array(i); ++r < i; )\n    o[r] = e + r * n;\n  return o;\n}\nfunction Bt(e, t) {\n  switch (arguments.length) {\n    case 0:\n      break;\n    case 1:\n      this.range(e);\n      break;\n    default:\n      this.range(t).domain(e);\n      break;\n  }\n  return this;\n}\nfunction En(e, t) {\n  switch (arguments.length) {\n    case 0:\n      break;\n    case 1: {\n      typeof e == \"function\" ? this.interpolator(e) : this.range(e);\n      break;\n    }\n    default: {\n      this.domain(e), typeof t == \"function\" ? this.interpolator(t) : this.range(t);\n      break;\n    }\n  }\n  return this;\n}\nconst il = Symbol(\"implicit\");\nfunction zf() {\n  var e = new Ih(), t = [], n = [], r = il;\n  function i(o) {\n    let a = e.get(o);\n    if (a === void 0) {\n      if (r !== il)\n        return r;\n      e.set(o, a = t.push(o) - 1);\n    }\n    return n[a % n.length];\n  }\n  return i.domain = function(o) {\n    if (!arguments.length)\n      return t.slice();\n    t = [], e = new Ih();\n    for (const a of o)\n      e.has(a) || e.set(a, t.push(a) - 1);\n    return i;\n  }, i.range = function(o) {\n    return arguments.length ? (n = Array.from(o), i) : n.slice();\n  }, i.unknown = function(o) {\n    return arguments.length ? (r = o, i) : r;\n  }, i.copy = function() {\n    return zf(t, n).unknown(r);\n  }, Bt.apply(i, arguments), i;\n}\nfunction so() {\n  var e = zf().unknown(void 0), t = e.domain, n = e.range, r = 0, i = 1, o, a, s = !1, u = 0, c = 0, f = 0.5;\n  delete e.unknown;\n  function l() {\n    var d = t().length, p = i < r, g = p ? i : r, h = p ? r : i;\n    o = (h - g) / Math.max(1, d - u + c * 2), s && (o = Math.floor(o)), g += (h - g - o * (d - u)) * f, a = o * (1 - u), s && (g = Math.round(g), a = Math.round(a));\n    var v = sL(d).map(function(w) {\n      return g + o * w;\n    });\n    return n(p ? v.reverse() : v);\n  }\n  return e.domain = function(d) {\n    return arguments.length ? (t(d), l()) : t();\n  }, e.range = function(d) {\n    return arguments.length ? ([r, i] = d, r = +r, i = +i, l()) : [r, i];\n  }, e.rangeRound = function(d) {\n    return [r, i] = d, r = +r, i = +i, s = !0, l();\n  }, e.bandwidth = function() {\n    return a;\n  }, e.step = function() {\n    return o;\n  }, e.round = function(d) {\n    return arguments.length ? (s = !!d, l()) : s;\n  }, e.padding = function(d) {\n    return arguments.length ? (u = Math.min(1, c = +d), l()) : u;\n  }, e.paddingInner = function(d) {\n    return arguments.length ? (u = Math.min(1, d), l()) : u;\n  }, e.paddingOuter = function(d) {\n    return arguments.length ? (c = +d, l()) : c;\n  }, e.align = function(d) {\n    return arguments.length ? (f = Math.max(0, Math.min(1, d)), l()) : f;\n  }, e.copy = function() {\n    return so(t(), [r, i]).round(s).paddingInner(u).paddingOuter(c).align(f);\n  }, Bt.apply(l(), arguments);\n}\nfunction Qb(e) {\n  var t = e.copy;\n  return e.padding = e.paddingOuter, delete e.paddingInner, delete e.paddingOuter, e.copy = function() {\n    return Qb(t());\n  }, e;\n}\nfunction Wi() {\n  return Qb(so.apply(null, arguments).paddingInner(1));\n}\nfunction Vf(e, t, n) {\n  e.prototype = t.prototype = n, n.constructor = e;\n}\nfunction e0(e, t) {\n  var n = Object.create(e.prototype);\n  for (var r in t)\n    n[r] = t[r];\n  return n;\n}\nfunction Ko() {\n}\nvar uo = 0.7, es = 1 / uo, Ir = \"\\\\s*([+-]?\\\\d+)\\\\s*\", co = \"\\\\s*([+-]?(?:\\\\d*\\\\.)?\\\\d+(?:[eE][+-]?\\\\d+)?)\\\\s*\", an = \"\\\\s*([+-]?(?:\\\\d*\\\\.)?\\\\d+(?:[eE][+-]?\\\\d+)?)%\\\\s*\", uL = /^#([0-9a-f]{3,8})$/, cL = new RegExp(`^rgb\\\\(${Ir},${Ir},${Ir}\\\\)$`), lL = new RegExp(`^rgb\\\\(${an},${an},${an}\\\\)$`), fL = new RegExp(`^rgba\\\\(${Ir},${Ir},${Ir},${co}\\\\)$`), dL = new RegExp(`^rgba\\\\(${an},${an},${an},${co}\\\\)$`), pL = new RegExp(`^hsl\\\\(${co},${an},${an}\\\\)$`), hL = new RegExp(`^hsla\\\\(${co},${an},${an},${co}\\\\)$`), Nh = {\n  aliceblue: 15792383,\n  antiquewhite: 16444375,\n  aqua: 65535,\n  aquamarine: 8388564,\n  azure: 15794175,\n  beige: 16119260,\n  bisque: 16770244,\n  black: 0,\n  blanchedalmond: 16772045,\n  blue: 255,\n  blueviolet: 9055202,\n  brown: 10824234,\n  burlywood: 14596231,\n  cadetblue: 6266528,\n  chartreuse: 8388352,\n  chocolate: 13789470,\n  coral: 16744272,\n  cornflowerblue: 6591981,\n  cornsilk: 16775388,\n  crimson: 14423100,\n  cyan: 65535,\n  darkblue: 139,\n  darkcyan: 35723,\n  darkgoldenrod: 12092939,\n  darkgray: 11119017,\n  darkgreen: 25600,\n  darkgrey: 11119017,\n  darkkhaki: 12433259,\n  darkmagenta: 9109643,\n  darkolivegreen: 5597999,\n  darkorange: 16747520,\n  darkorchid: 10040012,\n  darkred: 9109504,\n  darksalmon: 15308410,\n  darkseagreen: 9419919,\n  darkslateblue: 4734347,\n  darkslategray: 3100495,\n  darkslategrey: 3100495,\n  darkturquoise: 52945,\n  darkviolet: 9699539,\n  deeppink: 16716947,\n  deepskyblue: 49151,\n  dimgray: 6908265,\n  dimgrey: 6908265,\n  dodgerblue: 2003199,\n  firebrick: 11674146,\n  floralwhite: 16775920,\n  forestgreen: 2263842,\n  fuchsia: 16711935,\n  gainsboro: 14474460,\n  ghostwhite: 16316671,\n  gold: 16766720,\n  goldenrod: 14329120,\n  gray: 8421504,\n  green: 32768,\n  greenyellow: 11403055,\n  grey: 8421504,\n  honeydew: 15794160,\n  hotpink: 16738740,\n  indianred: 13458524,\n  indigo: 4915330,\n  ivory: 16777200,\n  khaki: 15787660,\n  lavender: 15132410,\n  lavenderblush: 16773365,\n  lawngreen: 8190976,\n  lemonchiffon: 16775885,\n  lightblue: 11393254,\n  lightcoral: 15761536,\n  lightcyan: 14745599,\n  lightgoldenrodyellow: 16448210,\n  lightgray: 13882323,\n  lightgreen: 9498256,\n  lightgrey: 13882323,\n  lightpink: 16758465,\n  lightsalmon: 16752762,\n  lightseagreen: 2142890,\n  lightskyblue: 8900346,\n  lightslategray: 7833753,\n  lightslategrey: 7833753,\n  lightsteelblue: 11584734,\n  lightyellow: 16777184,\n  lime: 65280,\n  limegreen: 3329330,\n  linen: 16445670,\n  magenta: 16711935,\n  maroon: 8388608,\n  mediumaquamarine: 6737322,\n  mediumblue: 205,\n  mediumorchid: 12211667,\n  mediumpurple: 9662683,\n  mediumseagreen: 3978097,\n  mediumslateblue: 8087790,\n  mediumspringgreen: 64154,\n  mediumturquoise: 4772300,\n  mediumvioletred: 13047173,\n  midnightblue: 1644912,\n  mintcream: 16121850,\n  mistyrose: 16770273,\n  moccasin: 16770229,\n  navajowhite: 16768685,\n  navy: 128,\n  oldlace: 16643558,\n  olive: 8421376,\n  olivedrab: 7048739,\n  orange: 16753920,\n  orangered: 16729344,\n  orchid: 14315734,\n  palegoldenrod: 15657130,\n  palegreen: 10025880,\n  paleturquoise: 11529966,\n  palevioletred: 14381203,\n  papayawhip: 16773077,\n  peachpuff: 16767673,\n  peru: 13468991,\n  pink: 16761035,\n  plum: 14524637,\n  powderblue: 11591910,\n  purple: 8388736,\n  rebeccapurple: 6697881,\n  red: 16711680,\n  rosybrown: 12357519,\n  royalblue: 4286945,\n  saddlebrown: 9127187,\n  salmon: 16416882,\n  sandybrown: 16032864,\n  seagreen: 3050327,\n  seashell: 16774638,\n  sienna: 10506797,\n  silver: 12632256,\n  skyblue: 8900331,\n  slateblue: 6970061,\n  slategray: 7372944,\n  slategrey: 7372944,\n  snow: 16775930,\n  springgreen: 65407,\n  steelblue: 4620980,\n  tan: 13808780,\n  teal: 32896,\n  thistle: 14204888,\n  tomato: 16737095,\n  turquoise: 4251856,\n  violet: 15631086,\n  wheat: 16113331,\n  white: 16777215,\n  whitesmoke: 16119285,\n  yellow: 16776960,\n  yellowgreen: 10145074\n};\nVf(Ko, lo, {\n  copy(e) {\n    return Object.assign(new this.constructor(), this, e);\n  },\n  displayable() {\n    return this.rgb().displayable();\n  },\n  hex: Fh,\n  // Deprecated! Use color.formatHex.\n  formatHex: Fh,\n  formatHex8: gL,\n  formatHsl: vL,\n  formatRgb: Lh,\n  toString: Lh\n});\nfunction Fh() {\n  return this.rgb().formatHex();\n}\nfunction gL() {\n  return this.rgb().formatHex8();\n}\nfunction vL() {\n  return t0(this).formatHsl();\n}\nfunction Lh() {\n  return this.rgb().formatRgb();\n}\nfunction lo(e) {\n  var t, n;\n  return e = (e + \"\").trim().toLowerCase(), (t = uL.exec(e)) ? (n = t[1].length, t = parseInt(t[1], 16), n === 6 ? Bh(t) : n === 3 ? new ht(t >> 8 & 15 | t >> 4 & 240, t >> 4 & 15 | t & 240, (t & 15) << 4 | t & 15, 1) : n === 8 ? ha(t >> 24 & 255, t >> 16 & 255, t >> 8 & 255, (t & 255) / 255) : n === 4 ? ha(t >> 12 & 15 | t >> 8 & 240, t >> 8 & 15 | t >> 4 & 240, t >> 4 & 15 | t & 240, ((t & 15) << 4 | t & 15) / 255) : null) : (t = cL.exec(e)) ? new ht(t[1], t[2], t[3], 1) : (t = lL.exec(e)) ? new ht(t[1] * 255 / 100, t[2] * 255 / 100, t[3] * 255 / 100, 1) : (t = fL.exec(e)) ? ha(t[1], t[2], t[3], t[4]) : (t = dL.exec(e)) ? ha(t[1] * 255 / 100, t[2] * 255 / 100, t[3] * 255 / 100, t[4]) : (t = pL.exec(e)) ? Gh(t[1], t[2] / 100, t[3] / 100, 1) : (t = hL.exec(e)) ? Gh(t[1], t[2] / 100, t[3] / 100, t[4]) : Nh.hasOwnProperty(e) ? Bh(Nh[e]) : e === \"transparent\" ? new ht(NaN, NaN, NaN, 0) : null;\n}\nfunction Bh(e) {\n  return new ht(e >> 16 & 255, e >> 8 & 255, e & 255, 1);\n}\nfunction ha(e, t, n, r) {\n  return r <= 0 && (e = t = n = NaN), new ht(e, t, n, r);\n}\nfunction mL(e) {\n  return e instanceof Ko || (e = lo(e)), e ? (e = e.rgb(), new ht(e.r, e.g, e.b, e.opacity)) : new ht();\n}\nfunction ol(e, t, n, r) {\n  return arguments.length === 1 ? mL(e) : new ht(e, t, n, r ?? 1);\n}\nfunction ht(e, t, n, r) {\n  this.r = +e, this.g = +t, this.b = +n, this.opacity = +r;\n}\nVf(ht, ol, e0(Ko, {\n  brighter(e) {\n    return e = e == null ? es : Math.pow(es, e), new ht(this.r * e, this.g * e, this.b * e, this.opacity);\n  },\n  darker(e) {\n    return e = e == null ? uo : Math.pow(uo, e), new ht(this.r * e, this.g * e, this.b * e, this.opacity);\n  },\n  rgb() {\n    return this;\n  },\n  clamp() {\n    return new ht(sr(this.r), sr(this.g), sr(this.b), ts(this.opacity));\n  },\n  displayable() {\n    return -0.5 <= this.r && this.r < 255.5 && -0.5 <= this.g && this.g < 255.5 && -0.5 <= this.b && this.b < 255.5 && 0 <= this.opacity && this.opacity <= 1;\n  },\n  hex: zh,\n  // Deprecated! Use color.formatHex.\n  formatHex: zh,\n  formatHex8: yL,\n  formatRgb: Vh,\n  toString: Vh\n}));\nfunction zh() {\n  return `#${rr(this.r)}${rr(this.g)}${rr(this.b)}`;\n}\nfunction yL() {\n  return `#${rr(this.r)}${rr(this.g)}${rr(this.b)}${rr((isNaN(this.opacity) ? 1 : this.opacity) * 255)}`;\n}\nfunction Vh() {\n  const e = ts(this.opacity);\n  return `${e === 1 ? \"rgb(\" : \"rgba(\"}${sr(this.r)}, ${sr(this.g)}, ${sr(this.b)}${e === 1 ? \")\" : `, ${e})`}`;\n}\nfunction ts(e) {\n  return isNaN(e) ? 1 : Math.max(0, Math.min(1, e));\n}\nfunction sr(e) {\n  return Math.max(0, Math.min(255, Math.round(e) || 0));\n}\nfunction rr(e) {\n  return e = sr(e), (e < 16 ? \"0\" : \"\") + e.toString(16);\n}\nfunction Gh(e, t, n, r) {\n  return r <= 0 ? e = t = n = NaN : n <= 0 || n >= 1 ? e = t = NaN : t <= 0 && (e = NaN), new qt(e, t, n, r);\n}\nfunction t0(e) {\n  if (e instanceof qt)\n    return new qt(e.h, e.s, e.l, e.opacity);\n  if (e instanceof Ko || (e = lo(e)), !e)\n    return new qt();\n  if (e instanceof qt)\n    return e;\n  e = e.rgb();\n  var t = e.r / 255, n = e.g / 255, r = e.b / 255, i = Math.min(t, n, r), o = Math.max(t, n, r), a = NaN, s = o - i, u = (o + i) / 2;\n  return s ? (t === o ? a = (n - r) / s + (n < r) * 6 : n === o ? a = (r - t) / s + 2 : a = (t - n) / s + 4, s /= u < 0.5 ? o + i : 2 - o - i, a *= 60) : s = u > 0 && u < 1 ? 0 : a, new qt(a, s, u, e.opacity);\n}\nfunction bL(e, t, n, r) {\n  return arguments.length === 1 ? t0(e) : new qt(e, t, n, r ?? 1);\n}\nfunction qt(e, t, n, r) {\n  this.h = +e, this.s = +t, this.l = +n, this.opacity = +r;\n}\nVf(qt, bL, e0(Ko, {\n  brighter(e) {\n    return e = e == null ? es : Math.pow(es, e), new qt(this.h, this.s, this.l * e, this.opacity);\n  },\n  darker(e) {\n    return e = e == null ? uo : Math.pow(uo, e), new qt(this.h, this.s, this.l * e, this.opacity);\n  },\n  rgb() {\n    var e = this.h % 360 + (this.h < 0) * 360, t = isNaN(e) || isNaN(this.s) ? 0 : this.s, n = this.l, r = n + (n < 0.5 ? n : 1 - n) * t, i = 2 * n - r;\n    return new ht(\n      Nu(e >= 240 ? e - 240 : e + 120, i, r),\n      Nu(e, i, r),\n      Nu(e < 120 ? e + 240 : e - 120, i, r),\n      this.opacity\n    );\n  },\n  clamp() {\n    return new qt(Wh(this.h), ga(this.s), ga(this.l), ts(this.opacity));\n  },\n  displayable() {\n    return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && 0 <= this.l && this.l <= 1 && 0 <= this.opacity && this.opacity <= 1;\n  },\n  formatHsl() {\n    const e = ts(this.opacity);\n    return `${e === 1 ? \"hsl(\" : \"hsla(\"}${Wh(this.h)}, ${ga(this.s) * 100}%, ${ga(this.l) * 100}%${e === 1 ? \")\" : `, ${e})`}`;\n  }\n}));\nfunction Wh(e) {\n  return e = (e || 0) % 360, e < 0 ? e + 360 : e;\n}\nfunction ga(e) {\n  return Math.max(0, Math.min(1, e || 0));\n}\nfunction Nu(e, t, n) {\n  return (e < 60 ? t + (n - t) * e / 60 : e < 180 ? n : e < 240 ? t + (n - t) * (240 - e) / 60 : t) * 255;\n}\nconst Gf = (e) => () => e;\nfunction wL(e, t) {\n  return function(n) {\n    return e + n * t;\n  };\n}\nfunction xL(e, t, n) {\n  return e = Math.pow(e, n), t = Math.pow(t, n) - e, n = 1 / n, function(r) {\n    return Math.pow(e + r * t, n);\n  };\n}\nfunction SL(e) {\n  return (e = +e) == 1 ? n0 : function(t, n) {\n    return n - t ? xL(t, n, e) : Gf(isNaN(t) ? n : t);\n  };\n}\nfunction n0(e, t) {\n  var n = t - e;\n  return n ? wL(e, n) : Gf(isNaN(e) ? t : e);\n}\nconst Uh = function e(t) {\n  var n = SL(t);\n  function r(i, o) {\n    var a = n((i = ol(i)).r, (o = ol(o)).r), s = n(i.g, o.g), u = n(i.b, o.b), c = n0(i.opacity, o.opacity);\n    return function(f) {\n      return i.r = a(f), i.g = s(f), i.b = u(f), i.opacity = c(f), i + \"\";\n    };\n  }\n  return r.gamma = e, r;\n}(1);\nfunction $L(e, t) {\n  t || (t = []);\n  var n = e ? Math.min(t.length, e.length) : 0, r = t.slice(), i;\n  return function(o) {\n    for (i = 0; i < n; ++i)\n      r[i] = e[i] * (1 - o) + t[i] * o;\n    return r;\n  };\n}\nfunction OL(e) {\n  return ArrayBuffer.isView(e) && !(e instanceof DataView);\n}\nfunction _L(e, t) {\n  var n = t ? t.length : 0, r = e ? Math.min(n, e.length) : 0, i = new Array(r), o = new Array(n), a;\n  for (a = 0; a < r; ++a)\n    i[a] = vi(e[a], t[a]);\n  for (; a < n; ++a)\n    o[a] = t[a];\n  return function(s) {\n    for (a = 0; a < r; ++a)\n      o[a] = i[a](s);\n    return o;\n  };\n}\nfunction AL(e, t) {\n  var n = /* @__PURE__ */ new Date();\n  return e = +e, t = +t, function(r) {\n    return n.setTime(e * (1 - r) + t * r), n;\n  };\n}\nfunction ns(e, t) {\n  return e = +e, t = +t, function(n) {\n    return e * (1 - n) + t * n;\n  };\n}\nfunction PL(e, t) {\n  var n = {}, r = {}, i;\n  (e === null || typeof e != \"object\") && (e = {}), (t === null || typeof t != \"object\") && (t = {});\n  for (i in t)\n    i in e ? n[i] = vi(e[i], t[i]) : r[i] = t[i];\n  return function(o) {\n    for (i in n)\n      r[i] = n[i](o);\n    return r;\n  };\n}\nvar al = /[-+]?(?:\\d+\\.?\\d*|\\.?\\d+)(?:[eE][-+]?\\d+)?/g, Fu = new RegExp(al.source, \"g\");\nfunction CL(e) {\n  return function() {\n    return e;\n  };\n}\nfunction EL(e) {\n  return function(t) {\n    return e(t) + \"\";\n  };\n}\nfunction TL(e, t) {\n  var n = al.lastIndex = Fu.lastIndex = 0, r, i, o, a = -1, s = [], u = [];\n  for (e = e + \"\", t = t + \"\"; (r = al.exec(e)) && (i = Fu.exec(t)); )\n    (o = i.index) > n && (o = t.slice(n, o), s[a] ? s[a] += o : s[++a] = o), (r = r[0]) === (i = i[0]) ? s[a] ? s[a] += i : s[++a] = i : (s[++a] = null, u.push({ i: a, x: ns(r, i) })), n = Fu.lastIndex;\n  return n < t.length && (o = t.slice(n), s[a] ? s[a] += o : s[++a] = o), s.length < 2 ? u[0] ? EL(u[0].x) : CL(t) : (t = u.length, function(c) {\n    for (var f = 0, l; f < t; ++f)\n      s[(l = u[f]).i] = l.x(c);\n    return s.join(\"\");\n  });\n}\nfunction vi(e, t) {\n  var n = typeof t, r;\n  return t == null || n === \"boolean\" ? Gf(t) : (n === \"number\" ? ns : n === \"string\" ? (r = lo(t)) ? (t = r, Uh) : TL : t instanceof lo ? Uh : t instanceof Date ? AL : OL(t) ? $L : Array.isArray(t) ? _L : typeof t.valueOf != \"function\" && typeof t.toString != \"function\" || isNaN(t) ? PL : ns)(e, t);\n}\nfunction Wf(e, t) {\n  return e = +e, t = +t, function(n) {\n    return Math.round(e * (1 - n) + t * n);\n  };\n}\nfunction ML(e, t) {\n  t === void 0 && (t = e, e = vi);\n  for (var n = 0, r = t.length - 1, i = t[0], o = new Array(r < 0 ? 0 : r); n < r; )\n    o[n] = e(i, i = t[++n]);\n  return function(a) {\n    var s = Math.max(0, Math.min(r - 1, Math.floor(a *= r)));\n    return o[s](a - s);\n  };\n}\nfunction RL(e) {\n  return function() {\n    return e;\n  };\n}\nfunction rs(e) {\n  return +e;\n}\nvar Hh = [0, 1];\nfunction ft(e) {\n  return e;\n}\nfunction sl(e, t) {\n  return (t -= e = +e) ? function(n) {\n    return (n - e) / t;\n  } : RL(isNaN(t) ? NaN : 0.5);\n}\nfunction IL(e, t) {\n  var n;\n  return e > t && (n = e, e = t, t = n), function(r) {\n    return Math.max(e, Math.min(t, r));\n  };\n}\nfunction jL(e, t, n) {\n  var r = e[0], i = e[1], o = t[0], a = t[1];\n  return i < r ? (r = sl(i, r), o = n(a, o)) : (r = sl(r, i), o = n(o, a)), function(s) {\n    return o(r(s));\n  };\n}\nfunction kL(e, t, n) {\n  var r = Math.min(e.length, t.length) - 1, i = new Array(r), o = new Array(r), a = -1;\n  for (e[r] < e[0] && (e = e.slice().reverse(), t = t.slice().reverse()); ++a < r; )\n    i[a] = sl(e[a], e[a + 1]), o[a] = n(t[a], t[a + 1]);\n  return function(s) {\n    var u = qo(e, s, 1, r) - 1;\n    return o[u](i[u](s));\n  };\n}\nfunction Yo(e, t) {\n  return t.domain(e.domain()).range(e.range()).interpolate(e.interpolate()).clamp(e.clamp()).unknown(e.unknown());\n}\nfunction qs() {\n  var e = Hh, t = Hh, n = vi, r, i, o, a = ft, s, u, c;\n  function f() {\n    var d = Math.min(e.length, t.length);\n    return a !== ft && (a = IL(e[0], e[d - 1])), s = d > 2 ? kL : jL, u = c = null, l;\n  }\n  function l(d) {\n    return d == null || isNaN(d = +d) ? o : (u || (u = s(e.map(r), t, n)))(r(a(d)));\n  }\n  return l.invert = function(d) {\n    return a(i((c || (c = s(t, e.map(r), ns)))(d)));\n  }, l.domain = function(d) {\n    return arguments.length ? (e = Array.from(d, rs), f()) : e.slice();\n  }, l.range = function(d) {\n    return arguments.length ? (t = Array.from(d), f()) : t.slice();\n  }, l.rangeRound = function(d) {\n    return t = Array.from(d), n = Wf, f();\n  }, l.clamp = function(d) {\n    return arguments.length ? (a = d ? !0 : ft, f()) : a !== ft;\n  }, l.interpolate = function(d) {\n    return arguments.length ? (n = d, f()) : n;\n  }, l.unknown = function(d) {\n    return arguments.length ? (o = d, l) : o;\n  }, function(d, p) {\n    return r = d, i = p, f();\n  };\n}\nfunction Uf() {\n  return qs()(ft, ft);\n}\nfunction DL(e) {\n  return Math.abs(e = Math.round(e)) >= 1e21 ? e.toLocaleString(\"en\").replace(/,/g, \"\") : e.toString(10);\n}\nfunction is(e, t) {\n  if ((n = (e = t ? e.toExponential(t - 1) : e.toExponential()).indexOf(\"e\")) < 0)\n    return null;\n  var n, r = e.slice(0, n);\n  return [\n    r.length > 1 ? r[0] + r.slice(2) : r,\n    +e.slice(n + 1)\n  ];\n}\nfunction Ur(e) {\n  return e = is(Math.abs(e)), e ? e[1] : NaN;\n}\nfunction NL(e, t) {\n  return function(n, r) {\n    for (var i = n.length, o = [], a = 0, s = e[0], u = 0; i > 0 && s > 0 && (u + s + 1 > r && (s = Math.max(1, r - u)), o.push(n.substring(i -= s, i + s)), !((u += s + 1) > r)); )\n      s = e[a = (a + 1) % e.length];\n    return o.reverse().join(t);\n  };\n}\nfunction FL(e) {\n  return function(t) {\n    return t.replace(/[0-9]/g, function(n) {\n      return e[+n];\n    });\n  };\n}\nvar LL = /^(?:(.)?([<>=^]))?([+\\-( ])?([$#])?(0)?(\\d+)?(,)?(\\.\\d+)?(~)?([a-z%])?$/i;\nfunction fo(e) {\n  if (!(t = LL.exec(e)))\n    throw new Error(\"invalid format: \" + e);\n  var t;\n  return new Hf({\n    fill: t[1],\n    align: t[2],\n    sign: t[3],\n    symbol: t[4],\n    zero: t[5],\n    width: t[6],\n    comma: t[7],\n    precision: t[8] && t[8].slice(1),\n    trim: t[9],\n    type: t[10]\n  });\n}\nfo.prototype = Hf.prototype;\nfunction Hf(e) {\n  this.fill = e.fill === void 0 ? \" \" : e.fill + \"\", this.align = e.align === void 0 ? \">\" : e.align + \"\", this.sign = e.sign === void 0 ? \"-\" : e.sign + \"\", this.symbol = e.symbol === void 0 ? \"\" : e.symbol + \"\", this.zero = !!e.zero, this.width = e.width === void 0 ? void 0 : +e.width, this.comma = !!e.comma, this.precision = e.precision === void 0 ? void 0 : +e.precision, this.trim = !!e.trim, this.type = e.type === void 0 ? \"\" : e.type + \"\";\n}\nHf.prototype.toString = function() {\n  return this.fill + this.align + this.sign + this.symbol + (this.zero ? \"0\" : \"\") + (this.width === void 0 ? \"\" : Math.max(1, this.width | 0)) + (this.comma ? \",\" : \"\") + (this.precision === void 0 ? \"\" : \".\" + Math.max(0, this.precision | 0)) + (this.trim ? \"~\" : \"\") + this.type;\n};\nfunction BL(e) {\n  e:\n    for (var t = e.length, n = 1, r = -1, i; n < t; ++n)\n      switch (e[n]) {\n        case \".\":\n          r = i = n;\n          break;\n        case \"0\":\n          r === 0 && (r = n), i = n;\n          break;\n        default:\n          if (!+e[n])\n            break e;\n          r > 0 && (r = 0);\n          break;\n      }\n  return r > 0 ? e.slice(0, r) + e.slice(i + 1) : e;\n}\nvar r0;\nfunction zL(e, t) {\n  var n = is(e, t);\n  if (!n)\n    return e + \"\";\n  var r = n[0], i = n[1], o = i - (r0 = Math.max(-8, Math.min(8, Math.floor(i / 3))) * 3) + 1, a = r.length;\n  return o === a ? r : o > a ? r + new Array(o - a + 1).join(\"0\") : o > 0 ? r.slice(0, o) + \".\" + r.slice(o) : \"0.\" + new Array(1 - o).join(\"0\") + is(e, Math.max(0, t + o - 1))[0];\n}\nfunction qh(e, t) {\n  var n = is(e, t);\n  if (!n)\n    return e + \"\";\n  var r = n[0], i = n[1];\n  return i < 0 ? \"0.\" + new Array(-i).join(\"0\") + r : r.length > i + 1 ? r.slice(0, i + 1) + \".\" + r.slice(i + 1) : r + new Array(i - r.length + 2).join(\"0\");\n}\nconst Kh = {\n  \"%\": (e, t) => (e * 100).toFixed(t),\n  b: (e) => Math.round(e).toString(2),\n  c: (e) => e + \"\",\n  d: DL,\n  e: (e, t) => e.toExponential(t),\n  f: (e, t) => e.toFixed(t),\n  g: (e, t) => e.toPrecision(t),\n  o: (e) => Math.round(e).toString(8),\n  p: (e, t) => qh(e * 100, t),\n  r: qh,\n  s: zL,\n  X: (e) => Math.round(e).toString(16).toUpperCase(),\n  x: (e) => Math.round(e).toString(16)\n};\nfunction Yh(e) {\n  return e;\n}\nvar Xh = Array.prototype.map, Zh = [\"y\", \"z\", \"a\", \"f\", \"p\", \"n\", \"\", \"m\", \"\", \"k\", \"M\", \"G\", \"T\", \"P\", \"E\", \"Z\", \"Y\"];\nfunction VL(e) {\n  var t = e.grouping === void 0 || e.thousands === void 0 ? Yh : NL(Xh.call(e.grouping, Number), e.thousands + \"\"), n = e.currency === void 0 ? \"\" : e.currency[0] + \"\", r = e.currency === void 0 ? \"\" : e.currency[1] + \"\", i = e.decimal === void 0 ? \".\" : e.decimal + \"\", o = e.numerals === void 0 ? Yh : FL(Xh.call(e.numerals, String)), a = e.percent === void 0 ? \"%\" : e.percent + \"\", s = e.minus === void 0 ? \"\" : e.minus + \"\", u = e.nan === void 0 ? \"NaN\" : e.nan + \"\";\n  function c(l) {\n    l = fo(l);\n    var d = l.fill, p = l.align, g = l.sign, h = l.symbol, v = l.zero, w = l.width, b = l.comma, x = l.precision, m = l.trim, y = l.type;\n    y === \"n\" ? (b = !0, y = \"g\") : Kh[y] || (x === void 0 && (x = 12), m = !0, y = \"g\"), (v || d === \"0\" && p === \"=\") && (v = !0, d = \"0\", p = \"=\");\n    var S = h === \"$\" ? n : h === \"#\" && /[boxX]/.test(y) ? \"0\" + y.toLowerCase() : \"\", $ = h === \"$\" ? r : /[%p]/.test(y) ? a : \"\", O = Kh[y], T = /[defgprs%]/.test(y);\n    x = x === void 0 ? 6 : /[gprs]/.test(y) ? Math.max(1, Math.min(21, x)) : Math.max(0, Math.min(20, x));\n    function M(E) {\n      var A = S, j = $, R, N, k;\n      if (y === \"c\")\n        j = O(E) + j, E = \"\";\n      else {\n        E = +E;\n        var F = E < 0 || 1 / E < 0;\n        if (E = isNaN(E) ? u : O(Math.abs(E), x), m && (E = BL(E)), F && +E == 0 && g !== \"+\" && (F = !1), A = (F ? g === \"(\" ? g : s : g === \"-\" || g === \"(\" ? \"\" : g) + A, j = (y === \"s\" ? Zh[8 + r0 / 3] : \"\") + j + (F && g === \"(\" ? \")\" : \"\"), T) {\n          for (R = -1, N = E.length; ++R < N; )\n            if (k = E.charCodeAt(R), 48 > k || k > 57) {\n              j = (k === 46 ? i + E.slice(R + 1) : E.slice(R)) + j, E = E.slice(0, R);\n              break;\n            }\n        }\n      }\n      b && !v && (E = t(E, 1 / 0));\n      var V = A.length + E.length + j.length, L = V < w ? new Array(w - V + 1).join(d) : \"\";\n      switch (b && v && (E = t(L + E, L.length ? w - j.length : 1 / 0), L = \"\"), p) {\n        case \"<\":\n          E = A + E + j + L;\n          break;\n        case \"=\":\n          E = A + L + E + j;\n          break;\n        case \"^\":\n          E = L.slice(0, V = L.length >> 1) + A + E + j + L.slice(V);\n          break;\n        default:\n          E = L + A + E + j;\n          break;\n      }\n      return o(E);\n    }\n    return M.toString = function() {\n      return l + \"\";\n    }, M;\n  }\n  function f(l, d) {\n    var p = c((l = fo(l), l.type = \"f\", l)), g = Math.max(-8, Math.min(8, Math.floor(Ur(d) / 3))) * 3, h = Math.pow(10, -g), v = Zh[8 + g / 3];\n    return function(w) {\n      return p(h * w) + v;\n    };\n  }\n  return {\n    format: c,\n    formatPrefix: f\n  };\n}\nvar va, qf, i0;\nGL({\n  thousands: \",\",\n  grouping: [3],\n  currency: [\"$\", \"\"]\n});\nfunction GL(e) {\n  return va = VL(e), qf = va.format, i0 = va.formatPrefix, va;\n}\nfunction WL(e) {\n  return Math.max(0, -Ur(Math.abs(e)));\n}\nfunction UL(e, t) {\n  return Math.max(0, Math.max(-8, Math.min(8, Math.floor(Ur(t) / 3))) * 3 - Ur(Math.abs(e)));\n}\nfunction HL(e, t) {\n  return e = Math.abs(e), t = Math.abs(t) - e, Math.max(0, Ur(t) - Ur(e)) + 1;\n}\nfunction o0(e, t, n, r) {\n  var i = rl(e, t, n), o;\n  switch (r = fo(r ?? \",f\"), r.type) {\n    case \"s\": {\n      var a = Math.max(Math.abs(e), Math.abs(t));\n      return r.precision == null && !isNaN(o = UL(i, a)) && (r.precision = o), i0(r, a);\n    }\n    case \"\":\n    case \"e\":\n    case \"g\":\n    case \"p\":\n    case \"r\": {\n      r.precision == null && !isNaN(o = HL(i, Math.max(Math.abs(e), Math.abs(t)))) && (r.precision = o - (r.type === \"e\"));\n      break;\n    }\n    case \"f\":\n    case \"%\": {\n      r.precision == null && !isNaN(o = WL(i)) && (r.precision = o - (r.type === \"%\") * 2);\n      break;\n    }\n  }\n  return qf(r);\n}\nfunction qn(e) {\n  var t = e.domain;\n  return e.ticks = function(n) {\n    var r = t();\n    return tl(r[0], r[r.length - 1], n ?? 10);\n  }, e.tickFormat = function(n, r) {\n    var i = t();\n    return o0(i[0], i[i.length - 1], n ?? 10, r);\n  }, e.nice = function(n) {\n    n == null && (n = 10);\n    var r = t(), i = 0, o = r.length - 1, a = r[i], s = r[o], u, c, f = 10;\n    for (s < a && (c = a, a = s, s = c, c = i, i = o, o = c); f-- > 0; ) {\n      if (c = nl(a, s, n), c === u)\n        return r[i] = a, r[o] = s, t(r);\n      if (c > 0)\n        a = Math.floor(a / c) * c, s = Math.ceil(s / c) * c;\n      else if (c < 0)\n        a = Math.ceil(a * c) / c, s = Math.floor(s * c) / c;\n      else\n        break;\n      u = c;\n    }\n    return e;\n  }, e;\n}\nfunction os() {\n  var e = Uf();\n  return e.copy = function() {\n    return Yo(e, os());\n  }, Bt.apply(e, arguments), qn(e);\n}\nfunction a0(e) {\n  var t;\n  function n(r) {\n    return r == null || isNaN(r = +r) ? t : r;\n  }\n  return n.invert = n, n.domain = n.range = function(r) {\n    return arguments.length ? (e = Array.from(r, rs), n) : e.slice();\n  }, n.unknown = function(r) {\n    return arguments.length ? (t = r, n) : t;\n  }, n.copy = function() {\n    return a0(e).unknown(t);\n  }, e = arguments.length ? Array.from(e, rs) : [0, 1], qn(n);\n}\nfunction s0(e, t) {\n  e = e.slice();\n  var n = 0, r = e.length - 1, i = e[n], o = e[r], a;\n  return o < i && (a = n, n = r, r = a, a = i, i = o, o = a), e[n] = t.floor(i), e[r] = t.ceil(o), e;\n}\nfunction Jh(e) {\n  return Math.log(e);\n}\nfunction Qh(e) {\n  return Math.exp(e);\n}\nfunction qL(e) {\n  return -Math.log(-e);\n}\nfunction KL(e) {\n  return -Math.exp(-e);\n}\nfunction YL(e) {\n  return isFinite(e) ? +(\"1e\" + e) : e < 0 ? 0 : e;\n}\nfunction XL(e) {\n  return e === 10 ? YL : e === Math.E ? Math.exp : (t) => Math.pow(e, t);\n}\nfunction ZL(e) {\n  return e === Math.E ? Math.log : e === 10 && Math.log10 || e === 2 && Math.log2 || (e = Math.log(e), (t) => Math.log(t) / e);\n}\nfunction eg(e) {\n  return (t, n) => -e(-t, n);\n}\nfunction Kf(e) {\n  const t = e(Jh, Qh), n = t.domain;\n  let r = 10, i, o;\n  function a() {\n    return i = ZL(r), o = XL(r), n()[0] < 0 ? (i = eg(i), o = eg(o), e(qL, KL)) : e(Jh, Qh), t;\n  }\n  return t.base = function(s) {\n    return arguments.length ? (r = +s, a()) : r;\n  }, t.domain = function(s) {\n    return arguments.length ? (n(s), a()) : n();\n  }, t.ticks = (s) => {\n    const u = n();\n    let c = u[0], f = u[u.length - 1];\n    const l = f < c;\n    l && ([c, f] = [f, c]);\n    let d = i(c), p = i(f), g, h;\n    const v = s == null ? 10 : +s;\n    let w = [];\n    if (!(r % 1) && p - d < v) {\n      if (d = Math.floor(d), p = Math.ceil(p), c > 0) {\n        for (; d <= p; ++d)\n          for (g = 1; g < r; ++g)\n            if (h = d < 0 ? g / o(-d) : g * o(d), !(h < c)) {\n              if (h > f)\n                break;\n              w.push(h);\n            }\n      } else\n        for (; d <= p; ++d)\n          for (g = r - 1; g >= 1; --g)\n            if (h = d > 0 ? g / o(-d) : g * o(d), !(h < c)) {\n              if (h > f)\n                break;\n              w.push(h);\n            }\n      w.length * 2 < v && (w = tl(c, f, v));\n    } else\n      w = tl(d, p, Math.min(p - d, v)).map(o);\n    return l ? w.reverse() : w;\n  }, t.tickFormat = (s, u) => {\n    if (s == null && (s = 10), u == null && (u = r === 10 ? \"s\" : \",\"), typeof u != \"function\" && (!(r % 1) && (u = fo(u)).precision == null && (u.trim = !0), u = qf(u)), s === 1 / 0)\n      return u;\n    const c = Math.max(1, r * s / t.ticks().length);\n    return (f) => {\n      let l = f / o(Math.round(i(f)));\n      return l * r < r - 0.5 && (l *= r), l <= c ? u(f) : \"\";\n    };\n  }, t.nice = () => n(s0(n(), {\n    floor: (s) => o(Math.floor(i(s))),\n    ceil: (s) => o(Math.ceil(i(s)))\n  })), t;\n}\nfunction u0() {\n  const e = Kf(qs()).domain([1, 10]);\n  return e.copy = () => Yo(e, u0()).base(e.base()), Bt.apply(e, arguments), e;\n}\nfunction tg(e) {\n  return function(t) {\n    return Math.sign(t) * Math.log1p(Math.abs(t / e));\n  };\n}\nfunction ng(e) {\n  return function(t) {\n    return Math.sign(t) * Math.expm1(Math.abs(t)) * e;\n  };\n}\nfunction Yf(e) {\n  var t = 1, n = e(tg(t), ng(t));\n  return n.constant = function(r) {\n    return arguments.length ? e(tg(t = +r), ng(t)) : t;\n  }, qn(n);\n}\nfunction c0() {\n  var e = Yf(qs());\n  return e.copy = function() {\n    return Yo(e, c0()).constant(e.constant());\n  }, Bt.apply(e, arguments);\n}\nfunction rg(e) {\n  return function(t) {\n    return t < 0 ? -Math.pow(-t, e) : Math.pow(t, e);\n  };\n}\nfunction JL(e) {\n  return e < 0 ? -Math.sqrt(-e) : Math.sqrt(e);\n}\nfunction QL(e) {\n  return e < 0 ? -e * e : e * e;\n}\nfunction Xf(e) {\n  var t = e(ft, ft), n = 1;\n  function r() {\n    return n === 1 ? e(ft, ft) : n === 0.5 ? e(JL, QL) : e(rg(n), rg(1 / n));\n  }\n  return t.exponent = function(i) {\n    return arguments.length ? (n = +i, r()) : n;\n  }, qn(t);\n}\nfunction Zf() {\n  var e = Xf(qs());\n  return e.copy = function() {\n    return Yo(e, Zf()).exponent(e.exponent());\n  }, Bt.apply(e, arguments), e;\n}\nfunction e3() {\n  return Zf.apply(null, arguments).exponent(0.5);\n}\nfunction ig(e) {\n  return Math.sign(e) * e * e;\n}\nfunction t3(e) {\n  return Math.sign(e) * Math.sqrt(Math.abs(e));\n}\nfunction l0() {\n  var e = Uf(), t = [0, 1], n = !1, r;\n  function i(o) {\n    var a = t3(e(o));\n    return isNaN(a) ? r : n ? Math.round(a) : a;\n  }\n  return i.invert = function(o) {\n    return e.invert(ig(o));\n  }, i.domain = function(o) {\n    return arguments.length ? (e.domain(o), i) : e.domain();\n  }, i.range = function(o) {\n    return arguments.length ? (e.range((t = Array.from(o, rs)).map(ig)), i) : t.slice();\n  }, i.rangeRound = function(o) {\n    return i.range(o).round(!0);\n  }, i.round = function(o) {\n    return arguments.length ? (n = !!o, i) : n;\n  }, i.clamp = function(o) {\n    return arguments.length ? (e.clamp(o), i) : e.clamp();\n  }, i.unknown = function(o) {\n    return arguments.length ? (r = o, i) : r;\n  }, i.copy = function() {\n    return l0(e.domain(), t).round(n).clamp(e.clamp()).unknown(r);\n  }, Bt.apply(i, arguments), qn(i);\n}\nfunction f0() {\n  var e = [], t = [], n = [], r;\n  function i() {\n    var a = 0, s = Math.max(1, t.length);\n    for (n = new Array(s - 1); ++a < s; )\n      n[a - 1] = aL(e, a / s);\n    return o;\n  }\n  function o(a) {\n    return a == null || isNaN(a = +a) ? r : t[qo(n, a)];\n  }\n  return o.invertExtent = function(a) {\n    var s = t.indexOf(a);\n    return s < 0 ? [NaN, NaN] : [\n      s > 0 ? n[s - 1] : e[0],\n      s < n.length ? n[s] : e[e.length - 1]\n    ];\n  }, o.domain = function(a) {\n    if (!arguments.length)\n      return e.slice();\n    e = [];\n    for (let s of a)\n      s != null && !isNaN(s = +s) && e.push(s);\n    return e.sort(Ln), i();\n  }, o.range = function(a) {\n    return arguments.length ? (t = Array.from(a), i()) : t.slice();\n  }, o.unknown = function(a) {\n    return arguments.length ? (r = a, o) : r;\n  }, o.quantiles = function() {\n    return n.slice();\n  }, o.copy = function() {\n    return f0().domain(e).range(t).unknown(r);\n  }, Bt.apply(o, arguments);\n}\nfunction d0() {\n  var e = 0, t = 1, n = 1, r = [0.5], i = [0, 1], o;\n  function a(u) {\n    return u != null && u <= u ? i[qo(r, u, 0, n)] : o;\n  }\n  function s() {\n    var u = -1;\n    for (r = new Array(n); ++u < n; )\n      r[u] = ((u + 1) * t - (u - n) * e) / (n + 1);\n    return a;\n  }\n  return a.domain = function(u) {\n    return arguments.length ? ([e, t] = u, e = +e, t = +t, s()) : [e, t];\n  }, a.range = function(u) {\n    return arguments.length ? (n = (i = Array.from(u)).length - 1, s()) : i.slice();\n  }, a.invertExtent = function(u) {\n    var c = i.indexOf(u);\n    return c < 0 ? [NaN, NaN] : c < 1 ? [e, r[0]] : c >= n ? [r[n - 1], t] : [r[c - 1], r[c]];\n  }, a.unknown = function(u) {\n    return arguments.length && (o = u), a;\n  }, a.thresholds = function() {\n    return r.slice();\n  }, a.copy = function() {\n    return d0().domain([e, t]).range(i).unknown(o);\n  }, Bt.apply(qn(a), arguments);\n}\nfunction p0() {\n  var e = [0.5], t = [0, 1], n, r = 1;\n  function i(o) {\n    return o != null && o <= o ? t[qo(e, o, 0, r)] : n;\n  }\n  return i.domain = function(o) {\n    return arguments.length ? (e = Array.from(o), r = Math.min(e.length, t.length - 1), i) : e.slice();\n  }, i.range = function(o) {\n    return arguments.length ? (t = Array.from(o), r = Math.min(e.length, t.length - 1), i) : t.slice();\n  }, i.invertExtent = function(o) {\n    var a = t.indexOf(o);\n    return [e[a - 1], e[a]];\n  }, i.unknown = function(o) {\n    return arguments.length ? (n = o, i) : n;\n  }, i.copy = function() {\n    return p0().domain(e).range(t).unknown(n);\n  }, Bt.apply(i, arguments);\n}\nconst Lu = /* @__PURE__ */ new Date(), Bu = /* @__PURE__ */ new Date();\nfunction Xe(e, t, n, r) {\n  function i(o) {\n    return e(o = arguments.length === 0 ? /* @__PURE__ */ new Date() : /* @__PURE__ */ new Date(+o)), o;\n  }\n  return i.floor = (o) => (e(o = /* @__PURE__ */ new Date(+o)), o), i.ceil = (o) => (e(o = new Date(o - 1)), t(o, 1), e(o), o), i.round = (o) => {\n    const a = i(o), s = i.ceil(o);\n    return o - a < s - o ? a : s;\n  }, i.offset = (o, a) => (t(o = /* @__PURE__ */ new Date(+o), a == null ? 1 : Math.floor(a)), o), i.range = (o, a, s) => {\n    const u = [];\n    if (o = i.ceil(o), s = s == null ? 1 : Math.floor(s), !(o < a) || !(s > 0))\n      return u;\n    let c;\n    do\n      u.push(c = /* @__PURE__ */ new Date(+o)), t(o, s), e(o);\n    while (c < o && o < a);\n    return u;\n  }, i.filter = (o) => Xe((a) => {\n    if (a >= a)\n      for (; e(a), !o(a); )\n        a.setTime(a - 1);\n  }, (a, s) => {\n    if (a >= a)\n      if (s < 0)\n        for (; ++s <= 0; )\n          for (; t(a, -1), !o(a); )\n            ;\n      else\n        for (; --s >= 0; )\n          for (; t(a, 1), !o(a); )\n            ;\n  }), n && (i.count = (o, a) => (Lu.setTime(+o), Bu.setTime(+a), e(Lu), e(Bu), Math.floor(n(Lu, Bu))), i.every = (o) => (o = Math.floor(o), !isFinite(o) || !(o > 0) ? null : o > 1 ? i.filter(r ? (a) => r(a) % o === 0 : (a) => i.count(0, a) % o === 0) : i)), i;\n}\nconst as = Xe(() => {\n}, (e, t) => {\n  e.setTime(+e + t);\n}, (e, t) => t - e);\nas.every = (e) => (e = Math.floor(e), !isFinite(e) || !(e > 0) ? null : e > 1 ? Xe((t) => {\n  t.setTime(Math.floor(t / e) * e);\n}, (t, n) => {\n  t.setTime(+t + n * e);\n}, (t, n) => (n - t) / e) : as);\nas.range;\nconst gn = 1e3, It = gn * 60, vn = It * 60, Sn = vn * 24, Jf = Sn * 7, og = Sn * 30, zu = Sn * 365, ir = Xe((e) => {\n  e.setTime(e - e.getMilliseconds());\n}, (e, t) => {\n  e.setTime(+e + t * gn);\n}, (e, t) => (t - e) / gn, (e) => e.getUTCSeconds());\nir.range;\nconst Qf = Xe((e) => {\n  e.setTime(e - e.getMilliseconds() - e.getSeconds() * gn);\n}, (e, t) => {\n  e.setTime(+e + t * It);\n}, (e, t) => (t - e) / It, (e) => e.getMinutes());\nQf.range;\nconst ed = Xe((e) => {\n  e.setUTCSeconds(0, 0);\n}, (e, t) => {\n  e.setTime(+e + t * It);\n}, (e, t) => (t - e) / It, (e) => e.getUTCMinutes());\ned.range;\nconst td = Xe((e) => {\n  e.setTime(e - e.getMilliseconds() - e.getSeconds() * gn - e.getMinutes() * It);\n}, (e, t) => {\n  e.setTime(+e + t * vn);\n}, (e, t) => (t - e) / vn, (e) => e.getHours());\ntd.range;\nconst nd = Xe((e) => {\n  e.setUTCMinutes(0, 0, 0);\n}, (e, t) => {\n  e.setTime(+e + t * vn);\n}, (e, t) => (t - e) / vn, (e) => e.getUTCHours());\nnd.range;\nconst Xo = Xe(\n  (e) => e.setHours(0, 0, 0, 0),\n  (e, t) => e.setDate(e.getDate() + t),\n  (e, t) => (t - e - (t.getTimezoneOffset() - e.getTimezoneOffset()) * It) / Sn,\n  (e) => e.getDate() - 1\n);\nXo.range;\nconst Ks = Xe((e) => {\n  e.setUTCHours(0, 0, 0, 0);\n}, (e, t) => {\n  e.setUTCDate(e.getUTCDate() + t);\n}, (e, t) => (t - e) / Sn, (e) => e.getUTCDate() - 1);\nKs.range;\nconst h0 = Xe((e) => {\n  e.setUTCHours(0, 0, 0, 0);\n}, (e, t) => {\n  e.setUTCDate(e.getUTCDate() + t);\n}, (e, t) => (t - e) / Sn, (e) => Math.floor(e / Sn));\nh0.range;\nfunction mr(e) {\n  return Xe((t) => {\n    t.setDate(t.getDate() - (t.getDay() + 7 - e) % 7), t.setHours(0, 0, 0, 0);\n  }, (t, n) => {\n    t.setDate(t.getDate() + n * 7);\n  }, (t, n) => (n - t - (n.getTimezoneOffset() - t.getTimezoneOffset()) * It) / Jf);\n}\nconst Ys = mr(0), ss = mr(1), n3 = mr(2), r3 = mr(3), Hr = mr(4), i3 = mr(5), o3 = mr(6);\nYs.range;\nss.range;\nn3.range;\nr3.range;\nHr.range;\ni3.range;\no3.range;\nfunction yr(e) {\n  return Xe((t) => {\n    t.setUTCDate(t.getUTCDate() - (t.getUTCDay() + 7 - e) % 7), t.setUTCHours(0, 0, 0, 0);\n  }, (t, n) => {\n    t.setUTCDate(t.getUTCDate() + n * 7);\n  }, (t, n) => (n - t) / Jf);\n}\nconst Xs = yr(0), us = yr(1), a3 = yr(2), s3 = yr(3), qr = yr(4), u3 = yr(5), c3 = yr(6);\nXs.range;\nus.range;\na3.range;\ns3.range;\nqr.range;\nu3.range;\nc3.range;\nconst rd = Xe((e) => {\n  e.setDate(1), e.setHours(0, 0, 0, 0);\n}, (e, t) => {\n  e.setMonth(e.getMonth() + t);\n}, (e, t) => t.getMonth() - e.getMonth() + (t.getFullYear() - e.getFullYear()) * 12, (e) => e.getMonth());\nrd.range;\nconst id = Xe((e) => {\n  e.setUTCDate(1), e.setUTCHours(0, 0, 0, 0);\n}, (e, t) => {\n  e.setUTCMonth(e.getUTCMonth() + t);\n}, (e, t) => t.getUTCMonth() - e.getUTCMonth() + (t.getUTCFullYear() - e.getUTCFullYear()) * 12, (e) => e.getUTCMonth());\nid.range;\nconst $n = Xe((e) => {\n  e.setMonth(0, 1), e.setHours(0, 0, 0, 0);\n}, (e, t) => {\n  e.setFullYear(e.getFullYear() + t);\n}, (e, t) => t.getFullYear() - e.getFullYear(), (e) => e.getFullYear());\n$n.every = (e) => !isFinite(e = Math.floor(e)) || !(e > 0) ? null : Xe((t) => {\n  t.setFullYear(Math.floor(t.getFullYear() / e) * e), t.setMonth(0, 1), t.setHours(0, 0, 0, 0);\n}, (t, n) => {\n  t.setFullYear(t.getFullYear() + n * e);\n});\n$n.range;\nconst On = Xe((e) => {\n  e.setUTCMonth(0, 1), e.setUTCHours(0, 0, 0, 0);\n}, (e, t) => {\n  e.setUTCFullYear(e.getUTCFullYear() + t);\n}, (e, t) => t.getUTCFullYear() - e.getUTCFullYear(), (e) => e.getUTCFullYear());\nOn.every = (e) => !isFinite(e = Math.floor(e)) || !(e > 0) ? null : Xe((t) => {\n  t.setUTCFullYear(Math.floor(t.getUTCFullYear() / e) * e), t.setUTCMonth(0, 1), t.setUTCHours(0, 0, 0, 0);\n}, (t, n) => {\n  t.setUTCFullYear(t.getUTCFullYear() + n * e);\n});\nOn.range;\nfunction g0(e, t, n, r, i, o) {\n  const a = [\n    [ir, 1, gn],\n    [ir, 5, 5 * gn],\n    [ir, 15, 15 * gn],\n    [ir, 30, 30 * gn],\n    [o, 1, It],\n    [o, 5, 5 * It],\n    [o, 15, 15 * It],\n    [o, 30, 30 * It],\n    [i, 1, vn],\n    [i, 3, 3 * vn],\n    [i, 6, 6 * vn],\n    [i, 12, 12 * vn],\n    [r, 1, Sn],\n    [r, 2, 2 * Sn],\n    [n, 1, Jf],\n    [t, 1, og],\n    [t, 3, 3 * og],\n    [e, 1, zu]\n  ];\n  function s(c, f, l) {\n    const d = f < c;\n    d && ([c, f] = [f, c]);\n    const p = l && typeof l.range == \"function\" ? l : u(c, f, l), g = p ? p.range(c, +f + 1) : [];\n    return d ? g.reverse() : g;\n  }\n  function u(c, f, l) {\n    const d = Math.abs(f - c) / l, p = Bf(([, , v]) => v).right(a, d);\n    if (p === a.length)\n      return e.every(rl(c / zu, f / zu, l));\n    if (p === 0)\n      return as.every(Math.max(rl(c, f, l), 1));\n    const [g, h] = a[d / a[p - 1][2] < a[p][2] / d ? p - 1 : p];\n    return g.every(h);\n  }\n  return [s, u];\n}\nconst [l3, f3] = g0(On, id, Xs, h0, nd, ed), [d3, p3] = g0($n, rd, Ys, Xo, td, Qf);\nfunction Vu(e) {\n  if (0 <= e.y && e.y < 100) {\n    var t = new Date(-1, e.m, e.d, e.H, e.M, e.S, e.L);\n    return t.setFullYear(e.y), t;\n  }\n  return new Date(e.y, e.m, e.d, e.H, e.M, e.S, e.L);\n}\nfunction Gu(e) {\n  if (0 <= e.y && e.y < 100) {\n    var t = new Date(Date.UTC(-1, e.m, e.d, e.H, e.M, e.S, e.L));\n    return t.setUTCFullYear(e.y), t;\n  }\n  return new Date(Date.UTC(e.y, e.m, e.d, e.H, e.M, e.S, e.L));\n}\nfunction Ii(e, t, n) {\n  return { y: e, m: t, d: n, H: 0, M: 0, S: 0, L: 0 };\n}\nfunction h3(e) {\n  var t = e.dateTime, n = e.date, r = e.time, i = e.periods, o = e.days, a = e.shortDays, s = e.months, u = e.shortMonths, c = ji(i), f = ki(i), l = ji(o), d = ki(o), p = ji(a), g = ki(a), h = ji(s), v = ki(s), w = ji(u), b = ki(u), x = {\n    a: F,\n    A: V,\n    b: L,\n    B: I,\n    c: null,\n    d: fg,\n    e: fg,\n    f: N3,\n    g: q3,\n    G: Y3,\n    H: j3,\n    I: k3,\n    j: D3,\n    L: v0,\n    m: F3,\n    M: L3,\n    p: D,\n    q: G,\n    Q: hg,\n    s: gg,\n    S: B3,\n    u: z3,\n    U: V3,\n    V: G3,\n    w: W3,\n    W: U3,\n    x: null,\n    X: null,\n    y: H3,\n    Y: K3,\n    Z: X3,\n    \"%\": pg\n  }, m = {\n    a: q,\n    A: J,\n    b: ne,\n    B: te,\n    c: null,\n    d: dg,\n    e: dg,\n    f: eB,\n    g: lB,\n    G: dB,\n    H: Z3,\n    I: J3,\n    j: Q3,\n    L: y0,\n    m: tB,\n    M: nB,\n    p: ee,\n    q: ie,\n    Q: hg,\n    s: gg,\n    S: rB,\n    u: iB,\n    U: oB,\n    V: aB,\n    w: sB,\n    W: uB,\n    x: null,\n    X: null,\n    y: cB,\n    Y: fB,\n    Z: pB,\n    \"%\": pg\n  }, y = {\n    a: M,\n    A: E,\n    b: A,\n    B: j,\n    c: R,\n    d: cg,\n    e: cg,\n    f: T3,\n    g: ug,\n    G: sg,\n    H: lg,\n    I: lg,\n    j: A3,\n    L: E3,\n    m: _3,\n    M: P3,\n    p: T,\n    q: O3,\n    Q: R3,\n    s: I3,\n    S: C3,\n    u: b3,\n    U: w3,\n    V: x3,\n    w: y3,\n    W: S3,\n    x: N,\n    X: k,\n    y: ug,\n    Y: sg,\n    Z: $3,\n    \"%\": M3\n  };\n  x.x = S(n, x), x.X = S(r, x), x.c = S(t, x), m.x = S(n, m), m.X = S(r, m), m.c = S(t, m);\n  function S(B, U) {\n    return function(re) {\n      var C = [], ge = -1, le = 0, xe = B.length, Ee, Ze, dt;\n      for (re instanceof Date || (re = /* @__PURE__ */ new Date(+re)); ++ge < xe; )\n        B.charCodeAt(ge) === 37 && (C.push(B.slice(le, ge)), (Ze = ag[Ee = B.charAt(++ge)]) != null ? Ee = B.charAt(++ge) : Ze = Ee === \"e\" ? \" \" : \"0\", (dt = U[Ee]) && (Ee = dt(re, Ze)), C.push(Ee), le = ge + 1);\n      return C.push(B.slice(le, ge)), C.join(\"\");\n    };\n  }\n  function $(B, U) {\n    return function(re) {\n      var C = Ii(1900, void 0, 1), ge = O(C, B, re += \"\", 0), le, xe;\n      if (ge != re.length)\n        return null;\n      if (\"Q\" in C)\n        return new Date(C.Q);\n      if (\"s\" in C)\n        return new Date(C.s * 1e3 + (\"L\" in C ? C.L : 0));\n      if (U && !(\"Z\" in C) && (C.Z = 0), \"p\" in C && (C.H = C.H % 12 + C.p * 12), C.m === void 0 && (C.m = \"q\" in C ? C.q : 0), \"V\" in C) {\n        if (C.V < 1 || C.V > 53)\n          return null;\n        \"w\" in C || (C.w = 1), \"Z\" in C ? (le = Gu(Ii(C.y, 0, 1)), xe = le.getUTCDay(), le = xe > 4 || xe === 0 ? us.ceil(le) : us(le), le = Ks.offset(le, (C.V - 1) * 7), C.y = le.getUTCFullYear(), C.m = le.getUTCMonth(), C.d = le.getUTCDate() + (C.w + 6) % 7) : (le = Vu(Ii(C.y, 0, 1)), xe = le.getDay(), le = xe > 4 || xe === 0 ? ss.ceil(le) : ss(le), le = Xo.offset(le, (C.V - 1) * 7), C.y = le.getFullYear(), C.m = le.getMonth(), C.d = le.getDate() + (C.w + 6) % 7);\n      } else\n        (\"W\" in C || \"U\" in C) && (\"w\" in C || (C.w = \"u\" in C ? C.u % 7 : \"W\" in C ? 1 : 0), xe = \"Z\" in C ? Gu(Ii(C.y, 0, 1)).getUTCDay() : Vu(Ii(C.y, 0, 1)).getDay(), C.m = 0, C.d = \"W\" in C ? (C.w + 6) % 7 + C.W * 7 - (xe + 5) % 7 : C.w + C.U * 7 - (xe + 6) % 7);\n      return \"Z\" in C ? (C.H += C.Z / 100 | 0, C.M += C.Z % 100, Gu(C)) : Vu(C);\n    };\n  }\n  function O(B, U, re, C) {\n    for (var ge = 0, le = U.length, xe = re.length, Ee, Ze; ge < le; ) {\n      if (C >= xe)\n        return -1;\n      if (Ee = U.charCodeAt(ge++), Ee === 37) {\n        if (Ee = U.charAt(ge++), Ze = y[Ee in ag ? U.charAt(ge++) : Ee], !Ze || (C = Ze(B, re, C)) < 0)\n          return -1;\n      } else if (Ee != re.charCodeAt(C++))\n        return -1;\n    }\n    return C;\n  }\n  function T(B, U, re) {\n    var C = c.exec(U.slice(re));\n    return C ? (B.p = f.get(C[0].toLowerCase()), re + C[0].length) : -1;\n  }\n  function M(B, U, re) {\n    var C = p.exec(U.slice(re));\n    return C ? (B.w = g.get(C[0].toLowerCase()), re + C[0].length) : -1;\n  }\n  function E(B, U, re) {\n    var C = l.exec(U.slice(re));\n    return C ? (B.w = d.get(C[0].toLowerCase()), re + C[0].length) : -1;\n  }\n  function A(B, U, re) {\n    var C = w.exec(U.slice(re));\n    return C ? (B.m = b.get(C[0].toLowerCase()), re + C[0].length) : -1;\n  }\n  function j(B, U, re) {\n    var C = h.exec(U.slice(re));\n    return C ? (B.m = v.get(C[0].toLowerCase()), re + C[0].length) : -1;\n  }\n  function R(B, U, re) {\n    return O(B, t, U, re);\n  }\n  function N(B, U, re) {\n    return O(B, n, U, re);\n  }\n  function k(B, U, re) {\n    return O(B, r, U, re);\n  }\n  function F(B) {\n    return a[B.getDay()];\n  }\n  function V(B) {\n    return o[B.getDay()];\n  }\n  function L(B) {\n    return u[B.getMonth()];\n  }\n  function I(B) {\n    return s[B.getMonth()];\n  }\n  function D(B) {\n    return i[+(B.getHours() >= 12)];\n  }\n  function G(B) {\n    return 1 + ~~(B.getMonth() / 3);\n  }\n  function q(B) {\n    return a[B.getUTCDay()];\n  }\n  function J(B) {\n    return o[B.getUTCDay()];\n  }\n  function ne(B) {\n    return u[B.getUTCMonth()];\n  }\n  function te(B) {\n    return s[B.getUTCMonth()];\n  }\n  function ee(B) {\n    return i[+(B.getUTCHours() >= 12)];\n  }\n  function ie(B) {\n    return 1 + ~~(B.getUTCMonth() / 3);\n  }\n  return {\n    format: function(B) {\n      var U = S(B += \"\", x);\n      return U.toString = function() {\n        return B;\n      }, U;\n    },\n    parse: function(B) {\n      var U = $(B += \"\", !1);\n      return U.toString = function() {\n        return B;\n      }, U;\n    },\n    utcFormat: function(B) {\n      var U = S(B += \"\", m);\n      return U.toString = function() {\n        return B;\n      }, U;\n    },\n    utcParse: function(B) {\n      var U = $(B += \"\", !0);\n      return U.toString = function() {\n        return B;\n      }, U;\n    }\n  };\n}\nvar ag = { \"-\": \"\", _: \" \", 0: \"0\" }, et = /^\\s*\\d+/, g3 = /^%/, v3 = /[\\\\^$*+?|[\\]().{}]/g;\nfunction Oe(e, t, n) {\n  var r = e < 0 ? \"-\" : \"\", i = (r ? -e : e) + \"\", o = i.length;\n  return r + (o < n ? new Array(n - o + 1).join(t) + i : i);\n}\nfunction m3(e) {\n  return e.replace(v3, \"\\\\$&\");\n}\nfunction ji(e) {\n  return new RegExp(\"^(?:\" + e.map(m3).join(\"|\") + \")\", \"i\");\n}\nfunction ki(e) {\n  return new Map(e.map((t, n) => [t.toLowerCase(), n]));\n}\nfunction y3(e, t, n) {\n  var r = et.exec(t.slice(n, n + 1));\n  return r ? (e.w = +r[0], n + r[0].length) : -1;\n}\nfunction b3(e, t, n) {\n  var r = et.exec(t.slice(n, n + 1));\n  return r ? (e.u = +r[0], n + r[0].length) : -1;\n}\nfunction w3(e, t, n) {\n  var r = et.exec(t.slice(n, n + 2));\n  return r ? (e.U = +r[0], n + r[0].length) : -1;\n}\nfunction x3(e, t, n) {\n  var r = et.exec(t.slice(n, n + 2));\n  return r ? (e.V = +r[0], n + r[0].length) : -1;\n}\nfunction S3(e, t, n) {\n  var r = et.exec(t.slice(n, n + 2));\n  return r ? (e.W = +r[0], n + r[0].length) : -1;\n}\nfunction sg(e, t, n) {\n  var r = et.exec(t.slice(n, n + 4));\n  return r ? (e.y = +r[0], n + r[0].length) : -1;\n}\nfunction ug(e, t, n) {\n  var r = et.exec(t.slice(n, n + 2));\n  return r ? (e.y = +r[0] + (+r[0] > 68 ? 1900 : 2e3), n + r[0].length) : -1;\n}\nfunction $3(e, t, n) {\n  var r = /^(Z)|([+-]\\d\\d)(?::?(\\d\\d))?/.exec(t.slice(n, n + 6));\n  return r ? (e.Z = r[1] ? 0 : -(r[2] + (r[3] || \"00\")), n + r[0].length) : -1;\n}\nfunction O3(e, t, n) {\n  var r = et.exec(t.slice(n, n + 1));\n  return r ? (e.q = r[0] * 3 - 3, n + r[0].length) : -1;\n}\nfunction _3(e, t, n) {\n  var r = et.exec(t.slice(n, n + 2));\n  return r ? (e.m = r[0] - 1, n + r[0].length) : -1;\n}\nfunction cg(e, t, n) {\n  var r = et.exec(t.slice(n, n + 2));\n  return r ? (e.d = +r[0], n + r[0].length) : -1;\n}\nfunction A3(e, t, n) {\n  var r = et.exec(t.slice(n, n + 3));\n  return r ? (e.m = 0, e.d = +r[0], n + r[0].length) : -1;\n}\nfunction lg(e, t, n) {\n  var r = et.exec(t.slice(n, n + 2));\n  return r ? (e.H = +r[0], n + r[0].length) : -1;\n}\nfunction P3(e, t, n) {\n  var r = et.exec(t.slice(n, n + 2));\n  return r ? (e.M = +r[0], n + r[0].length) : -1;\n}\nfunction C3(e, t, n) {\n  var r = et.exec(t.slice(n, n + 2));\n  return r ? (e.S = +r[0], n + r[0].length) : -1;\n}\nfunction E3(e, t, n) {\n  var r = et.exec(t.slice(n, n + 3));\n  return r ? (e.L = +r[0], n + r[0].length) : -1;\n}\nfunction T3(e, t, n) {\n  var r = et.exec(t.slice(n, n + 6));\n  return r ? (e.L = Math.floor(r[0] / 1e3), n + r[0].length) : -1;\n}\nfunction M3(e, t, n) {\n  var r = g3.exec(t.slice(n, n + 1));\n  return r ? n + r[0].length : -1;\n}\nfunction R3(e, t, n) {\n  var r = et.exec(t.slice(n));\n  return r ? (e.Q = +r[0], n + r[0].length) : -1;\n}\nfunction I3(e, t, n) {\n  var r = et.exec(t.slice(n));\n  return r ? (e.s = +r[0], n + r[0].length) : -1;\n}\nfunction fg(e, t) {\n  return Oe(e.getDate(), t, 2);\n}\nfunction j3(e, t) {\n  return Oe(e.getHours(), t, 2);\n}\nfunction k3(e, t) {\n  return Oe(e.getHours() % 12 || 12, t, 2);\n}\nfunction D3(e, t) {\n  return Oe(1 + Xo.count($n(e), e), t, 3);\n}\nfunction v0(e, t) {\n  return Oe(e.getMilliseconds(), t, 3);\n}\nfunction N3(e, t) {\n  return v0(e, t) + \"000\";\n}\nfunction F3(e, t) {\n  return Oe(e.getMonth() + 1, t, 2);\n}\nfunction L3(e, t) {\n  return Oe(e.getMinutes(), t, 2);\n}\nfunction B3(e, t) {\n  return Oe(e.getSeconds(), t, 2);\n}\nfunction z3(e) {\n  var t = e.getDay();\n  return t === 0 ? 7 : t;\n}\nfunction V3(e, t) {\n  return Oe(Ys.count($n(e) - 1, e), t, 2);\n}\nfunction m0(e) {\n  var t = e.getDay();\n  return t >= 4 || t === 0 ? Hr(e) : Hr.ceil(e);\n}\nfunction G3(e, t) {\n  return e = m0(e), Oe(Hr.count($n(e), e) + ($n(e).getDay() === 4), t, 2);\n}\nfunction W3(e) {\n  return e.getDay();\n}\nfunction U3(e, t) {\n  return Oe(ss.count($n(e) - 1, e), t, 2);\n}\nfunction H3(e, t) {\n  return Oe(e.getFullYear() % 100, t, 2);\n}\nfunction q3(e, t) {\n  return e = m0(e), Oe(e.getFullYear() % 100, t, 2);\n}\nfunction K3(e, t) {\n  return Oe(e.getFullYear() % 1e4, t, 4);\n}\nfunction Y3(e, t) {\n  var n = e.getDay();\n  return e = n >= 4 || n === 0 ? Hr(e) : Hr.ceil(e), Oe(e.getFullYear() % 1e4, t, 4);\n}\nfunction X3(e) {\n  var t = e.getTimezoneOffset();\n  return (t > 0 ? \"-\" : (t *= -1, \"+\")) + Oe(t / 60 | 0, \"0\", 2) + Oe(t % 60, \"0\", 2);\n}\nfunction dg(e, t) {\n  return Oe(e.getUTCDate(), t, 2);\n}\nfunction Z3(e, t) {\n  return Oe(e.getUTCHours(), t, 2);\n}\nfunction J3(e, t) {\n  return Oe(e.getUTCHours() % 12 || 12, t, 2);\n}\nfunction Q3(e, t) {\n  return Oe(1 + Ks.count(On(e), e), t, 3);\n}\nfunction y0(e, t) {\n  return Oe(e.getUTCMilliseconds(), t, 3);\n}\nfunction eB(e, t) {\n  return y0(e, t) + \"000\";\n}\nfunction tB(e, t) {\n  return Oe(e.getUTCMonth() + 1, t, 2);\n}\nfunction nB(e, t) {\n  return Oe(e.getUTCMinutes(), t, 2);\n}\nfunction rB(e, t) {\n  return Oe(e.getUTCSeconds(), t, 2);\n}\nfunction iB(e) {\n  var t = e.getUTCDay();\n  return t === 0 ? 7 : t;\n}\nfunction oB(e, t) {\n  return Oe(Xs.count(On(e) - 1, e), t, 2);\n}\nfunction b0(e) {\n  var t = e.getUTCDay();\n  return t >= 4 || t === 0 ? qr(e) : qr.ceil(e);\n}\nfunction aB(e, t) {\n  return e = b0(e), Oe(qr.count(On(e), e) + (On(e).getUTCDay() === 4), t, 2);\n}\nfunction sB(e) {\n  return e.getUTCDay();\n}\nfunction uB(e, t) {\n  return Oe(us.count(On(e) - 1, e), t, 2);\n}\nfunction cB(e, t) {\n  return Oe(e.getUTCFullYear() % 100, t, 2);\n}\nfunction lB(e, t) {\n  return e = b0(e), Oe(e.getUTCFullYear() % 100, t, 2);\n}\nfunction fB(e, t) {\n  return Oe(e.getUTCFullYear() % 1e4, t, 4);\n}\nfunction dB(e, t) {\n  var n = e.getUTCDay();\n  return e = n >= 4 || n === 0 ? qr(e) : qr.ceil(e), Oe(e.getUTCFullYear() % 1e4, t, 4);\n}\nfunction pB() {\n  return \"+0000\";\n}\nfunction pg() {\n  return \"%\";\n}\nfunction hg(e) {\n  return +e;\n}\nfunction gg(e) {\n  return Math.floor(+e / 1e3);\n}\nvar _r, w0, x0;\nhB({\n  dateTime: \"%x, %X\",\n  date: \"%-m/%-d/%Y\",\n  time: \"%-I:%M:%S %p\",\n  periods: [\"AM\", \"PM\"],\n  days: [\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"],\n  shortDays: [\"Sun\", \"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\"],\n  months: [\"January\", \"February\", \"March\", \"April\", \"May\", \"June\", \"July\", \"August\", \"September\", \"October\", \"November\", \"December\"],\n  shortMonths: [\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"]\n});\nfunction hB(e) {\n  return _r = h3(e), w0 = _r.format, _r.parse, x0 = _r.utcFormat, _r.utcParse, _r;\n}\nfunction gB(e) {\n  return new Date(e);\n}\nfunction vB(e) {\n  return e instanceof Date ? +e : +/* @__PURE__ */ new Date(+e);\n}\nfunction od(e, t, n, r, i, o, a, s, u, c) {\n  var f = Uf(), l = f.invert, d = f.domain, p = c(\".%L\"), g = c(\":%S\"), h = c(\"%I:%M\"), v = c(\"%I %p\"), w = c(\"%a %d\"), b = c(\"%b %d\"), x = c(\"%B\"), m = c(\"%Y\");\n  function y(S) {\n    return (u(S) < S ? p : s(S) < S ? g : a(S) < S ? h : o(S) < S ? v : r(S) < S ? i(S) < S ? w : b : n(S) < S ? x : m)(S);\n  }\n  return f.invert = function(S) {\n    return new Date(l(S));\n  }, f.domain = function(S) {\n    return arguments.length ? d(Array.from(S, vB)) : d().map(gB);\n  }, f.ticks = function(S) {\n    var $ = d();\n    return e($[0], $[$.length - 1], S ?? 10);\n  }, f.tickFormat = function(S, $) {\n    return $ == null ? y : c($);\n  }, f.nice = function(S) {\n    var $ = d();\n    return (!S || typeof S.range != \"function\") && (S = t($[0], $[$.length - 1], S ?? 10)), S ? d(s0($, S)) : f;\n  }, f.copy = function() {\n    return Yo(f, od(e, t, n, r, i, o, a, s, u, c));\n  }, f;\n}\nfunction mB() {\n  return Bt.apply(od(d3, p3, $n, rd, Ys, Xo, td, Qf, ir, w0).domain([new Date(2e3, 0, 1), new Date(2e3, 0, 2)]), arguments);\n}\nfunction yB() {\n  return Bt.apply(od(l3, f3, On, id, Xs, Ks, nd, ed, ir, x0).domain([Date.UTC(2e3, 0, 1), Date.UTC(2e3, 0, 2)]), arguments);\n}\nfunction Zs() {\n  var e = 0, t = 1, n, r, i, o, a = ft, s = !1, u;\n  function c(l) {\n    return l == null || isNaN(l = +l) ? u : a(i === 0 ? 0.5 : (l = (o(l) - n) * i, s ? Math.max(0, Math.min(1, l)) : l));\n  }\n  c.domain = function(l) {\n    return arguments.length ? ([e, t] = l, n = o(e = +e), r = o(t = +t), i = n === r ? 0 : 1 / (r - n), c) : [e, t];\n  }, c.clamp = function(l) {\n    return arguments.length ? (s = !!l, c) : s;\n  }, c.interpolator = function(l) {\n    return arguments.length ? (a = l, c) : a;\n  };\n  function f(l) {\n    return function(d) {\n      var p, g;\n      return arguments.length ? ([p, g] = d, a = l(p, g), c) : [a(0), a(1)];\n    };\n  }\n  return c.range = f(vi), c.rangeRound = f(Wf), c.unknown = function(l) {\n    return arguments.length ? (u = l, c) : u;\n  }, function(l) {\n    return o = l, n = l(e), r = l(t), i = n === r ? 0 : 1 / (r - n), c;\n  };\n}\nfunction Kn(e, t) {\n  return t.domain(e.domain()).interpolator(e.interpolator()).clamp(e.clamp()).unknown(e.unknown());\n}\nfunction S0() {\n  var e = qn(Zs()(ft));\n  return e.copy = function() {\n    return Kn(e, S0());\n  }, En.apply(e, arguments);\n}\nfunction $0() {\n  var e = Kf(Zs()).domain([1, 10]);\n  return e.copy = function() {\n    return Kn(e, $0()).base(e.base());\n  }, En.apply(e, arguments);\n}\nfunction O0() {\n  var e = Yf(Zs());\n  return e.copy = function() {\n    return Kn(e, O0()).constant(e.constant());\n  }, En.apply(e, arguments);\n}\nfunction ad() {\n  var e = Xf(Zs());\n  return e.copy = function() {\n    return Kn(e, ad()).exponent(e.exponent());\n  }, En.apply(e, arguments);\n}\nfunction bB() {\n  return ad.apply(null, arguments).exponent(0.5);\n}\nfunction _0() {\n  var e = [], t = ft;\n  function n(r) {\n    if (r != null && !isNaN(r = +r))\n      return t((qo(e, r, 1) - 1) / (e.length - 1));\n  }\n  return n.domain = function(r) {\n    if (!arguments.length)\n      return e.slice();\n    e = [];\n    for (let i of r)\n      i != null && !isNaN(i = +i) && e.push(i);\n    return e.sort(Ln), n;\n  }, n.interpolator = function(r) {\n    return arguments.length ? (t = r, n) : t;\n  }, n.range = function() {\n    return e.map((r, i) => t(i / (e.length - 1)));\n  }, n.quantiles = function(r) {\n    return Array.from({ length: r + 1 }, (i, o) => oL(e, o / r));\n  }, n.copy = function() {\n    return _0(t).domain(e);\n  }, En.apply(n, arguments);\n}\nfunction Js() {\n  var e = 0, t = 0.5, n = 1, r = 1, i, o, a, s, u, c = ft, f, l = !1, d;\n  function p(h) {\n    return isNaN(h = +h) ? d : (h = 0.5 + ((h = +f(h)) - o) * (r * h < r * o ? s : u), c(l ? Math.max(0, Math.min(1, h)) : h));\n  }\n  p.domain = function(h) {\n    return arguments.length ? ([e, t, n] = h, i = f(e = +e), o = f(t = +t), a = f(n = +n), s = i === o ? 0 : 0.5 / (o - i), u = o === a ? 0 : 0.5 / (a - o), r = o < i ? -1 : 1, p) : [e, t, n];\n  }, p.clamp = function(h) {\n    return arguments.length ? (l = !!h, p) : l;\n  }, p.interpolator = function(h) {\n    return arguments.length ? (c = h, p) : c;\n  };\n  function g(h) {\n    return function(v) {\n      var w, b, x;\n      return arguments.length ? ([w, b, x] = v, c = ML(h, [w, b, x]), p) : [c(0), c(0.5), c(1)];\n    };\n  }\n  return p.range = g(vi), p.rangeRound = g(Wf), p.unknown = function(h) {\n    return arguments.length ? (d = h, p) : d;\n  }, function(h) {\n    return f = h, i = h(e), o = h(t), a = h(n), s = i === o ? 0 : 0.5 / (o - i), u = o === a ? 0 : 0.5 / (a - o), r = o < i ? -1 : 1, p;\n  };\n}\nfunction A0() {\n  var e = qn(Js()(ft));\n  return e.copy = function() {\n    return Kn(e, A0());\n  }, En.apply(e, arguments);\n}\nfunction P0() {\n  var e = Kf(Js()).domain([0.1, 1, 10]);\n  return e.copy = function() {\n    return Kn(e, P0()).base(e.base());\n  }, En.apply(e, arguments);\n}\nfunction C0() {\n  var e = Yf(Js());\n  return e.copy = function() {\n    return Kn(e, C0()).constant(e.constant());\n  }, En.apply(e, arguments);\n}\nfunction sd() {\n  var e = Xf(Js());\n  return e.copy = function() {\n    return Kn(e, sd()).exponent(e.exponent());\n  }, En.apply(e, arguments);\n}\nfunction wB() {\n  return sd.apply(null, arguments).exponent(0.5);\n}\nconst vg = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n  __proto__: null,\n  scaleBand: so,\n  scaleDiverging: A0,\n  scaleDivergingLog: P0,\n  scaleDivergingPow: sd,\n  scaleDivergingSqrt: wB,\n  scaleDivergingSymlog: C0,\n  scaleIdentity: a0,\n  scaleImplicit: il,\n  scaleLinear: os,\n  scaleLog: u0,\n  scaleOrdinal: zf,\n  scalePoint: Wi,\n  scalePow: Zf,\n  scaleQuantile: f0,\n  scaleQuantize: d0,\n  scaleRadial: l0,\n  scaleSequential: S0,\n  scaleSequentialLog: $0,\n  scaleSequentialPow: ad,\n  scaleSequentialQuantile: _0,\n  scaleSequentialSqrt: bB,\n  scaleSequentialSymlog: O0,\n  scaleSqrt: e3,\n  scaleSymlog: c0,\n  scaleThreshold: p0,\n  scaleTime: mB,\n  scaleUtc: yB,\n  tickFormat: o0\n}, Symbol.toStringTag, { value: \"Module\" }));\nvar xB = ui;\nfunction SB(e, t, n) {\n  for (var r = -1, i = e.length; ++r < i; ) {\n    var o = e[r], a = t(o);\n    if (a != null && (s === void 0 ? a === a && !xB(a) : n(a, s)))\n      var s = a, u = o;\n  }\n  return u;\n}\nvar E0 = SB;\nfunction $B(e, t) {\n  return e > t;\n}\nvar OB = $B, _B = E0, AB = OB, PB = gi;\nfunction CB(e) {\n  return e && e.length ? _B(e, PB, AB) : void 0;\n}\nvar EB = CB;\nconst Qs = /* @__PURE__ */ je(EB);\nfunction TB(e, t) {\n  return e < t;\n}\nvar MB = TB, RB = E0, IB = MB, jB = gi;\nfunction kB(e) {\n  return e && e.length ? RB(e, jB, IB) : void 0;\n}\nvar DB = kB;\nconst eu = /* @__PURE__ */ je(DB);\nvar NB = Sf, FB = Hn, LB = Fb, BB = mt;\nfunction zB(e, t) {\n  var n = BB(e) ? NB : LB;\n  return n(e, FB(t));\n}\nvar VB = zB, GB = Db, WB = VB;\nfunction UB(e, t) {\n  return GB(WB(e, t), 1);\n}\nvar HB = UB;\nconst qB = /* @__PURE__ */ je(HB);\nvar KB = Df;\nfunction YB(e, t) {\n  return KB(e, t);\n}\nvar XB = YB;\nconst tu = /* @__PURE__ */ je(XB);\nvar mi = 1e9, ZB = {\n  // These values must be integers within the stated ranges (inclusive).\n  // Most of these values can be changed during run-time using `Decimal.config`.\n  // The maximum number of significant digits of the result of a calculation or base conversion.\n  // E.g. `Decimal.config({ precision: 20 });`\n  precision: 20,\n  // 1 to MAX_DIGITS\n  // The rounding mode used by default by `toInteger`, `toDecimalPlaces`, `toExponential`,\n  // `toFixed`, `toPrecision` and `toSignificantDigits`.\n  //\n  // ROUND_UP         0 Away from zero.\n  // ROUND_DOWN       1 Towards zero.\n  // ROUND_CEIL       2 Towards +Infinity.\n  // ROUND_FLOOR      3 Towards -Infinity.\n  // ROUND_HALF_UP    4 Towards nearest neighbour. If equidistant, up.\n  // ROUND_HALF_DOWN  5 Towards nearest neighbour. If equidistant, down.\n  // ROUND_HALF_EVEN  6 Towards nearest neighbour. If equidistant, towards even neighbour.\n  // ROUND_HALF_CEIL  7 Towards nearest neighbour. If equidistant, towards +Infinity.\n  // ROUND_HALF_FLOOR 8 Towards nearest neighbour. If equidistant, towards -Infinity.\n  //\n  // E.g.\n  // `Decimal.rounding = 4;`\n  // `Decimal.rounding = Decimal.ROUND_HALF_UP;`\n  rounding: 4,\n  // 0 to 8\n  // The exponent value at and beneath which `toString` returns exponential notation.\n  // JavaScript numbers: -7\n  toExpNeg: -7,\n  // 0 to -MAX_E\n  // The exponent value at and above which `toString` returns exponential notation.\n  // JavaScript numbers: 21\n  toExpPos: 21,\n  // 0 to MAX_E\n  // The natural logarithm of 10.\n  // 115 digits\n  LN10: \"2.302585092994045684017991454684364207601101488628772976033327900967572609677352480235997205089598298341967784042286\"\n}, cd, Be = !0, Dt = \"[DecimalError] \", ur = Dt + \"Invalid argument: \", ud = Dt + \"Exponent out of range: \", yi = Math.floor, tr = Math.pow, JB = /^(\\d+(\\.\\d*)?|\\.\\d+)(e[+-]?\\d+)?$/i, St, Qe = 1e7, Ne = 7, T0 = 9007199254740991, cs = yi(T0 / Ne), Q = {};\nQ.absoluteValue = Q.abs = function() {\n  var e = new this.constructor(this);\n  return e.s && (e.s = 1), e;\n};\nQ.comparedTo = Q.cmp = function(e) {\n  var t, n, r, i, o = this;\n  if (e = new o.constructor(e), o.s !== e.s)\n    return o.s || -e.s;\n  if (o.e !== e.e)\n    return o.e > e.e ^ o.s < 0 ? 1 : -1;\n  for (r = o.d.length, i = e.d.length, t = 0, n = r < i ? r : i; t < n; ++t)\n    if (o.d[t] !== e.d[t])\n      return o.d[t] > e.d[t] ^ o.s < 0 ? 1 : -1;\n  return r === i ? 0 : r > i ^ o.s < 0 ? 1 : -1;\n};\nQ.decimalPlaces = Q.dp = function() {\n  var e = this, t = e.d.length - 1, n = (t - e.e) * Ne;\n  if (t = e.d[t], t)\n    for (; t % 10 == 0; t /= 10)\n      n--;\n  return n < 0 ? 0 : n;\n};\nQ.dividedBy = Q.div = function(e) {\n  return bn(this, new this.constructor(e));\n};\nQ.dividedToIntegerBy = Q.idiv = function(e) {\n  var t = this, n = t.constructor;\n  return Re(bn(t, new n(e), 0, 1), n.precision);\n};\nQ.equals = Q.eq = function(e) {\n  return !this.cmp(e);\n};\nQ.exponent = function() {\n  return He(this);\n};\nQ.greaterThan = Q.gt = function(e) {\n  return this.cmp(e) > 0;\n};\nQ.greaterThanOrEqualTo = Q.gte = function(e) {\n  return this.cmp(e) >= 0;\n};\nQ.isInteger = Q.isint = function() {\n  return this.e > this.d.length - 2;\n};\nQ.isNegative = Q.isneg = function() {\n  return this.s < 0;\n};\nQ.isPositive = Q.ispos = function() {\n  return this.s > 0;\n};\nQ.isZero = function() {\n  return this.s === 0;\n};\nQ.lessThan = Q.lt = function(e) {\n  return this.cmp(e) < 0;\n};\nQ.lessThanOrEqualTo = Q.lte = function(e) {\n  return this.cmp(e) < 1;\n};\nQ.logarithm = Q.log = function(e) {\n  var t, n = this, r = n.constructor, i = r.precision, o = i + 5;\n  if (e === void 0)\n    e = new r(10);\n  else if (e = new r(e), e.s < 1 || e.eq(St))\n    throw Error(Dt + \"NaN\");\n  if (n.s < 1)\n    throw Error(Dt + (n.s ? \"NaN\" : \"-Infinity\"));\n  return n.eq(St) ? new r(0) : (Be = !1, t = bn(po(n, o), po(e, o), o), Be = !0, Re(t, i));\n};\nQ.minus = Q.sub = function(e) {\n  var t = this;\n  return e = new t.constructor(e), t.s == e.s ? I0(t, e) : M0(t, (e.s = -e.s, e));\n};\nQ.modulo = Q.mod = function(e) {\n  var t, n = this, r = n.constructor, i = r.precision;\n  if (e = new r(e), !e.s)\n    throw Error(Dt + \"NaN\");\n  return n.s ? (Be = !1, t = bn(n, e, 0, 1).times(e), Be = !0, n.minus(t)) : Re(new r(n), i);\n};\nQ.naturalExponential = Q.exp = function() {\n  return R0(this);\n};\nQ.naturalLogarithm = Q.ln = function() {\n  return po(this);\n};\nQ.negated = Q.neg = function() {\n  var e = new this.constructor(this);\n  return e.s = -e.s || 0, e;\n};\nQ.plus = Q.add = function(e) {\n  var t = this;\n  return e = new t.constructor(e), t.s == e.s ? M0(t, e) : I0(t, (e.s = -e.s, e));\n};\nQ.precision = Q.sd = function(e) {\n  var t, n, r, i = this;\n  if (e !== void 0 && e !== !!e && e !== 1 && e !== 0)\n    throw Error(ur + e);\n  if (t = He(i) + 1, r = i.d.length - 1, n = r * Ne + 1, r = i.d[r], r) {\n    for (; r % 10 == 0; r /= 10)\n      n--;\n    for (r = i.d[0]; r >= 10; r /= 10)\n      n++;\n  }\n  return e && t > n ? t : n;\n};\nQ.squareRoot = Q.sqrt = function() {\n  var e, t, n, r, i, o, a, s = this, u = s.constructor;\n  if (s.s < 1) {\n    if (!s.s)\n      return new u(0);\n    throw Error(Dt + \"NaN\");\n  }\n  for (e = He(s), Be = !1, i = Math.sqrt(+s), i == 0 || i == 1 / 0 ? (t = on(s.d), (t.length + e) % 2 == 0 && (t += \"0\"), i = Math.sqrt(t), e = yi((e + 1) / 2) - (e < 0 || e % 2), i == 1 / 0 ? t = \"5e\" + e : (t = i.toExponential(), t = t.slice(0, t.indexOf(\"e\") + 1) + e), r = new u(t)) : r = new u(i.toString()), n = u.precision, i = a = n + 3; ; )\n    if (o = r, r = o.plus(bn(s, o, a + 2)).times(0.5), on(o.d).slice(0, a) === (t = on(r.d)).slice(0, a)) {\n      if (t = t.slice(a - 3, a + 1), i == a && t == \"4999\") {\n        if (Re(o, n + 1, 0), o.times(o).eq(s)) {\n          r = o;\n          break;\n        }\n      } else if (t != \"9999\")\n        break;\n      a += 4;\n    }\n  return Be = !0, Re(r, n);\n};\nQ.times = Q.mul = function(e) {\n  var t, n, r, i, o, a, s, u, c, f = this, l = f.constructor, d = f.d, p = (e = new l(e)).d;\n  if (!f.s || !e.s)\n    return new l(0);\n  for (e.s *= f.s, n = f.e + e.e, u = d.length, c = p.length, u < c && (o = d, d = p, p = o, a = u, u = c, c = a), o = [], a = u + c, r = a; r--; )\n    o.push(0);\n  for (r = c; --r >= 0; ) {\n    for (t = 0, i = u + r; i > r; )\n      s = o[i] + p[r] * d[i - r - 1] + t, o[i--] = s % Qe | 0, t = s / Qe | 0;\n    o[i] = (o[i] + t) % Qe | 0;\n  }\n  for (; !o[--a]; )\n    o.pop();\n  return t ? ++n : o.shift(), e.d = o, e.e = n, Be ? Re(e, l.precision) : e;\n};\nQ.toDecimalPlaces = Q.todp = function(e, t) {\n  var n = this, r = n.constructor;\n  return n = new r(n), e === void 0 ? n : (fn(e, 0, mi), t === void 0 ? t = r.rounding : fn(t, 0, 8), Re(n, e + He(n) + 1, t));\n};\nQ.toExponential = function(e, t) {\n  var n, r = this, i = r.constructor;\n  return e === void 0 ? n = fr(r, !0) : (fn(e, 0, mi), t === void 0 ? t = i.rounding : fn(t, 0, 8), r = Re(new i(r), e + 1, t), n = fr(r, !0, e + 1)), n;\n};\nQ.toFixed = function(e, t) {\n  var n, r, i = this, o = i.constructor;\n  return e === void 0 ? fr(i) : (fn(e, 0, mi), t === void 0 ? t = o.rounding : fn(t, 0, 8), r = Re(new o(i), e + He(i) + 1, t), n = fr(r.abs(), !1, e + He(r) + 1), i.isneg() && !i.isZero() ? \"-\" + n : n);\n};\nQ.toInteger = Q.toint = function() {\n  var e = this, t = e.constructor;\n  return Re(new t(e), He(e) + 1, t.rounding);\n};\nQ.toNumber = function() {\n  return +this;\n};\nQ.toPower = Q.pow = function(e) {\n  var t, n, r, i, o, a, s = this, u = s.constructor, c = 12, f = +(e = new u(e));\n  if (!e.s)\n    return new u(St);\n  if (s = new u(s), !s.s) {\n    if (e.s < 1)\n      throw Error(Dt + \"Infinity\");\n    return s;\n  }\n  if (s.eq(St))\n    return s;\n  if (r = u.precision, e.eq(St))\n    return Re(s, r);\n  if (t = e.e, n = e.d.length - 1, a = t >= n, o = s.s, a) {\n    if ((n = f < 0 ? -f : f) <= T0) {\n      for (i = new u(St), t = Math.ceil(r / Ne + 4), Be = !1; n % 2 && (i = i.times(s), yg(i.d, t)), n = yi(n / 2), n !== 0; )\n        s = s.times(s), yg(s.d, t);\n      return Be = !0, e.s < 0 ? new u(St).div(i) : Re(i, r);\n    }\n  } else if (o < 0)\n    throw Error(Dt + \"NaN\");\n  return o = o < 0 && e.d[Math.max(t, n)] & 1 ? -1 : 1, s.s = 1, Be = !1, i = e.times(po(s, r + c)), Be = !0, i = R0(i), i.s = o, i;\n};\nQ.toPrecision = function(e, t) {\n  var n, r, i = this, o = i.constructor;\n  return e === void 0 ? (n = He(i), r = fr(i, n <= o.toExpNeg || n >= o.toExpPos)) : (fn(e, 1, mi), t === void 0 ? t = o.rounding : fn(t, 0, 8), i = Re(new o(i), e, t), n = He(i), r = fr(i, e <= n || n <= o.toExpNeg, e)), r;\n};\nQ.toSignificantDigits = Q.tosd = function(e, t) {\n  var n = this, r = n.constructor;\n  return e === void 0 ? (e = r.precision, t = r.rounding) : (fn(e, 1, mi), t === void 0 ? t = r.rounding : fn(t, 0, 8)), Re(new r(n), e, t);\n};\nQ.toString = Q.valueOf = Q.val = Q.toJSON = Q[Symbol.for(\"nodejs.util.inspect.custom\")] = function() {\n  var e = this, t = He(e), n = e.constructor;\n  return fr(e, t <= n.toExpNeg || t >= n.toExpPos);\n};\nfunction M0(e, t) {\n  var n, r, i, o, a, s, u, c, f = e.constructor, l = f.precision;\n  if (!e.s || !t.s)\n    return t.s || (t = new f(e)), Be ? Re(t, l) : t;\n  if (u = e.d, c = t.d, a = e.e, i = t.e, u = u.slice(), o = a - i, o) {\n    for (o < 0 ? (r = u, o = -o, s = c.length) : (r = c, i = a, s = u.length), a = Math.ceil(l / Ne), s = a > s ? a + 1 : s + 1, o > s && (o = s, r.length = 1), r.reverse(); o--; )\n      r.push(0);\n    r.reverse();\n  }\n  for (s = u.length, o = c.length, s - o < 0 && (o = s, r = c, c = u, u = r), n = 0; o; )\n    n = (u[--o] = u[o] + c[o] + n) / Qe | 0, u[o] %= Qe;\n  for (n && (u.unshift(n), ++i), s = u.length; u[--s] == 0; )\n    u.pop();\n  return t.d = u, t.e = i, Be ? Re(t, l) : t;\n}\nfunction fn(e, t, n) {\n  if (e !== ~~e || e < t || e > n)\n    throw Error(ur + e);\n}\nfunction on(e) {\n  var t, n, r, i = e.length - 1, o = \"\", a = e[0];\n  if (i > 0) {\n    for (o += a, t = 1; t < i; t++)\n      r = e[t] + \"\", n = Ne - r.length, n && (o += jn(n)), o += r;\n    a = e[t], r = a + \"\", n = Ne - r.length, n && (o += jn(n));\n  } else if (a === 0)\n    return \"0\";\n  for (; a % 10 === 0; )\n    a /= 10;\n  return o + a;\n}\nvar bn = /* @__PURE__ */ function() {\n  function e(r, i) {\n    var o, a = 0, s = r.length;\n    for (r = r.slice(); s--; )\n      o = r[s] * i + a, r[s] = o % Qe | 0, a = o / Qe | 0;\n    return a && r.unshift(a), r;\n  }\n  function t(r, i, o, a) {\n    var s, u;\n    if (o != a)\n      u = o > a ? 1 : -1;\n    else\n      for (s = u = 0; s < o; s++)\n        if (r[s] != i[s]) {\n          u = r[s] > i[s] ? 1 : -1;\n          break;\n        }\n    return u;\n  }\n  function n(r, i, o) {\n    for (var a = 0; o--; )\n      r[o] -= a, a = r[o] < i[o] ? 1 : 0, r[o] = a * Qe + r[o] - i[o];\n    for (; !r[0] && r.length > 1; )\n      r.shift();\n  }\n  return function(r, i, o, a) {\n    var s, u, c, f, l, d, p, g, h, v, w, b, x, m, y, S, $, O, T = r.constructor, M = r.s == i.s ? 1 : -1, E = r.d, A = i.d;\n    if (!r.s)\n      return new T(r);\n    if (!i.s)\n      throw Error(Dt + \"Division by zero\");\n    for (u = r.e - i.e, $ = A.length, y = E.length, p = new T(M), g = p.d = [], c = 0; A[c] == (E[c] || 0); )\n      ++c;\n    if (A[c] > (E[c] || 0) && --u, o == null ? b = o = T.precision : a ? b = o + (He(r) - He(i)) + 1 : b = o, b < 0)\n      return new T(0);\n    if (b = b / Ne + 2 | 0, c = 0, $ == 1)\n      for (f = 0, A = A[0], b++; (c < y || f) && b--; c++)\n        x = f * Qe + (E[c] || 0), g[c] = x / A | 0, f = x % A | 0;\n    else {\n      for (f = Qe / (A[0] + 1) | 0, f > 1 && (A = e(A, f), E = e(E, f), $ = A.length, y = E.length), m = $, h = E.slice(0, $), v = h.length; v < $; )\n        h[v++] = 0;\n      O = A.slice(), O.unshift(0), S = A[0], A[1] >= Qe / 2 && ++S;\n      do\n        f = 0, s = t(A, h, $, v), s < 0 ? (w = h[0], $ != v && (w = w * Qe + (h[1] || 0)), f = w / S | 0, f > 1 ? (f >= Qe && (f = Qe - 1), l = e(A, f), d = l.length, v = h.length, s = t(l, h, d, v), s == 1 && (f--, n(l, $ < d ? O : A, d))) : (f == 0 && (s = f = 1), l = A.slice()), d = l.length, d < v && l.unshift(0), n(h, l, v), s == -1 && (v = h.length, s = t(A, h, $, v), s < 1 && (f++, n(h, $ < v ? O : A, v))), v = h.length) : s === 0 && (f++, h = [0]), g[c++] = f, s && h[0] ? h[v++] = E[m] || 0 : (h = [E[m]], v = 1);\n      while ((m++ < y || h[0] !== void 0) && b--);\n    }\n    return g[0] || g.shift(), p.e = u, Re(p, a ? o + He(p) + 1 : o);\n  };\n}();\nfunction R0(e, t) {\n  var n, r, i, o, a, s, u = 0, c = 0, f = e.constructor, l = f.precision;\n  if (He(e) > 16)\n    throw Error(ud + He(e));\n  if (!e.s)\n    return new f(St);\n  for (t == null ? (Be = !1, s = l) : s = t, a = new f(0.03125); e.abs().gte(0.1); )\n    e = e.times(a), c += 5;\n  for (r = Math.log(tr(2, c)) / Math.LN10 * 2 + 5 | 0, s += r, n = i = o = new f(St), f.precision = s; ; ) {\n    if (i = Re(i.times(e), s), n = n.times(++u), a = o.plus(bn(i, n, s)), on(a.d).slice(0, s) === on(o.d).slice(0, s)) {\n      for (; c--; )\n        o = Re(o.times(o), s);\n      return f.precision = l, t == null ? (Be = !0, Re(o, l)) : o;\n    }\n    o = a;\n  }\n}\nfunction He(e) {\n  for (var t = e.e * Ne, n = e.d[0]; n >= 10; n /= 10)\n    t++;\n  return t;\n}\nfunction Wu(e, t, n) {\n  if (t > e.LN10.sd())\n    throw Be = !0, n && (e.precision = n), Error(Dt + \"LN10 precision limit exceeded\");\n  return Re(new e(e.LN10), t);\n}\nfunction jn(e) {\n  for (var t = \"\"; e--; )\n    t += \"0\";\n  return t;\n}\nfunction po(e, t) {\n  var n, r, i, o, a, s, u, c, f, l = 1, d = 10, p = e, g = p.d, h = p.constructor, v = h.precision;\n  if (p.s < 1)\n    throw Error(Dt + (p.s ? \"NaN\" : \"-Infinity\"));\n  if (p.eq(St))\n    return new h(0);\n  if (t == null ? (Be = !1, c = v) : c = t, p.eq(10))\n    return t == null && (Be = !0), Wu(h, c);\n  if (c += d, h.precision = c, n = on(g), r = n.charAt(0), o = He(p), Math.abs(o) < 15e14) {\n    for (; r < 7 && r != 1 || r == 1 && n.charAt(1) > 3; )\n      p = p.times(e), n = on(p.d), r = n.charAt(0), l++;\n    o = He(p), r > 1 ? (p = new h(\"0.\" + n), o++) : p = new h(r + \".\" + n.slice(1));\n  } else\n    return u = Wu(h, c + 2, v).times(o + \"\"), p = po(new h(r + \".\" + n.slice(1)), c - d).plus(u), h.precision = v, t == null ? (Be = !0, Re(p, v)) : p;\n  for (s = a = p = bn(p.minus(St), p.plus(St), c), f = Re(p.times(p), c), i = 3; ; ) {\n    if (a = Re(a.times(f), c), u = s.plus(bn(a, new h(i), c)), on(u.d).slice(0, c) === on(s.d).slice(0, c))\n      return s = s.times(2), o !== 0 && (s = s.plus(Wu(h, c + 2, v).times(o + \"\"))), s = bn(s, new h(l), c), h.precision = v, t == null ? (Be = !0, Re(s, v)) : s;\n    s = u, i += 2;\n  }\n}\nfunction mg(e, t) {\n  var n, r, i;\n  for ((n = t.indexOf(\".\")) > -1 && (t = t.replace(\".\", \"\")), (r = t.search(/e/i)) > 0 ? (n < 0 && (n = r), n += +t.slice(r + 1), t = t.substring(0, r)) : n < 0 && (n = t.length), r = 0; t.charCodeAt(r) === 48; )\n    ++r;\n  for (i = t.length; t.charCodeAt(i - 1) === 48; )\n    --i;\n  if (t = t.slice(r, i), t) {\n    if (i -= r, n = n - r - 1, e.e = yi(n / Ne), e.d = [], r = (n + 1) % Ne, n < 0 && (r += Ne), r < i) {\n      for (r && e.d.push(+t.slice(0, r)), i -= Ne; r < i; )\n        e.d.push(+t.slice(r, r += Ne));\n      t = t.slice(r), r = Ne - t.length;\n    } else\n      r -= i;\n    for (; r--; )\n      t += \"0\";\n    if (e.d.push(+t), Be && (e.e > cs || e.e < -cs))\n      throw Error(ud + n);\n  } else\n    e.s = 0, e.e = 0, e.d = [0];\n  return e;\n}\nfunction Re(e, t, n) {\n  var r, i, o, a, s, u, c, f, l = e.d;\n  for (a = 1, o = l[0]; o >= 10; o /= 10)\n    a++;\n  if (r = t - a, r < 0)\n    r += Ne, i = t, c = l[f = 0];\n  else {\n    if (f = Math.ceil((r + 1) / Ne), o = l.length, f >= o)\n      return e;\n    for (c = o = l[f], a = 1; o >= 10; o /= 10)\n      a++;\n    r %= Ne, i = r - Ne + a;\n  }\n  if (n !== void 0 && (o = tr(10, a - i - 1), s = c / o % 10 | 0, u = t < 0 || l[f + 1] !== void 0 || c % o, u = n < 4 ? (s || u) && (n == 0 || n == (e.s < 0 ? 3 : 2)) : s > 5 || s == 5 && (n == 4 || u || n == 6 && // Check whether the digit to the left of the rounding digit is odd.\n  (r > 0 ? i > 0 ? c / tr(10, a - i) : 0 : l[f - 1]) % 10 & 1 || n == (e.s < 0 ? 8 : 7))), t < 1 || !l[0])\n    return u ? (o = He(e), l.length = 1, t = t - o - 1, l[0] = tr(10, (Ne - t % Ne) % Ne), e.e = yi(-t / Ne) || 0) : (l.length = 1, l[0] = e.e = e.s = 0), e;\n  if (r == 0 ? (l.length = f, o = 1, f--) : (l.length = f + 1, o = tr(10, Ne - r), l[f] = i > 0 ? (c / tr(10, a - i) % tr(10, i) | 0) * o : 0), u)\n    for (; ; )\n      if (f == 0) {\n        (l[0] += o) == Qe && (l[0] = 1, ++e.e);\n        break;\n      } else {\n        if (l[f] += o, l[f] != Qe)\n          break;\n        l[f--] = 0, o = 1;\n      }\n  for (r = l.length; l[--r] === 0; )\n    l.pop();\n  if (Be && (e.e > cs || e.e < -cs))\n    throw Error(ud + He(e));\n  return e;\n}\nfunction I0(e, t) {\n  var n, r, i, o, a, s, u, c, f, l, d = e.constructor, p = d.precision;\n  if (!e.s || !t.s)\n    return t.s ? t.s = -t.s : t = new d(e), Be ? Re(t, p) : t;\n  if (u = e.d, l = t.d, r = t.e, c = e.e, u = u.slice(), a = c - r, a) {\n    for (f = a < 0, f ? (n = u, a = -a, s = l.length) : (n = l, r = c, s = u.length), i = Math.max(Math.ceil(p / Ne), s) + 2, a > i && (a = i, n.length = 1), n.reverse(), i = a; i--; )\n      n.push(0);\n    n.reverse();\n  } else {\n    for (i = u.length, s = l.length, f = i < s, f && (s = i), i = 0; i < s; i++)\n      if (u[i] != l[i]) {\n        f = u[i] < l[i];\n        break;\n      }\n    a = 0;\n  }\n  for (f && (n = u, u = l, l = n, t.s = -t.s), s = u.length, i = l.length - s; i > 0; --i)\n    u[s++] = 0;\n  for (i = l.length; i > a; ) {\n    if (u[--i] < l[i]) {\n      for (o = i; o && u[--o] === 0; )\n        u[o] = Qe - 1;\n      --u[o], u[i] += Qe;\n    }\n    u[i] -= l[i];\n  }\n  for (; u[--s] === 0; )\n    u.pop();\n  for (; u[0] === 0; u.shift())\n    --r;\n  return u[0] ? (t.d = u, t.e = r, Be ? Re(t, p) : t) : new d(0);\n}\nfunction fr(e, t, n) {\n  var r, i = He(e), o = on(e.d), a = o.length;\n  return t ? (n && (r = n - a) > 0 ? o = o.charAt(0) + \".\" + o.slice(1) + jn(r) : a > 1 && (o = o.charAt(0) + \".\" + o.slice(1)), o = o + (i < 0 ? \"e\" : \"e+\") + i) : i < 0 ? (o = \"0.\" + jn(-i - 1) + o, n && (r = n - a) > 0 && (o += jn(r))) : i >= a ? (o += jn(i + 1 - a), n && (r = n - i - 1) > 0 && (o = o + \".\" + jn(r))) : ((r = i + 1) < a && (o = o.slice(0, r) + \".\" + o.slice(r)), n && (r = n - a) > 0 && (i + 1 === a && (o += \".\"), o += jn(r))), e.s < 0 ? \"-\" + o : o;\n}\nfunction yg(e, t) {\n  if (e.length > t)\n    return e.length = t, !0;\n}\nfunction j0(e) {\n  var t, n, r;\n  function i(o) {\n    var a = this;\n    if (!(a instanceof i))\n      return new i(o);\n    if (a.constructor = i, o instanceof i) {\n      a.s = o.s, a.e = o.e, a.d = (o = o.d) ? o.slice() : o;\n      return;\n    }\n    if (typeof o == \"number\") {\n      if (o * 0 !== 0)\n        throw Error(ur + o);\n      if (o > 0)\n        a.s = 1;\n      else if (o < 0)\n        o = -o, a.s = -1;\n      else {\n        a.s = 0, a.e = 0, a.d = [0];\n        return;\n      }\n      if (o === ~~o && o < 1e7) {\n        a.e = 0, a.d = [o];\n        return;\n      }\n      return mg(a, o.toString());\n    } else if (typeof o != \"string\")\n      throw Error(ur + o);\n    if (o.charCodeAt(0) === 45 ? (o = o.slice(1), a.s = -1) : a.s = 1, JB.test(o))\n      mg(a, o);\n    else\n      throw Error(ur + o);\n  }\n  if (i.prototype = Q, i.ROUND_UP = 0, i.ROUND_DOWN = 1, i.ROUND_CEIL = 2, i.ROUND_FLOOR = 3, i.ROUND_HALF_UP = 4, i.ROUND_HALF_DOWN = 5, i.ROUND_HALF_EVEN = 6, i.ROUND_HALF_CEIL = 7, i.ROUND_HALF_FLOOR = 8, i.clone = j0, i.config = i.set = QB, e === void 0 && (e = {}), e)\n    for (r = [\"precision\", \"rounding\", \"toExpNeg\", \"toExpPos\", \"LN10\"], t = 0; t < r.length; )\n      e.hasOwnProperty(n = r[t++]) || (e[n] = this[n]);\n  return i.config(e), i;\n}\nfunction QB(e) {\n  if (!e || typeof e != \"object\")\n    throw Error(Dt + \"Object expected\");\n  var t, n, r, i = [\n    \"precision\",\n    1,\n    mi,\n    \"rounding\",\n    0,\n    8,\n    \"toExpNeg\",\n    -1 / 0,\n    0,\n    \"toExpPos\",\n    0,\n    1 / 0\n  ];\n  for (t = 0; t < i.length; t += 3)\n    if ((r = e[n = i[t]]) !== void 0)\n      if (yi(r) === r && r >= i[t + 1] && r <= i[t + 2])\n        this[n] = r;\n      else\n        throw Error(ur + n + \": \" + r);\n  if ((r = e[n = \"LN10\"]) !== void 0)\n    if (r == Math.LN10)\n      this[n] = new this(r);\n    else\n      throw Error(ur + n + \": \" + r);\n  return this;\n}\nvar cd = j0(ZB);\nSt = new cd(1);\nconst Te = cd;\nfunction e6(e) {\n  return i6(e) || r6(e) || n6(e) || t6();\n}\nfunction t6() {\n  throw new TypeError(`Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);\n}\nfunction n6(e, t) {\n  if (e) {\n    if (typeof e == \"string\")\n      return ul(e, t);\n    var n = Object.prototype.toString.call(e).slice(8, -1);\n    if (n === \"Object\" && e.constructor && (n = e.constructor.name), n === \"Map\" || n === \"Set\")\n      return Array.from(e);\n    if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))\n      return ul(e, t);\n  }\n}\nfunction r6(e) {\n  if (typeof Symbol < \"u\" && Symbol.iterator in Object(e))\n    return Array.from(e);\n}\nfunction i6(e) {\n  if (Array.isArray(e))\n    return ul(e);\n}\nfunction ul(e, t) {\n  (t == null || t > e.length) && (t = e.length);\n  for (var n = 0, r = new Array(t); n < t; n++)\n    r[n] = e[n];\n  return r;\n}\nvar o6 = function(t) {\n  return t;\n}, k0 = {\n  \"@@functional/placeholder\": !0\n}, D0 = function(t) {\n  return t === k0;\n}, bg = function(t) {\n  return function n() {\n    return arguments.length === 0 || arguments.length === 1 && D0(arguments.length <= 0 ? void 0 : arguments[0]) ? n : t.apply(void 0, arguments);\n  };\n}, a6 = function e(t, n) {\n  return t === 1 ? n : bg(function() {\n    for (var r = arguments.length, i = new Array(r), o = 0; o < r; o++)\n      i[o] = arguments[o];\n    var a = i.filter(function(s) {\n      return s !== k0;\n    }).length;\n    return a >= t ? n.apply(void 0, i) : e(t - a, bg(function() {\n      for (var s = arguments.length, u = new Array(s), c = 0; c < s; c++)\n        u[c] = arguments[c];\n      var f = i.map(function(l) {\n        return D0(l) ? u.shift() : l;\n      });\n      return n.apply(void 0, e6(f).concat(u));\n    }));\n  });\n}, nu = function(t) {\n  return a6(t.length, t);\n}, cl = function(t, n) {\n  for (var r = [], i = t; i < n; ++i)\n    r[i - t] = i;\n  return r;\n}, s6 = nu(function(e, t) {\n  return Array.isArray(t) ? t.map(e) : Object.keys(t).map(function(n) {\n    return t[n];\n  }).map(e);\n}), u6 = function() {\n  for (var t = arguments.length, n = new Array(t), r = 0; r < t; r++)\n    n[r] = arguments[r];\n  if (!n.length)\n    return o6;\n  var i = n.reverse(), o = i[0], a = i.slice(1);\n  return function() {\n    return a.reduce(function(s, u) {\n      return u(s);\n    }, o.apply(void 0, arguments));\n  };\n}, ll = function(t) {\n  return Array.isArray(t) ? t.reverse() : t.split(\"\").reverse.join(\"\");\n}, N0 = function(t) {\n  var n = null, r = null;\n  return function() {\n    for (var i = arguments.length, o = new Array(i), a = 0; a < i; a++)\n      o[a] = arguments[a];\n    return n && o.every(function(s, u) {\n      return s === n[u];\n    }) || (n = o, r = t.apply(void 0, o)), r;\n  };\n};\nfunction c6(e) {\n  var t;\n  return e === 0 ? t = 1 : t = Math.floor(new Te(e).abs().log(10).toNumber()) + 1, t;\n}\nfunction l6(e, t, n) {\n  for (var r = new Te(e), i = 0, o = []; r.lt(t) && i < 1e5; )\n    o.push(r.toNumber()), r = r.add(n), i++;\n  return o;\n}\nvar f6 = nu(function(e, t, n) {\n  var r = +e, i = +t;\n  return r + n * (i - r);\n}), d6 = nu(function(e, t, n) {\n  var r = t - +e;\n  return r = r || 1 / 0, (n - e) / r;\n}), p6 = nu(function(e, t, n) {\n  var r = t - +e;\n  return r = r || 1 / 0, Math.max(0, Math.min(1, (n - e) / r));\n});\nconst ru = {\n  rangeStep: l6,\n  getDigitCount: c6,\n  interpolateNumber: f6,\n  uninterpolateNumber: d6,\n  uninterpolateTruncation: p6\n};\nfunction fl(e) {\n  return v6(e) || g6(e) || F0(e) || h6();\n}\nfunction h6() {\n  throw new TypeError(`Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);\n}\nfunction g6(e) {\n  if (typeof Symbol < \"u\" && Symbol.iterator in Object(e))\n    return Array.from(e);\n}\nfunction v6(e) {\n  if (Array.isArray(e))\n    return dl(e);\n}\nfunction ho(e, t) {\n  return b6(e) || y6(e, t) || F0(e, t) || m6();\n}\nfunction m6() {\n  throw new TypeError(`Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);\n}\nfunction F0(e, t) {\n  if (e) {\n    if (typeof e == \"string\")\n      return dl(e, t);\n    var n = Object.prototype.toString.call(e).slice(8, -1);\n    if (n === \"Object\" && e.constructor && (n = e.constructor.name), n === \"Map\" || n === \"Set\")\n      return Array.from(e);\n    if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))\n      return dl(e, t);\n  }\n}\nfunction dl(e, t) {\n  (t == null || t > e.length) && (t = e.length);\n  for (var n = 0, r = new Array(t); n < t; n++)\n    r[n] = e[n];\n  return r;\n}\nfunction y6(e, t) {\n  if (!(typeof Symbol > \"u\" || !(Symbol.iterator in Object(e)))) {\n    var n = [], r = !0, i = !1, o = void 0;\n    try {\n      for (var a = e[Symbol.iterator](), s; !(r = (s = a.next()).done) && (n.push(s.value), !(t && n.length === t)); r = !0)\n        ;\n    } catch (u) {\n      i = !0, o = u;\n    } finally {\n      try {\n        !r && a.return != null && a.return();\n      } finally {\n        if (i)\n          throw o;\n      }\n    }\n    return n;\n  }\n}\nfunction b6(e) {\n  if (Array.isArray(e))\n    return e;\n}\nfunction L0(e) {\n  var t = ho(e, 2), n = t[0], r = t[1], i = n, o = r;\n  return n > r && (i = r, o = n), [i, o];\n}\nfunction B0(e, t, n) {\n  if (e.lte(0))\n    return new Te(0);\n  var r = ru.getDigitCount(e.toNumber()), i = new Te(10).pow(r), o = e.div(i), a = r !== 1 ? 0.05 : 0.1, s = new Te(Math.ceil(o.div(a).toNumber())).add(n).mul(a), u = s.mul(i);\n  return t ? u : new Te(Math.ceil(u));\n}\nfunction w6(e, t, n) {\n  var r = 1, i = new Te(e);\n  if (!i.isint() && n) {\n    var o = Math.abs(e);\n    o < 1 ? (r = new Te(10).pow(ru.getDigitCount(e) - 1), i = new Te(Math.floor(i.div(r).toNumber())).mul(r)) : o > 1 && (i = new Te(Math.floor(e)));\n  } else\n    e === 0 ? i = new Te(Math.floor((t - 1) / 2)) : n || (i = new Te(Math.floor(e)));\n  var a = Math.floor((t - 1) / 2), s = u6(s6(function(u) {\n    return i.add(new Te(u - a).mul(r)).toNumber();\n  }), cl);\n  return s(0, t);\n}\nfunction z0(e, t, n, r) {\n  var i = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : 0;\n  if (!Number.isFinite((t - e) / (n - 1)))\n    return {\n      step: new Te(0),\n      tickMin: new Te(0),\n      tickMax: new Te(0)\n    };\n  var o = B0(new Te(t).sub(e).div(n - 1), r, i), a;\n  e <= 0 && t >= 0 ? a = new Te(0) : (a = new Te(e).add(t).div(2), a = a.sub(new Te(a).mod(o)));\n  var s = Math.ceil(a.sub(e).div(o).toNumber()), u = Math.ceil(new Te(t).sub(a).div(o).toNumber()), c = s + u + 1;\n  return c > n ? z0(e, t, n, r, i + 1) : (c < n && (u = t > 0 ? u + (n - c) : u, s = t > 0 ? s : s + (n - c)), {\n    step: o,\n    tickMin: a.sub(new Te(s).mul(o)),\n    tickMax: a.add(new Te(u).mul(o))\n  });\n}\nfunction x6(e) {\n  var t = ho(e, 2), n = t[0], r = t[1], i = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 6, o = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !0, a = Math.max(i, 2), s = L0([n, r]), u = ho(s, 2), c = u[0], f = u[1];\n  if (c === -1 / 0 || f === 1 / 0) {\n    var l = f === 1 / 0 ? [c].concat(fl(cl(0, i - 1).map(function() {\n      return 1 / 0;\n    }))) : [].concat(fl(cl(0, i - 1).map(function() {\n      return -1 / 0;\n    })), [f]);\n    return n > r ? ll(l) : l;\n  }\n  if (c === f)\n    return w6(c, i, o);\n  var d = z0(c, f, a, o), p = d.step, g = d.tickMin, h = d.tickMax, v = ru.rangeStep(g, h.add(new Te(0.1).mul(p)), p);\n  return n > r ? ll(v) : v;\n}\nfunction S6(e, t) {\n  var n = ho(e, 2), r = n[0], i = n[1], o = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !0, a = L0([r, i]), s = ho(a, 2), u = s[0], c = s[1];\n  if (u === -1 / 0 || c === 1 / 0)\n    return [r, i];\n  if (u === c)\n    return [u];\n  var f = Math.max(t, 2), l = B0(new Te(c).sub(u).div(f - 1), o, 0), d = [].concat(fl(ru.rangeStep(new Te(u), new Te(c).sub(new Te(0.99).mul(l)), l)), [c]);\n  return r > i ? ll(d) : d;\n}\nvar $6 = N0(x6), O6 = N0(S6), _6 = \"development\" === \"production\", Uu = \"Invariant failed\";\nfunction gt(e, t) {\n  if (_6)\n    throw new Error(Uu);\n  var n = typeof t == \"function\" ? t() : t, r = n ? \"\".concat(Uu, \": \").concat(n) : Uu;\n  throw new Error(r);\n}\nvar A6 = [\"offset\", \"layout\", \"width\", \"dataKey\", \"data\", \"dataPointFormatter\", \"xAxis\", \"yAxis\"];\nfunction ls() {\n  return ls = Object.assign ? Object.assign.bind() : function(e) {\n    for (var t = 1; t < arguments.length; t++) {\n      var n = arguments[t];\n      for (var r in n)\n        Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);\n    }\n    return e;\n  }, ls.apply(this, arguments);\n}\nfunction P6(e, t) {\n  return M6(e) || T6(e, t) || E6(e, t) || C6();\n}\nfunction C6() {\n  throw new TypeError(`Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);\n}\nfunction E6(e, t) {\n  if (e) {\n    if (typeof e == \"string\")\n      return wg(e, t);\n    var n = Object.prototype.toString.call(e).slice(8, -1);\n    if (n === \"Object\" && e.constructor && (n = e.constructor.name), n === \"Map\" || n === \"Set\")\n      return Array.from(e);\n    if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))\n      return wg(e, t);\n  }\n}\nfunction wg(e, t) {\n  (t == null || t > e.length) && (t = e.length);\n  for (var n = 0, r = new Array(t); n < t; n++)\n    r[n] = e[n];\n  return r;\n}\nfunction T6(e, t) {\n  var n = e == null ? null : typeof Symbol < \"u\" && e[Symbol.iterator] || e[\"@@iterator\"];\n  if (n != null) {\n    var r, i, o, a, s = [], u = !0, c = !1;\n    try {\n      if (o = (n = n.call(e)).next, t !== 0)\n        for (; !(u = (r = o.call(n)).done) && (s.push(r.value), s.length !== t); u = !0)\n          ;\n    } catch (f) {\n      c = !0, i = f;\n    } finally {\n      try {\n        if (!u && n.return != null && (a = n.return(), Object(a) !== a))\n          return;\n      } finally {\n        if (c)\n          throw i;\n      }\n    }\n    return s;\n  }\n}\nfunction M6(e) {\n  if (Array.isArray(e))\n    return e;\n}\nfunction R6(e, t) {\n  if (e == null)\n    return {};\n  var n = I6(e, t), r, i;\n  if (Object.getOwnPropertySymbols) {\n    var o = Object.getOwnPropertySymbols(e);\n    for (i = 0; i < o.length; i++)\n      r = o[i], !(t.indexOf(r) >= 0) && Object.prototype.propertyIsEnumerable.call(e, r) && (n[r] = e[r]);\n  }\n  return n;\n}\nfunction I6(e, t) {\n  if (e == null)\n    return {};\n  var n = {}, r = Object.keys(e), i, o;\n  for (o = 0; o < r.length; o++)\n    i = r[o], !(t.indexOf(i) >= 0) && (n[i] = e[i]);\n  return n;\n}\nfunction Zo(e) {\n  var t = e.offset, n = e.layout, r = e.width, i = e.dataKey, o = e.data, a = e.dataPointFormatter, s = e.xAxis, u = e.yAxis, c = R6(e, A6), f = ye(c, !1);\n  e.direction === \"x\" && s.type !== \"number\" && ( true ? gt(!1, 'ErrorBar requires Axis type property to be \"number\".') : 0);\n  var l = o.map(function(d) {\n    var p = a(d, i), g = p.x, h = p.y, v = p.value, w = p.errorVal;\n    if (!w)\n      return null;\n    var b = [], x, m;\n    if (Array.isArray(w)) {\n      var y = P6(w, 2);\n      x = y[0], m = y[1];\n    } else\n      x = m = w;\n    if (n === \"vertical\") {\n      var S = s.scale, $ = h + t, O = $ + r, T = $ - r, M = S(v - x), E = S(v + m);\n      b.push({\n        x1: E,\n        y1: O,\n        x2: E,\n        y2: T\n      }), b.push({\n        x1: M,\n        y1: $,\n        x2: E,\n        y2: $\n      }), b.push({\n        x1: M,\n        y1: O,\n        x2: M,\n        y2: T\n      });\n    } else if (n === \"horizontal\") {\n      var A = u.scale, j = g + t, R = j - r, N = j + r, k = A(v - x), F = A(v + m);\n      b.push({\n        x1: R,\n        y1: F,\n        x2: N,\n        y2: F\n      }), b.push({\n        x1: j,\n        y1: k,\n        x2: j,\n        y2: F\n      }), b.push({\n        x1: R,\n        y1: k,\n        x2: N,\n        y2: k\n      });\n    }\n    return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(We, ls({\n      className: \"recharts-errorBar\",\n      key: \"bar-\".concat(b.map(function(V) {\n        return \"\".concat(V.x1, \"-\").concat(V.x2, \"-\").concat(V.y1, \"-\").concat(V.y2);\n      }))\n    }, f), b.map(function(V) {\n      return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"line\", ls({}, V, {\n        key: \"line-\".concat(V.x1, \"-\").concat(V.x2, \"-\").concat(V.y1, \"-\").concat(V.y2)\n      }));\n    }));\n  });\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(We, {\n    className: \"recharts-errorBars\"\n  }, l);\n}\nZo.defaultProps = {\n  stroke: \"black\",\n  strokeWidth: 1.5,\n  width: 5,\n  offset: 0,\n  layout: \"horizontal\"\n};\nZo.displayName = \"ErrorBar\";\nfunction go(e) {\n  \"@babel/helpers - typeof\";\n  return go = typeof Symbol == \"function\" && typeof Symbol.iterator == \"symbol\" ? function(t) {\n    return typeof t;\n  } : function(t) {\n    return t && typeof Symbol == \"function\" && t.constructor === Symbol && t !== Symbol.prototype ? \"symbol\" : typeof t;\n  }, go(e);\n}\nfunction xg(e, t) {\n  var n = Object.keys(e);\n  if (Object.getOwnPropertySymbols) {\n    var r = Object.getOwnPropertySymbols(e);\n    t && (r = r.filter(function(i) {\n      return Object.getOwnPropertyDescriptor(e, i).enumerable;\n    })), n.push.apply(n, r);\n  }\n  return n;\n}\nfunction Hu(e) {\n  for (var t = 1; t < arguments.length; t++) {\n    var n = arguments[t] != null ? arguments[t] : {};\n    t % 2 ? xg(Object(n), !0).forEach(function(r) {\n      j6(e, r, n[r]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : xg(Object(n)).forEach(function(r) {\n      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));\n    });\n  }\n  return e;\n}\nfunction j6(e, t, n) {\n  return t = k6(t), t in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;\n}\nfunction k6(e) {\n  var t = D6(e, \"string\");\n  return go(t) == \"symbol\" ? t : String(t);\n}\nfunction D6(e, t) {\n  if (go(e) != \"object\" || !e)\n    return e;\n  var n = e[Symbol.toPrimitive];\n  if (n !== void 0) {\n    var r = n.call(e, t || \"default\");\n    if (go(r) != \"object\")\n      return r;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (t === \"string\" ? String : Number)(e);\n}\nvar V0 = function(t) {\n  var n = t.children, r = t.formattedGraphicalItems, i = t.legendWidth, o = t.legendContent, a = wt(n, Vr);\n  if (!a)\n    return null;\n  var s;\n  return a.props && a.props.payload ? s = a.props && a.props.payload : o === \"children\" ? s = (r || []).reduce(function(u, c) {\n    var f = c.item, l = c.props, d = l.sectors || l.data || [];\n    return u.concat(d.map(function(p) {\n      return {\n        type: a.props.iconType || f.props.legendType,\n        value: p.name,\n        color: p.fill,\n        payload: p\n      };\n    }));\n  }, []) : s = (r || []).map(function(u) {\n    var c = u.item, f = c.props, l = f.dataKey, d = f.name, p = f.legendType, g = f.hide;\n    return {\n      inactive: g,\n      dataKey: l,\n      type: a.props.iconType || p || \"square\",\n      color: ld(c),\n      value: d || l,\n      // @ts-expect-error property strokeDasharray is required in Payload but optional in props\n      payload: c.props\n    };\n  }), Hu(Hu(Hu({}, a.props), Vr.getWithHeight(a, i)), {}, {\n    payload: s,\n    item: a\n  });\n};\nfunction vo(e) {\n  \"@babel/helpers - typeof\";\n  return vo = typeof Symbol == \"function\" && typeof Symbol.iterator == \"symbol\" ? function(t) {\n    return typeof t;\n  } : function(t) {\n    return t && typeof Symbol == \"function\" && t.constructor === Symbol && t !== Symbol.prototype ? \"symbol\" : typeof t;\n  }, vo(e);\n}\nfunction Sg(e, t) {\n  var n = Object.keys(e);\n  if (Object.getOwnPropertySymbols) {\n    var r = Object.getOwnPropertySymbols(e);\n    t && (r = r.filter(function(i) {\n      return Object.getOwnPropertyDescriptor(e, i).enumerable;\n    })), n.push.apply(n, r);\n  }\n  return n;\n}\nfunction Rt(e) {\n  for (var t = 1; t < arguments.length; t++) {\n    var n = arguments[t] != null ? arguments[t] : {};\n    t % 2 ? Sg(Object(n), !0).forEach(function(r) {\n      jr(e, r, n[r]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Sg(Object(n)).forEach(function(r) {\n      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));\n    });\n  }\n  return e;\n}\nfunction jr(e, t, n) {\n  return t = N6(t), t in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;\n}\nfunction N6(e) {\n  var t = F6(e, \"string\");\n  return vo(t) == \"symbol\" ? t : String(t);\n}\nfunction F6(e, t) {\n  if (vo(e) != \"object\" || !e)\n    return e;\n  var n = e[Symbol.toPrimitive];\n  if (n !== void 0) {\n    var r = n.call(e, t || \"default\");\n    if (vo(r) != \"object\")\n      return r;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (t === \"string\" ? String : Number)(e);\n}\nfunction $g(e) {\n  return V6(e) || z6(e) || B6(e) || L6();\n}\nfunction L6() {\n  throw new TypeError(`Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);\n}\nfunction B6(e, t) {\n  if (e) {\n    if (typeof e == \"string\")\n      return pl(e, t);\n    var n = Object.prototype.toString.call(e).slice(8, -1);\n    if (n === \"Object\" && e.constructor && (n = e.constructor.name), n === \"Map\" || n === \"Set\")\n      return Array.from(e);\n    if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))\n      return pl(e, t);\n  }\n}\nfunction z6(e) {\n  if (typeof Symbol < \"u\" && e[Symbol.iterator] != null || e[\"@@iterator\"] != null)\n    return Array.from(e);\n}\nfunction V6(e) {\n  if (Array.isArray(e))\n    return pl(e);\n}\nfunction pl(e, t) {\n  (t == null || t > e.length) && (t = e.length);\n  for (var n = 0, r = new Array(t); n < t; n++)\n    r[n] = e[n];\n  return r;\n}\nfunction At(e, t, n) {\n  return me(e) || me(t) ? n : Ke(t) ? jt(e, t, n) : pe(t) ? t(e) : n;\n}\nfunction Ui(e, t, n, r) {\n  var i = qB(e, function(s) {\n    return At(s, t);\n  });\n  if (n === \"number\") {\n    var o = i.filter(function(s) {\n      return K(s) || parseFloat(s);\n    });\n    return o.length ? [eu(o), Qs(o)] : [1 / 0, -1 / 0];\n  }\n  var a = r ? i.filter(function(s) {\n    return !me(s);\n  }) : i;\n  return a.map(function(s) {\n    return Ke(s) || s instanceof Date ? s : \"\";\n  });\n}\nvar G6 = function(t) {\n  var n, r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [], i = arguments.length > 2 ? arguments[2] : void 0, o = arguments.length > 3 ? arguments[3] : void 0, a = -1, s = (n = r == null ? void 0 : r.length) !== null && n !== void 0 ? n : 0;\n  if (s <= 1)\n    return 0;\n  if (o && o.axisType === \"angleAxis\" && Math.abs(Math.abs(o.range[1] - o.range[0]) - 360) <= 1e-6)\n    for (var u = o.range, c = 0; c < s; c++) {\n      var f = c > 0 ? i[c - 1].coordinate : i[s - 1].coordinate, l = i[c].coordinate, d = c >= s - 1 ? i[0].coordinate : i[c + 1].coordinate, p = void 0;\n      if (Kt(l - f) !== Kt(d - l)) {\n        var g = [];\n        if (Kt(d - l) === Kt(u[1] - u[0])) {\n          p = d;\n          var h = l + u[1] - u[0];\n          g[0] = Math.min(h, (h + f) / 2), g[1] = Math.max(h, (h + f) / 2);\n        } else {\n          p = f;\n          var v = d + u[1] - u[0];\n          g[0] = Math.min(l, (v + l) / 2), g[1] = Math.max(l, (v + l) / 2);\n        }\n        var w = [Math.min(l, (p + l) / 2), Math.max(l, (p + l) / 2)];\n        if (t > w[0] && t <= w[1] || t >= g[0] && t <= g[1]) {\n          a = i[c].index;\n          break;\n        }\n      } else {\n        var b = Math.min(f, d), x = Math.max(f, d);\n        if (t > (b + l) / 2 && t <= (x + l) / 2) {\n          a = i[c].index;\n          break;\n        }\n      }\n    }\n  else\n    for (var m = 0; m < s; m++)\n      if (m === 0 && t <= (r[m].coordinate + r[m + 1].coordinate) / 2 || m > 0 && m < s - 1 && t > (r[m].coordinate + r[m - 1].coordinate) / 2 && t <= (r[m].coordinate + r[m + 1].coordinate) / 2 || m === s - 1 && t > (r[m].coordinate + r[m - 1].coordinate) / 2) {\n        a = r[m].index;\n        break;\n      }\n  return a;\n}, ld = function(t) {\n  var n = t, r = n.type.displayName, i = t.props, o = i.stroke, a = i.fill, s;\n  switch (r) {\n    case \"Line\":\n      s = o;\n      break;\n    case \"Area\":\n    case \"Radar\":\n      s = o && o !== \"none\" ? o : a;\n      break;\n    default:\n      s = a;\n      break;\n  }\n  return s;\n}, W6 = function(t) {\n  var n = t.barSize, r = t.totalSize, i = t.stackGroups, o = i === void 0 ? {} : i;\n  if (!o)\n    return {};\n  for (var a = {}, s = Object.keys(o), u = 0, c = s.length; u < c; u++)\n    for (var f = o[s[u]].stackGroups, l = Object.keys(f), d = 0, p = l.length; d < p; d++) {\n      var g = f[l[d]], h = g.items, v = g.cateAxisId, w = h.filter(function(y) {\n        return Fn(y.type).indexOf(\"Bar\") >= 0;\n      });\n      if (w && w.length) {\n        var b = w[0].props.barSize, x = w[0].props[v];\n        a[x] || (a[x] = []);\n        var m = me(b) ? n : b;\n        a[x].push({\n          item: w[0],\n          stackList: w.slice(1),\n          barSize: me(m) ? void 0 : lr(m, r, 0)\n        });\n      }\n    }\n  return a;\n}, U6 = function(t) {\n  var n = t.barGap, r = t.barCategoryGap, i = t.bandSize, o = t.sizeList, a = o === void 0 ? [] : o, s = t.maxBarSize, u = a.length;\n  if (u < 1)\n    return null;\n  var c = lr(n, i, 0, !0), f, l = [];\n  if (a[0].barSize === +a[0].barSize) {\n    var d = !1, p = i / u, g = a.reduce(function(m, y) {\n      return m + y.barSize || 0;\n    }, 0);\n    g += (u - 1) * c, g >= i && (g -= (u - 1) * c, c = 0), g >= i && p > 0 && (d = !0, p *= 0.9, g = u * p);\n    var h = (i - g) / 2 >> 0, v = {\n      offset: h - c,\n      size: 0\n    };\n    f = a.reduce(function(m, y) {\n      var S = {\n        item: y.item,\n        position: {\n          offset: v.offset + v.size + c,\n          // @ts-expect-error the type check above does not check for type number explicitly\n          size: d ? p : y.barSize\n        }\n      }, $ = [].concat($g(m), [S]);\n      return v = $[$.length - 1].position, y.stackList && y.stackList.length && y.stackList.forEach(function(O) {\n        $.push({\n          item: O,\n          position: v\n        });\n      }), $;\n    }, l);\n  } else {\n    var w = lr(r, i, 0, !0);\n    i - 2 * w - (u - 1) * c <= 0 && (c = 0);\n    var b = (i - 2 * w - (u - 1) * c) / u;\n    b > 1 && (b >>= 0);\n    var x = s === +s ? Math.min(b, s) : b;\n    f = a.reduce(function(m, y, S) {\n      var $ = [].concat($g(m), [{\n        item: y.item,\n        position: {\n          offset: w + (b + c) * S + (b - x) / 2,\n          size: x\n        }\n      }]);\n      return y.stackList && y.stackList.length && y.stackList.forEach(function(O) {\n        $.push({\n          item: O,\n          position: $[$.length - 1].position\n        });\n      }), $;\n    }, l);\n  }\n  return f;\n}, H6 = function(t, n, r, i) {\n  var o = r.children, a = r.width, s = r.margin, u = a - (s.left || 0) - (s.right || 0), c = V0({\n    children: o,\n    legendWidth: u\n  });\n  if (c) {\n    var f = i || {}, l = f.width, d = f.height, p = c.align, g = c.verticalAlign, h = c.layout;\n    if ((h === \"vertical\" || h === \"horizontal\" && g === \"middle\") && p !== \"center\" && K(t[p]))\n      return Rt(Rt({}, t), {}, jr({}, p, t[p] + (l || 0)));\n    if ((h === \"horizontal\" || h === \"vertical\" && p === \"center\") && g !== \"middle\" && K(t[g]))\n      return Rt(Rt({}, t), {}, jr({}, g, t[g] + (d || 0)));\n  }\n  return t;\n}, q6 = function(t, n, r) {\n  return me(n) ? !0 : t === \"horizontal\" ? n === \"yAxis\" : t === \"vertical\" || r === \"x\" ? n === \"xAxis\" : r === \"y\" ? n === \"yAxis\" : !0;\n}, G0 = function(t, n, r, i, o) {\n  var a = n.props.children, s = kt(a, Zo).filter(function(c) {\n    return q6(i, o, c.props.direction);\n  });\n  if (s && s.length) {\n    var u = s.map(function(c) {\n      return c.props.dataKey;\n    });\n    return t.reduce(function(c, f) {\n      var l = At(f, r);\n      if (me(l))\n        return c;\n      var d = Array.isArray(l) ? [eu(l), Qs(l)] : [l, l], p = u.reduce(function(g, h) {\n        var v = At(f, h, 0), w = d[0] - Math.abs(Array.isArray(v) ? v[0] : v), b = d[1] + Math.abs(Array.isArray(v) ? v[1] : v);\n        return [Math.min(w, g[0]), Math.max(b, g[1])];\n      }, [1 / 0, -1 / 0]);\n      return [Math.min(p[0], c[0]), Math.max(p[1], c[1])];\n    }, [1 / 0, -1 / 0]);\n  }\n  return null;\n}, K6 = function(t, n, r, i, o) {\n  var a = n.map(function(s) {\n    return G0(t, s, r, o, i);\n  }).filter(function(s) {\n    return !me(s);\n  });\n  return a && a.length ? a.reduce(function(s, u) {\n    return [Math.min(s[0], u[0]), Math.max(s[1], u[1])];\n  }, [1 / 0, -1 / 0]) : null;\n}, W0 = function(t, n, r, i, o) {\n  var a = n.map(function(u) {\n    var c = u.props.dataKey;\n    return r === \"number\" && c && G0(t, u, c, i) || Ui(t, c, r, o);\n  });\n  if (r === \"number\")\n    return a.reduce(\n      // @ts-expect-error if (type === number) means that the domain is numerical type\n      // - but this link is missing in the type definition\n      function(u, c) {\n        return [Math.min(u[0], c[0]), Math.max(u[1], c[1])];\n      },\n      [1 / 0, -1 / 0]\n    );\n  var s = {};\n  return a.reduce(function(u, c) {\n    for (var f = 0, l = c.length; f < l; f++)\n      s[c[f]] || (s[c[f]] = !0, u.push(c[f]));\n    return u;\n  }, []);\n}, U0 = function(t, n) {\n  return t === \"horizontal\" && n === \"xAxis\" || t === \"vertical\" && n === \"yAxis\" || t === \"centric\" && n === \"angleAxis\" || t === \"radial\" && n === \"radiusAxis\";\n}, H0 = function(t, n, r, i) {\n  if (i)\n    return t.map(function(u) {\n      return u.coordinate;\n    });\n  var o, a, s = t.map(function(u) {\n    return u.coordinate === n && (o = !0), u.coordinate === r && (a = !0), u.coordinate;\n  });\n  return o || s.push(n), a || s.push(r), s;\n}, mn = function(t, n, r) {\n  if (!t)\n    return null;\n  var i = t.scale, o = t.duplicateDomain, a = t.type, s = t.range, u = t.realScaleType === \"scaleBand\" ? i.bandwidth() / 2 : 2, c = (n || r) && a === \"category\" && i.bandwidth ? i.bandwidth() / u : 0;\n  if (c = t.axisType === \"angleAxis\" && (s == null ? void 0 : s.length) >= 2 ? Kt(s[0] - s[1]) * 2 * c : c, n && (t.ticks || t.niceTicks)) {\n    var f = (t.ticks || t.niceTicks).map(function(l) {\n      var d = o ? o.indexOf(l) : l;\n      return {\n        // If the scaleContent is not a number, the coordinate will be NaN.\n        // That could be the case for example with a PointScale and a string as domain.\n        coordinate: i(d) + c,\n        value: l,\n        offset: c\n      };\n    });\n    return f.filter(function(l) {\n      return !Wo(l.coordinate);\n    });\n  }\n  return t.isCategorical && t.categoricalDomain ? t.categoricalDomain.map(function(l, d) {\n    return {\n      coordinate: i(l) + c,\n      value: l,\n      index: d,\n      offset: c\n    };\n  }) : i.ticks && !r ? i.ticks(t.tickCount).map(function(l) {\n    return {\n      coordinate: i(l) + c,\n      value: l,\n      offset: c\n    };\n  }) : i.domain().map(function(l, d) {\n    return {\n      coordinate: i(l) + c,\n      value: o ? o[l] : l,\n      index: d,\n      offset: c\n    };\n  });\n}, qu = /* @__PURE__ */ new WeakMap(), ma = function(t, n) {\n  if (typeof n != \"function\")\n    return t;\n  qu.has(t) || qu.set(t, /* @__PURE__ */ new WeakMap());\n  var r = qu.get(t);\n  if (r.has(n))\n    return r.get(n);\n  var i = function() {\n    t.apply(void 0, arguments), n.apply(void 0, arguments);\n  };\n  return r.set(n, i), i;\n}, Y6 = function(t, n, r) {\n  var i = t.scale, o = t.type, a = t.layout, s = t.axisType;\n  if (i === \"auto\")\n    return a === \"radial\" && s === \"radiusAxis\" ? {\n      scale: so(),\n      realScaleType: \"band\"\n    } : a === \"radial\" && s === \"angleAxis\" ? {\n      scale: os(),\n      realScaleType: \"linear\"\n    } : o === \"category\" && n && (n.indexOf(\"LineChart\") >= 0 || n.indexOf(\"AreaChart\") >= 0 || n.indexOf(\"ComposedChart\") >= 0 && !r) ? {\n      scale: Wi(),\n      realScaleType: \"point\"\n    } : o === \"category\" ? {\n      scale: so(),\n      realScaleType: \"band\"\n    } : {\n      scale: os(),\n      realScaleType: \"linear\"\n    };\n  if (Go(i)) {\n    var u = \"scale\".concat(Bs(i));\n    return {\n      scale: (vg[u] || Wi)(),\n      realScaleType: vg[u] ? u : \"point\"\n    };\n  }\n  return pe(i) ? {\n    scale: i\n  } : {\n    scale: Wi(),\n    realScaleType: \"point\"\n  };\n}, Og = 1e-4, X6 = function(t) {\n  var n = t.domain();\n  if (!(!n || n.length <= 2)) {\n    var r = n.length, i = t.range(), o = Math.min(i[0], i[1]) - Og, a = Math.max(i[0], i[1]) + Og, s = t(n[0]), u = t(n[r - 1]);\n    (s < o || s > a || u < o || u > a) && t.domain([n[0], n[r - 1]]);\n  }\n}, Z6 = function(t, n) {\n  if (!t)\n    return null;\n  for (var r = 0, i = t.length; r < i; r++)\n    if (t[r].item === n)\n      return t[r].position;\n  return null;\n}, J6 = function(t, n) {\n  if (!n || n.length !== 2 || !K(n[0]) || !K(n[1]))\n    return t;\n  var r = Math.min(n[0], n[1]), i = Math.max(n[0], n[1]), o = [t[0], t[1]];\n  return (!K(t[0]) || t[0] < r) && (o[0] = r), (!K(t[1]) || t[1] > i) && (o[1] = i), o[0] > i && (o[0] = i), o[1] < r && (o[1] = r), o;\n}, Q6 = function(t) {\n  var n = t.length;\n  if (!(n <= 0))\n    for (var r = 0, i = t[0].length; r < i; ++r)\n      for (var o = 0, a = 0, s = 0; s < n; ++s) {\n        var u = Wo(t[s][r][1]) ? t[s][r][0] : t[s][r][1];\n        u >= 0 ? (t[s][r][0] = o, t[s][r][1] = o + u, o = t[s][r][1]) : (t[s][r][0] = a, t[s][r][1] = a + u, a = t[s][r][1]);\n      }\n}, e8 = function(t) {\n  var n = t.length;\n  if (!(n <= 0))\n    for (var r = 0, i = t[0].length; r < i; ++r)\n      for (var o = 0, a = 0; a < n; ++a) {\n        var s = Wo(t[a][r][1]) ? t[a][r][0] : t[a][r][1];\n        s >= 0 ? (t[a][r][0] = o, t[a][r][1] = o + s, o = t[a][r][1]) : (t[a][r][0] = 0, t[a][r][1] = 0);\n      }\n}, t8 = {\n  sign: Q6,\n  // @ts-expect-error definitelytyped types are incorrect\n  expand: IT,\n  // @ts-expect-error definitelytyped types are incorrect\n  none: Lr,\n  // @ts-expect-error definitelytyped types are incorrect\n  silhouette: jT,\n  // @ts-expect-error definitelytyped types are incorrect\n  wiggle: kT,\n  positive: e8\n}, n8 = function(t, n, r) {\n  var i = n.map(function(s) {\n    return s.props.dataKey;\n  }), o = t8[r], a = RT().keys(i).value(function(s, u) {\n    return +At(s, u, 0);\n  }).order(Fc).offset(o);\n  return a(t);\n}, r8 = function(t, n, r, i, o, a) {\n  if (!t)\n    return null;\n  var s = a ? n.reverse() : n, u = {}, c = s.reduce(function(l, d) {\n    var p = d.props, g = p.stackId, h = p.hide;\n    if (h)\n      return l;\n    var v = d.props[r], w = l[v] || {\n      hasStack: !1,\n      stackGroups: {}\n    };\n    if (Ke(g)) {\n      var b = w.stackGroups[g] || {\n        numericAxisId: r,\n        cateAxisId: i,\n        items: []\n      };\n      b.items.push(d), w.hasStack = !0, w.stackGroups[g] = b;\n    } else\n      w.stackGroups[Uo(\"_stackId_\")] = {\n        numericAxisId: r,\n        cateAxisId: i,\n        items: [d]\n      };\n    return Rt(Rt({}, l), {}, jr({}, v, w));\n  }, u), f = {};\n  return Object.keys(c).reduce(function(l, d) {\n    var p = c[d];\n    if (p.hasStack) {\n      var g = {};\n      p.stackGroups = Object.keys(p.stackGroups).reduce(function(h, v) {\n        var w = p.stackGroups[v];\n        return Rt(Rt({}, h), {}, jr({}, v, {\n          numericAxisId: r,\n          cateAxisId: i,\n          items: w.items,\n          stackedData: n8(t, w.items, o)\n        }));\n      }, g);\n    }\n    return Rt(Rt({}, l), {}, jr({}, d, p));\n  }, f);\n}, i8 = function(t, n) {\n  var r = n.realScaleType, i = n.type, o = n.tickCount, a = n.originalDomain, s = n.allowDecimals, u = r || n.scale;\n  if (u !== \"auto\" && u !== \"linear\")\n    return null;\n  if (o && i === \"number\" && a && (a[0] === \"auto\" || a[1] === \"auto\")) {\n    var c = t.domain();\n    if (!c.length)\n      return null;\n    var f = $6(c, o, s);\n    return t.domain([eu(f), Qs(f)]), {\n      niceTicks: f\n    };\n  }\n  if (o && i === \"number\") {\n    var l = t.domain(), d = O6(l, o, s);\n    return {\n      niceTicks: d\n    };\n  }\n  return null;\n};\nfunction _g(e) {\n  var t = e.axis, n = e.ticks, r = e.bandSize, i = e.entry, o = e.index, a = e.dataKey;\n  if (t.type === \"category\") {\n    if (!t.allowDuplicatedCategory && t.dataKey && !me(i[t.dataKey])) {\n      var s = Da(n, \"value\", i[t.dataKey]);\n      if (s)\n        return s.coordinate + r / 2;\n    }\n    return n[o] ? n[o].coordinate + r / 2 : null;\n  }\n  var u = At(i, me(a) ? t.dataKey : a);\n  return me(u) ? null : t.scale(u);\n}\nvar Ag = function(t) {\n  var n = t.axis, r = t.ticks, i = t.offset, o = t.bandSize, a = t.entry, s = t.index;\n  if (n.type === \"category\")\n    return r[s] ? r[s].coordinate + i : null;\n  var u = At(a, n.dataKey, n.domain[s]);\n  return me(u) ? null : n.scale(u) - o / 2 + i;\n}, o8 = function(t) {\n  var n = t.numericAxis, r = n.scale.domain();\n  if (n.type === \"number\") {\n    var i = Math.min(r[0], r[1]), o = Math.max(r[0], r[1]);\n    return i <= 0 && o >= 0 ? 0 : o < 0 ? o : i;\n  }\n  return r[0];\n}, a8 = function(t, n) {\n  var r = t.props.stackId;\n  if (Ke(r)) {\n    var i = n[r];\n    if (i) {\n      var o = i.items.indexOf(t);\n      return o >= 0 ? i.stackedData[o] : null;\n    }\n  }\n  return null;\n}, s8 = function(t) {\n  return t.reduce(function(n, r) {\n    return [eu(r.concat([n[0]]).filter(K)), Qs(r.concat([n[1]]).filter(K))];\n  }, [1 / 0, -1 / 0]);\n}, q0 = function(t, n, r) {\n  return Object.keys(t).reduce(function(i, o) {\n    var a = t[o], s = a.stackedData, u = s.reduce(function(c, f) {\n      var l = s8(f.slice(n, r + 1));\n      return [Math.min(c[0], l[0]), Math.max(c[1], l[1])];\n    }, [1 / 0, -1 / 0]);\n    return [Math.min(u[0], i[0]), Math.max(u[1], i[1])];\n  }, [1 / 0, -1 / 0]).map(function(i) {\n    return i === 1 / 0 || i === -1 / 0 ? 0 : i;\n  });\n}, Pg = /^dataMin[\\s]*-[\\s]*([0-9]+([.]{1}[0-9]+){0,1})$/, Cg = /^dataMax[\\s]*\\+[\\s]*([0-9]+([.]{1}[0-9]+){0,1})$/, hl = function(t, n, r) {\n  if (pe(t))\n    return t(n, r);\n  if (!Array.isArray(t))\n    return n;\n  var i = [];\n  if (K(t[0]))\n    i[0] = r ? t[0] : Math.min(t[0], n[0]);\n  else if (Pg.test(t[0])) {\n    var o = +Pg.exec(t[0])[1];\n    i[0] = n[0] - o;\n  } else\n    pe(t[0]) ? i[0] = t[0](n[0]) : i[0] = n[0];\n  if (K(t[1]))\n    i[1] = r ? t[1] : Math.max(t[1], n[1]);\n  else if (Cg.test(t[1])) {\n    var a = +Cg.exec(t[1])[1];\n    i[1] = n[1] + a;\n  } else\n    pe(t[1]) ? i[1] = t[1](n[1]) : i[1] = n[1];\n  return i;\n}, fs = function(t, n, r) {\n  if (t && t.scale && t.scale.bandwidth) {\n    var i = t.scale.bandwidth();\n    if (!r || i > 0)\n      return i;\n  }\n  if (t && n && n.length >= 2) {\n    for (var o = Ff(n, function(l) {\n      return l.coordinate;\n    }), a = 1 / 0, s = 1, u = o.length; s < u; s++) {\n      var c = o[s], f = o[s - 1];\n      a = Math.min((c.coordinate || 0) - (f.coordinate || 0), a);\n    }\n    return a === 1 / 0 ? 0 : a;\n  }\n  return r ? void 0 : 0;\n}, Eg = function(t, n, r) {\n  return !t || !t.length || tu(t, jt(r, \"type.defaultProps.domain\")) ? n : t;\n}, K0 = function(t, n) {\n  var r = t.props, i = r.dataKey, o = r.name, a = r.unit, s = r.formatter, u = r.tooltipType, c = r.chartType, f = r.hide;\n  return Rt(Rt({}, ye(t, !1)), {}, {\n    dataKey: i,\n    unit: a,\n    formatter: s,\n    name: o || i,\n    color: ld(t),\n    value: At(n, i),\n    type: u,\n    payload: n,\n    chartType: c,\n    hide: f\n  });\n};\nfunction mo(e) {\n  \"@babel/helpers - typeof\";\n  return mo = typeof Symbol == \"function\" && typeof Symbol.iterator == \"symbol\" ? function(t) {\n    return typeof t;\n  } : function(t) {\n    return t && typeof Symbol == \"function\" && t.constructor === Symbol && t !== Symbol.prototype ? \"symbol\" : typeof t;\n  }, mo(e);\n}\nfunction Tg(e, t) {\n  var n = Object.keys(e);\n  if (Object.getOwnPropertySymbols) {\n    var r = Object.getOwnPropertySymbols(e);\n    t && (r = r.filter(function(i) {\n      return Object.getOwnPropertyDescriptor(e, i).enumerable;\n    })), n.push.apply(n, r);\n  }\n  return n;\n}\nfunction Mg(e) {\n  for (var t = 1; t < arguments.length; t++) {\n    var n = arguments[t] != null ? arguments[t] : {};\n    t % 2 ? Tg(Object(n), !0).forEach(function(r) {\n      u8(e, r, n[r]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Tg(Object(n)).forEach(function(r) {\n      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));\n    });\n  }\n  return e;\n}\nfunction u8(e, t, n) {\n  return t = c8(t), t in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;\n}\nfunction c8(e) {\n  var t = l8(e, \"string\");\n  return mo(t) == \"symbol\" ? t : String(t);\n}\nfunction l8(e, t) {\n  if (mo(e) != \"object\" || !e)\n    return e;\n  var n = e[Symbol.toPrimitive];\n  if (n !== void 0) {\n    var r = n.call(e, t || \"default\");\n    if (mo(r) != \"object\")\n      return r;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (t === \"string\" ? String : Number)(e);\n}\nvar ds = Math.PI / 180, f8 = function(t) {\n  return t * 180 / Math.PI;\n}, nt = function(t, n, r, i) {\n  return {\n    x: t + Math.cos(-ds * i) * r,\n    y: n + Math.sin(-ds * i) * r\n  };\n}, d8 = function(t, n) {\n  var r = t.x, i = t.y, o = n.x, a = n.y;\n  return Math.sqrt(Math.pow(r - o, 2) + Math.pow(i - a, 2));\n}, p8 = function(t, n) {\n  var r = t.x, i = t.y, o = n.cx, a = n.cy, s = d8({\n    x: r,\n    y: i\n  }, {\n    x: o,\n    y: a\n  });\n  if (s <= 0)\n    return {\n      radius: s\n    };\n  var u = (r - o) / s, c = Math.acos(u);\n  return i > a && (c = 2 * Math.PI - c), {\n    radius: s,\n    angle: f8(c),\n    angleInRadian: c\n  };\n}, h8 = function(t) {\n  var n = t.startAngle, r = t.endAngle, i = Math.floor(n / 360), o = Math.floor(r / 360), a = Math.min(i, o);\n  return {\n    startAngle: n - a * 360,\n    endAngle: r - a * 360\n  };\n}, g8 = function(t, n) {\n  var r = n.startAngle, i = n.endAngle, o = Math.floor(r / 360), a = Math.floor(i / 360), s = Math.min(o, a);\n  return t + s * 360;\n}, Rg = function(t, n) {\n  var r = t.x, i = t.y, o = p8({\n    x: r,\n    y: i\n  }, n), a = o.radius, s = o.angle, u = n.innerRadius, c = n.outerRadius;\n  if (a < u || a > c)\n    return !1;\n  if (a === 0)\n    return !0;\n  var f = h8(n), l = f.startAngle, d = f.endAngle, p = s, g;\n  if (l <= d) {\n    for (; p > d; )\n      p -= 360;\n    for (; p < l; )\n      p += 360;\n    g = p >= l && p <= d;\n  } else {\n    for (; p > l; )\n      p -= 360;\n    for (; p < d; )\n      p += 360;\n    g = p >= d && p <= l;\n  }\n  return g ? Mg(Mg({}, n), {}, {\n    radius: a,\n    angle: g8(p, n)\n  }) : null;\n};\nfunction yo(e) {\n  \"@babel/helpers - typeof\";\n  return yo = typeof Symbol == \"function\" && typeof Symbol.iterator == \"symbol\" ? function(t) {\n    return typeof t;\n  } : function(t) {\n    return t && typeof Symbol == \"function\" && t.constructor === Symbol && t !== Symbol.prototype ? \"symbol\" : typeof t;\n  }, yo(e);\n}\nvar v8 = [\"offset\"];\nfunction m8(e) {\n  return x8(e) || w8(e) || b8(e) || y8();\n}\nfunction y8() {\n  throw new TypeError(`Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);\n}\nfunction b8(e, t) {\n  if (e) {\n    if (typeof e == \"string\")\n      return gl(e, t);\n    var n = Object.prototype.toString.call(e).slice(8, -1);\n    if (n === \"Object\" && e.constructor && (n = e.constructor.name), n === \"Map\" || n === \"Set\")\n      return Array.from(e);\n    if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))\n      return gl(e, t);\n  }\n}\nfunction w8(e) {\n  if (typeof Symbol < \"u\" && e[Symbol.iterator] != null || e[\"@@iterator\"] != null)\n    return Array.from(e);\n}\nfunction x8(e) {\n  if (Array.isArray(e))\n    return gl(e);\n}\nfunction gl(e, t) {\n  (t == null || t > e.length) && (t = e.length);\n  for (var n = 0, r = new Array(t); n < t; n++)\n    r[n] = e[n];\n  return r;\n}\nfunction S8(e, t) {\n  if (e == null)\n    return {};\n  var n = $8(e, t), r, i;\n  if (Object.getOwnPropertySymbols) {\n    var o = Object.getOwnPropertySymbols(e);\n    for (i = 0; i < o.length; i++)\n      r = o[i], !(t.indexOf(r) >= 0) && Object.prototype.propertyIsEnumerable.call(e, r) && (n[r] = e[r]);\n  }\n  return n;\n}\nfunction $8(e, t) {\n  if (e == null)\n    return {};\n  var n = {}, r = Object.keys(e), i, o;\n  for (o = 0; o < r.length; o++)\n    i = r[o], !(t.indexOf(i) >= 0) && (n[i] = e[i]);\n  return n;\n}\nfunction Ig(e, t) {\n  var n = Object.keys(e);\n  if (Object.getOwnPropertySymbols) {\n    var r = Object.getOwnPropertySymbols(e);\n    t && (r = r.filter(function(i) {\n      return Object.getOwnPropertyDescriptor(e, i).enumerable;\n    })), n.push.apply(n, r);\n  }\n  return n;\n}\nfunction qe(e) {\n  for (var t = 1; t < arguments.length; t++) {\n    var n = arguments[t] != null ? arguments[t] : {};\n    t % 2 ? Ig(Object(n), !0).forEach(function(r) {\n      O8(e, r, n[r]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Ig(Object(n)).forEach(function(r) {\n      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));\n    });\n  }\n  return e;\n}\nfunction O8(e, t, n) {\n  return t = _8(t), t in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;\n}\nfunction _8(e) {\n  var t = A8(e, \"string\");\n  return yo(t) == \"symbol\" ? t : String(t);\n}\nfunction A8(e, t) {\n  if (yo(e) != \"object\" || !e)\n    return e;\n  var n = e[Symbol.toPrimitive];\n  if (n !== void 0) {\n    var r = n.call(e, t || \"default\");\n    if (yo(r) != \"object\")\n      return r;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (t === \"string\" ? String : Number)(e);\n}\nfunction bo() {\n  return bo = Object.assign ? Object.assign.bind() : function(e) {\n    for (var t = 1; t < arguments.length; t++) {\n      var n = arguments[t];\n      for (var r in n)\n        Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);\n    }\n    return e;\n  }, bo.apply(this, arguments);\n}\nvar P8 = function(t) {\n  var n = t.value, r = t.formatter, i = me(t.children) ? n : t.children;\n  return pe(r) ? r(i) : i;\n}, C8 = function(t, n) {\n  var r = Kt(n - t), i = Math.min(Math.abs(n - t), 360);\n  return r * i;\n}, E8 = function(t, n, r) {\n  var i = t.position, o = t.viewBox, a = t.offset, s = t.className, u = o, c = u.cx, f = u.cy, l = u.innerRadius, d = u.outerRadius, p = u.startAngle, g = u.endAngle, h = u.clockWise, v = (l + d) / 2, w = C8(p, g), b = w >= 0 ? 1 : -1, x, m;\n  i === \"insideStart\" ? (x = p + b * a, m = h) : i === \"insideEnd\" ? (x = g - b * a, m = !h) : i === \"end\" && (x = g + b * a, m = h), m = w <= 0 ? m : !m;\n  var y = nt(c, f, v, x), S = nt(c, f, v, x + (m ? 1 : -1) * 359), $ = \"M\".concat(y.x, \",\").concat(y.y, `\n    A`).concat(v, \",\").concat(v, \",0,1,\").concat(m ? 0 : 1, `,\n    `).concat(S.x, \",\").concat(S.y), O = me(t.id) ? Uo(\"recharts-radial-line-\") : t.id;\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"text\", bo({}, r, {\n    dominantBaseline: \"central\",\n    className: $e(\"recharts-radial-bar-label\", s)\n  }), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"defs\", null, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"path\", {\n    id: O,\n    d: $\n  })), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"textPath\", {\n    xlinkHref: \"#\".concat(O)\n  }, n));\n}, T8 = function(t) {\n  var n = t.viewBox, r = t.offset, i = t.position, o = n, a = o.cx, s = o.cy, u = o.innerRadius, c = o.outerRadius, f = o.startAngle, l = o.endAngle, d = (f + l) / 2;\n  if (i === \"outside\") {\n    var p = nt(a, s, c + r, d), g = p.x, h = p.y;\n    return {\n      x: g,\n      y: h,\n      textAnchor: g >= a ? \"start\" : \"end\",\n      verticalAnchor: \"middle\"\n    };\n  }\n  if (i === \"center\")\n    return {\n      x: a,\n      y: s,\n      textAnchor: \"middle\",\n      verticalAnchor: \"middle\"\n    };\n  if (i === \"centerTop\")\n    return {\n      x: a,\n      y: s,\n      textAnchor: \"middle\",\n      verticalAnchor: \"start\"\n    };\n  if (i === \"centerBottom\")\n    return {\n      x: a,\n      y: s,\n      textAnchor: \"middle\",\n      verticalAnchor: \"end\"\n    };\n  var v = (u + c) / 2, w = nt(a, s, v, d), b = w.x, x = w.y;\n  return {\n    x: b,\n    y: x,\n    textAnchor: \"middle\",\n    verticalAnchor: \"middle\"\n  };\n}, M8 = function(t) {\n  var n = t.viewBox, r = t.parentViewBox, i = t.offset, o = t.position, a = n, s = a.x, u = a.y, c = a.width, f = a.height, l = f >= 0 ? 1 : -1, d = l * i, p = l > 0 ? \"end\" : \"start\", g = l > 0 ? \"start\" : \"end\", h = c >= 0 ? 1 : -1, v = h * i, w = h > 0 ? \"end\" : \"start\", b = h > 0 ? \"start\" : \"end\";\n  if (o === \"top\") {\n    var x = {\n      x: s + c / 2,\n      y: u - l * i,\n      textAnchor: \"middle\",\n      verticalAnchor: p\n    };\n    return qe(qe({}, x), r ? {\n      height: Math.max(u - r.y, 0),\n      width: c\n    } : {});\n  }\n  if (o === \"bottom\") {\n    var m = {\n      x: s + c / 2,\n      y: u + f + d,\n      textAnchor: \"middle\",\n      verticalAnchor: g\n    };\n    return qe(qe({}, m), r ? {\n      height: Math.max(r.y + r.height - (u + f), 0),\n      width: c\n    } : {});\n  }\n  if (o === \"left\") {\n    var y = {\n      x: s - v,\n      y: u + f / 2,\n      textAnchor: w,\n      verticalAnchor: \"middle\"\n    };\n    return qe(qe({}, y), r ? {\n      width: Math.max(y.x - r.x, 0),\n      height: f\n    } : {});\n  }\n  if (o === \"right\") {\n    var S = {\n      x: s + c + v,\n      y: u + f / 2,\n      textAnchor: b,\n      verticalAnchor: \"middle\"\n    };\n    return qe(qe({}, S), r ? {\n      width: Math.max(r.x + r.width - S.x, 0),\n      height: f\n    } : {});\n  }\n  var $ = r ? {\n    width: c,\n    height: f\n  } : {};\n  return o === \"insideLeft\" ? qe({\n    x: s + v,\n    y: u + f / 2,\n    textAnchor: b,\n    verticalAnchor: \"middle\"\n  }, $) : o === \"insideRight\" ? qe({\n    x: s + c - v,\n    y: u + f / 2,\n    textAnchor: w,\n    verticalAnchor: \"middle\"\n  }, $) : o === \"insideTop\" ? qe({\n    x: s + c / 2,\n    y: u + d,\n    textAnchor: \"middle\",\n    verticalAnchor: g\n  }, $) : o === \"insideBottom\" ? qe({\n    x: s + c / 2,\n    y: u + f - d,\n    textAnchor: \"middle\",\n    verticalAnchor: p\n  }, $) : o === \"insideTopLeft\" ? qe({\n    x: s + v,\n    y: u + d,\n    textAnchor: b,\n    verticalAnchor: g\n  }, $) : o === \"insideTopRight\" ? qe({\n    x: s + c - v,\n    y: u + d,\n    textAnchor: w,\n    verticalAnchor: g\n  }, $) : o === \"insideBottomLeft\" ? qe({\n    x: s + v,\n    y: u + f - d,\n    textAnchor: b,\n    verticalAnchor: p\n  }, $) : o === \"insideBottomRight\" ? qe({\n    x: s + c - v,\n    y: u + f - d,\n    textAnchor: w,\n    verticalAnchor: p\n  }, $) : ci(o) && (K(o.x) || Ac(o.x)) && (K(o.y) || Ac(o.y)) ? qe({\n    x: s + lr(o.x, c),\n    y: u + lr(o.y, f),\n    textAnchor: \"end\",\n    verticalAnchor: \"end\"\n  }, $) : qe({\n    x: s + c / 2,\n    y: u + f / 2,\n    textAnchor: \"middle\",\n    verticalAnchor: \"middle\"\n  }, $);\n}, R8 = function(t) {\n  return \"cx\" in t && K(t.cx);\n};\nfunction at(e) {\n  var t = e.offset, n = t === void 0 ? 5 : t, r = S8(e, v8), i = qe({\n    offset: n\n  }, r), o = i.viewBox, a = i.position, s = i.value, u = i.children, c = i.content, f = i.className, l = f === void 0 ? \"\" : f, d = i.textBreakAll;\n  if (!o || me(s) && me(u) && !/* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.isValidElement)(c) && !pe(c))\n    return null;\n  if (/* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.isValidElement)(c))\n    return /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.cloneElement)(c, i);\n  var p;\n  if (pe(c)) {\n    if (p = /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(c, i), /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.isValidElement)(p))\n      return p;\n  } else\n    p = P8(i);\n  var g = R8(o), h = ye(i, !0);\n  if (g && (a === \"insideStart\" || a === \"insideEnd\" || a === \"end\"))\n    return E8(i, p, h);\n  var v = g ? T8(i) : M8(i);\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(Ja, bo({\n    className: $e(\"recharts-label\", l)\n  }, h, v, {\n    breakAll: d\n  }), p);\n}\nat.displayName = \"Label\";\nvar Y0 = function(t) {\n  var n = t.cx, r = t.cy, i = t.angle, o = t.startAngle, a = t.endAngle, s = t.r, u = t.radius, c = t.innerRadius, f = t.outerRadius, l = t.x, d = t.y, p = t.top, g = t.left, h = t.width, v = t.height, w = t.clockWise, b = t.labelViewBox;\n  if (b)\n    return b;\n  if (K(h) && K(v)) {\n    if (K(l) && K(d))\n      return {\n        x: l,\n        y: d,\n        width: h,\n        height: v\n      };\n    if (K(p) && K(g))\n      return {\n        x: p,\n        y: g,\n        width: h,\n        height: v\n      };\n  }\n  return K(l) && K(d) ? {\n    x: l,\n    y: d,\n    width: 0,\n    height: 0\n  } : K(n) && K(r) ? {\n    cx: n,\n    cy: r,\n    startAngle: o || i || 0,\n    endAngle: a || i || 0,\n    innerRadius: c || 0,\n    outerRadius: f || u || s || 0,\n    clockWise: w\n  } : t.viewBox ? t.viewBox : {};\n}, I8 = function(t, n) {\n  return t ? t === !0 ? /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(at, {\n    key: \"label-implicit\",\n    viewBox: n\n  }) : Ke(t) ? /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(at, {\n    key: \"label-implicit\",\n    viewBox: n,\n    value: t\n  }) : /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.isValidElement)(t) ? t.type === at ? /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.cloneElement)(t, {\n    key: \"label-implicit\",\n    viewBox: n\n  }) : /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(at, {\n    key: \"label-implicit\",\n    content: t,\n    viewBox: n\n  }) : pe(t) ? /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(at, {\n    key: \"label-implicit\",\n    content: t,\n    viewBox: n\n  }) : ci(t) ? /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(at, bo({\n    viewBox: n\n  }, t, {\n    key: \"label-implicit\"\n  })) : null : null;\n}, j8 = function(t, n) {\n  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !0;\n  if (!t || !t.children && r && !t.label)\n    return null;\n  var i = t.children, o = Y0(t), a = kt(i, at).map(function(u, c) {\n    return /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.cloneElement)(u, {\n      viewBox: n || o,\n      // eslint-disable-next-line react/no-array-index-key\n      key: \"label-\".concat(c)\n    });\n  });\n  if (!r)\n    return a;\n  var s = I8(t.label, n || o);\n  return [s].concat(m8(a));\n};\nat.parseViewBox = Y0;\nat.renderCallByParent = j8;\nfunction k8(e) {\n  var t = e == null ? 0 : e.length;\n  return t ? e[t - 1] : void 0;\n}\nvar D8 = k8;\nconst N8 = /* @__PURE__ */ je(D8);\nfunction wo(e) {\n  \"@babel/helpers - typeof\";\n  return wo = typeof Symbol == \"function\" && typeof Symbol.iterator == \"symbol\" ? function(t) {\n    return typeof t;\n  } : function(t) {\n    return t && typeof Symbol == \"function\" && t.constructor === Symbol && t !== Symbol.prototype ? \"symbol\" : typeof t;\n  }, wo(e);\n}\nvar F8 = [\"valueAccessor\"], L8 = [\"data\", \"dataKey\", \"clockWise\", \"id\", \"textBreakAll\"];\nfunction B8(e) {\n  return W8(e) || G8(e) || V8(e) || z8();\n}\nfunction z8() {\n  throw new TypeError(`Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);\n}\nfunction V8(e, t) {\n  if (e) {\n    if (typeof e == \"string\")\n      return vl(e, t);\n    var n = Object.prototype.toString.call(e).slice(8, -1);\n    if (n === \"Object\" && e.constructor && (n = e.constructor.name), n === \"Map\" || n === \"Set\")\n      return Array.from(e);\n    if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))\n      return vl(e, t);\n  }\n}\nfunction G8(e) {\n  if (typeof Symbol < \"u\" && e[Symbol.iterator] != null || e[\"@@iterator\"] != null)\n    return Array.from(e);\n}\nfunction W8(e) {\n  if (Array.isArray(e))\n    return vl(e);\n}\nfunction vl(e, t) {\n  (t == null || t > e.length) && (t = e.length);\n  for (var n = 0, r = new Array(t); n < t; n++)\n    r[n] = e[n];\n  return r;\n}\nfunction ps() {\n  return ps = Object.assign ? Object.assign.bind() : function(e) {\n    for (var t = 1; t < arguments.length; t++) {\n      var n = arguments[t];\n      for (var r in n)\n        Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);\n    }\n    return e;\n  }, ps.apply(this, arguments);\n}\nfunction jg(e, t) {\n  var n = Object.keys(e);\n  if (Object.getOwnPropertySymbols) {\n    var r = Object.getOwnPropertySymbols(e);\n    t && (r = r.filter(function(i) {\n      return Object.getOwnPropertyDescriptor(e, i).enumerable;\n    })), n.push.apply(n, r);\n  }\n  return n;\n}\nfunction kg(e) {\n  for (var t = 1; t < arguments.length; t++) {\n    var n = arguments[t] != null ? arguments[t] : {};\n    t % 2 ? jg(Object(n), !0).forEach(function(r) {\n      U8(e, r, n[r]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : jg(Object(n)).forEach(function(r) {\n      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));\n    });\n  }\n  return e;\n}\nfunction U8(e, t, n) {\n  return t = H8(t), t in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;\n}\nfunction H8(e) {\n  var t = q8(e, \"string\");\n  return wo(t) == \"symbol\" ? t : String(t);\n}\nfunction q8(e, t) {\n  if (wo(e) != \"object\" || !e)\n    return e;\n  var n = e[Symbol.toPrimitive];\n  if (n !== void 0) {\n    var r = n.call(e, t || \"default\");\n    if (wo(r) != \"object\")\n      return r;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (t === \"string\" ? String : Number)(e);\n}\nfunction Dg(e, t) {\n  if (e == null)\n    return {};\n  var n = K8(e, t), r, i;\n  if (Object.getOwnPropertySymbols) {\n    var o = Object.getOwnPropertySymbols(e);\n    for (i = 0; i < o.length; i++)\n      r = o[i], !(t.indexOf(r) >= 0) && Object.prototype.propertyIsEnumerable.call(e, r) && (n[r] = e[r]);\n  }\n  return n;\n}\nfunction K8(e, t) {\n  if (e == null)\n    return {};\n  var n = {}, r = Object.keys(e), i, o;\n  for (o = 0; o < r.length; o++)\n    i = r[o], !(t.indexOf(i) >= 0) && (n[i] = e[i]);\n  return n;\n}\nvar Y8 = function(t) {\n  return Array.isArray(t.value) ? N8(t.value) : t.value;\n};\nfunction Bn(e) {\n  var t = e.valueAccessor, n = t === void 0 ? Y8 : t, r = Dg(e, F8), i = r.data, o = r.dataKey, a = r.clockWise, s = r.id, u = r.textBreakAll, c = Dg(r, L8);\n  return !i || !i.length ? null : /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(We, {\n    className: \"recharts-label-list\"\n  }, i.map(function(f, l) {\n    var d = me(o) ? n(f, l) : At(f && f.payload, o), p = me(s) ? {} : {\n      id: \"\".concat(s, \"-\").concat(l)\n    };\n    return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(at, ps({}, ye(f, !0), c, p, {\n      parentViewBox: f.parentViewBox,\n      value: d,\n      textBreakAll: u,\n      viewBox: at.parseViewBox(me(a) ? f : kg(kg({}, f), {}, {\n        clockWise: a\n      })),\n      key: \"label-\".concat(l),\n      index: l\n    }));\n  }));\n}\nBn.displayName = \"LabelList\";\nfunction X8(e, t) {\n  return e ? e === !0 ? /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(Bn, {\n    key: \"labelList-implicit\",\n    data: t\n  }) : /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.isValidElement(e) || pe(e) ? /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(Bn, {\n    key: \"labelList-implicit\",\n    data: t,\n    content: e\n  }) : ci(e) ? /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(Bn, ps({\n    data: t\n  }, e, {\n    key: \"labelList-implicit\"\n  })) : null : null;\n}\nfunction Z8(e, t) {\n  var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !0;\n  if (!e || !e.children && n && !e.label)\n    return null;\n  var r = e.children, i = kt(r, Bn).map(function(a, s) {\n    return /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.cloneElement)(a, {\n      data: t,\n      // eslint-disable-next-line react/no-array-index-key\n      key: \"labelList-\".concat(s)\n    });\n  });\n  if (!n)\n    return i;\n  var o = X8(e.label, t);\n  return [o].concat(B8(i));\n}\nBn.renderCallByParent = Z8;\nfunction xo(e) {\n  \"@babel/helpers - typeof\";\n  return xo = typeof Symbol == \"function\" && typeof Symbol.iterator == \"symbol\" ? function(t) {\n    return typeof t;\n  } : function(t) {\n    return t && typeof Symbol == \"function\" && t.constructor === Symbol && t !== Symbol.prototype ? \"symbol\" : typeof t;\n  }, xo(e);\n}\nfunction ml() {\n  return ml = Object.assign ? Object.assign.bind() : function(e) {\n    for (var t = 1; t < arguments.length; t++) {\n      var n = arguments[t];\n      for (var r in n)\n        Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);\n    }\n    return e;\n  }, ml.apply(this, arguments);\n}\nfunction Ng(e, t) {\n  var n = Object.keys(e);\n  if (Object.getOwnPropertySymbols) {\n    var r = Object.getOwnPropertySymbols(e);\n    t && (r = r.filter(function(i) {\n      return Object.getOwnPropertyDescriptor(e, i).enumerable;\n    })), n.push.apply(n, r);\n  }\n  return n;\n}\nfunction Fg(e) {\n  for (var t = 1; t < arguments.length; t++) {\n    var n = arguments[t] != null ? arguments[t] : {};\n    t % 2 ? Ng(Object(n), !0).forEach(function(r) {\n      J8(e, r, n[r]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Ng(Object(n)).forEach(function(r) {\n      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));\n    });\n  }\n  return e;\n}\nfunction J8(e, t, n) {\n  return t = Q8(t), t in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;\n}\nfunction Q8(e) {\n  var t = ez(e, \"string\");\n  return xo(t) == \"symbol\" ? t : String(t);\n}\nfunction ez(e, t) {\n  if (xo(e) != \"object\" || !e)\n    return e;\n  var n = e[Symbol.toPrimitive];\n  if (n !== void 0) {\n    var r = n.call(e, t || \"default\");\n    if (xo(r) != \"object\")\n      return r;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (t === \"string\" ? String : Number)(e);\n}\nvar tz = function(t, n) {\n  var r = Kt(n - t), i = Math.min(Math.abs(n - t), 359.999);\n  return r * i;\n}, ya = function(t) {\n  var n = t.cx, r = t.cy, i = t.radius, o = t.angle, a = t.sign, s = t.isExternal, u = t.cornerRadius, c = t.cornerIsExternal, f = u * (s ? 1 : -1) + i, l = Math.asin(u / f) / ds, d = c ? o : o + a * l, p = nt(n, r, f, d), g = nt(n, r, i, d), h = c ? o - a * l : o, v = nt(n, r, f * Math.cos(l * ds), h);\n  return {\n    center: p,\n    circleTangency: g,\n    lineTangency: v,\n    theta: l\n  };\n}, X0 = function(t) {\n  var n = t.cx, r = t.cy, i = t.innerRadius, o = t.outerRadius, a = t.startAngle, s = t.endAngle, u = tz(a, s), c = a + u, f = nt(n, r, o, a), l = nt(n, r, o, c), d = \"M \".concat(f.x, \",\").concat(f.y, `\n    A `).concat(o, \",\").concat(o, `,0,\n    `).concat(+(Math.abs(u) > 180), \",\").concat(+(a > c), `,\n    `).concat(l.x, \",\").concat(l.y, `\n  `);\n  if (i > 0) {\n    var p = nt(n, r, i, a), g = nt(n, r, i, c);\n    d += \"L \".concat(g.x, \",\").concat(g.y, `\n            A `).concat(i, \",\").concat(i, `,0,\n            `).concat(+(Math.abs(u) > 180), \",\").concat(+(a <= c), `,\n            `).concat(p.x, \",\").concat(p.y, \" Z\");\n  } else\n    d += \"L \".concat(n, \",\").concat(r, \" Z\");\n  return d;\n}, nz = function(t) {\n  var n = t.cx, r = t.cy, i = t.innerRadius, o = t.outerRadius, a = t.cornerRadius, s = t.forceCornerRadius, u = t.cornerIsExternal, c = t.startAngle, f = t.endAngle, l = Kt(f - c), d = ya({\n    cx: n,\n    cy: r,\n    radius: o,\n    angle: c,\n    sign: l,\n    cornerRadius: a,\n    cornerIsExternal: u\n  }), p = d.circleTangency, g = d.lineTangency, h = d.theta, v = ya({\n    cx: n,\n    cy: r,\n    radius: o,\n    angle: f,\n    sign: -l,\n    cornerRadius: a,\n    cornerIsExternal: u\n  }), w = v.circleTangency, b = v.lineTangency, x = v.theta, m = u ? Math.abs(c - f) : Math.abs(c - f) - h - x;\n  if (m < 0)\n    return s ? \"M \".concat(g.x, \",\").concat(g.y, `\n        a`).concat(a, \",\").concat(a, \",0,0,1,\").concat(a * 2, `,0\n        a`).concat(a, \",\").concat(a, \",0,0,1,\").concat(-a * 2, `,0\n      `) : X0({\n      cx: n,\n      cy: r,\n      innerRadius: i,\n      outerRadius: o,\n      startAngle: c,\n      endAngle: f\n    });\n  var y = \"M \".concat(g.x, \",\").concat(g.y, `\n    A`).concat(a, \",\").concat(a, \",0,0,\").concat(+(l < 0), \",\").concat(p.x, \",\").concat(p.y, `\n    A`).concat(o, \",\").concat(o, \",0,\").concat(+(m > 180), \",\").concat(+(l < 0), \",\").concat(w.x, \",\").concat(w.y, `\n    A`).concat(a, \",\").concat(a, \",0,0,\").concat(+(l < 0), \",\").concat(b.x, \",\").concat(b.y, `\n  `);\n  if (i > 0) {\n    var S = ya({\n      cx: n,\n      cy: r,\n      radius: i,\n      angle: c,\n      sign: l,\n      isExternal: !0,\n      cornerRadius: a,\n      cornerIsExternal: u\n    }), $ = S.circleTangency, O = S.lineTangency, T = S.theta, M = ya({\n      cx: n,\n      cy: r,\n      radius: i,\n      angle: f,\n      sign: -l,\n      isExternal: !0,\n      cornerRadius: a,\n      cornerIsExternal: u\n    }), E = M.circleTangency, A = M.lineTangency, j = M.theta, R = u ? Math.abs(c - f) : Math.abs(c - f) - T - j;\n    if (R < 0 && a === 0)\n      return \"\".concat(y, \"L\").concat(n, \",\").concat(r, \"Z\");\n    y += \"L\".concat(A.x, \",\").concat(A.y, `\n      A`).concat(a, \",\").concat(a, \",0,0,\").concat(+(l < 0), \",\").concat(E.x, \",\").concat(E.y, `\n      A`).concat(i, \",\").concat(i, \",0,\").concat(+(R > 180), \",\").concat(+(l > 0), \",\").concat($.x, \",\").concat($.y, `\n      A`).concat(a, \",\").concat(a, \",0,0,\").concat(+(l < 0), \",\").concat(O.x, \",\").concat(O.y, \"Z\");\n  } else\n    y += \"L\".concat(n, \",\").concat(r, \"Z\");\n  return y;\n}, rz = {\n  cx: 0,\n  cy: 0,\n  innerRadius: 0,\n  outerRadius: 0,\n  startAngle: 0,\n  endAngle: 0,\n  cornerRadius: 0,\n  forceCornerRadius: !1,\n  cornerIsExternal: !1\n}, Z0 = function(t) {\n  var n = Fg(Fg({}, rz), t), r = n.cx, i = n.cy, o = n.innerRadius, a = n.outerRadius, s = n.cornerRadius, u = n.forceCornerRadius, c = n.cornerIsExternal, f = n.startAngle, l = n.endAngle, d = n.className;\n  if (a < o || f === l)\n    return null;\n  var p = $e(\"recharts-sector\", d), g = a - o, h = lr(s, g, 0, !0), v;\n  return h > 0 && Math.abs(f - l) < 360 ? v = nz({\n    cx: r,\n    cy: i,\n    innerRadius: o,\n    outerRadius: a,\n    cornerRadius: Math.min(h, g / 2),\n    forceCornerRadius: u,\n    cornerIsExternal: c,\n    startAngle: f,\n    endAngle: l\n  }) : v = X0({\n    cx: r,\n    cy: i,\n    innerRadius: o,\n    outerRadius: a,\n    startAngle: f,\n    endAngle: l\n  }), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"path\", ml({}, ye(n, !0), {\n    className: p,\n    d: v,\n    role: \"img\"\n  }));\n};\nfunction So(e) {\n  \"@babel/helpers - typeof\";\n  return So = typeof Symbol == \"function\" && typeof Symbol.iterator == \"symbol\" ? function(t) {\n    return typeof t;\n  } : function(t) {\n    return t && typeof Symbol == \"function\" && t.constructor === Symbol && t !== Symbol.prototype ? \"symbol\" : typeof t;\n  }, So(e);\n}\nfunction yl() {\n  return yl = Object.assign ? Object.assign.bind() : function(e) {\n    for (var t = 1; t < arguments.length; t++) {\n      var n = arguments[t];\n      for (var r in n)\n        Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);\n    }\n    return e;\n  }, yl.apply(this, arguments);\n}\nfunction Lg(e, t) {\n  var n = Object.keys(e);\n  if (Object.getOwnPropertySymbols) {\n    var r = Object.getOwnPropertySymbols(e);\n    t && (r = r.filter(function(i) {\n      return Object.getOwnPropertyDescriptor(e, i).enumerable;\n    })), n.push.apply(n, r);\n  }\n  return n;\n}\nfunction Bg(e) {\n  for (var t = 1; t < arguments.length; t++) {\n    var n = arguments[t] != null ? arguments[t] : {};\n    t % 2 ? Lg(Object(n), !0).forEach(function(r) {\n      iz(e, r, n[r]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Lg(Object(n)).forEach(function(r) {\n      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));\n    });\n  }\n  return e;\n}\nfunction iz(e, t, n) {\n  return t = oz(t), t in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;\n}\nfunction oz(e) {\n  var t = az(e, \"string\");\n  return So(t) == \"symbol\" ? t : String(t);\n}\nfunction az(e, t) {\n  if (So(e) != \"object\" || !e)\n    return e;\n  var n = e[Symbol.toPrimitive];\n  if (n !== void 0) {\n    var r = n.call(e, t || \"default\");\n    if (So(r) != \"object\")\n      return r;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (t === \"string\" ? String : Number)(e);\n}\nvar zg = {\n  curveBasisClosed: xT,\n  curveBasisOpen: ST,\n  curveBasis: wT,\n  curveBumpX: aT,\n  curveBumpY: sT,\n  curveLinearClosed: $T,\n  curveLinear: Vs,\n  curveMonotoneX: OT,\n  curveMonotoneY: _T,\n  curveNatural: AT,\n  curveStep: PT,\n  curveStepAfter: ET,\n  curveStepBefore: CT\n}, ba = function(t) {\n  return t.x === +t.x && t.y === +t.y;\n}, Di = function(t) {\n  return t.x;\n}, Ni = function(t) {\n  return t.y;\n}, sz = function(t, n) {\n  if (pe(t))\n    return t;\n  var r = \"curve\".concat(Bs(t));\n  return (r === \"curveMonotone\" || r === \"curveBump\") && n ? zg[\"\".concat(r).concat(n === \"vertical\" ? \"Y\" : \"X\")] : zg[r] || Vs;\n}, uz = function(t) {\n  var n = t.type, r = n === void 0 ? \"linear\" : n, i = t.points, o = i === void 0 ? [] : i, a = t.baseLine, s = t.layout, u = t.connectNulls, c = u === void 0 ? !1 : u, f = sz(r, s), l = c ? o.filter(function(h) {\n    return ba(h);\n  }) : o, d;\n  if (Array.isArray(a)) {\n    var p = c ? a.filter(function(h) {\n      return ba(h);\n    }) : a, g = l.map(function(h, v) {\n      return Bg(Bg({}, h), {}, {\n        base: p[v]\n      });\n    });\n    return s === \"vertical\" ? d = la().y(Ni).x1(Di).x0(function(h) {\n      return h.base.x;\n    }) : d = la().x(Di).y1(Ni).y0(function(h) {\n      return h.base.y;\n    }), d.defined(ba).curve(f), d(g);\n  }\n  return s === \"vertical\" && K(a) ? d = la().y(Ni).x1(Di).x0(a) : K(a) ? d = la().x(Di).y1(Ni).y0(a) : d = eb().x(Di).y(Ni), d.defined(ba).curve(f), d(l);\n}, bl = function(t) {\n  var n = t.className, r = t.points, i = t.path, o = t.pathRef;\n  if ((!r || !r.length) && !i)\n    return null;\n  var a = r && r.length ? uz(t) : i;\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"path\", yl({}, ye(t, !1), Na(t), {\n    className: $e(\"recharts-curve\", n),\n    d: a,\n    ref: o\n  }));\n}, wl = { exports: {} };\n/*\nobject-assign\n(c) Sindre Sorhus\n@license MIT\n*/\nvar Ku, Vg;\nfunction cz() {\n  if (Vg)\n    return Ku;\n  Vg = 1;\n  var e = Object.getOwnPropertySymbols, t = Object.prototype.hasOwnProperty, n = Object.prototype.propertyIsEnumerable;\n  function r(o) {\n    if (o == null)\n      throw new TypeError(\"Object.assign cannot be called with null or undefined\");\n    return Object(o);\n  }\n  function i() {\n    try {\n      if (!Object.assign)\n        return !1;\n      var o = new String(\"abc\");\n      if (o[5] = \"de\", Object.getOwnPropertyNames(o)[0] === \"5\")\n        return !1;\n      for (var a = {}, s = 0; s < 10; s++)\n        a[\"_\" + String.fromCharCode(s)] = s;\n      var u = Object.getOwnPropertyNames(a).map(function(f) {\n        return a[f];\n      });\n      if (u.join(\"\") !== \"0123456789\")\n        return !1;\n      var c = {};\n      return \"abcdefghijklmnopqrst\".split(\"\").forEach(function(f) {\n        c[f] = f;\n      }), Object.keys(Object.assign({}, c)).join(\"\") === \"abcdefghijklmnopqrst\";\n    } catch {\n      return !1;\n    }\n  }\n  return Ku = i() ? Object.assign : function(o, a) {\n    for (var s, u = r(o), c, f = 1; f < arguments.length; f++) {\n      s = Object(arguments[f]);\n      for (var l in s)\n        t.call(s, l) && (u[l] = s[l]);\n      if (e) {\n        c = e(s);\n        for (var d = 0; d < c.length; d++)\n          n.call(s, c[d]) && (u[c[d]] = s[c[d]]);\n      }\n    }\n    return u;\n  }, Ku;\n}\nvar Yu, Gg;\nfunction fd() {\n  if (Gg)\n    return Yu;\n  Gg = 1;\n  var e = \"SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED\";\n  return Yu = e, Yu;\n}\nvar Xu, Wg;\nfunction J0() {\n  return Wg || (Wg = 1, Xu = Function.call.bind(Object.prototype.hasOwnProperty)), Xu;\n}\nvar Zu, Ug;\nfunction lz() {\n  if (Ug)\n    return Zu;\n  Ug = 1;\n  var e = function() {\n  };\n  if (true) {\n    var t = fd(), n = {}, r = J0();\n    e = function(o) {\n      var a = \"Warning: \" + o;\n      typeof console < \"u\" && console.error(a);\n      try {\n        throw new Error(a);\n      } catch {\n      }\n    };\n  }\n  function i(o, a, s, u, c) {\n    if (true) {\n      for (var f in o)\n        if (r(o, f)) {\n          var l;\n          try {\n            if (typeof o[f] != \"function\") {\n              var d = Error(\n                (u || \"React class\") + \": \" + s + \" type `\" + f + \"` is invalid; it must be a function, usually from the `prop-types` package, but received `\" + typeof o[f] + \"`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.\"\n              );\n              throw d.name = \"Invariant Violation\", d;\n            }\n            l = o[f](a, f, u, s, null, t);\n          } catch (g) {\n            l = g;\n          }\n          if (l && !(l instanceof Error) && e(\n            (u || \"React class\") + \": type specification of \" + s + \" `\" + f + \"` is invalid; the type checker function must return `null` or an `Error` but returned a \" + typeof l + \". You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).\"\n          ), l instanceof Error && !(l.message in n)) {\n            n[l.message] = !0;\n            var p = c ? c() : \"\";\n            e(\n              \"Failed \" + s + \" type: \" + l.message + (p ?? \"\")\n            );\n          }\n        }\n    }\n  }\n  return i.resetWarningCache = function() {\n     true && (n = {});\n  }, Zu = i, Zu;\n}\nvar Ju, Hg;\nfunction fz() {\n  if (Hg)\n    return Ju;\n  Hg = 1;\n  var e = Of, t = cz(), n = fd(), r = J0(), i = lz(), o = function() {\n  };\n   true && (o = function(s) {\n    var u = \"Warning: \" + s;\n    typeof console < \"u\" && console.error(u);\n    try {\n      throw new Error(u);\n    } catch {\n    }\n  });\n  function a() {\n    return null;\n  }\n  return Ju = function(s, u) {\n    var c = typeof Symbol == \"function\" && Symbol.iterator, f = \"@@iterator\";\n    function l(I) {\n      var D = I && (c && I[c] || I[f]);\n      if (typeof D == \"function\")\n        return D;\n    }\n    var d = \"<<anonymous>>\", p = {\n      array: w(\"array\"),\n      bigint: w(\"bigint\"),\n      bool: w(\"boolean\"),\n      func: w(\"function\"),\n      number: w(\"number\"),\n      object: w(\"object\"),\n      string: w(\"string\"),\n      symbol: w(\"symbol\"),\n      any: b(),\n      arrayOf: x,\n      element: m(),\n      elementType: y(),\n      instanceOf: S,\n      node: M(),\n      objectOf: O,\n      oneOf: $,\n      oneOfType: T,\n      shape: A,\n      exact: j\n    };\n    function g(I, D) {\n      return I === D ? I !== 0 || 1 / I === 1 / D : I !== I && D !== D;\n    }\n    function h(I, D) {\n      this.message = I, this.data = D && typeof D == \"object\" ? D : {}, this.stack = \"\";\n    }\n    h.prototype = Error.prototype;\n    function v(I) {\n      if (true)\n        var D = {}, G = 0;\n      function q(ne, te, ee, ie, B, U, re) {\n        if (ie = ie || d, U = U || ee, re !== n) {\n          if (u) {\n            var C = new Error(\n              \"Calling PropTypes validators directly is not supported by the `prop-types` package. Use `PropTypes.checkPropTypes()` to call them. Read more at http://fb.me/use-check-prop-types\"\n            );\n            throw C.name = \"Invariant Violation\", C;\n          } else if ( true && typeof console < \"u\") {\n            var ge = ie + \":\" + ee;\n            !D[ge] && // Avoid spamming the console because they are often not actionable except for lib authors\n            G < 3 && (o(\n              \"You are manually calling a React.PropTypes validation function for the `\" + U + \"` prop on `\" + ie + \"`. This is deprecated and will throw in the standalone `prop-types` package. You may be seeing this warning due to a third-party PropTypes library. See https://fb.me/react-warning-dont-call-proptypes for details.\"\n            ), D[ge] = !0, G++);\n          }\n        }\n        return te[ee] == null ? ne ? te[ee] === null ? new h(\"The \" + B + \" `\" + U + \"` is marked as required \" + (\"in `\" + ie + \"`, but its value is `null`.\")) : new h(\"The \" + B + \" `\" + U + \"` is marked as required in \" + (\"`\" + ie + \"`, but its value is `undefined`.\")) : null : I(te, ee, ie, B, U);\n      }\n      var J = q.bind(null, !1);\n      return J.isRequired = q.bind(null, !0), J;\n    }\n    function w(I) {\n      function D(G, q, J, ne, te, ee) {\n        var ie = G[q], B = k(ie);\n        if (B !== I) {\n          var U = F(ie);\n          return new h(\n            \"Invalid \" + ne + \" `\" + te + \"` of type \" + (\"`\" + U + \"` supplied to `\" + J + \"`, expected \") + (\"`\" + I + \"`.\"),\n            { expectedType: I }\n          );\n        }\n        return null;\n      }\n      return v(D);\n    }\n    function b() {\n      return v(a);\n    }\n    function x(I) {\n      function D(G, q, J, ne, te) {\n        if (typeof I != \"function\")\n          return new h(\"Property `\" + te + \"` of component `\" + J + \"` has invalid PropType notation inside arrayOf.\");\n        var ee = G[q];\n        if (!Array.isArray(ee)) {\n          var ie = k(ee);\n          return new h(\"Invalid \" + ne + \" `\" + te + \"` of type \" + (\"`\" + ie + \"` supplied to `\" + J + \"`, expected an array.\"));\n        }\n        for (var B = 0; B < ee.length; B++) {\n          var U = I(ee, B, J, ne, te + \"[\" + B + \"]\", n);\n          if (U instanceof Error)\n            return U;\n        }\n        return null;\n      }\n      return v(D);\n    }\n    function m() {\n      function I(D, G, q, J, ne) {\n        var te = D[G];\n        if (!s(te)) {\n          var ee = k(te);\n          return new h(\"Invalid \" + J + \" `\" + ne + \"` of type \" + (\"`\" + ee + \"` supplied to `\" + q + \"`, expected a single ReactElement.\"));\n        }\n        return null;\n      }\n      return v(I);\n    }\n    function y() {\n      function I(D, G, q, J, ne) {\n        var te = D[G];\n        if (!e.isValidElementType(te)) {\n          var ee = k(te);\n          return new h(\"Invalid \" + J + \" `\" + ne + \"` of type \" + (\"`\" + ee + \"` supplied to `\" + q + \"`, expected a single ReactElement type.\"));\n        }\n        return null;\n      }\n      return v(I);\n    }\n    function S(I) {\n      function D(G, q, J, ne, te) {\n        if (!(G[q] instanceof I)) {\n          var ee = I.name || d, ie = L(G[q]);\n          return new h(\"Invalid \" + ne + \" `\" + te + \"` of type \" + (\"`\" + ie + \"` supplied to `\" + J + \"`, expected \") + (\"instance of `\" + ee + \"`.\"));\n        }\n        return null;\n      }\n      return v(D);\n    }\n    function $(I) {\n      if (!Array.isArray(I))\n        return  true && (arguments.length > 1 ? o(\n          \"Invalid arguments supplied to oneOf, expected an array, got \" + arguments.length + \" arguments. A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z]).\"\n        ) : o(\"Invalid argument supplied to oneOf, expected an array.\")), a;\n      function D(G, q, J, ne, te) {\n        for (var ee = G[q], ie = 0; ie < I.length; ie++)\n          if (g(ee, I[ie]))\n            return null;\n        var B = JSON.stringify(I, function(re, C) {\n          var ge = F(C);\n          return ge === \"symbol\" ? String(C) : C;\n        });\n        return new h(\"Invalid \" + ne + \" `\" + te + \"` of value `\" + String(ee) + \"` \" + (\"supplied to `\" + J + \"`, expected one of \" + B + \".\"));\n      }\n      return v(D);\n    }\n    function O(I) {\n      function D(G, q, J, ne, te) {\n        if (typeof I != \"function\")\n          return new h(\"Property `\" + te + \"` of component `\" + J + \"` has invalid PropType notation inside objectOf.\");\n        var ee = G[q], ie = k(ee);\n        if (ie !== \"object\")\n          return new h(\"Invalid \" + ne + \" `\" + te + \"` of type \" + (\"`\" + ie + \"` supplied to `\" + J + \"`, expected an object.\"));\n        for (var B in ee)\n          if (r(ee, B)) {\n            var U = I(ee, B, J, ne, te + \".\" + B, n);\n            if (U instanceof Error)\n              return U;\n          }\n        return null;\n      }\n      return v(D);\n    }\n    function T(I) {\n      if (!Array.isArray(I))\n        return  true && o(\"Invalid argument supplied to oneOfType, expected an instance of array.\"), a;\n      for (var D = 0; D < I.length; D++) {\n        var G = I[D];\n        if (typeof G != \"function\")\n          return o(\n            \"Invalid argument supplied to oneOfType. Expected an array of check functions, but received \" + V(G) + \" at index \" + D + \".\"\n          ), a;\n      }\n      function q(J, ne, te, ee, ie) {\n        for (var B = [], U = 0; U < I.length; U++) {\n          var re = I[U], C = re(J, ne, te, ee, ie, n);\n          if (C == null)\n            return null;\n          C.data && r(C.data, \"expectedType\") && B.push(C.data.expectedType);\n        }\n        var ge = B.length > 0 ? \", expected one of type [\" + B.join(\", \") + \"]\" : \"\";\n        return new h(\"Invalid \" + ee + \" `\" + ie + \"` supplied to \" + (\"`\" + te + \"`\" + ge + \".\"));\n      }\n      return v(q);\n    }\n    function M() {\n      function I(D, G, q, J, ne) {\n        return R(D[G]) ? null : new h(\"Invalid \" + J + \" `\" + ne + \"` supplied to \" + (\"`\" + q + \"`, expected a ReactNode.\"));\n      }\n      return v(I);\n    }\n    function E(I, D, G, q, J) {\n      return new h(\n        (I || \"React class\") + \": \" + D + \" type `\" + G + \".\" + q + \"` is invalid; it must be a function, usually from the `prop-types` package, but received `\" + J + \"`.\"\n      );\n    }\n    function A(I) {\n      function D(G, q, J, ne, te) {\n        var ee = G[q], ie = k(ee);\n        if (ie !== \"object\")\n          return new h(\"Invalid \" + ne + \" `\" + te + \"` of type `\" + ie + \"` \" + (\"supplied to `\" + J + \"`, expected `object`.\"));\n        for (var B in I) {\n          var U = I[B];\n          if (typeof U != \"function\")\n            return E(J, ne, te, B, F(U));\n          var re = U(ee, B, J, ne, te + \".\" + B, n);\n          if (re)\n            return re;\n        }\n        return null;\n      }\n      return v(D);\n    }\n    function j(I) {\n      function D(G, q, J, ne, te) {\n        var ee = G[q], ie = k(ee);\n        if (ie !== \"object\")\n          return new h(\"Invalid \" + ne + \" `\" + te + \"` of type `\" + ie + \"` \" + (\"supplied to `\" + J + \"`, expected `object`.\"));\n        var B = t({}, G[q], I);\n        for (var U in B) {\n          var re = I[U];\n          if (r(I, U) && typeof re != \"function\")\n            return E(J, ne, te, U, F(re));\n          if (!re)\n            return new h(\n              \"Invalid \" + ne + \" `\" + te + \"` key `\" + U + \"` supplied to `\" + J + \"`.\\nBad object: \" + JSON.stringify(G[q], null, \"  \") + `\nValid keys: ` + JSON.stringify(Object.keys(I), null, \"  \")\n            );\n          var C = re(ee, U, J, ne, te + \".\" + U, n);\n          if (C)\n            return C;\n        }\n        return null;\n      }\n      return v(D);\n    }\n    function R(I) {\n      switch (typeof I) {\n        case \"number\":\n        case \"string\":\n        case \"undefined\":\n          return !0;\n        case \"boolean\":\n          return !I;\n        case \"object\":\n          if (Array.isArray(I))\n            return I.every(R);\n          if (I === null || s(I))\n            return !0;\n          var D = l(I);\n          if (D) {\n            var G = D.call(I), q;\n            if (D !== I.entries) {\n              for (; !(q = G.next()).done; )\n                if (!R(q.value))\n                  return !1;\n            } else\n              for (; !(q = G.next()).done; ) {\n                var J = q.value;\n                if (J && !R(J[1]))\n                  return !1;\n              }\n          } else\n            return !1;\n          return !0;\n        default:\n          return !1;\n      }\n    }\n    function N(I, D) {\n      return I === \"symbol\" ? !0 : D ? D[\"@@toStringTag\"] === \"Symbol\" || typeof Symbol == \"function\" && D instanceof Symbol : !1;\n    }\n    function k(I) {\n      var D = typeof I;\n      return Array.isArray(I) ? \"array\" : I instanceof RegExp ? \"object\" : N(D, I) ? \"symbol\" : D;\n    }\n    function F(I) {\n      if (typeof I > \"u\" || I === null)\n        return \"\" + I;\n      var D = k(I);\n      if (D === \"object\") {\n        if (I instanceof Date)\n          return \"date\";\n        if (I instanceof RegExp)\n          return \"regexp\";\n      }\n      return D;\n    }\n    function V(I) {\n      var D = F(I);\n      switch (D) {\n        case \"array\":\n        case \"object\":\n          return \"an \" + D;\n        case \"boolean\":\n        case \"date\":\n        case \"regexp\":\n          return \"a \" + D;\n        default:\n          return D;\n      }\n    }\n    function L(I) {\n      return !I.constructor || !I.constructor.name ? d : I.constructor.name;\n    }\n    return p.checkPropTypes = i, p.resetWarningCache = i.resetWarningCache, p.PropTypes = p, p;\n  }, Ju;\n}\nvar Qu, qg;\nfunction dz() {\n  if (qg)\n    return Qu;\n  qg = 1;\n  var e = fd();\n  function t() {\n  }\n  function n() {\n  }\n  return n.resetWarningCache = t, Qu = function() {\n    function r(a, s, u, c, f, l) {\n      if (l !== e) {\n        var d = new Error(\n          \"Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types\"\n        );\n        throw d.name = \"Invariant Violation\", d;\n      }\n    }\n    r.isRequired = r;\n    function i() {\n      return r;\n    }\n    var o = {\n      array: r,\n      bigint: r,\n      bool: r,\n      func: r,\n      number: r,\n      object: r,\n      string: r,\n      symbol: r,\n      any: r,\n      arrayOf: i,\n      element: r,\n      elementType: r,\n      instanceOf: i,\n      node: r,\n      objectOf: i,\n      oneOf: i,\n      oneOfType: i,\n      shape: i,\n      exact: i,\n      checkPropTypes: n,\n      resetWarningCache: t\n    };\n    return o.PropTypes = o, o;\n  }, Qu;\n}\nif (true) {\n  var pz = Of, hz = !0;\n  wl.exports = fz()(pz.isElement, hz);\n} else\n  {}\nvar gz = wl.exports;\nconst de = /* @__PURE__ */ je(gz);\nvar vz = Object.getOwnPropertyNames, mz = Object.getOwnPropertySymbols, yz = Object.prototype.hasOwnProperty;\nfunction Kg(e, t) {\n  return function(r, i, o) {\n    return e(r, i, o) && t(r, i, o);\n  };\n}\nfunction wa(e) {\n  return function(n, r, i) {\n    if (!n || !r || typeof n != \"object\" || typeof r != \"object\")\n      return e(n, r, i);\n    var o = i.cache, a = o.get(n), s = o.get(r);\n    if (a && s)\n      return a === r && s === n;\n    o.set(n, r), o.set(r, n);\n    var u = e(n, r, i);\n    return o.delete(n), o.delete(r), u;\n  };\n}\nfunction Yg(e) {\n  return vz(e).concat(mz(e));\n}\nvar Q0 = Object.hasOwn || function(e, t) {\n  return yz.call(e, t);\n};\nfunction bi(e, t) {\n  return e || t ? e === t : e === t || e !== e && t !== t;\n}\nvar ew = \"_owner\", Xg = Object.getOwnPropertyDescriptor, Zg = Object.keys;\nfunction bz(e, t, n) {\n  var r = e.length;\n  if (t.length !== r)\n    return !1;\n  for (; r-- > 0; )\n    if (!n.equals(e[r], t[r], r, r, e, t, n))\n      return !1;\n  return !0;\n}\nfunction wz(e, t) {\n  return bi(e.getTime(), t.getTime());\n}\nfunction Jg(e, t, n) {\n  if (e.size !== t.size)\n    return !1;\n  for (var r = {}, i = e.entries(), o = 0, a, s; (a = i.next()) && !a.done; ) {\n    for (var u = t.entries(), c = !1, f = 0; (s = u.next()) && !s.done; ) {\n      var l = a.value, d = l[0], p = l[1], g = s.value, h = g[0], v = g[1];\n      !c && !r[f] && (c = n.equals(d, h, o, f, e, t, n) && n.equals(p, v, d, h, e, t, n)) && (r[f] = !0), f++;\n    }\n    if (!c)\n      return !1;\n    o++;\n  }\n  return !0;\n}\nfunction xz(e, t, n) {\n  var r = Zg(e), i = r.length;\n  if (Zg(t).length !== i)\n    return !1;\n  for (var o; i-- > 0; )\n    if (o = r[i], o === ew && (e.$$typeof || t.$$typeof) && e.$$typeof !== t.$$typeof || !Q0(t, o) || !n.equals(e[o], t[o], o, o, e, t, n))\n      return !1;\n  return !0;\n}\nfunction Fi(e, t, n) {\n  var r = Yg(e), i = r.length;\n  if (Yg(t).length !== i)\n    return !1;\n  for (var o, a, s; i-- > 0; )\n    if (o = r[i], o === ew && (e.$$typeof || t.$$typeof) && e.$$typeof !== t.$$typeof || !Q0(t, o) || !n.equals(e[o], t[o], o, o, e, t, n) || (a = Xg(e, o), s = Xg(t, o), (a || s) && (!a || !s || a.configurable !== s.configurable || a.enumerable !== s.enumerable || a.writable !== s.writable)))\n      return !1;\n  return !0;\n}\nfunction Sz(e, t) {\n  return bi(e.valueOf(), t.valueOf());\n}\nfunction $z(e, t) {\n  return e.source === t.source && e.flags === t.flags;\n}\nfunction Qg(e, t, n) {\n  if (e.size !== t.size)\n    return !1;\n  for (var r = {}, i = e.values(), o, a; (o = i.next()) && !o.done; ) {\n    for (var s = t.values(), u = !1, c = 0; (a = s.next()) && !a.done; )\n      !u && !r[c] && (u = n.equals(o.value, a.value, o.value, a.value, e, t, n)) && (r[c] = !0), c++;\n    if (!u)\n      return !1;\n  }\n  return !0;\n}\nfunction Oz(e, t) {\n  var n = e.length;\n  if (t.length !== n)\n    return !1;\n  for (; n-- > 0; )\n    if (e[n] !== t[n])\n      return !1;\n  return !0;\n}\nvar _z = \"[object Arguments]\", Az = \"[object Boolean]\", Pz = \"[object Date]\", Cz = \"[object Map]\", Ez = \"[object Number]\", Tz = \"[object Object]\", Mz = \"[object RegExp]\", Rz = \"[object Set]\", Iz = \"[object String]\", jz = Array.isArray, ev = typeof ArrayBuffer == \"function\" && ArrayBuffer.isView ? ArrayBuffer.isView : null, tv = Object.assign, kz = Object.prototype.toString.call.bind(Object.prototype.toString);\nfunction Dz(e) {\n  var t = e.areArraysEqual, n = e.areDatesEqual, r = e.areMapsEqual, i = e.areObjectsEqual, o = e.arePrimitiveWrappersEqual, a = e.areRegExpsEqual, s = e.areSetsEqual, u = e.areTypedArraysEqual;\n  return function(f, l, d) {\n    if (f === l)\n      return !0;\n    if (f == null || l == null || typeof f != \"object\" || typeof l != \"object\")\n      return f !== f && l !== l;\n    var p = f.constructor;\n    if (p !== l.constructor)\n      return !1;\n    if (p === Object)\n      return i(f, l, d);\n    if (jz(f))\n      return t(f, l, d);\n    if (ev != null && ev(f))\n      return u(f, l, d);\n    if (p === Date)\n      return n(f, l, d);\n    if (p === RegExp)\n      return a(f, l, d);\n    if (p === Map)\n      return r(f, l, d);\n    if (p === Set)\n      return s(f, l, d);\n    var g = kz(f);\n    return g === Pz ? n(f, l, d) : g === Mz ? a(f, l, d) : g === Cz ? r(f, l, d) : g === Rz ? s(f, l, d) : g === Tz ? typeof f.then != \"function\" && typeof l.then != \"function\" && i(f, l, d) : g === _z ? i(f, l, d) : g === Az || g === Ez || g === Iz ? o(f, l, d) : !1;\n  };\n}\nfunction Nz(e) {\n  var t = e.circular, n = e.createCustomConfig, r = e.strict, i = {\n    areArraysEqual: r ? Fi : bz,\n    areDatesEqual: wz,\n    areMapsEqual: r ? Kg(Jg, Fi) : Jg,\n    areObjectsEqual: r ? Fi : xz,\n    arePrimitiveWrappersEqual: Sz,\n    areRegExpsEqual: $z,\n    areSetsEqual: r ? Kg(Qg, Fi) : Qg,\n    areTypedArraysEqual: r ? Fi : Oz\n  };\n  if (n && (i = tv({}, i, n(i))), t) {\n    var o = wa(i.areArraysEqual), a = wa(i.areMapsEqual), s = wa(i.areObjectsEqual), u = wa(i.areSetsEqual);\n    i = tv({}, i, {\n      areArraysEqual: o,\n      areMapsEqual: a,\n      areObjectsEqual: s,\n      areSetsEqual: u\n    });\n  }\n  return i;\n}\nfunction Fz(e) {\n  return function(t, n, r, i, o, a, s) {\n    return e(t, n, s);\n  };\n}\nfunction Lz(e) {\n  var t = e.circular, n = e.comparator, r = e.createState, i = e.equals, o = e.strict;\n  if (r)\n    return function(u, c) {\n      var f = r(), l = f.cache, d = l === void 0 ? t ? /* @__PURE__ */ new WeakMap() : void 0 : l, p = f.meta;\n      return n(u, c, {\n        cache: d,\n        equals: i,\n        meta: p,\n        strict: o\n      });\n    };\n  if (t)\n    return function(u, c) {\n      return n(u, c, {\n        cache: /* @__PURE__ */ new WeakMap(),\n        equals: i,\n        meta: void 0,\n        strict: o\n      });\n    };\n  var a = {\n    cache: void 0,\n    equals: i,\n    meta: void 0,\n    strict: o\n  };\n  return function(u, c) {\n    return n(u, c, a);\n  };\n}\nvar Bz = Yn();\nYn({ strict: !0 });\nYn({ circular: !0 });\nYn({\n  circular: !0,\n  strict: !0\n});\nYn({\n  createInternalComparator: function() {\n    return bi;\n  }\n});\nYn({\n  strict: !0,\n  createInternalComparator: function() {\n    return bi;\n  }\n});\nYn({\n  circular: !0,\n  createInternalComparator: function() {\n    return bi;\n  }\n});\nYn({\n  circular: !0,\n  createInternalComparator: function() {\n    return bi;\n  },\n  strict: !0\n});\nfunction Yn(e) {\n  e === void 0 && (e = {});\n  var t = e.circular, n = t === void 0 ? !1 : t, r = e.createInternalComparator, i = e.createState, o = e.strict, a = o === void 0 ? !1 : o, s = Nz(e), u = Dz(s), c = r ? r(u) : Fz(u);\n  return Lz({ circular: n, comparator: u, createState: i, equals: c, strict: a });\n}\nfunction zz(e) {\n  typeof requestAnimationFrame < \"u\" && requestAnimationFrame(e);\n}\nfunction nv(e) {\n  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, n = -1, r = function i(o) {\n    n < 0 && (n = o), o - n > t ? (e(o), n = -1) : zz(i);\n  };\n  requestAnimationFrame(r);\n}\nfunction xl(e) {\n  \"@babel/helpers - typeof\";\n  return xl = typeof Symbol == \"function\" && typeof Symbol.iterator == \"symbol\" ? function(t) {\n    return typeof t;\n  } : function(t) {\n    return t && typeof Symbol == \"function\" && t.constructor === Symbol && t !== Symbol.prototype ? \"symbol\" : typeof t;\n  }, xl(e);\n}\nfunction Vz(e) {\n  return Hz(e) || Uz(e) || Wz(e) || Gz();\n}\nfunction Gz() {\n  throw new TypeError(`Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);\n}\nfunction Wz(e, t) {\n  if (e) {\n    if (typeof e == \"string\")\n      return rv(e, t);\n    var n = Object.prototype.toString.call(e).slice(8, -1);\n    if (n === \"Object\" && e.constructor && (n = e.constructor.name), n === \"Map\" || n === \"Set\")\n      return Array.from(e);\n    if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))\n      return rv(e, t);\n  }\n}\nfunction rv(e, t) {\n  (t == null || t > e.length) && (t = e.length);\n  for (var n = 0, r = new Array(t); n < t; n++)\n    r[n] = e[n];\n  return r;\n}\nfunction Uz(e) {\n  if (typeof Symbol < \"u\" && e[Symbol.iterator] != null || e[\"@@iterator\"] != null)\n    return Array.from(e);\n}\nfunction Hz(e) {\n  if (Array.isArray(e))\n    return e;\n}\nfunction qz() {\n  var e = {}, t = function() {\n    return null;\n  }, n = !1, r = function i(o) {\n    if (!n) {\n      if (Array.isArray(o)) {\n        if (!o.length)\n          return;\n        var a = o, s = Vz(a), u = s[0], c = s.slice(1);\n        if (typeof u == \"number\") {\n          nv(i.bind(null, c), u);\n          return;\n        }\n        i(u), nv(i.bind(null, c));\n        return;\n      }\n      xl(o) === \"object\" && (e = o, t(e)), typeof o == \"function\" && o();\n    }\n  };\n  return {\n    stop: function() {\n      n = !0;\n    },\n    start: function(o) {\n      n = !1, r(o);\n    },\n    subscribe: function(o) {\n      return t = o, function() {\n        t = function() {\n          return null;\n        };\n      };\n    }\n  };\n}\nfunction $o(e) {\n  \"@babel/helpers - typeof\";\n  return $o = typeof Symbol == \"function\" && typeof Symbol.iterator == \"symbol\" ? function(t) {\n    return typeof t;\n  } : function(t) {\n    return t && typeof Symbol == \"function\" && t.constructor === Symbol && t !== Symbol.prototype ? \"symbol\" : typeof t;\n  }, $o(e);\n}\nfunction iv(e, t) {\n  var n = Object.keys(e);\n  if (Object.getOwnPropertySymbols) {\n    var r = Object.getOwnPropertySymbols(e);\n    t && (r = r.filter(function(i) {\n      return Object.getOwnPropertyDescriptor(e, i).enumerable;\n    })), n.push.apply(n, r);\n  }\n  return n;\n}\nfunction ov(e) {\n  for (var t = 1; t < arguments.length; t++) {\n    var n = arguments[t] != null ? arguments[t] : {};\n    t % 2 ? iv(Object(n), !0).forEach(function(r) {\n      tw(e, r, n[r]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : iv(Object(n)).forEach(function(r) {\n      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));\n    });\n  }\n  return e;\n}\nfunction tw(e, t, n) {\n  return t = Kz(t), t in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;\n}\nfunction Kz(e) {\n  var t = Yz(e, \"string\");\n  return $o(t) === \"symbol\" ? t : String(t);\n}\nfunction Yz(e, t) {\n  if ($o(e) !== \"object\" || e === null)\n    return e;\n  var n = e[Symbol.toPrimitive];\n  if (n !== void 0) {\n    var r = n.call(e, t || \"default\");\n    if ($o(r) !== \"object\")\n      return r;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (t === \"string\" ? String : Number)(e);\n}\nvar Xz = function(t, n) {\n  return [Object.keys(t), Object.keys(n)].reduce(function(r, i) {\n    return r.filter(function(o) {\n      return i.includes(o);\n    });\n  });\n}, Zz = function(t) {\n  return t;\n}, Jz = function(t) {\n  return t.replace(/([A-Z])/g, function(n) {\n    return \"-\".concat(n.toLowerCase());\n  });\n}, Hi = function(t, n) {\n  return Object.keys(n).reduce(function(r, i) {\n    return ov(ov({}, r), {}, tw({}, i, t(i, n[i])));\n  }, {});\n}, av = function(t, n, r) {\n  return t.map(function(i) {\n    return \"\".concat(Jz(i), \" \").concat(n, \"ms \").concat(r);\n  }).join(\",\");\n}, Qz = \"development\" !== \"production\", hs = function(t, n, r, i, o, a, s, u) {\n  if (Qz && typeof console < \"u\" && console.warn && (n === void 0 && console.warn(\"LogUtils requires an error message argument\"), !t))\n    if (n === void 0)\n      console.warn(\"Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings.\");\n    else {\n      var c = [r, i, o, a, s, u], f = 0;\n      console.warn(n.replace(/%s/g, function() {\n        return c[f++];\n      }));\n    }\n};\nfunction e7(e, t) {\n  return r7(e) || n7(e, t) || nw(e, t) || t7();\n}\nfunction t7() {\n  throw new TypeError(`Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);\n}\nfunction n7(e, t) {\n  var n = e == null ? null : typeof Symbol < \"u\" && e[Symbol.iterator] || e[\"@@iterator\"];\n  if (n != null) {\n    var r, i, o, a, s = [], u = !0, c = !1;\n    try {\n      if (o = (n = n.call(e)).next, t !== 0)\n        for (; !(u = (r = o.call(n)).done) && (s.push(r.value), s.length !== t); u = !0)\n          ;\n    } catch (f) {\n      c = !0, i = f;\n    } finally {\n      try {\n        if (!u && n.return != null && (a = n.return(), Object(a) !== a))\n          return;\n      } finally {\n        if (c)\n          throw i;\n      }\n    }\n    return s;\n  }\n}\nfunction r7(e) {\n  if (Array.isArray(e))\n    return e;\n}\nfunction i7(e) {\n  return s7(e) || a7(e) || nw(e) || o7();\n}\nfunction o7() {\n  throw new TypeError(`Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);\n}\nfunction nw(e, t) {\n  if (e) {\n    if (typeof e == \"string\")\n      return Sl(e, t);\n    var n = Object.prototype.toString.call(e).slice(8, -1);\n    if (n === \"Object\" && e.constructor && (n = e.constructor.name), n === \"Map\" || n === \"Set\")\n      return Array.from(e);\n    if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))\n      return Sl(e, t);\n  }\n}\nfunction a7(e) {\n  if (typeof Symbol < \"u\" && e[Symbol.iterator] != null || e[\"@@iterator\"] != null)\n    return Array.from(e);\n}\nfunction s7(e) {\n  if (Array.isArray(e))\n    return Sl(e);\n}\nfunction Sl(e, t) {\n  (t == null || t > e.length) && (t = e.length);\n  for (var n = 0, r = new Array(t); n < t; n++)\n    r[n] = e[n];\n  return r;\n}\nvar gs = 1e-4, rw = function(t, n) {\n  return [0, 3 * t, 3 * n - 6 * t, 3 * t - 3 * n + 1];\n}, iw = function(t, n) {\n  return t.map(function(r, i) {\n    return r * Math.pow(n, i);\n  }).reduce(function(r, i) {\n    return r + i;\n  });\n}, sv = function(t, n) {\n  return function(r) {\n    var i = rw(t, n);\n    return iw(i, r);\n  };\n}, u7 = function(t, n) {\n  return function(r) {\n    var i = rw(t, n), o = [].concat(i7(i.map(function(a, s) {\n      return a * s;\n    }).slice(1)), [0]);\n    return iw(o, r);\n  };\n}, uv = function() {\n  for (var t = arguments.length, n = new Array(t), r = 0; r < t; r++)\n    n[r] = arguments[r];\n  var i = n[0], o = n[1], a = n[2], s = n[3];\n  if (n.length === 1)\n    switch (n[0]) {\n      case \"linear\":\n        i = 0, o = 0, a = 1, s = 1;\n        break;\n      case \"ease\":\n        i = 0.25, o = 0.1, a = 0.25, s = 1;\n        break;\n      case \"ease-in\":\n        i = 0.42, o = 0, a = 1, s = 1;\n        break;\n      case \"ease-out\":\n        i = 0.42, o = 0, a = 0.58, s = 1;\n        break;\n      case \"ease-in-out\":\n        i = 0, o = 0, a = 0.58, s = 1;\n        break;\n      default: {\n        var u = n[0].split(\"(\");\n        if (u[0] === \"cubic-bezier\" && u[1].split(\")\")[0].split(\",\").length === 4) {\n          var c = u[1].split(\")\")[0].split(\",\").map(function(v) {\n            return parseFloat(v);\n          }), f = e7(c, 4);\n          i = f[0], o = f[1], a = f[2], s = f[3];\n        } else\n          hs(!1, \"[configBezier]: arguments should be one of oneOf 'linear', 'ease', 'ease-in', 'ease-out', 'ease-in-out','cubic-bezier(x1,y1,x2,y2)', instead received %s\", n);\n      }\n    }\n  hs([i, a, o, s].every(function(v) {\n    return typeof v == \"number\" && v >= 0 && v <= 1;\n  }), \"[configBezier]: arguments should be x1, y1, x2, y2 of [0, 1] instead received %s\", n);\n  var l = sv(i, a), d = sv(o, s), p = u7(i, a), g = function(w) {\n    return w > 1 ? 1 : w < 0 ? 0 : w;\n  }, h = function(w) {\n    for (var b = w > 1 ? 1 : w, x = b, m = 0; m < 8; ++m) {\n      var y = l(x) - b, S = p(x);\n      if (Math.abs(y - b) < gs || S < gs)\n        return d(x);\n      x = g(x - y / S);\n    }\n    return d(x);\n  };\n  return h.isStepper = !1, h;\n}, c7 = function() {\n  var t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, n = t.stiff, r = n === void 0 ? 100 : n, i = t.damping, o = i === void 0 ? 8 : i, a = t.dt, s = a === void 0 ? 17 : a, u = function(f, l, d) {\n    var p = -(f - l) * r, g = d * o, h = d + (p - g) * s / 1e3, v = d * s / 1e3 + f;\n    return Math.abs(v - l) < gs && Math.abs(h) < gs ? [l, 0] : [v, h];\n  };\n  return u.isStepper = !0, u.dt = s, u;\n}, l7 = function() {\n  for (var t = arguments.length, n = new Array(t), r = 0; r < t; r++)\n    n[r] = arguments[r];\n  var i = n[0];\n  if (typeof i == \"string\")\n    switch (i) {\n      case \"ease\":\n      case \"ease-in-out\":\n      case \"ease-out\":\n      case \"ease-in\":\n      case \"linear\":\n        return uv(i);\n      case \"spring\":\n        return c7();\n      default:\n        if (i.split(\"(\")[0] === \"cubic-bezier\")\n          return uv(i);\n        hs(!1, \"[configEasing]: first argument should be one of 'ease', 'ease-in', 'ease-out', 'ease-in-out','cubic-bezier(x1,y1,x2,y2)', 'linear' and 'spring', instead  received %s\", n);\n    }\n  return typeof i == \"function\" ? i : (hs(!1, \"[configEasing]: first argument type should be function or string, instead received %s\", n), null);\n};\nfunction Oo(e) {\n  \"@babel/helpers - typeof\";\n  return Oo = typeof Symbol == \"function\" && typeof Symbol.iterator == \"symbol\" ? function(t) {\n    return typeof t;\n  } : function(t) {\n    return t && typeof Symbol == \"function\" && t.constructor === Symbol && t !== Symbol.prototype ? \"symbol\" : typeof t;\n  }, Oo(e);\n}\nfunction cv(e) {\n  return p7(e) || d7(e) || ow(e) || f7();\n}\nfunction f7() {\n  throw new TypeError(`Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);\n}\nfunction d7(e) {\n  if (typeof Symbol < \"u\" && e[Symbol.iterator] != null || e[\"@@iterator\"] != null)\n    return Array.from(e);\n}\nfunction p7(e) {\n  if (Array.isArray(e))\n    return Ol(e);\n}\nfunction lv(e, t) {\n  var n = Object.keys(e);\n  if (Object.getOwnPropertySymbols) {\n    var r = Object.getOwnPropertySymbols(e);\n    t && (r = r.filter(function(i) {\n      return Object.getOwnPropertyDescriptor(e, i).enumerable;\n    })), n.push.apply(n, r);\n  }\n  return n;\n}\nfunction tt(e) {\n  for (var t = 1; t < arguments.length; t++) {\n    var n = arguments[t] != null ? arguments[t] : {};\n    t % 2 ? lv(Object(n), !0).forEach(function(r) {\n      $l(e, r, n[r]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : lv(Object(n)).forEach(function(r) {\n      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));\n    });\n  }\n  return e;\n}\nfunction $l(e, t, n) {\n  return t = h7(t), t in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;\n}\nfunction h7(e) {\n  var t = g7(e, \"string\");\n  return Oo(t) === \"symbol\" ? t : String(t);\n}\nfunction g7(e, t) {\n  if (Oo(e) !== \"object\" || e === null)\n    return e;\n  var n = e[Symbol.toPrimitive];\n  if (n !== void 0) {\n    var r = n.call(e, t || \"default\");\n    if (Oo(r) !== \"object\")\n      return r;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (t === \"string\" ? String : Number)(e);\n}\nfunction v7(e, t) {\n  return b7(e) || y7(e, t) || ow(e, t) || m7();\n}\nfunction m7() {\n  throw new TypeError(`Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);\n}\nfunction ow(e, t) {\n  if (e) {\n    if (typeof e == \"string\")\n      return Ol(e, t);\n    var n = Object.prototype.toString.call(e).slice(8, -1);\n    if (n === \"Object\" && e.constructor && (n = e.constructor.name), n === \"Map\" || n === \"Set\")\n      return Array.from(e);\n    if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))\n      return Ol(e, t);\n  }\n}\nfunction Ol(e, t) {\n  (t == null || t > e.length) && (t = e.length);\n  for (var n = 0, r = new Array(t); n < t; n++)\n    r[n] = e[n];\n  return r;\n}\nfunction y7(e, t) {\n  var n = e == null ? null : typeof Symbol < \"u\" && e[Symbol.iterator] || e[\"@@iterator\"];\n  if (n != null) {\n    var r, i, o, a, s = [], u = !0, c = !1;\n    try {\n      if (o = (n = n.call(e)).next, t !== 0)\n        for (; !(u = (r = o.call(n)).done) && (s.push(r.value), s.length !== t); u = !0)\n          ;\n    } catch (f) {\n      c = !0, i = f;\n    } finally {\n      try {\n        if (!u && n.return != null && (a = n.return(), Object(a) !== a))\n          return;\n      } finally {\n        if (c)\n          throw i;\n      }\n    }\n    return s;\n  }\n}\nfunction b7(e) {\n  if (Array.isArray(e))\n    return e;\n}\nvar vs = function(t, n, r) {\n  return t + (n - t) * r;\n}, _l = function(t) {\n  var n = t.from, r = t.to;\n  return n !== r;\n}, w7 = function e(t, n, r) {\n  var i = Hi(function(o, a) {\n    if (_l(a)) {\n      var s = t(a.from, a.to, a.velocity), u = v7(s, 2), c = u[0], f = u[1];\n      return tt(tt({}, a), {}, {\n        from: c,\n        velocity: f\n      });\n    }\n    return a;\n  }, n);\n  return r < 1 ? Hi(function(o, a) {\n    return _l(a) ? tt(tt({}, a), {}, {\n      velocity: vs(a.velocity, i[o].velocity, r),\n      from: vs(a.from, i[o].from, r)\n    }) : a;\n  }, n) : e(t, i, r - 1);\n};\nconst x7 = function(e, t, n, r, i) {\n  var o = Xz(e, t), a = o.reduce(function(v, w) {\n    return tt(tt({}, v), {}, $l({}, w, [e[w], t[w]]));\n  }, {}), s = o.reduce(function(v, w) {\n    return tt(tt({}, v), {}, $l({}, w, {\n      from: e[w],\n      velocity: 0,\n      to: t[w]\n    }));\n  }, {}), u = -1, c, f, l = function() {\n    return null;\n  }, d = function() {\n    return Hi(function(w, b) {\n      return b.from;\n    }, s);\n  }, p = function() {\n    return !Object.values(s).filter(_l).length;\n  }, g = function(w) {\n    c || (c = w);\n    var b = w - c, x = b / n.dt;\n    s = w7(n, s, x), i(tt(tt(tt({}, e), t), d())), c = w, p() || (u = requestAnimationFrame(l));\n  }, h = function(w) {\n    f || (f = w);\n    var b = (w - f) / r, x = Hi(function(y, S) {\n      return vs.apply(void 0, cv(S).concat([n(b)]));\n    }, a);\n    if (i(tt(tt(tt({}, e), t), x)), b < 1)\n      u = requestAnimationFrame(l);\n    else {\n      var m = Hi(function(y, S) {\n        return vs.apply(void 0, cv(S).concat([n(1)]));\n      }, a);\n      i(tt(tt(tt({}, e), t), m));\n    }\n  };\n  return l = n.isStepper ? g : h, function() {\n    return requestAnimationFrame(l), function() {\n      cancelAnimationFrame(u);\n    };\n  };\n};\nfunction Kr(e) {\n  \"@babel/helpers - typeof\";\n  return Kr = typeof Symbol == \"function\" && typeof Symbol.iterator == \"symbol\" ? function(t) {\n    return typeof t;\n  } : function(t) {\n    return t && typeof Symbol == \"function\" && t.constructor === Symbol && t !== Symbol.prototype ? \"symbol\" : typeof t;\n  }, Kr(e);\n}\nvar S7 = [\"children\", \"begin\", \"duration\", \"attributeName\", \"easing\", \"isActive\", \"steps\", \"from\", \"to\", \"canBegin\", \"onAnimationEnd\", \"shouldReAnimate\", \"onAnimationReStart\"];\nfunction $7(e, t) {\n  if (e == null)\n    return {};\n  var n = O7(e, t), r, i;\n  if (Object.getOwnPropertySymbols) {\n    var o = Object.getOwnPropertySymbols(e);\n    for (i = 0; i < o.length; i++)\n      r = o[i], !(t.indexOf(r) >= 0) && Object.prototype.propertyIsEnumerable.call(e, r) && (n[r] = e[r]);\n  }\n  return n;\n}\nfunction O7(e, t) {\n  if (e == null)\n    return {};\n  var n = {}, r = Object.keys(e), i, o;\n  for (o = 0; o < r.length; o++)\n    i = r[o], !(t.indexOf(i) >= 0) && (n[i] = e[i]);\n  return n;\n}\nfunction ec(e) {\n  return C7(e) || P7(e) || A7(e) || _7();\n}\nfunction _7() {\n  throw new TypeError(`Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);\n}\nfunction A7(e, t) {\n  if (e) {\n    if (typeof e == \"string\")\n      return Al(e, t);\n    var n = Object.prototype.toString.call(e).slice(8, -1);\n    if (n === \"Object\" && e.constructor && (n = e.constructor.name), n === \"Map\" || n === \"Set\")\n      return Array.from(e);\n    if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))\n      return Al(e, t);\n  }\n}\nfunction P7(e) {\n  if (typeof Symbol < \"u\" && e[Symbol.iterator] != null || e[\"@@iterator\"] != null)\n    return Array.from(e);\n}\nfunction C7(e) {\n  if (Array.isArray(e))\n    return Al(e);\n}\nfunction Al(e, t) {\n  (t == null || t > e.length) && (t = e.length);\n  for (var n = 0, r = new Array(t); n < t; n++)\n    r[n] = e[n];\n  return r;\n}\nfunction fv(e, t) {\n  var n = Object.keys(e);\n  if (Object.getOwnPropertySymbols) {\n    var r = Object.getOwnPropertySymbols(e);\n    t && (r = r.filter(function(i) {\n      return Object.getOwnPropertyDescriptor(e, i).enumerable;\n    })), n.push.apply(n, r);\n  }\n  return n;\n}\nfunction Gt(e) {\n  for (var t = 1; t < arguments.length; t++) {\n    var n = arguments[t] != null ? arguments[t] : {};\n    t % 2 ? fv(Object(n), !0).forEach(function(r) {\n      zi(e, r, n[r]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : fv(Object(n)).forEach(function(r) {\n      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));\n    });\n  }\n  return e;\n}\nfunction zi(e, t, n) {\n  return t = aw(t), t in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;\n}\nfunction E7(e, t) {\n  if (!(e instanceof t))\n    throw new TypeError(\"Cannot call a class as a function\");\n}\nfunction T7(e, t) {\n  for (var n = 0; n < t.length; n++) {\n    var r = t[n];\n    r.enumerable = r.enumerable || !1, r.configurable = !0, \"value\" in r && (r.writable = !0), Object.defineProperty(e, aw(r.key), r);\n  }\n}\nfunction M7(e, t, n) {\n  return t && T7(e.prototype, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e;\n}\nfunction aw(e) {\n  var t = R7(e, \"string\");\n  return Kr(t) === \"symbol\" ? t : String(t);\n}\nfunction R7(e, t) {\n  if (Kr(e) !== \"object\" || e === null)\n    return e;\n  var n = e[Symbol.toPrimitive];\n  if (n !== void 0) {\n    var r = n.call(e, t || \"default\");\n    if (Kr(r) !== \"object\")\n      return r;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (t === \"string\" ? String : Number)(e);\n}\nfunction I7(e, t) {\n  if (typeof t != \"function\" && t !== null)\n    throw new TypeError(\"Super expression must either be null or a function\");\n  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, writable: !0, configurable: !0 } }), Object.defineProperty(e, \"prototype\", { writable: !1 }), t && Pl(e, t);\n}\nfunction Pl(e, t) {\n  return Pl = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(r, i) {\n    return r.__proto__ = i, r;\n  }, Pl(e, t);\n}\nfunction j7(e) {\n  var t = k7();\n  return function() {\n    var r = ms(e), i;\n    if (t) {\n      var o = ms(this).constructor;\n      i = Reflect.construct(r, arguments, o);\n    } else\n      i = r.apply(this, arguments);\n    return Cl(this, i);\n  };\n}\nfunction Cl(e, t) {\n  if (t && (Kr(t) === \"object\" || typeof t == \"function\"))\n    return t;\n  if (t !== void 0)\n    throw new TypeError(\"Derived constructors may only return object or undefined\");\n  return El(e);\n}\nfunction El(e) {\n  if (e === void 0)\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  return e;\n}\nfunction k7() {\n  if (typeof Reflect > \"u\" || !Reflect.construct || Reflect.construct.sham)\n    return !1;\n  if (typeof Proxy == \"function\")\n    return !0;\n  try {\n    return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {\n    })), !0;\n  } catch {\n    return !1;\n  }\n}\nfunction ms(e) {\n  return ms = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(n) {\n    return n.__proto__ || Object.getPrototypeOf(n);\n  }, ms(e);\n}\nvar _n = /* @__PURE__ */ function(e) {\n  I7(n, e);\n  var t = j7(n);\n  function n(r, i) {\n    var o;\n    E7(this, n), o = t.call(this, r, i);\n    var a = o.props, s = a.isActive, u = a.attributeName, c = a.from, f = a.to, l = a.steps, d = a.children, p = a.duration;\n    if (o.handleStyleChange = o.handleStyleChange.bind(El(o)), o.changeStyle = o.changeStyle.bind(El(o)), !s || p <= 0)\n      return o.state = {\n        style: {}\n      }, typeof d == \"function\" && (o.state = {\n        style: f\n      }), Cl(o);\n    if (l && l.length)\n      o.state = {\n        style: l[0].style\n      };\n    else if (c) {\n      if (typeof d == \"function\")\n        return o.state = {\n          style: c\n        }, Cl(o);\n      o.state = {\n        style: u ? zi({}, u, c) : c\n      };\n    } else\n      o.state = {\n        style: {}\n      };\n    return o;\n  }\n  return M7(n, [{\n    key: \"componentDidMount\",\n    value: function() {\n      var i = this.props, o = i.isActive, a = i.canBegin;\n      this.mounted = !0, !(!o || !a) && this.runAnimation(this.props);\n    }\n  }, {\n    key: \"componentDidUpdate\",\n    value: function(i) {\n      var o = this.props, a = o.isActive, s = o.canBegin, u = o.attributeName, c = o.shouldReAnimate, f = o.to, l = o.from, d = this.state.style;\n      if (s) {\n        if (!a) {\n          var p = {\n            style: u ? zi({}, u, f) : f\n          };\n          this.state && d && (u && d[u] !== f || !u && d !== f) && this.setState(p);\n          return;\n        }\n        if (!(Bz(i.to, f) && i.canBegin && i.isActive)) {\n          var g = !i.canBegin || !i.isActive;\n          this.manager && this.manager.stop(), this.stopJSAnimation && this.stopJSAnimation();\n          var h = g || c ? l : i.to;\n          if (this.state && d) {\n            var v = {\n              style: u ? zi({}, u, h) : h\n            };\n            (u && d[u] !== h || !u && d !== h) && this.setState(v);\n          }\n          this.runAnimation(Gt(Gt({}, this.props), {}, {\n            from: h,\n            begin: 0\n          }));\n        }\n      }\n    }\n  }, {\n    key: \"componentWillUnmount\",\n    value: function() {\n      this.mounted = !1;\n      var i = this.props.onAnimationEnd;\n      this.unSubscribe && this.unSubscribe(), this.manager && (this.manager.stop(), this.manager = null), this.stopJSAnimation && this.stopJSAnimation(), i && i();\n    }\n  }, {\n    key: \"handleStyleChange\",\n    value: function(i) {\n      this.changeStyle(i);\n    }\n  }, {\n    key: \"changeStyle\",\n    value: function(i) {\n      this.mounted && this.setState({\n        style: i\n      });\n    }\n  }, {\n    key: \"runJSAnimation\",\n    value: function(i) {\n      var o = this, a = i.from, s = i.to, u = i.duration, c = i.easing, f = i.begin, l = i.onAnimationEnd, d = i.onAnimationStart, p = x7(a, s, l7(c), u, this.changeStyle), g = function() {\n        o.stopJSAnimation = p();\n      };\n      this.manager.start([d, f, g, u, l]);\n    }\n  }, {\n    key: \"runStepAnimation\",\n    value: function(i) {\n      var o = this, a = i.steps, s = i.begin, u = i.onAnimationStart, c = a[0], f = c.style, l = c.duration, d = l === void 0 ? 0 : l, p = function(h, v, w) {\n        if (w === 0)\n          return h;\n        var b = v.duration, x = v.easing, m = x === void 0 ? \"ease\" : x, y = v.style, S = v.properties, $ = v.onAnimationEnd, O = w > 0 ? a[w - 1] : v, T = S || Object.keys(y);\n        if (typeof m == \"function\" || m === \"spring\")\n          return [].concat(ec(h), [o.runJSAnimation.bind(o, {\n            from: O.style,\n            to: y,\n            duration: b,\n            easing: m\n          }), b]);\n        var M = av(T, b, m), E = Gt(Gt(Gt({}, O.style), y), {}, {\n          transition: M\n        });\n        return [].concat(ec(h), [E, b, $]).filter(Zz);\n      };\n      return this.manager.start([u].concat(ec(a.reduce(p, [f, Math.max(d, s)])), [i.onAnimationEnd]));\n    }\n  }, {\n    key: \"runAnimation\",\n    value: function(i) {\n      this.manager || (this.manager = qz());\n      var o = i.begin, a = i.duration, s = i.attributeName, u = i.to, c = i.easing, f = i.onAnimationStart, l = i.onAnimationEnd, d = i.steps, p = i.children, g = this.manager;\n      if (this.unSubscribe = g.subscribe(this.handleStyleChange), typeof c == \"function\" || typeof p == \"function\" || c === \"spring\") {\n        this.runJSAnimation(i);\n        return;\n      }\n      if (d.length > 1) {\n        this.runStepAnimation(i);\n        return;\n      }\n      var h = s ? zi({}, s, u) : u, v = av(Object.keys(h), a, c);\n      g.start([f, o, Gt(Gt({}, h), {}, {\n        transition: v\n      }), a, l]);\n    }\n  }, {\n    key: \"render\",\n    value: function() {\n      var i = this.props, o = i.children;\n      i.begin;\n      var a = i.duration;\n      i.attributeName, i.easing;\n      var s = i.isActive;\n      i.steps, i.from, i.to, i.canBegin, i.onAnimationEnd, i.shouldReAnimate, i.onAnimationReStart;\n      var u = $7(i, S7), c = react__WEBPACK_IMPORTED_MODULE_0__.Children.count(o), f = this.state.style;\n      if (typeof o == \"function\")\n        return o(f);\n      if (!s || c === 0 || a <= 0)\n        return o;\n      var l = function(p) {\n        var g = p.props, h = g.style, v = h === void 0 ? {} : h, w = g.className, b = /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.cloneElement)(p, Gt(Gt({}, u), {}, {\n          style: Gt(Gt({}, v), f),\n          className: w\n        }));\n        return b;\n      };\n      return c === 1 ? l(react__WEBPACK_IMPORTED_MODULE_0__.Children.only(o)) : /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", null, react__WEBPACK_IMPORTED_MODULE_0__.Children.map(o, function(d) {\n        return l(d);\n      }));\n    }\n  }]), n;\n}(react__WEBPACK_IMPORTED_MODULE_0__.PureComponent);\n_n.displayName = \"Animate\";\n_n.defaultProps = {\n  begin: 0,\n  duration: 1e3,\n  from: \"\",\n  to: \"\",\n  attributeName: \"\",\n  easing: \"ease\",\n  isActive: !0,\n  canBegin: !0,\n  steps: [],\n  onAnimationEnd: function() {\n  },\n  onAnimationStart: function() {\n  }\n};\n_n.propTypes = {\n  from: de.oneOfType([de.object, de.string]),\n  to: de.oneOfType([de.object, de.string]),\n  attributeName: de.string,\n  // animation duration\n  duration: de.number,\n  begin: de.number,\n  easing: de.oneOfType([de.string, de.func]),\n  steps: de.arrayOf(de.shape({\n    duration: de.number.isRequired,\n    style: de.object.isRequired,\n    easing: de.oneOfType([de.oneOf([\"ease\", \"ease-in\", \"ease-out\", \"ease-in-out\", \"linear\"]), de.func]),\n    // transition css properties(dash case), optional\n    properties: de.arrayOf(\"string\"),\n    onAnimationEnd: de.func\n  })),\n  children: de.oneOfType([de.node, de.func]),\n  isActive: de.bool,\n  canBegin: de.bool,\n  onAnimationEnd: de.func,\n  // decide if it should reanimate with initial from style when props change\n  shouldReAnimate: de.bool,\n  onAnimationStart: de.func,\n  onAnimationReStart: de.func\n};\nde.object, de.object, de.object, de.element;\nde.object, de.object, de.object, de.oneOfType([de.array, de.element]), de.any;\nfunction _o(e) {\n  \"@babel/helpers - typeof\";\n  return _o = typeof Symbol == \"function\" && typeof Symbol.iterator == \"symbol\" ? function(t) {\n    return typeof t;\n  } : function(t) {\n    return t && typeof Symbol == \"function\" && t.constructor === Symbol && t !== Symbol.prototype ? \"symbol\" : typeof t;\n  }, _o(e);\n}\nfunction ys() {\n  return ys = Object.assign ? Object.assign.bind() : function(e) {\n    for (var t = 1; t < arguments.length; t++) {\n      var n = arguments[t];\n      for (var r in n)\n        Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);\n    }\n    return e;\n  }, ys.apply(this, arguments);\n}\nfunction D7(e, t) {\n  return B7(e) || L7(e, t) || F7(e, t) || N7();\n}\nfunction N7() {\n  throw new TypeError(`Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);\n}\nfunction F7(e, t) {\n  if (e) {\n    if (typeof e == \"string\")\n      return dv(e, t);\n    var n = Object.prototype.toString.call(e).slice(8, -1);\n    if (n === \"Object\" && e.constructor && (n = e.constructor.name), n === \"Map\" || n === \"Set\")\n      return Array.from(e);\n    if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))\n      return dv(e, t);\n  }\n}\nfunction dv(e, t) {\n  (t == null || t > e.length) && (t = e.length);\n  for (var n = 0, r = new Array(t); n < t; n++)\n    r[n] = e[n];\n  return r;\n}\nfunction L7(e, t) {\n  var n = e == null ? null : typeof Symbol < \"u\" && e[Symbol.iterator] || e[\"@@iterator\"];\n  if (n != null) {\n    var r, i, o, a, s = [], u = !0, c = !1;\n    try {\n      if (o = (n = n.call(e)).next, t !== 0)\n        for (; !(u = (r = o.call(n)).done) && (s.push(r.value), s.length !== t); u = !0)\n          ;\n    } catch (f) {\n      c = !0, i = f;\n    } finally {\n      try {\n        if (!u && n.return != null && (a = n.return(), Object(a) !== a))\n          return;\n      } finally {\n        if (c)\n          throw i;\n      }\n    }\n    return s;\n  }\n}\nfunction B7(e) {\n  if (Array.isArray(e))\n    return e;\n}\nfunction pv(e, t) {\n  var n = Object.keys(e);\n  if (Object.getOwnPropertySymbols) {\n    var r = Object.getOwnPropertySymbols(e);\n    t && (r = r.filter(function(i) {\n      return Object.getOwnPropertyDescriptor(e, i).enumerable;\n    })), n.push.apply(n, r);\n  }\n  return n;\n}\nfunction hv(e) {\n  for (var t = 1; t < arguments.length; t++) {\n    var n = arguments[t] != null ? arguments[t] : {};\n    t % 2 ? pv(Object(n), !0).forEach(function(r) {\n      z7(e, r, n[r]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : pv(Object(n)).forEach(function(r) {\n      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));\n    });\n  }\n  return e;\n}\nfunction z7(e, t, n) {\n  return t = V7(t), t in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;\n}\nfunction V7(e) {\n  var t = G7(e, \"string\");\n  return _o(t) == \"symbol\" ? t : String(t);\n}\nfunction G7(e, t) {\n  if (_o(e) != \"object\" || !e)\n    return e;\n  var n = e[Symbol.toPrimitive];\n  if (n !== void 0) {\n    var r = n.call(e, t || \"default\");\n    if (_o(r) != \"object\")\n      return r;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (t === \"string\" ? String : Number)(e);\n}\nvar gv = function(t, n, r, i, o) {\n  var a = Math.min(Math.abs(r) / 2, Math.abs(i) / 2), s = i >= 0 ? 1 : -1, u = r >= 0 ? 1 : -1, c = i >= 0 && r >= 0 || i < 0 && r < 0 ? 1 : 0, f;\n  if (a > 0 && o instanceof Array) {\n    for (var l = [0, 0, 0, 0], d = 0, p = 4; d < p; d++)\n      l[d] = o[d] > a ? a : o[d];\n    f = \"M\".concat(t, \",\").concat(n + s * l[0]), l[0] > 0 && (f += \"A \".concat(l[0], \",\").concat(l[0], \",0,0,\").concat(c, \",\").concat(t + u * l[0], \",\").concat(n)), f += \"L \".concat(t + r - u * l[1], \",\").concat(n), l[1] > 0 && (f += \"A \".concat(l[1], \",\").concat(l[1], \",0,0,\").concat(c, `,\n        `).concat(t + r, \",\").concat(n + s * l[1])), f += \"L \".concat(t + r, \",\").concat(n + i - s * l[2]), l[2] > 0 && (f += \"A \".concat(l[2], \",\").concat(l[2], \",0,0,\").concat(c, `,\n        `).concat(t + r - u * l[2], \",\").concat(n + i)), f += \"L \".concat(t + u * l[3], \",\").concat(n + i), l[3] > 0 && (f += \"A \".concat(l[3], \",\").concat(l[3], \",0,0,\").concat(c, `,\n        `).concat(t, \",\").concat(n + i - s * l[3])), f += \"Z\";\n  } else if (a > 0 && o === +o && o > 0) {\n    var g = Math.min(a, o);\n    f = \"M \".concat(t, \",\").concat(n + s * g, `\n            A `).concat(g, \",\").concat(g, \",0,0,\").concat(c, \",\").concat(t + u * g, \",\").concat(n, `\n            L `).concat(t + r - u * g, \",\").concat(n, `\n            A `).concat(g, \",\").concat(g, \",0,0,\").concat(c, \",\").concat(t + r, \",\").concat(n + s * g, `\n            L `).concat(t + r, \",\").concat(n + i - s * g, `\n            A `).concat(g, \",\").concat(g, \",0,0,\").concat(c, \",\").concat(t + r - u * g, \",\").concat(n + i, `\n            L `).concat(t + u * g, \",\").concat(n + i, `\n            A `).concat(g, \",\").concat(g, \",0,0,\").concat(c, \",\").concat(t, \",\").concat(n + i - s * g, \" Z\");\n  } else\n    f = \"M \".concat(t, \",\").concat(n, \" h \").concat(r, \" v \").concat(i, \" h \").concat(-r, \" Z\");\n  return f;\n}, W7 = function(t, n) {\n  if (!t || !n)\n    return !1;\n  var r = t.x, i = t.y, o = n.x, a = n.y, s = n.width, u = n.height;\n  if (Math.abs(s) > 0 && Math.abs(u) > 0) {\n    var c = Math.min(o, o + s), f = Math.max(o, o + s), l = Math.min(a, a + u), d = Math.max(a, a + u);\n    return r >= c && r <= f && i >= l && i <= d;\n  }\n  return !1;\n}, U7 = {\n  x: 0,\n  y: 0,\n  width: 0,\n  height: 0,\n  // The radius of border\n  // The radius of four corners when radius is a number\n  // The radius of left-top, right-top, right-bottom, left-bottom when radius is an array\n  radius: 0,\n  isAnimationActive: !1,\n  isUpdateAnimationActive: !1,\n  animationBegin: 0,\n  animationDuration: 1500,\n  animationEasing: \"ease\"\n}, dd = function(t) {\n  var n = hv(hv({}, U7), t), r = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(), i = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(-1), o = D7(i, 2), a = o[0], s = o[1];\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(function() {\n    if (r.current && r.current.getTotalLength)\n      try {\n        var m = r.current.getTotalLength();\n        m && s(m);\n      } catch {\n      }\n  }, []);\n  var u = n.x, c = n.y, f = n.width, l = n.height, d = n.radius, p = n.className, g = n.animationEasing, h = n.animationDuration, v = n.animationBegin, w = n.isAnimationActive, b = n.isUpdateAnimationActive;\n  if (u !== +u || c !== +c || f !== +f || l !== +l || f === 0 || l === 0)\n    return null;\n  var x = $e(\"recharts-rectangle\", p);\n  return b ? /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(_n, {\n    canBegin: a > 0,\n    from: {\n      width: f,\n      height: l,\n      x: u,\n      y: c\n    },\n    to: {\n      width: f,\n      height: l,\n      x: u,\n      y: c\n    },\n    duration: h,\n    animationEasing: g,\n    isActive: b\n  }, function(m) {\n    var y = m.width, S = m.height, $ = m.x, O = m.y;\n    return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(_n, {\n      canBegin: a > 0,\n      from: \"0px \".concat(a === -1 ? 1 : a, \"px\"),\n      to: \"\".concat(a, \"px 0px\"),\n      attributeName: \"strokeDasharray\",\n      begin: v,\n      duration: h,\n      isActive: w,\n      easing: g\n    }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"path\", ys({}, ye(n, !0), {\n      className: x,\n      d: gv($, O, y, S, d),\n      ref: r\n    })));\n  }) : /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"path\", ys({}, ye(n, !0), {\n    className: x,\n    d: gv(u, c, f, l, d)\n  }));\n};\nfunction Tl() {\n  return Tl = Object.assign ? Object.assign.bind() : function(e) {\n    for (var t = 1; t < arguments.length; t++) {\n      var n = arguments[t];\n      for (var r in n)\n        Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);\n    }\n    return e;\n  }, Tl.apply(this, arguments);\n}\nvar pd = function(t) {\n  var n = t.cx, r = t.cy, i = t.r, o = t.className, a = $e(\"recharts-dot\", o);\n  return n === +n && r === +r && i === +i ? /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"circle\", Tl({}, ye(t, !1), Na(t), {\n    className: a,\n    cx: n,\n    cy: r,\n    r: i\n  })) : null;\n};\nfunction Ao(e) {\n  \"@babel/helpers - typeof\";\n  return Ao = typeof Symbol == \"function\" && typeof Symbol.iterator == \"symbol\" ? function(t) {\n    return typeof t;\n  } : function(t) {\n    return t && typeof Symbol == \"function\" && t.constructor === Symbol && t !== Symbol.prototype ? \"symbol\" : typeof t;\n  }, Ao(e);\n}\nvar H7 = [\"x\", \"y\", \"top\", \"left\", \"width\", \"height\", \"className\"];\nfunction Ml() {\n  return Ml = Object.assign ? Object.assign.bind() : function(e) {\n    for (var t = 1; t < arguments.length; t++) {\n      var n = arguments[t];\n      for (var r in n)\n        Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);\n    }\n    return e;\n  }, Ml.apply(this, arguments);\n}\nfunction vv(e, t) {\n  var n = Object.keys(e);\n  if (Object.getOwnPropertySymbols) {\n    var r = Object.getOwnPropertySymbols(e);\n    t && (r = r.filter(function(i) {\n      return Object.getOwnPropertyDescriptor(e, i).enumerable;\n    })), n.push.apply(n, r);\n  }\n  return n;\n}\nfunction q7(e) {\n  for (var t = 1; t < arguments.length; t++) {\n    var n = arguments[t] != null ? arguments[t] : {};\n    t % 2 ? vv(Object(n), !0).forEach(function(r) {\n      K7(e, r, n[r]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : vv(Object(n)).forEach(function(r) {\n      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));\n    });\n  }\n  return e;\n}\nfunction K7(e, t, n) {\n  return t = Y7(t), t in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;\n}\nfunction Y7(e) {\n  var t = X7(e, \"string\");\n  return Ao(t) == \"symbol\" ? t : String(t);\n}\nfunction X7(e, t) {\n  if (Ao(e) != \"object\" || !e)\n    return e;\n  var n = e[Symbol.toPrimitive];\n  if (n !== void 0) {\n    var r = n.call(e, t || \"default\");\n    if (Ao(r) != \"object\")\n      return r;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (t === \"string\" ? String : Number)(e);\n}\nfunction Z7(e, t) {\n  if (e == null)\n    return {};\n  var n = J7(e, t), r, i;\n  if (Object.getOwnPropertySymbols) {\n    var o = Object.getOwnPropertySymbols(e);\n    for (i = 0; i < o.length; i++)\n      r = o[i], !(t.indexOf(r) >= 0) && Object.prototype.propertyIsEnumerable.call(e, r) && (n[r] = e[r]);\n  }\n  return n;\n}\nfunction J7(e, t) {\n  if (e == null)\n    return {};\n  var n = {}, r = Object.keys(e), i, o;\n  for (o = 0; o < r.length; o++)\n    i = r[o], !(t.indexOf(i) >= 0) && (n[i] = e[i]);\n  return n;\n}\nvar Q7 = function(t, n, r, i, o, a) {\n  return \"M\".concat(t, \",\").concat(o, \"v\").concat(i, \"M\").concat(a, \",\").concat(n, \"h\").concat(r);\n}, e9 = function(t) {\n  var n = t.x, r = n === void 0 ? 0 : n, i = t.y, o = i === void 0 ? 0 : i, a = t.top, s = a === void 0 ? 0 : a, u = t.left, c = u === void 0 ? 0 : u, f = t.width, l = f === void 0 ? 0 : f, d = t.height, p = d === void 0 ? 0 : d, g = t.className, h = Z7(t, H7), v = q7({\n    x: r,\n    y: o,\n    top: s,\n    left: c,\n    width: l,\n    height: p\n  }, h);\n  return !K(r) || !K(o) || !K(l) || !K(p) || !K(s) || !K(c) ? null : /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"path\", Ml({}, ye(v, !0), {\n    className: $e(\"recharts-cross\", g),\n    d: Q7(r, o, l, p, s, c)\n  }));\n}, t9 = Ob, n9 = t9(Object.getPrototypeOf, Object), r9 = n9, i9 = Pn, o9 = r9, a9 = Cn, s9 = \"[object Object]\", u9 = Function.prototype, c9 = Object.prototype, sw = u9.toString, l9 = c9.hasOwnProperty, f9 = sw.call(Object);\nfunction d9(e) {\n  if (!a9(e) || i9(e) != s9)\n    return !1;\n  var t = o9(e);\n  if (t === null)\n    return !0;\n  var n = l9.call(t, \"constructor\") && t.constructor;\n  return typeof n == \"function\" && n instanceof n && sw.call(n) == f9;\n}\nvar p9 = d9;\nconst h9 = /* @__PURE__ */ je(p9);\nvar g9 = Pn, v9 = Cn, m9 = \"[object Boolean]\";\nfunction y9(e) {\n  return e === !0 || e === !1 || v9(e) && g9(e) == m9;\n}\nvar b9 = y9;\nconst w9 = /* @__PURE__ */ je(b9);\nfunction Po(e) {\n  \"@babel/helpers - typeof\";\n  return Po = typeof Symbol == \"function\" && typeof Symbol.iterator == \"symbol\" ? function(t) {\n    return typeof t;\n  } : function(t) {\n    return t && typeof Symbol == \"function\" && t.constructor === Symbol && t !== Symbol.prototype ? \"symbol\" : typeof t;\n  }, Po(e);\n}\nfunction bs() {\n  return bs = Object.assign ? Object.assign.bind() : function(e) {\n    for (var t = 1; t < arguments.length; t++) {\n      var n = arguments[t];\n      for (var r in n)\n        Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);\n    }\n    return e;\n  }, bs.apply(this, arguments);\n}\nfunction x9(e, t) {\n  return _9(e) || O9(e, t) || $9(e, t) || S9();\n}\nfunction S9() {\n  throw new TypeError(`Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);\n}\nfunction $9(e, t) {\n  if (e) {\n    if (typeof e == \"string\")\n      return mv(e, t);\n    var n = Object.prototype.toString.call(e).slice(8, -1);\n    if (n === \"Object\" && e.constructor && (n = e.constructor.name), n === \"Map\" || n === \"Set\")\n      return Array.from(e);\n    if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))\n      return mv(e, t);\n  }\n}\nfunction mv(e, t) {\n  (t == null || t > e.length) && (t = e.length);\n  for (var n = 0, r = new Array(t); n < t; n++)\n    r[n] = e[n];\n  return r;\n}\nfunction O9(e, t) {\n  var n = e == null ? null : typeof Symbol < \"u\" && e[Symbol.iterator] || e[\"@@iterator\"];\n  if (n != null) {\n    var r, i, o, a, s = [], u = !0, c = !1;\n    try {\n      if (o = (n = n.call(e)).next, t !== 0)\n        for (; !(u = (r = o.call(n)).done) && (s.push(r.value), s.length !== t); u = !0)\n          ;\n    } catch (f) {\n      c = !0, i = f;\n    } finally {\n      try {\n        if (!u && n.return != null && (a = n.return(), Object(a) !== a))\n          return;\n      } finally {\n        if (c)\n          throw i;\n      }\n    }\n    return s;\n  }\n}\nfunction _9(e) {\n  if (Array.isArray(e))\n    return e;\n}\nfunction yv(e, t) {\n  var n = Object.keys(e);\n  if (Object.getOwnPropertySymbols) {\n    var r = Object.getOwnPropertySymbols(e);\n    t && (r = r.filter(function(i) {\n      return Object.getOwnPropertyDescriptor(e, i).enumerable;\n    })), n.push.apply(n, r);\n  }\n  return n;\n}\nfunction bv(e) {\n  for (var t = 1; t < arguments.length; t++) {\n    var n = arguments[t] != null ? arguments[t] : {};\n    t % 2 ? yv(Object(n), !0).forEach(function(r) {\n      A9(e, r, n[r]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : yv(Object(n)).forEach(function(r) {\n      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));\n    });\n  }\n  return e;\n}\nfunction A9(e, t, n) {\n  return t = P9(t), t in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;\n}\nfunction P9(e) {\n  var t = C9(e, \"string\");\n  return Po(t) == \"symbol\" ? t : String(t);\n}\nfunction C9(e, t) {\n  if (Po(e) != \"object\" || !e)\n    return e;\n  var n = e[Symbol.toPrimitive];\n  if (n !== void 0) {\n    var r = n.call(e, t || \"default\");\n    if (Po(r) != \"object\")\n      return r;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (t === \"string\" ? String : Number)(e);\n}\nvar wv = function(t, n, r, i, o) {\n  var a = r - i, s;\n  return s = \"M \".concat(t, \",\").concat(n), s += \"L \".concat(t + r, \",\").concat(n), s += \"L \".concat(t + r - a / 2, \",\").concat(n + o), s += \"L \".concat(t + r - a / 2 - i, \",\").concat(n + o), s += \"L \".concat(t, \",\").concat(n, \" Z\"), s;\n}, E9 = {\n  x: 0,\n  y: 0,\n  upperWidth: 0,\n  lowerWidth: 0,\n  height: 0,\n  isUpdateAnimationActive: !1,\n  animationBegin: 0,\n  animationDuration: 1500,\n  animationEasing: \"ease\"\n}, T9 = function(t) {\n  var n = bv(bv({}, E9), t), r = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(), i = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(-1), o = x9(i, 2), a = o[0], s = o[1];\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(function() {\n    if (r.current && r.current.getTotalLength)\n      try {\n        var x = r.current.getTotalLength();\n        x && s(x);\n      } catch {\n      }\n  }, []);\n  var u = n.x, c = n.y, f = n.upperWidth, l = n.lowerWidth, d = n.height, p = n.className, g = n.animationEasing, h = n.animationDuration, v = n.animationBegin, w = n.isUpdateAnimationActive;\n  if (u !== +u || c !== +c || f !== +f || l !== +l || d !== +d || f === 0 && l === 0 || d === 0)\n    return null;\n  var b = $e(\"recharts-trapezoid\", p);\n  return w ? /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(_n, {\n    canBegin: a > 0,\n    from: {\n      upperWidth: 0,\n      lowerWidth: 0,\n      height: d,\n      x: u,\n      y: c\n    },\n    to: {\n      upperWidth: f,\n      lowerWidth: l,\n      height: d,\n      x: u,\n      y: c\n    },\n    duration: h,\n    animationEasing: g,\n    isActive: w\n  }, function(x) {\n    var m = x.upperWidth, y = x.lowerWidth, S = x.height, $ = x.x, O = x.y;\n    return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(_n, {\n      canBegin: a > 0,\n      from: \"0px \".concat(a === -1 ? 1 : a, \"px\"),\n      to: \"\".concat(a, \"px 0px\"),\n      attributeName: \"strokeDasharray\",\n      begin: v,\n      duration: h,\n      easing: g\n    }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"path\", bs({}, ye(n, !0), {\n      className: b,\n      d: wv($, O, m, y, S),\n      ref: r\n    })));\n  }) : /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"g\", null, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"path\", bs({}, ye(n, !0), {\n    className: b,\n    d: wv(u, c, f, l, d)\n  })));\n}, M9 = [\"option\", \"shapeType\", \"propTransformer\", \"activeClassName\", \"isActive\"];\nfunction Co(e) {\n  \"@babel/helpers - typeof\";\n  return Co = typeof Symbol == \"function\" && typeof Symbol.iterator == \"symbol\" ? function(t) {\n    return typeof t;\n  } : function(t) {\n    return t && typeof Symbol == \"function\" && t.constructor === Symbol && t !== Symbol.prototype ? \"symbol\" : typeof t;\n  }, Co(e);\n}\nfunction R9(e, t) {\n  if (e == null)\n    return {};\n  var n = I9(e, t), r, i;\n  if (Object.getOwnPropertySymbols) {\n    var o = Object.getOwnPropertySymbols(e);\n    for (i = 0; i < o.length; i++)\n      r = o[i], !(t.indexOf(r) >= 0) && Object.prototype.propertyIsEnumerable.call(e, r) && (n[r] = e[r]);\n  }\n  return n;\n}\nfunction I9(e, t) {\n  if (e == null)\n    return {};\n  var n = {}, r = Object.keys(e), i, o;\n  for (o = 0; o < r.length; o++)\n    i = r[o], !(t.indexOf(i) >= 0) && (n[i] = e[i]);\n  return n;\n}\nfunction xv(e, t) {\n  var n = Object.keys(e);\n  if (Object.getOwnPropertySymbols) {\n    var r = Object.getOwnPropertySymbols(e);\n    t && (r = r.filter(function(i) {\n      return Object.getOwnPropertyDescriptor(e, i).enumerable;\n    })), n.push.apply(n, r);\n  }\n  return n;\n}\nfunction ws(e) {\n  for (var t = 1; t < arguments.length; t++) {\n    var n = arguments[t] != null ? arguments[t] : {};\n    t % 2 ? xv(Object(n), !0).forEach(function(r) {\n      j9(e, r, n[r]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : xv(Object(n)).forEach(function(r) {\n      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));\n    });\n  }\n  return e;\n}\nfunction j9(e, t, n) {\n  return t = k9(t), t in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;\n}\nfunction k9(e) {\n  var t = D9(e, \"string\");\n  return Co(t) == \"symbol\" ? t : String(t);\n}\nfunction D9(e, t) {\n  if (Co(e) != \"object\" || !e)\n    return e;\n  var n = e[Symbol.toPrimitive];\n  if (n !== void 0) {\n    var r = n.call(e, t || \"default\");\n    if (Co(r) != \"object\")\n      return r;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (t === \"string\" ? String : Number)(e);\n}\nfunction N9(e, t) {\n  return ws(ws({}, t), e);\n}\nfunction F9(e, t) {\n  return e === \"symbols\";\n}\nfunction Sv(e) {\n  var t = e.shapeType, n = e.elementProps;\n  switch (t) {\n    case \"rectangle\":\n      return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(dd, n);\n    case \"trapezoid\":\n      return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(T9, n);\n    case \"sector\":\n      return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(Z0, n);\n    case \"symbols\":\n      if (F9(t))\n        return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(Tf, n);\n      break;\n    default:\n      return null;\n  }\n}\nfunction L9(e) {\n  return /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.isValidElement)(e) ? e.props : e;\n}\nfunction B9(e) {\n  var t = e.option, n = e.shapeType, r = e.propTransformer, i = r === void 0 ? N9 : r, o = e.activeClassName, a = o === void 0 ? \"recharts-active-shape\" : o, s = e.isActive, u = R9(e, M9), c;\n  if (/* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.isValidElement)(t))\n    c = /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.cloneElement)(t, ws(ws({}, u), L9(t)));\n  else if (pe(t))\n    c = t(u);\n  else if (h9(t) && !w9(t)) {\n    var f = i(t, u);\n    c = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(Sv, {\n      shapeType: n,\n      elementProps: f\n    });\n  } else {\n    var l = u;\n    c = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(Sv, {\n      shapeType: n,\n      elementProps: l\n    });\n  }\n  return s ? /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(We, {\n    className: a\n  }, c) : c;\n}\nfunction iu(e, t) {\n  return t != null && \"trapezoids\" in e.props;\n}\nfunction ou(e, t) {\n  return t != null && \"sectors\" in e.props;\n}\nfunction Eo(e, t) {\n  return t != null && \"points\" in e.props;\n}\nfunction z9(e, t) {\n  var n, r, i = e.x === (t == null || (n = t.labelViewBox) === null || n === void 0 ? void 0 : n.x) || e.x === t.x, o = e.y === (t == null || (r = t.labelViewBox) === null || r === void 0 ? void 0 : r.y) || e.y === t.y;\n  return i && o;\n}\nfunction V9(e, t) {\n  var n = e.endAngle === t.endAngle, r = e.startAngle === t.startAngle;\n  return n && r;\n}\nfunction G9(e, t) {\n  var n = e.x === t.x, r = e.y === t.y, i = e.z === t.z;\n  return n && r && i;\n}\nfunction W9(e, t) {\n  var n;\n  return iu(e, t) ? n = z9 : ou(e, t) ? n = V9 : Eo(e, t) && (n = G9), n;\n}\nfunction U9(e, t) {\n  var n;\n  return iu(e, t) ? n = \"trapezoids\" : ou(e, t) ? n = \"sectors\" : Eo(e, t) && (n = \"points\"), n;\n}\nfunction H9(e, t) {\n  if (iu(e, t)) {\n    var n;\n    return (n = t.tooltipPayload) === null || n === void 0 || (n = n[0]) === null || n === void 0 || (n = n.payload) === null || n === void 0 ? void 0 : n.payload;\n  }\n  if (ou(e, t)) {\n    var r;\n    return (r = t.tooltipPayload) === null || r === void 0 || (r = r[0]) === null || r === void 0 || (r = r.payload) === null || r === void 0 ? void 0 : r.payload;\n  }\n  return Eo(e, t) ? t.payload : {};\n}\nfunction q9(e) {\n  var t = e.activeTooltipItem, n = e.graphicalItem, r = e.itemData, i = U9(n, t), o = H9(n, t), a = r.filter(function(u, c) {\n    var f = tu(o, u), l = n.props[i].filter(function(g) {\n      var h = W9(n, t);\n      return h(g, t);\n    }), d = n.props[i].indexOf(l[l.length - 1]), p = c === d;\n    return f && p;\n  }), s = r.indexOf(a[a.length - 1]);\n  return s;\n}\nvar K9 = Math.ceil, Y9 = Math.max;\nfunction X9(e, t, n, r) {\n  for (var i = -1, o = Y9(K9((t - e) / (n || 1)), 0), a = Array(o); o--; )\n    a[r ? o : ++i] = e, e += n;\n  return a;\n}\nvar Z9 = X9, J9 = Wb, $v = 1 / 0, Q9 = 17976931348623157e292;\nfunction eV(e) {\n  if (!e)\n    return e === 0 ? e : 0;\n  if (e = J9(e), e === $v || e === -$v) {\n    var t = e < 0 ? -1 : 1;\n    return t * Q9;\n  }\n  return e === e ? e : 0;\n}\nvar uw = eV, tV = Z9, nV = Hs, tc = uw;\nfunction rV(e) {\n  return function(t, n, r) {\n    return r && typeof r != \"number\" && nV(t, n, r) && (n = r = void 0), t = tc(t), n === void 0 ? (n = t, t = 0) : n = tc(n), r = r === void 0 ? t < n ? 1 : -1 : tc(r), tV(t, n, r, e);\n  };\n}\nvar iV = rV, oV = iV, aV = oV(), sV = aV;\nconst xs = /* @__PURE__ */ je(sV);\nfunction To(e) {\n  \"@babel/helpers - typeof\";\n  return To = typeof Symbol == \"function\" && typeof Symbol.iterator == \"symbol\" ? function(t) {\n    return typeof t;\n  } : function(t) {\n    return t && typeof Symbol == \"function\" && t.constructor === Symbol && t !== Symbol.prototype ? \"symbol\" : typeof t;\n  }, To(e);\n}\nfunction Ov(e, t) {\n  var n = Object.keys(e);\n  if (Object.getOwnPropertySymbols) {\n    var r = Object.getOwnPropertySymbols(e);\n    t && (r = r.filter(function(i) {\n      return Object.getOwnPropertyDescriptor(e, i).enumerable;\n    })), n.push.apply(n, r);\n  }\n  return n;\n}\nfunction _v(e) {\n  for (var t = 1; t < arguments.length; t++) {\n    var n = arguments[t] != null ? arguments[t] : {};\n    t % 2 ? Ov(Object(n), !0).forEach(function(r) {\n      cw(e, r, n[r]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Ov(Object(n)).forEach(function(r) {\n      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));\n    });\n  }\n  return e;\n}\nfunction cw(e, t, n) {\n  return t = uV(t), t in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;\n}\nfunction uV(e) {\n  var t = cV(e, \"string\");\n  return To(t) == \"symbol\" ? t : String(t);\n}\nfunction cV(e, t) {\n  if (To(e) != \"object\" || !e)\n    return e;\n  var n = e[Symbol.toPrimitive];\n  if (n !== void 0) {\n    var r = n.call(e, t || \"default\");\n    if (To(r) != \"object\")\n      return r;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (t === \"string\" ? String : Number)(e);\n}\nvar lV = [\"Webkit\", \"Moz\", \"O\", \"ms\"], fV = function(t, n) {\n  var r = t.replace(/(\\w)/, function(o) {\n    return o.toUpperCase();\n  }), i = lV.reduce(function(o, a) {\n    return _v(_v({}, o), {}, cw({}, a + r, n));\n  }, {});\n  return i[t] = n, i;\n};\nfunction Yr(e) {\n  \"@babel/helpers - typeof\";\n  return Yr = typeof Symbol == \"function\" && typeof Symbol.iterator == \"symbol\" ? function(t) {\n    return typeof t;\n  } : function(t) {\n    return t && typeof Symbol == \"function\" && t.constructor === Symbol && t !== Symbol.prototype ? \"symbol\" : typeof t;\n  }, Yr(e);\n}\nfunction Ss() {\n  return Ss = Object.assign ? Object.assign.bind() : function(e) {\n    for (var t = 1; t < arguments.length; t++) {\n      var n = arguments[t];\n      for (var r in n)\n        Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);\n    }\n    return e;\n  }, Ss.apply(this, arguments);\n}\nfunction Av(e, t) {\n  var n = Object.keys(e);\n  if (Object.getOwnPropertySymbols) {\n    var r = Object.getOwnPropertySymbols(e);\n    t && (r = r.filter(function(i) {\n      return Object.getOwnPropertyDescriptor(e, i).enumerable;\n    })), n.push.apply(n, r);\n  }\n  return n;\n}\nfunction nc(e) {\n  for (var t = 1; t < arguments.length; t++) {\n    var n = arguments[t] != null ? arguments[t] : {};\n    t % 2 ? Av(Object(n), !0).forEach(function(r) {\n      bt(e, r, n[r]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Av(Object(n)).forEach(function(r) {\n      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));\n    });\n  }\n  return e;\n}\nfunction dV(e, t) {\n  if (!(e instanceof t))\n    throw new TypeError(\"Cannot call a class as a function\");\n}\nfunction Pv(e, t) {\n  for (var n = 0; n < t.length; n++) {\n    var r = t[n];\n    r.enumerable = r.enumerable || !1, r.configurable = !0, \"value\" in r && (r.writable = !0), Object.defineProperty(e, fw(r.key), r);\n  }\n}\nfunction pV(e, t, n) {\n  return t && Pv(e.prototype, t), n && Pv(e, n), Object.defineProperty(e, \"prototype\", { writable: !1 }), e;\n}\nfunction hV(e, t, n) {\n  return t = $s(t), gV(e, lw() ? Reflect.construct(t, n || [], $s(e).constructor) : t.apply(e, n));\n}\nfunction gV(e, t) {\n  if (t && (Yr(t) === \"object\" || typeof t == \"function\"))\n    return t;\n  if (t !== void 0)\n    throw new TypeError(\"Derived constructors may only return object or undefined\");\n  return en(e);\n}\nfunction lw() {\n  try {\n    var e = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {\n    }));\n  } catch {\n  }\n  return (lw = function() {\n    return !!e;\n  })();\n}\nfunction $s(e) {\n  return $s = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(n) {\n    return n.__proto__ || Object.getPrototypeOf(n);\n  }, $s(e);\n}\nfunction en(e) {\n  if (e === void 0)\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  return e;\n}\nfunction vV(e, t) {\n  if (typeof t != \"function\" && t !== null)\n    throw new TypeError(\"Super expression must either be null or a function\");\n  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, writable: !0, configurable: !0 } }), Object.defineProperty(e, \"prototype\", { writable: !1 }), t && Rl(e, t);\n}\nfunction Rl(e, t) {\n  return Rl = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(r, i) {\n    return r.__proto__ = i, r;\n  }, Rl(e, t);\n}\nfunction bt(e, t, n) {\n  return t = fw(t), t in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;\n}\nfunction fw(e) {\n  var t = mV(e, \"string\");\n  return Yr(t) == \"symbol\" ? t : String(t);\n}\nfunction mV(e, t) {\n  if (Yr(e) != \"object\" || !e)\n    return e;\n  var n = e[Symbol.toPrimitive];\n  if (n !== void 0) {\n    var r = n.call(e, t || \"default\");\n    if (Yr(r) != \"object\")\n      return r;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (t === \"string\" ? String : Number)(e);\n}\nvar yV = function(t) {\n  var n = t.data, r = t.startIndex, i = t.endIndex, o = t.x, a = t.width, s = t.travellerWidth;\n  if (!n || !n.length)\n    return {};\n  var u = n.length, c = Wi().domain(xs(0, u)).range([o, o + a - s]), f = c.domain().map(function(l) {\n    return c(l);\n  });\n  return {\n    isTextActive: !1,\n    isSlideMoving: !1,\n    isTravellerMoving: !1,\n    isTravellerFocused: !1,\n    startX: c(r),\n    endX: c(i),\n    scale: c,\n    scaleValues: f\n  };\n}, Cv = function(t) {\n  return t.changedTouches && !!t.changedTouches.length;\n}, Xr = /* @__PURE__ */ function(e) {\n  vV(t, e);\n  function t(n) {\n    var r;\n    return dV(this, t), r = hV(this, t, [n]), bt(en(r), \"handleDrag\", function(i) {\n      r.leaveTimer && (clearTimeout(r.leaveTimer), r.leaveTimer = null), r.state.isTravellerMoving ? r.handleTravellerMove(i) : r.state.isSlideMoving && r.handleSlideDrag(i);\n    }), bt(en(r), \"handleTouchMove\", function(i) {\n      i.changedTouches != null && i.changedTouches.length > 0 && r.handleDrag(i.changedTouches[0]);\n    }), bt(en(r), \"handleDragEnd\", function() {\n      r.setState({\n        isTravellerMoving: !1,\n        isSlideMoving: !1\n      }, function() {\n        var i = r.props, o = i.endIndex, a = i.onDragEnd, s = i.startIndex;\n        a == null || a({\n          endIndex: o,\n          startIndex: s\n        });\n      }), r.detachDragEndListener();\n    }), bt(en(r), \"handleLeaveWrapper\", function() {\n      (r.state.isTravellerMoving || r.state.isSlideMoving) && (r.leaveTimer = window.setTimeout(r.handleDragEnd, r.props.leaveTimeOut));\n    }), bt(en(r), \"handleEnterSlideOrTraveller\", function() {\n      r.setState({\n        isTextActive: !0\n      });\n    }), bt(en(r), \"handleLeaveSlideOrTraveller\", function() {\n      r.setState({\n        isTextActive: !1\n      });\n    }), bt(en(r), \"handleSlideDragStart\", function(i) {\n      var o = Cv(i) ? i.changedTouches[0] : i;\n      r.setState({\n        isTravellerMoving: !1,\n        isSlideMoving: !0,\n        slideMoveStartX: o.pageX\n      }), r.attachDragEndListener();\n    }), r.travellerDragStartHandlers = {\n      startX: r.handleTravellerDragStart.bind(en(r), \"startX\"),\n      endX: r.handleTravellerDragStart.bind(en(r), \"endX\")\n    }, r.state = {}, r;\n  }\n  return pV(t, [{\n    key: \"componentWillUnmount\",\n    value: function() {\n      this.leaveTimer && (clearTimeout(this.leaveTimer), this.leaveTimer = null), this.detachDragEndListener();\n    }\n  }, {\n    key: \"getIndex\",\n    value: function(r) {\n      var i = r.startX, o = r.endX, a = this.state.scaleValues, s = this.props, u = s.gap, c = s.data, f = c.length - 1, l = Math.min(i, o), d = Math.max(i, o), p = t.getIndexInRange(a, l), g = t.getIndexInRange(a, d);\n      return {\n        startIndex: p - p % u,\n        endIndex: g === f ? f : g - g % u\n      };\n    }\n  }, {\n    key: \"getTextOfTick\",\n    value: function(r) {\n      var i = this.props, o = i.data, a = i.tickFormatter, s = i.dataKey, u = At(o[r], s, r);\n      return pe(a) ? a(u, r) : u;\n    }\n  }, {\n    key: \"attachDragEndListener\",\n    value: function() {\n      window.addEventListener(\"mouseup\", this.handleDragEnd, !0), window.addEventListener(\"touchend\", this.handleDragEnd, !0), window.addEventListener(\"mousemove\", this.handleDrag, !0);\n    }\n  }, {\n    key: \"detachDragEndListener\",\n    value: function() {\n      window.removeEventListener(\"mouseup\", this.handleDragEnd, !0), window.removeEventListener(\"touchend\", this.handleDragEnd, !0), window.removeEventListener(\"mousemove\", this.handleDrag, !0);\n    }\n  }, {\n    key: \"handleSlideDrag\",\n    value: function(r) {\n      var i = this.state, o = i.slideMoveStartX, a = i.startX, s = i.endX, u = this.props, c = u.x, f = u.width, l = u.travellerWidth, d = u.startIndex, p = u.endIndex, g = u.onChange, h = r.pageX - o;\n      h > 0 ? h = Math.min(h, c + f - l - s, c + f - l - a) : h < 0 && (h = Math.max(h, c - a, c - s));\n      var v = this.getIndex({\n        startX: a + h,\n        endX: s + h\n      });\n      (v.startIndex !== d || v.endIndex !== p) && g && g(v), this.setState({\n        startX: a + h,\n        endX: s + h,\n        slideMoveStartX: r.pageX\n      });\n    }\n  }, {\n    key: \"handleTravellerDragStart\",\n    value: function(r, i) {\n      var o = Cv(i) ? i.changedTouches[0] : i;\n      this.setState({\n        isSlideMoving: !1,\n        isTravellerMoving: !0,\n        movingTravellerId: r,\n        brushMoveStartX: o.pageX\n      }), this.attachDragEndListener();\n    }\n  }, {\n    key: \"handleTravellerMove\",\n    value: function(r) {\n      var i = this.state, o = i.brushMoveStartX, a = i.movingTravellerId, s = i.endX, u = i.startX, c = this.state[a], f = this.props, l = f.x, d = f.width, p = f.travellerWidth, g = f.onChange, h = f.gap, v = f.data, w = {\n        startX: this.state.startX,\n        endX: this.state.endX\n      }, b = r.pageX - o;\n      b > 0 ? b = Math.min(b, l + d - p - c) : b < 0 && (b = Math.max(b, l - c)), w[a] = c + b;\n      var x = this.getIndex(w), m = x.startIndex, y = x.endIndex, S = function() {\n        var O = v.length - 1;\n        return a === \"startX\" && (s > u ? m % h === 0 : y % h === 0) || s < u && y === O || a === \"endX\" && (s > u ? y % h === 0 : m % h === 0) || s > u && y === O;\n      };\n      this.setState(bt(bt({}, a, c + b), \"brushMoveStartX\", r.pageX), function() {\n        g && S() && g(x);\n      });\n    }\n  }, {\n    key: \"handleTravellerMoveKeyboard\",\n    value: function(r, i) {\n      var o = this, a = this.state, s = a.scaleValues, u = a.startX, c = a.endX, f = this.state[i], l = s.indexOf(f);\n      if (l !== -1) {\n        var d = l + r;\n        if (!(d === -1 || d >= s.length)) {\n          var p = s[d];\n          i === \"startX\" && p >= c || i === \"endX\" && p <= u || this.setState(bt({}, i, p), function() {\n            o.props.onChange(o.getIndex({\n              startX: o.state.startX,\n              endX: o.state.endX\n            }));\n          });\n        }\n      }\n    }\n  }, {\n    key: \"renderBackground\",\n    value: function() {\n      var r = this.props, i = r.x, o = r.y, a = r.width, s = r.height, u = r.fill, c = r.stroke;\n      return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"rect\", {\n        stroke: c,\n        fill: u,\n        x: i,\n        y: o,\n        width: a,\n        height: s\n      });\n    }\n  }, {\n    key: \"renderPanorama\",\n    value: function() {\n      var r = this.props, i = r.x, o = r.y, a = r.width, s = r.height, u = r.data, c = r.children, f = r.padding, l = react__WEBPACK_IMPORTED_MODULE_0__.Children.only(c);\n      return l ? /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.cloneElement(l, {\n        x: i,\n        y: o,\n        width: a,\n        height: s,\n        margin: f,\n        compact: !0,\n        data: u\n      }) : null;\n    }\n  }, {\n    key: \"renderTravellerLayer\",\n    value: function(r, i) {\n      var o, a, s = this, u = this.props, c = u.y, f = u.travellerWidth, l = u.height, d = u.traveller, p = u.ariaLabel, g = u.data, h = u.startIndex, v = u.endIndex, w = Math.max(r, this.props.x), b = nc(nc({}, ye(this.props, !1)), {}, {\n        x: w,\n        y: c,\n        width: f,\n        height: l\n      }), x = p || \"Min value: \".concat((o = g[h]) === null || o === void 0 ? void 0 : o.name, \", Max value: \").concat((a = g[v]) === null || a === void 0 ? void 0 : a.name);\n      return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(We, {\n        tabIndex: 0,\n        role: \"slider\",\n        \"aria-label\": x,\n        \"aria-valuenow\": r,\n        className: \"recharts-brush-traveller\",\n        onMouseEnter: this.handleEnterSlideOrTraveller,\n        onMouseLeave: this.handleLeaveSlideOrTraveller,\n        onMouseDown: this.travellerDragStartHandlers[i],\n        onTouchStart: this.travellerDragStartHandlers[i],\n        onKeyDown: function(y) {\n          [\"ArrowLeft\", \"ArrowRight\"].includes(y.key) && (y.preventDefault(), y.stopPropagation(), s.handleTravellerMoveKeyboard(y.key === \"ArrowRight\" ? 1 : -1, i));\n        },\n        onFocus: function() {\n          s.setState({\n            isTravellerFocused: !0\n          });\n        },\n        onBlur: function() {\n          s.setState({\n            isTravellerFocused: !1\n          });\n        },\n        style: {\n          cursor: \"col-resize\"\n        }\n      }, t.renderTraveller(d, b));\n    }\n  }, {\n    key: \"renderSlide\",\n    value: function(r, i) {\n      var o = this.props, a = o.y, s = o.height, u = o.stroke, c = o.travellerWidth, f = Math.min(r, i) + c, l = Math.max(Math.abs(i - r) - c, 0);\n      return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"rect\", {\n        className: \"recharts-brush-slide\",\n        onMouseEnter: this.handleEnterSlideOrTraveller,\n        onMouseLeave: this.handleLeaveSlideOrTraveller,\n        onMouseDown: this.handleSlideDragStart,\n        onTouchStart: this.handleSlideDragStart,\n        style: {\n          cursor: \"move\"\n        },\n        stroke: \"none\",\n        fill: u,\n        fillOpacity: 0.2,\n        x: f,\n        y: a,\n        width: l,\n        height: s\n      });\n    }\n  }, {\n    key: \"renderText\",\n    value: function() {\n      var r = this.props, i = r.startIndex, o = r.endIndex, a = r.y, s = r.height, u = r.travellerWidth, c = r.stroke, f = this.state, l = f.startX, d = f.endX, p = 5, g = {\n        pointerEvents: \"none\",\n        fill: c\n      };\n      return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(We, {\n        className: \"recharts-brush-texts\"\n      }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(Ja, Ss({\n        textAnchor: \"end\",\n        verticalAnchor: \"middle\",\n        x: Math.min(l, d) - p,\n        y: a + s / 2\n      }, g), this.getTextOfTick(i)), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(Ja, Ss({\n        textAnchor: \"start\",\n        verticalAnchor: \"middle\",\n        x: Math.max(l, d) + u + p,\n        y: a + s / 2\n      }, g), this.getTextOfTick(o)));\n    }\n  }, {\n    key: \"render\",\n    value: function() {\n      var r = this.props, i = r.data, o = r.className, a = r.children, s = r.x, u = r.y, c = r.width, f = r.height, l = r.alwaysShowText, d = this.state, p = d.startX, g = d.endX, h = d.isTextActive, v = d.isSlideMoving, w = d.isTravellerMoving, b = d.isTravellerFocused;\n      if (!i || !i.length || !K(s) || !K(u) || !K(c) || !K(f) || c <= 0 || f <= 0)\n        return null;\n      var x = $e(\"recharts-brush\", o), m = react__WEBPACK_IMPORTED_MODULE_0__.Children.count(a) === 1, y = fV(\"userSelect\", \"none\");\n      return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(We, {\n        className: x,\n        onMouseLeave: this.handleLeaveWrapper,\n        onTouchMove: this.handleTouchMove,\n        style: y\n      }, this.renderBackground(), m && this.renderPanorama(), this.renderSlide(p, g), this.renderTravellerLayer(p, \"startX\"), this.renderTravellerLayer(g, \"endX\"), (h || v || w || b || l) && this.renderText());\n    }\n  }], [{\n    key: \"renderDefaultTraveller\",\n    value: function(r) {\n      var i = r.x, o = r.y, a = r.width, s = r.height, u = r.stroke, c = Math.floor(o + s / 2) - 1;\n      return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"rect\", {\n        x: i,\n        y: o,\n        width: a,\n        height: s,\n        fill: u,\n        stroke: \"none\"\n      }), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"line\", {\n        x1: i + 1,\n        y1: c,\n        x2: i + a - 1,\n        y2: c,\n        fill: \"none\",\n        stroke: \"#fff\"\n      }), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"line\", {\n        x1: i + 1,\n        y1: c + 2,\n        x2: i + a - 1,\n        y2: c + 2,\n        fill: \"none\",\n        stroke: \"#fff\"\n      }));\n    }\n  }, {\n    key: \"renderTraveller\",\n    value: function(r, i) {\n      var o;\n      return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.isValidElement(r) ? o = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.cloneElement(r, i) : pe(r) ? o = r(i) : o = t.renderDefaultTraveller(i), o;\n    }\n  }, {\n    key: \"getDerivedStateFromProps\",\n    value: function(r, i) {\n      var o = r.data, a = r.width, s = r.x, u = r.travellerWidth, c = r.updateId, f = r.startIndex, l = r.endIndex;\n      if (o !== i.prevData || c !== i.prevUpdateId)\n        return nc({\n          prevData: o,\n          prevTravellerWidth: u,\n          prevUpdateId: c,\n          prevX: s,\n          prevWidth: a\n        }, o && o.length ? yV({\n          data: o,\n          width: a,\n          x: s,\n          travellerWidth: u,\n          startIndex: f,\n          endIndex: l\n        }) : {\n          scale: null,\n          scaleValues: null\n        });\n      if (i.scale && (a !== i.prevWidth || s !== i.prevX || u !== i.prevTravellerWidth)) {\n        i.scale.range([s, s + a - u]);\n        var d = i.scale.domain().map(function(p) {\n          return i.scale(p);\n        });\n        return {\n          prevData: o,\n          prevTravellerWidth: u,\n          prevUpdateId: c,\n          prevX: s,\n          prevWidth: a,\n          startX: i.scale(r.startIndex),\n          endX: i.scale(r.endIndex),\n          scaleValues: d\n        };\n      }\n      return null;\n    }\n  }, {\n    key: \"getIndexInRange\",\n    value: function(r, i) {\n      for (var o = r.length, a = 0, s = o - 1; s - a > 1; ) {\n        var u = Math.floor((a + s) / 2);\n        r[u] > i ? s = u : a = u;\n      }\n      return i >= r[s] ? s : a;\n    }\n  }]), t;\n}(react__WEBPACK_IMPORTED_MODULE_0__.PureComponent);\nbt(Xr, \"displayName\", \"Brush\");\nbt(Xr, \"defaultProps\", {\n  height: 40,\n  travellerWidth: 5,\n  gap: 1,\n  fill: \"#fff\",\n  stroke: \"#666\",\n  padding: {\n    top: 1,\n    right: 1,\n    bottom: 1,\n    left: 1\n  },\n  leaveTimeOut: 1e3,\n  alwaysShowText: !1\n});\nvar bV = Nf;\nfunction wV(e, t) {\n  var n;\n  return bV(e, function(r, i, o) {\n    return n = t(r, i, o), !n;\n  }), !!n;\n}\nvar xV = wV, SV = vb, $V = Hn, OV = xV, _V = mt, AV = Hs;\nfunction PV(e, t, n) {\n  var r = _V(e) ? SV : OV;\n  return n && AV(e, t, n) && (t = void 0), r(e, $V(t));\n}\nvar CV = PV;\nconst EV = /* @__PURE__ */ je(CV);\nvar sn = function(t, n) {\n  var r = t.alwaysShow, i = t.ifOverflow;\n  return r && (i = \"extendDomain\"), i === n;\n}, Ev = Lb;\nfunction TV(e, t, n) {\n  t == \"__proto__\" && Ev ? Ev(e, t, {\n    configurable: !0,\n    enumerable: !0,\n    value: n,\n    writable: !0\n  }) : e[t] = n;\n}\nvar MV = TV, RV = MV, IV = Nb, jV = Hn;\nfunction kV(e, t) {\n  var n = {};\n  return t = jV(t), IV(e, function(r, i, o) {\n    RV(n, i, t(r, i, o));\n  }), n;\n}\nvar DV = kV;\nconst NV = /* @__PURE__ */ je(DV);\nfunction FV(e, t) {\n  for (var n = -1, r = e == null ? 0 : e.length; ++n < r; )\n    if (!t(e[n], n, e))\n      return !1;\n  return !0;\n}\nvar LV = FV, BV = Nf;\nfunction zV(e, t) {\n  var n = !0;\n  return BV(e, function(r, i, o) {\n    return n = !!t(r, i, o), n;\n  }), n;\n}\nvar VV = zV, GV = LV, WV = VV, UV = Hn, HV = mt, qV = Hs;\nfunction KV(e, t, n) {\n  var r = HV(e) ? GV : WV;\n  return n && qV(e, t, n) && (t = void 0), r(e, UV(t));\n}\nvar YV = KV;\nconst dw = /* @__PURE__ */ je(YV);\nvar XV = [\"x\", \"y\"];\nfunction Zr(e) {\n  \"@babel/helpers - typeof\";\n  return Zr = typeof Symbol == \"function\" && typeof Symbol.iterator == \"symbol\" ? function(t) {\n    return typeof t;\n  } : function(t) {\n    return t && typeof Symbol == \"function\" && t.constructor === Symbol && t !== Symbol.prototype ? \"symbol\" : typeof t;\n  }, Zr(e);\n}\nfunction Il() {\n  return Il = Object.assign ? Object.assign.bind() : function(e) {\n    for (var t = 1; t < arguments.length; t++) {\n      var n = arguments[t];\n      for (var r in n)\n        Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);\n    }\n    return e;\n  }, Il.apply(this, arguments);\n}\nfunction Tv(e, t) {\n  var n = Object.keys(e);\n  if (Object.getOwnPropertySymbols) {\n    var r = Object.getOwnPropertySymbols(e);\n    t && (r = r.filter(function(i) {\n      return Object.getOwnPropertyDescriptor(e, i).enumerable;\n    })), n.push.apply(n, r);\n  }\n  return n;\n}\nfunction Li(e) {\n  for (var t = 1; t < arguments.length; t++) {\n    var n = arguments[t] != null ? arguments[t] : {};\n    t % 2 ? Tv(Object(n), !0).forEach(function(r) {\n      ZV(e, r, n[r]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Tv(Object(n)).forEach(function(r) {\n      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));\n    });\n  }\n  return e;\n}\nfunction ZV(e, t, n) {\n  return t = JV(t), t in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;\n}\nfunction JV(e) {\n  var t = QV(e, \"string\");\n  return Zr(t) == \"symbol\" ? t : String(t);\n}\nfunction QV(e, t) {\n  if (Zr(e) != \"object\" || !e)\n    return e;\n  var n = e[Symbol.toPrimitive];\n  if (n !== void 0) {\n    var r = n.call(e, t || \"default\");\n    if (Zr(r) != \"object\")\n      return r;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (t === \"string\" ? String : Number)(e);\n}\nfunction e5(e, t) {\n  if (e == null)\n    return {};\n  var n = t5(e, t), r, i;\n  if (Object.getOwnPropertySymbols) {\n    var o = Object.getOwnPropertySymbols(e);\n    for (i = 0; i < o.length; i++)\n      r = o[i], !(t.indexOf(r) >= 0) && Object.prototype.propertyIsEnumerable.call(e, r) && (n[r] = e[r]);\n  }\n  return n;\n}\nfunction t5(e, t) {\n  if (e == null)\n    return {};\n  var n = {}, r = Object.keys(e), i, o;\n  for (o = 0; o < r.length; o++)\n    i = r[o], !(t.indexOf(i) >= 0) && (n[i] = e[i]);\n  return n;\n}\nfunction n5(e, t) {\n  var n = e.x, r = e.y, i = e5(e, XV), o = \"\".concat(n), a = parseInt(o, 10), s = \"\".concat(r), u = parseInt(s, 10), c = \"\".concat(t.height || i.height), f = parseInt(c, 10), l = \"\".concat(t.width || i.width), d = parseInt(l, 10);\n  return Li(Li(Li(Li(Li({}, t), i), a ? {\n    x: a\n  } : {}), u ? {\n    y: u\n  } : {}), {}, {\n    height: f,\n    width: d,\n    name: t.name,\n    radius: t.radius\n  });\n}\nfunction Mv(e) {\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(B9, Il({\n    shapeType: \"rectangle\",\n    propTransformer: n5,\n    activeClassName: \"recharts-active-bar\"\n  }, e));\n}\nvar r5 = function(t) {\n  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;\n  return function(r, i) {\n    if (typeof t == \"number\")\n      return t;\n    var o = typeof r == \"number\";\n    return o ? t(r, i) : (o || ( true ? gt(!1, \"minPointSize callback function received a value with type of \".concat(Zr(r), \". Currently only numbers are supported.\")) : 0), n);\n  };\n}, i5 = [\"value\", \"background\"], pw;\nfunction Jr(e) {\n  \"@babel/helpers - typeof\";\n  return Jr = typeof Symbol == \"function\" && typeof Symbol.iterator == \"symbol\" ? function(t) {\n    return typeof t;\n  } : function(t) {\n    return t && typeof Symbol == \"function\" && t.constructor === Symbol && t !== Symbol.prototype ? \"symbol\" : typeof t;\n  }, Jr(e);\n}\nfunction o5(e, t) {\n  if (e == null)\n    return {};\n  var n = a5(e, t), r, i;\n  if (Object.getOwnPropertySymbols) {\n    var o = Object.getOwnPropertySymbols(e);\n    for (i = 0; i < o.length; i++)\n      r = o[i], !(t.indexOf(r) >= 0) && Object.prototype.propertyIsEnumerable.call(e, r) && (n[r] = e[r]);\n  }\n  return n;\n}\nfunction a5(e, t) {\n  if (e == null)\n    return {};\n  var n = {}, r = Object.keys(e), i, o;\n  for (o = 0; o < r.length; o++)\n    i = r[o], !(t.indexOf(i) >= 0) && (n[i] = e[i]);\n  return n;\n}\nfunction Os() {\n  return Os = Object.assign ? Object.assign.bind() : function(e) {\n    for (var t = 1; t < arguments.length; t++) {\n      var n = arguments[t];\n      for (var r in n)\n        Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);\n    }\n    return e;\n  }, Os.apply(this, arguments);\n}\nfunction Rv(e, t) {\n  var n = Object.keys(e);\n  if (Object.getOwnPropertySymbols) {\n    var r = Object.getOwnPropertySymbols(e);\n    t && (r = r.filter(function(i) {\n      return Object.getOwnPropertyDescriptor(e, i).enumerable;\n    })), n.push.apply(n, r);\n  }\n  return n;\n}\nfunction Je(e) {\n  for (var t = 1; t < arguments.length; t++) {\n    var n = arguments[t] != null ? arguments[t] : {};\n    t % 2 ? Rv(Object(n), !0).forEach(function(r) {\n      Dn(e, r, n[r]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Rv(Object(n)).forEach(function(r) {\n      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));\n    });\n  }\n  return e;\n}\nfunction s5(e, t) {\n  if (!(e instanceof t))\n    throw new TypeError(\"Cannot call a class as a function\");\n}\nfunction Iv(e, t) {\n  for (var n = 0; n < t.length; n++) {\n    var r = t[n];\n    r.enumerable = r.enumerable || !1, r.configurable = !0, \"value\" in r && (r.writable = !0), Object.defineProperty(e, gw(r.key), r);\n  }\n}\nfunction u5(e, t, n) {\n  return t && Iv(e.prototype, t), n && Iv(e, n), Object.defineProperty(e, \"prototype\", { writable: !1 }), e;\n}\nfunction c5(e, t, n) {\n  return t = _s(t), l5(e, hw() ? Reflect.construct(t, n || [], _s(e).constructor) : t.apply(e, n));\n}\nfunction l5(e, t) {\n  if (t && (Jr(t) === \"object\" || typeof t == \"function\"))\n    return t;\n  if (t !== void 0)\n    throw new TypeError(\"Derived constructors may only return object or undefined\");\n  return Vi(e);\n}\nfunction hw() {\n  try {\n    var e = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {\n    }));\n  } catch {\n  }\n  return (hw = function() {\n    return !!e;\n  })();\n}\nfunction _s(e) {\n  return _s = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(n) {\n    return n.__proto__ || Object.getPrototypeOf(n);\n  }, _s(e);\n}\nfunction Vi(e) {\n  if (e === void 0)\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  return e;\n}\nfunction f5(e, t) {\n  if (typeof t != \"function\" && t !== null)\n    throw new TypeError(\"Super expression must either be null or a function\");\n  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, writable: !0, configurable: !0 } }), Object.defineProperty(e, \"prototype\", { writable: !1 }), t && jl(e, t);\n}\nfunction jl(e, t) {\n  return jl = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(r, i) {\n    return r.__proto__ = i, r;\n  }, jl(e, t);\n}\nfunction Dn(e, t, n) {\n  return t = gw(t), t in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;\n}\nfunction gw(e) {\n  var t = d5(e, \"string\");\n  return Jr(t) == \"symbol\" ? t : String(t);\n}\nfunction d5(e, t) {\n  if (Jr(e) != \"object\" || !e)\n    return e;\n  var n = e[Symbol.toPrimitive];\n  if (n !== void 0) {\n    var r = n.call(e, t || \"default\");\n    if (Jr(r) != \"object\")\n      return r;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (t === \"string\" ? String : Number)(e);\n}\nvar Jo = /* @__PURE__ */ function(e) {\n  f5(t, e);\n  function t() {\n    var n;\n    s5(this, t);\n    for (var r = arguments.length, i = new Array(r), o = 0; o < r; o++)\n      i[o] = arguments[o];\n    return n = c5(this, t, [].concat(i)), Dn(Vi(n), \"state\", {\n      isAnimationFinished: !1\n    }), Dn(Vi(n), \"id\", Uo(\"recharts-bar-\")), Dn(Vi(n), \"handleAnimationEnd\", function() {\n      var a = n.props.onAnimationEnd;\n      n.setState({\n        isAnimationFinished: !0\n      }), a && a();\n    }), Dn(Vi(n), \"handleAnimationStart\", function() {\n      var a = n.props.onAnimationStart;\n      n.setState({\n        isAnimationFinished: !1\n      }), a && a();\n    }), n;\n  }\n  return u5(t, [{\n    key: \"renderRectanglesStatically\",\n    value: function(r) {\n      var i = this, o = this.props, a = o.shape, s = o.dataKey, u = o.activeIndex, c = o.activeBar, f = ye(this.props, !1);\n      return r && r.map(function(l, d) {\n        var p = d === u, g = p ? c : a, h = Je(Je(Je({}, f), l), {}, {\n          isActive: p,\n          option: g,\n          index: d,\n          dataKey: s,\n          onAnimationStart: i.handleAnimationStart,\n          onAnimationEnd: i.handleAnimationEnd\n        });\n        return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(We, Os({\n          className: \"recharts-bar-rectangle\"\n        }, Fa(i.props, l, d), {\n          key: \"rectangle-\".concat(l == null ? void 0 : l.x, \"-\").concat(l == null ? void 0 : l.y, \"-\").concat(l == null ? void 0 : l.value)\n        }), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(Mv, h));\n      });\n    }\n  }, {\n    key: \"renderRectanglesWithAnimation\",\n    value: function() {\n      var r = this, i = this.props, o = i.data, a = i.layout, s = i.isAnimationActive, u = i.animationBegin, c = i.animationDuration, f = i.animationEasing, l = i.animationId, d = this.state.prevData;\n      return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(_n, {\n        begin: u,\n        duration: c,\n        isActive: s,\n        easing: f,\n        from: {\n          t: 0\n        },\n        to: {\n          t: 1\n        },\n        key: \"bar-\".concat(l),\n        onAnimationEnd: this.handleAnimationEnd,\n        onAnimationStart: this.handleAnimationStart\n      }, function(p) {\n        var g = p.t, h = o.map(function(v, w) {\n          var b = d && d[w];\n          if (b) {\n            var x = Ht(b.x, v.x), m = Ht(b.y, v.y), y = Ht(b.width, v.width), S = Ht(b.height, v.height);\n            return Je(Je({}, v), {}, {\n              x: x(g),\n              y: m(g),\n              width: y(g),\n              height: S(g)\n            });\n          }\n          if (a === \"horizontal\") {\n            var $ = Ht(0, v.height), O = $(g);\n            return Je(Je({}, v), {}, {\n              y: v.y + v.height - O,\n              height: O\n            });\n          }\n          var T = Ht(0, v.width), M = T(g);\n          return Je(Je({}, v), {}, {\n            width: M\n          });\n        });\n        return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(We, null, r.renderRectanglesStatically(h));\n      });\n    }\n  }, {\n    key: \"renderRectangles\",\n    value: function() {\n      var r = this.props, i = r.data, o = r.isAnimationActive, a = this.state.prevData;\n      return o && i && i.length && (!a || !tu(a, i)) ? this.renderRectanglesWithAnimation() : this.renderRectanglesStatically(i);\n    }\n  }, {\n    key: \"renderBackground\",\n    value: function() {\n      var r = this, i = this.props, o = i.data, a = i.dataKey, s = i.activeIndex, u = ye(this.props.background, !1);\n      return o.map(function(c, f) {\n        c.value;\n        var l = c.background, d = o5(c, i5);\n        if (!l)\n          return null;\n        var p = Je(Je(Je(Je(Je({}, d), {}, {\n          fill: \"#eee\"\n        }, l), u), Fa(r.props, c, f)), {}, {\n          onAnimationStart: r.handleAnimationStart,\n          onAnimationEnd: r.handleAnimationEnd,\n          dataKey: a,\n          index: f,\n          key: \"background-bar-\".concat(f),\n          className: \"recharts-bar-background-rectangle\"\n        });\n        return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(Mv, Os({\n          option: r.props.background,\n          isActive: f === s\n        }, p));\n      });\n    }\n  }, {\n    key: \"renderErrorBar\",\n    value: function(r, i) {\n      if (this.props.isAnimationActive && !this.state.isAnimationFinished)\n        return null;\n      var o = this.props, a = o.data, s = o.xAxis, u = o.yAxis, c = o.layout, f = o.children, l = kt(f, Zo);\n      if (!l)\n        return null;\n      var d = c === \"vertical\" ? a[0].height / 2 : a[0].width / 2, p = function(v, w) {\n        var b = Array.isArray(v.value) ? v.value[1] : v.value;\n        return {\n          x: v.x,\n          y: v.y,\n          value: b,\n          errorVal: At(v, w)\n        };\n      }, g = {\n        clipPath: r ? \"url(#clipPath-\".concat(i, \")\") : null\n      };\n      return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(We, g, l.map(function(h) {\n        return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.cloneElement(h, {\n          key: \"error-bar-\".concat(i, \"-\").concat(h.props.dataKey),\n          data: a,\n          xAxis: s,\n          yAxis: u,\n          layout: c,\n          offset: d,\n          dataPointFormatter: p\n        });\n      }));\n    }\n  }, {\n    key: \"render\",\n    value: function() {\n      var r = this.props, i = r.hide, o = r.data, a = r.className, s = r.xAxis, u = r.yAxis, c = r.left, f = r.top, l = r.width, d = r.height, p = r.isAnimationActive, g = r.background, h = r.id;\n      if (i || !o || !o.length)\n        return null;\n      var v = this.state.isAnimationFinished, w = $e(\"recharts-bar\", a), b = s && s.allowDataOverflow, x = u && u.allowDataOverflow, m = b || x, y = me(h) ? this.id : h;\n      return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(We, {\n        className: w\n      }, b || x ? /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"defs\", null, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"clipPath\", {\n        id: \"clipPath-\".concat(y)\n      }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"rect\", {\n        x: b ? c : c - l / 2,\n        y: x ? f : f - d / 2,\n        width: b ? l : l * 2,\n        height: x ? d : d * 2\n      }))) : null, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(We, {\n        className: \"recharts-bar-rectangles\",\n        clipPath: m ? \"url(#clipPath-\".concat(y, \")\") : null\n      }, g ? this.renderBackground() : null, this.renderRectangles()), this.renderErrorBar(m, y), (!p || v) && Bn.renderCallByParent(this.props, o));\n    }\n  }], [{\n    key: \"getDerivedStateFromProps\",\n    value: function(r, i) {\n      return r.animationId !== i.prevAnimationId ? {\n        prevAnimationId: r.animationId,\n        curData: r.data,\n        prevData: i.curData\n      } : r.data !== i.curData ? {\n        curData: r.data\n      } : null;\n    }\n  }]), t;\n}(react__WEBPACK_IMPORTED_MODULE_0__.PureComponent);\npw = Jo;\nDn(Jo, \"displayName\", \"Bar\");\nDn(Jo, \"defaultProps\", {\n  xAxisId: 0,\n  yAxisId: 0,\n  legendType: \"rect\",\n  minPointSize: 0,\n  hide: !1,\n  data: [],\n  layout: \"vertical\",\n  activeBar: !1,\n  isAnimationActive: !yn.isSsr,\n  animationBegin: 0,\n  animationDuration: 400,\n  animationEasing: \"ease\"\n});\nDn(Jo, \"getComposedData\", function(e) {\n  var t = e.props, n = e.item, r = e.barPosition, i = e.bandSize, o = e.xAxis, a = e.yAxis, s = e.xAxisTicks, u = e.yAxisTicks, c = e.stackedData, f = e.dataStartIndex, l = e.displayedData, d = e.offset, p = Z6(r, n);\n  if (!p)\n    return null;\n  var g = t.layout, h = n.props, v = h.dataKey, w = h.children, b = h.minPointSize, x = g === \"horizontal\" ? a : o, m = c ? x.scale.domain() : null, y = o8({\n    numericAxis: x\n  }), S = kt(w, Ub), $ = l.map(function(O, T) {\n    var M, E, A, j, R, N;\n    c ? M = J6(c[f + T], m) : (M = At(O, v), Array.isArray(M) || (M = [y, M]));\n    var k = r5(b, pw.defaultProps.minPointSize)(M[1], T);\n    if (g === \"horizontal\") {\n      var F, V = [a.scale(M[0]), a.scale(M[1])], L = V[0], I = V[1];\n      E = Ag({\n        axis: o,\n        ticks: s,\n        bandSize: i,\n        offset: p.offset,\n        entry: O,\n        index: T\n      }), A = (F = I ?? L) !== null && F !== void 0 ? F : void 0, j = p.size;\n      var D = L - I;\n      if (R = Number.isNaN(D) ? 0 : D, N = {\n        x: E,\n        y: a.y,\n        width: j,\n        height: a.height\n      }, Math.abs(k) > 0 && Math.abs(R) < Math.abs(k)) {\n        var G = Kt(R || k) * (Math.abs(k) - Math.abs(R));\n        A -= G, R += G;\n      }\n    } else {\n      var q = [o.scale(M[0]), o.scale(M[1])], J = q[0], ne = q[1];\n      if (E = J, A = Ag({\n        axis: a,\n        ticks: u,\n        bandSize: i,\n        offset: p.offset,\n        entry: O,\n        index: T\n      }), j = ne - J, R = p.size, N = {\n        x: o.x,\n        y: A,\n        width: o.width,\n        height: R\n      }, Math.abs(k) > 0 && Math.abs(j) < Math.abs(k)) {\n        var te = Kt(j || k) * (Math.abs(k) - Math.abs(j));\n        j += te;\n      }\n    }\n    return Je(Je(Je({}, O), {}, {\n      x: E,\n      y: A,\n      width: j,\n      height: R,\n      value: c ? M : M[1],\n      payload: O,\n      background: N\n    }, S && S[T] && S[T].props), {}, {\n      tooltipPayload: [K0(n, O)],\n      tooltipPosition: {\n        x: E + j / 2,\n        y: A + R / 2\n      }\n    });\n  });\n  return Je({\n    data: $,\n    layout: g\n  }, d);\n});\nfunction Mo(e) {\n  \"@babel/helpers - typeof\";\n  return Mo = typeof Symbol == \"function\" && typeof Symbol.iterator == \"symbol\" ? function(t) {\n    return typeof t;\n  } : function(t) {\n    return t && typeof Symbol == \"function\" && t.constructor === Symbol && t !== Symbol.prototype ? \"symbol\" : typeof t;\n  }, Mo(e);\n}\nfunction p5(e, t) {\n  if (!(e instanceof t))\n    throw new TypeError(\"Cannot call a class as a function\");\n}\nfunction jv(e, t) {\n  for (var n = 0; n < t.length; n++) {\n    var r = t[n];\n    r.enumerable = r.enumerable || !1, r.configurable = !0, \"value\" in r && (r.writable = !0), Object.defineProperty(e, vw(r.key), r);\n  }\n}\nfunction h5(e, t, n) {\n  return t && jv(e.prototype, t), n && jv(e, n), Object.defineProperty(e, \"prototype\", { writable: !1 }), e;\n}\nfunction kv(e, t) {\n  var n = Object.keys(e);\n  if (Object.getOwnPropertySymbols) {\n    var r = Object.getOwnPropertySymbols(e);\n    t && (r = r.filter(function(i) {\n      return Object.getOwnPropertyDescriptor(e, i).enumerable;\n    })), n.push.apply(n, r);\n  }\n  return n;\n}\nfunction Wt(e) {\n  for (var t = 1; t < arguments.length; t++) {\n    var n = arguments[t] != null ? arguments[t] : {};\n    t % 2 ? kv(Object(n), !0).forEach(function(r) {\n      au(e, r, n[r]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : kv(Object(n)).forEach(function(r) {\n      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));\n    });\n  }\n  return e;\n}\nfunction au(e, t, n) {\n  return t = vw(t), t in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;\n}\nfunction vw(e) {\n  var t = g5(e, \"string\");\n  return Mo(t) == \"symbol\" ? t : String(t);\n}\nfunction g5(e, t) {\n  if (Mo(e) != \"object\" || !e)\n    return e;\n  var n = e[Symbol.toPrimitive];\n  if (n !== void 0) {\n    var r = n.call(e, t || \"default\");\n    if (Mo(r) != \"object\")\n      return r;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (t === \"string\" ? String : Number)(e);\n}\nvar v5 = function(t, n, r, i, o) {\n  var a = t.width, s = t.height, u = t.layout, c = t.children, f = Object.keys(n), l = {\n    left: r.left,\n    leftMirror: r.left,\n    right: a - r.right,\n    rightMirror: a - r.right,\n    top: r.top,\n    topMirror: r.top,\n    bottom: s - r.bottom,\n    bottomMirror: s - r.bottom\n  }, d = !!wt(c, Jo);\n  return f.reduce(function(p, g) {\n    var h = n[g], v = h.orientation, w = h.domain, b = h.padding, x = b === void 0 ? {} : b, m = h.mirror, y = h.reversed, S = \"\".concat(v).concat(m ? \"Mirror\" : \"\"), $, O, T, M, E;\n    if (h.type === \"number\" && (h.padding === \"gap\" || h.padding === \"no-gap\")) {\n      var A = w[1] - w[0], j = 1 / 0, R = h.categoricalDomain.sort();\n      if (R.forEach(function(J, ne) {\n        ne > 0 && (j = Math.min((J || 0) - (R[ne - 1] || 0), j));\n      }), Number.isFinite(j)) {\n        var N = j / A, k = h.layout === \"vertical\" ? r.height : r.width;\n        if (h.padding === \"gap\" && ($ = N * k / 2), h.padding === \"no-gap\") {\n          var F = lr(t.barCategoryGap, N * k), V = N * k / 2;\n          $ = V - F - (V - F) / k * F;\n        }\n      }\n    }\n    i === \"xAxis\" ? O = [r.left + (x.left || 0) + ($ || 0), r.left + r.width - (x.right || 0) - ($ || 0)] : i === \"yAxis\" ? O = u === \"horizontal\" ? [r.top + r.height - (x.bottom || 0), r.top + (x.top || 0)] : [r.top + (x.top || 0) + ($ || 0), r.top + r.height - (x.bottom || 0) - ($ || 0)] : O = h.range, y && (O = [O[1], O[0]]);\n    var L = Y6(h, o, d), I = L.scale, D = L.realScaleType;\n    I.domain(w).range(O), X6(I);\n    var G = i8(I, Wt(Wt({}, h), {}, {\n      realScaleType: D\n    }));\n    i === \"xAxis\" ? (E = v === \"top\" && !m || v === \"bottom\" && m, T = r.left, M = l[S] - E * h.height) : i === \"yAxis\" && (E = v === \"left\" && !m || v === \"right\" && m, T = l[S] - E * h.width, M = r.top);\n    var q = Wt(Wt(Wt({}, h), G), {}, {\n      realScaleType: D,\n      x: T,\n      y: M,\n      scale: I,\n      width: i === \"xAxis\" ? r.width : h.width,\n      height: i === \"yAxis\" ? r.height : h.height\n    });\n    return q.bandSize = fs(q, G), !h.hide && i === \"xAxis\" ? l[S] += (E ? -1 : 1) * q.height : h.hide || (l[S] += (E ? -1 : 1) * q.width), Wt(Wt({}, p), {}, au({}, g, q));\n  }, {});\n}, mw = function(t, n) {\n  var r = t.x, i = t.y, o = n.x, a = n.y;\n  return {\n    x: Math.min(r, o),\n    y: Math.min(i, a),\n    width: Math.abs(o - r),\n    height: Math.abs(a - i)\n  };\n}, m5 = function(t) {\n  var n = t.x1, r = t.y1, i = t.x2, o = t.y2;\n  return mw({\n    x: n,\n    y: r\n  }, {\n    x: i,\n    y: o\n  });\n}, yw = /* @__PURE__ */ function() {\n  function e(t) {\n    p5(this, e), this.scale = t;\n  }\n  return h5(e, [{\n    key: \"domain\",\n    get: function() {\n      return this.scale.domain;\n    }\n  }, {\n    key: \"range\",\n    get: function() {\n      return this.scale.range;\n    }\n  }, {\n    key: \"rangeMin\",\n    get: function() {\n      return this.range()[0];\n    }\n  }, {\n    key: \"rangeMax\",\n    get: function() {\n      return this.range()[1];\n    }\n  }, {\n    key: \"bandwidth\",\n    get: function() {\n      return this.scale.bandwidth;\n    }\n  }, {\n    key: \"apply\",\n    value: function(n) {\n      var r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, i = r.bandAware, o = r.position;\n      if (n !== void 0) {\n        if (o)\n          switch (o) {\n            case \"start\":\n              return this.scale(n);\n            case \"middle\": {\n              var a = this.bandwidth ? this.bandwidth() / 2 : 0;\n              return this.scale(n) + a;\n            }\n            case \"end\": {\n              var s = this.bandwidth ? this.bandwidth() : 0;\n              return this.scale(n) + s;\n            }\n            default:\n              return this.scale(n);\n          }\n        if (i) {\n          var u = this.bandwidth ? this.bandwidth() / 2 : 0;\n          return this.scale(n) + u;\n        }\n        return this.scale(n);\n      }\n    }\n  }, {\n    key: \"isInRange\",\n    value: function(n) {\n      var r = this.range(), i = r[0], o = r[r.length - 1];\n      return i <= o ? n >= i && n <= o : n >= o && n <= i;\n    }\n  }], [{\n    key: \"create\",\n    value: function(n) {\n      return new e(n);\n    }\n  }]), e;\n}();\nau(yw, \"EPS\", 1e-4);\nvar hd = function(t) {\n  var n = Object.keys(t).reduce(function(r, i) {\n    return Wt(Wt({}, r), {}, au({}, i, yw.create(t[i])));\n  }, {});\n  return Wt(Wt({}, n), {}, {\n    apply: function(i) {\n      var o = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, a = o.bandAware, s = o.position;\n      return NV(i, function(u, c) {\n        return n[c].apply(u, {\n          bandAware: a,\n          position: s\n        });\n      });\n    },\n    isInRange: function(i) {\n      return dw(i, function(o, a) {\n        return n[a].isInRange(o);\n      });\n    }\n  });\n};\nfunction y5(e) {\n  return (e % 180 + 180) % 180;\n}\nvar b5 = function(t) {\n  var n = t.width, r = t.height, i = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, o = y5(i), a = o * Math.PI / 180, s = Math.atan(r / n), u = a > s && a < Math.PI - s ? r / Math.sin(a) : n / Math.cos(a);\n  return Math.abs(u);\n}, w5 = Hn, x5 = Ho, S5 = Ws;\nfunction $5(e) {\n  return function(t, n, r) {\n    var i = Object(t);\n    if (!x5(t)) {\n      var o = w5(n);\n      t = S5(t), n = function(s) {\n        return o(i[s], s, i);\n      };\n    }\n    var a = e(t, n, r);\n    return a > -1 ? i[o ? t[a] : a] : void 0;\n  };\n}\nvar O5 = $5, _5 = uw;\nfunction A5(e) {\n  var t = _5(e), n = t % 1;\n  return t === t ? n ? t - n : t : 0;\n}\nvar P5 = A5, C5 = Tb, E5 = Hn, T5 = P5, M5 = Math.max;\nfunction R5(e, t, n) {\n  var r = e == null ? 0 : e.length;\n  if (!r)\n    return -1;\n  var i = n == null ? 0 : T5(n);\n  return i < 0 && (i = M5(r + i, 0)), C5(e, E5(t), i);\n}\nvar I5 = R5, j5 = O5, k5 = I5, D5 = j5(k5), N5 = D5;\nconst F5 = /* @__PURE__ */ je(N5);\nvar L5 = ZP(function(e) {\n  return {\n    x: e.left,\n    y: e.top,\n    width: e.width,\n    height: e.height\n  };\n}, function(e) {\n  return [\"l\", e.left, \"t\", e.top, \"w\", e.width, \"h\", e.height].join(\"\");\n});\nfunction As(e) {\n  \"@babel/helpers - typeof\";\n  return As = typeof Symbol == \"function\" && typeof Symbol.iterator == \"symbol\" ? function(t) {\n    return typeof t;\n  } : function(t) {\n    return t && typeof Symbol == \"function\" && t.constructor === Symbol && t !== Symbol.prototype ? \"symbol\" : typeof t;\n  }, As(e);\n}\nvar gd = /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(void 0), vd = /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(void 0), bw = /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(void 0), ww = /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)({}), xw = /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(void 0), Sw = /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(0), $w = /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(0), Dv = function(t) {\n  var n = t.state, r = n.xAxisMap, i = n.yAxisMap, o = n.offset, a = t.clipPathId, s = t.children, u = t.width, c = t.height, f = L5(o);\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(gd.Provider, {\n    value: r\n  }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(vd.Provider, {\n    value: i\n  }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(ww.Provider, {\n    value: o\n  }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(bw.Provider, {\n    value: f\n  }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(xw.Provider, {\n    value: a\n  }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(Sw.Provider, {\n    value: c\n  }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement($w.Provider, {\n    value: u\n  }, s)))))));\n}, B5 = function() {\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(xw);\n};\nfunction Ow(e) {\n  var t = Object.keys(e);\n  return t.length === 0 ? \"There are no available ids.\" : \"Available ids are: \".concat(t, \".\");\n}\nvar _w = function(t) {\n  var n = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(gd);\n  n == null && ( true ? gt(!1, \"Could not find Recharts context; are you sure this is rendered inside a Recharts wrapper component?\") : 0);\n  var r = n[t];\n  return r == null && ( true ? gt(!1, 'Could not find xAxis by id \"'.concat(t, '\" [').concat(As(t), \"]. \").concat(Ow(n))) : 0), r;\n}, z5 = function() {\n  var t = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(gd);\n  return kn(t);\n}, V5 = function() {\n  var t = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(vd), n = F5(t, function(r) {\n    return dw(r.domain, Number.isFinite);\n  });\n  return n || kn(t);\n}, Aw = function(t) {\n  var n = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(vd);\n  n == null && ( true ? gt(!1, \"Could not find Recharts context; are you sure this is rendered inside a Recharts wrapper component?\") : 0);\n  var r = n[t];\n  return r == null && ( true ? gt(!1, 'Could not find yAxis by id \"'.concat(t, '\" [').concat(As(t), \"]. \").concat(Ow(n))) : 0), r;\n}, G5 = function() {\n  var t = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(bw);\n  return t;\n}, W5 = function() {\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(ww);\n}, md = function() {\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)($w);\n}, yd = function() {\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(Sw);\n};\nfunction Ro(e) {\n  \"@babel/helpers - typeof\";\n  return Ro = typeof Symbol == \"function\" && typeof Symbol.iterator == \"symbol\" ? function(t) {\n    return typeof t;\n  } : function(t) {\n    return t && typeof Symbol == \"function\" && t.constructor === Symbol && t !== Symbol.prototype ? \"symbol\" : typeof t;\n  }, Ro(e);\n}\nfunction Nv(e, t) {\n  var n = Object.keys(e);\n  if (Object.getOwnPropertySymbols) {\n    var r = Object.getOwnPropertySymbols(e);\n    t && (r = r.filter(function(i) {\n      return Object.getOwnPropertyDescriptor(e, i).enumerable;\n    })), n.push.apply(n, r);\n  }\n  return n;\n}\nfunction Fv(e) {\n  for (var t = 1; t < arguments.length; t++) {\n    var n = arguments[t] != null ? arguments[t] : {};\n    t % 2 ? Nv(Object(n), !0).forEach(function(r) {\n      U5(e, r, n[r]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Nv(Object(n)).forEach(function(r) {\n      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));\n    });\n  }\n  return e;\n}\nfunction U5(e, t, n) {\n  return t = H5(t), t in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;\n}\nfunction H5(e) {\n  var t = q5(e, \"string\");\n  return Ro(t) == \"symbol\" ? t : String(t);\n}\nfunction q5(e, t) {\n  if (Ro(e) != \"object\" || !e)\n    return e;\n  var n = e[Symbol.toPrimitive];\n  if (n !== void 0) {\n    var r = n.call(e, t || \"default\");\n    if (Ro(r) != \"object\")\n      return r;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (t === \"string\" ? String : Number)(e);\n}\nfunction K5(e, t) {\n  return J5(e) || Z5(e, t) || X5(e, t) || Y5();\n}\nfunction Y5() {\n  throw new TypeError(`Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);\n}\nfunction X5(e, t) {\n  if (e) {\n    if (typeof e == \"string\")\n      return Lv(e, t);\n    var n = Object.prototype.toString.call(e).slice(8, -1);\n    if (n === \"Object\" && e.constructor && (n = e.constructor.name), n === \"Map\" || n === \"Set\")\n      return Array.from(e);\n    if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))\n      return Lv(e, t);\n  }\n}\nfunction Lv(e, t) {\n  (t == null || t > e.length) && (t = e.length);\n  for (var n = 0, r = new Array(t); n < t; n++)\n    r[n] = e[n];\n  return r;\n}\nfunction Z5(e, t) {\n  var n = e == null ? null : typeof Symbol < \"u\" && e[Symbol.iterator] || e[\"@@iterator\"];\n  if (n != null) {\n    var r, i, o, a, s = [], u = !0, c = !1;\n    try {\n      if (o = (n = n.call(e)).next, t !== 0)\n        for (; !(u = (r = o.call(n)).done) && (s.push(r.value), s.length !== t); u = !0)\n          ;\n    } catch (f) {\n      c = !0, i = f;\n    } finally {\n      try {\n        if (!u && n.return != null && (a = n.return(), Object(a) !== a))\n          return;\n      } finally {\n        if (c)\n          throw i;\n      }\n    }\n    return s;\n  }\n}\nfunction J5(e) {\n  if (Array.isArray(e))\n    return e;\n}\nfunction kl() {\n  return kl = Object.assign ? Object.assign.bind() : function(e) {\n    for (var t = 1; t < arguments.length; t++) {\n      var n = arguments[t];\n      for (var r in n)\n        Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);\n    }\n    return e;\n  }, kl.apply(this, arguments);\n}\nvar Q5 = function(t, n) {\n  var r;\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.isValidElement(t) ? r = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.cloneElement(t, n) : pe(t) ? r = t(n) : r = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"line\", kl({}, n, {\n    className: \"recharts-reference-line-line\"\n  })), r;\n}, eG = function(t, n, r, i, o, a, s, u, c) {\n  var f = o.x, l = o.y, d = o.width, p = o.height;\n  if (r) {\n    var g = c.y, h = t.y.apply(g, {\n      position: a\n    });\n    if (sn(c, \"discard\") && !t.y.isInRange(h))\n      return null;\n    var v = [{\n      x: f + d,\n      y: h\n    }, {\n      x: f,\n      y: h\n    }];\n    return u === \"left\" ? v.reverse() : v;\n  }\n  if (n) {\n    var w = c.x, b = t.x.apply(w, {\n      position: a\n    });\n    if (sn(c, \"discard\") && !t.x.isInRange(b))\n      return null;\n    var x = [{\n      x: b,\n      y: l + p\n    }, {\n      x: b,\n      y: l\n    }];\n    return s === \"top\" ? x.reverse() : x;\n  }\n  if (i) {\n    var m = c.segment, y = m.map(function(S) {\n      return t.apply(S, {\n        position: a\n      });\n    });\n    return sn(c, \"discard\") && EV(y, function(S) {\n      return !t.isInRange(S);\n    }) ? null : y;\n  }\n  return null;\n};\nfunction bd(e) {\n  var t = e.x, n = e.y, r = e.segment, i = e.xAxisId, o = e.yAxisId, a = e.shape, s = e.className, u = e.alwaysShow, c = B5(), f = _w(i), l = Aw(o), d = G5();\n  if (!c || !d)\n    return null;\n  Fr(u === void 0, 'The alwaysShow prop is deprecated. Please use ifOverflow=\"extendDomain\" instead.');\n  var p = hd({\n    x: f.scale,\n    y: l.scale\n  }), g = Ke(t), h = Ke(n), v = r && r.length === 2, w = eG(p, g, h, v, d, e.position, f.orientation, l.orientation, e);\n  if (!w)\n    return null;\n  var b = K5(w, 2), x = b[0], m = x.x, y = x.y, S = b[1], $ = S.x, O = S.y, T = sn(e, \"hidden\") ? \"url(#\".concat(c, \")\") : void 0, M = Fv(Fv({\n    clipPath: T\n  }, ye(e, !0)), {}, {\n    x1: m,\n    y1: y,\n    x2: $,\n    y2: O\n  });\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(We, {\n    className: $e(\"recharts-reference-line\", s)\n  }, Q5(a, M), at.renderCallByParent(e, m5({\n    x1: m,\n    y1: y,\n    x2: $,\n    y2: O\n  })));\n}\nbd.displayName = \"ReferenceLine\";\nbd.defaultProps = {\n  isFront: !1,\n  ifOverflow: \"discard\",\n  xAxisId: 0,\n  yAxisId: 0,\n  fill: \"none\",\n  stroke: \"#ccc\",\n  fillOpacity: 1,\n  strokeWidth: 1,\n  position: \"middle\"\n};\nfunction Io(e) {\n  \"@babel/helpers - typeof\";\n  return Io = typeof Symbol == \"function\" && typeof Symbol.iterator == \"symbol\" ? function(t) {\n    return typeof t;\n  } : function(t) {\n    return t && typeof Symbol == \"function\" && t.constructor === Symbol && t !== Symbol.prototype ? \"symbol\" : typeof t;\n  }, Io(e);\n}\nfunction Dl() {\n  return Dl = Object.assign ? Object.assign.bind() : function(e) {\n    for (var t = 1; t < arguments.length; t++) {\n      var n = arguments[t];\n      for (var r in n)\n        Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);\n    }\n    return e;\n  }, Dl.apply(this, arguments);\n}\nfunction Bv(e, t) {\n  var n = Object.keys(e);\n  if (Object.getOwnPropertySymbols) {\n    var r = Object.getOwnPropertySymbols(e);\n    t && (r = r.filter(function(i) {\n      return Object.getOwnPropertyDescriptor(e, i).enumerable;\n    })), n.push.apply(n, r);\n  }\n  return n;\n}\nfunction zv(e) {\n  for (var t = 1; t < arguments.length; t++) {\n    var n = arguments[t] != null ? arguments[t] : {};\n    t % 2 ? Bv(Object(n), !0).forEach(function(r) {\n      tG(e, r, n[r]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Bv(Object(n)).forEach(function(r) {\n      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));\n    });\n  }\n  return e;\n}\nfunction tG(e, t, n) {\n  return t = nG(t), t in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;\n}\nfunction nG(e) {\n  var t = rG(e, \"string\");\n  return Io(t) == \"symbol\" ? t : String(t);\n}\nfunction rG(e, t) {\n  if (Io(e) != \"object\" || !e)\n    return e;\n  var n = e[Symbol.toPrimitive];\n  if (n !== void 0) {\n    var r = n.call(e, t || \"default\");\n    if (Io(r) != \"object\")\n      return r;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (t === \"string\" ? String : Number)(e);\n}\nvar iG = function(t) {\n  var n = t.x, r = t.y, i = t.xAxis, o = t.yAxis, a = hd({\n    x: i.scale,\n    y: o.scale\n  }), s = a.apply({\n    x: n,\n    y: r\n  }, {\n    bandAware: !0\n  });\n  return sn(t, \"discard\") && !a.isInRange(s) ? null : s;\n};\nfunction Qo(e) {\n  var t = e.x, n = e.y, r = e.r, i = e.alwaysShow, o = e.clipPathId, a = Ke(t), s = Ke(n);\n  if (Fr(i === void 0, 'The alwaysShow prop is deprecated. Please use ifOverflow=\"extendDomain\" instead.'), !a || !s)\n    return null;\n  var u = iG(e);\n  if (!u)\n    return null;\n  var c = u.x, f = u.y, l = e.shape, d = e.className, p = sn(e, \"hidden\") ? \"url(#\".concat(o, \")\") : void 0, g = zv(zv({\n    clipPath: p\n  }, ye(e, !0)), {}, {\n    cx: c,\n    cy: f\n  });\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(We, {\n    className: $e(\"recharts-reference-dot\", d)\n  }, Qo.renderDot(l, g), at.renderCallByParent(e, {\n    x: c - r,\n    y: f - r,\n    width: 2 * r,\n    height: 2 * r\n  }));\n}\nQo.displayName = \"ReferenceDot\";\nQo.defaultProps = {\n  isFront: !1,\n  ifOverflow: \"discard\",\n  xAxisId: 0,\n  yAxisId: 0,\n  r: 10,\n  fill: \"#fff\",\n  stroke: \"#ccc\",\n  fillOpacity: 1,\n  strokeWidth: 1\n};\nQo.renderDot = function(e, t) {\n  var n;\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.isValidElement(e) ? n = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.cloneElement(e, t) : pe(e) ? n = e(t) : n = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(pd, Dl({}, t, {\n    cx: t.cx,\n    cy: t.cy,\n    className: \"recharts-reference-dot-dot\"\n  })), n;\n};\nfunction jo(e) {\n  \"@babel/helpers - typeof\";\n  return jo = typeof Symbol == \"function\" && typeof Symbol.iterator == \"symbol\" ? function(t) {\n    return typeof t;\n  } : function(t) {\n    return t && typeof Symbol == \"function\" && t.constructor === Symbol && t !== Symbol.prototype ? \"symbol\" : typeof t;\n  }, jo(e);\n}\nfunction Nl() {\n  return Nl = Object.assign ? Object.assign.bind() : function(e) {\n    for (var t = 1; t < arguments.length; t++) {\n      var n = arguments[t];\n      for (var r in n)\n        Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);\n    }\n    return e;\n  }, Nl.apply(this, arguments);\n}\nfunction Vv(e, t) {\n  var n = Object.keys(e);\n  if (Object.getOwnPropertySymbols) {\n    var r = Object.getOwnPropertySymbols(e);\n    t && (r = r.filter(function(i) {\n      return Object.getOwnPropertyDescriptor(e, i).enumerable;\n    })), n.push.apply(n, r);\n  }\n  return n;\n}\nfunction Gv(e) {\n  for (var t = 1; t < arguments.length; t++) {\n    var n = arguments[t] != null ? arguments[t] : {};\n    t % 2 ? Vv(Object(n), !0).forEach(function(r) {\n      oG(e, r, n[r]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Vv(Object(n)).forEach(function(r) {\n      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));\n    });\n  }\n  return e;\n}\nfunction oG(e, t, n) {\n  return t = aG(t), t in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;\n}\nfunction aG(e) {\n  var t = sG(e, \"string\");\n  return jo(t) == \"symbol\" ? t : String(t);\n}\nfunction sG(e, t) {\n  if (jo(e) != \"object\" || !e)\n    return e;\n  var n = e[Symbol.toPrimitive];\n  if (n !== void 0) {\n    var r = n.call(e, t || \"default\");\n    if (jo(r) != \"object\")\n      return r;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (t === \"string\" ? String : Number)(e);\n}\nvar uG = function(t, n, r, i, o) {\n  var a = o.x1, s = o.x2, u = o.y1, c = o.y2, f = o.xAxis, l = o.yAxis;\n  if (!f || !l)\n    return null;\n  var d = hd({\n    x: f.scale,\n    y: l.scale\n  }), p = {\n    x: t ? d.x.apply(a, {\n      position: \"start\"\n    }) : d.x.rangeMin,\n    y: r ? d.y.apply(u, {\n      position: \"start\"\n    }) : d.y.rangeMin\n  }, g = {\n    x: n ? d.x.apply(s, {\n      position: \"end\"\n    }) : d.x.rangeMax,\n    y: i ? d.y.apply(c, {\n      position: \"end\"\n    }) : d.y.rangeMax\n  };\n  return sn(o, \"discard\") && (!d.isInRange(p) || !d.isInRange(g)) ? null : mw(p, g);\n};\nfunction ea(e) {\n  var t = e.x1, n = e.x2, r = e.y1, i = e.y2, o = e.className, a = e.alwaysShow, s = e.clipPathId;\n  Fr(a === void 0, 'The alwaysShow prop is deprecated. Please use ifOverflow=\"extendDomain\" instead.');\n  var u = Ke(t), c = Ke(n), f = Ke(r), l = Ke(i), d = e.shape;\n  if (!u && !c && !f && !l && !d)\n    return null;\n  var p = uG(u, c, f, l, e);\n  if (!p && !d)\n    return null;\n  var g = sn(e, \"hidden\") ? \"url(#\".concat(s, \")\") : void 0;\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(We, {\n    className: $e(\"recharts-reference-area\", o)\n  }, ea.renderRect(d, Gv(Gv({\n    clipPath: g\n  }, ye(e, !0)), p)), at.renderCallByParent(e, p));\n}\nea.displayName = \"ReferenceArea\";\nea.defaultProps = {\n  isFront: !1,\n  ifOverflow: \"discard\",\n  xAxisId: 0,\n  yAxisId: 0,\n  r: 10,\n  fill: \"#ccc\",\n  fillOpacity: 0.5,\n  stroke: \"none\",\n  strokeWidth: 1\n};\nea.renderRect = function(e, t) {\n  var n;\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.isValidElement(e) ? n = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.cloneElement(e, t) : pe(e) ? n = e(t) : n = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(dd, Nl({}, t, {\n    className: \"recharts-reference-area-rect\"\n  })), n;\n};\nfunction Pw(e, t, n) {\n  if (t < 1)\n    return [];\n  if (t === 1 && n === void 0)\n    return e;\n  for (var r = [], i = 0; i < e.length; i += t)\n    r.push(e[i]);\n  return r;\n}\nfunction cG(e, t, n) {\n  var r = {\n    width: e.width + t.width,\n    height: e.height + t.height\n  };\n  return b5(r, n);\n}\nfunction lG(e, t, n) {\n  var r = n === \"width\", i = e.x, o = e.y, a = e.width, s = e.height;\n  return t === 1 ? {\n    start: r ? i : o,\n    end: r ? i + a : o + s\n  } : {\n    start: r ? i + a : o + s,\n    end: r ? i : o\n  };\n}\nfunction Ps(e, t, n, r, i) {\n  if (e * t < e * r || e * t > e * i)\n    return !1;\n  var o = n();\n  return e * (t - e * o / 2 - r) >= 0 && e * (t + e * o / 2 - i) <= 0;\n}\nfunction fG(e, t) {\n  return Pw(e, t + 1);\n}\nfunction dG(e, t, n, r, i) {\n  for (var o = (r || []).slice(), a = t.start, s = t.end, u = 0, c = 1, f = a, l = function() {\n    var g = r == null ? void 0 : r[u];\n    if (g === void 0)\n      return {\n        v: Pw(r, c)\n      };\n    var h = u, v, w = function() {\n      return v === void 0 && (v = n(g, h)), v;\n    }, b = g.coordinate, x = u === 0 || Ps(e, b, w, f, s);\n    x || (u = 0, f = a, c += 1), x && (f = b + e * (w() / 2 + i), u += c);\n  }, d; c <= o.length; )\n    if (d = l(), d)\n      return d.v;\n  return [];\n}\nfunction ko(e) {\n  \"@babel/helpers - typeof\";\n  return ko = typeof Symbol == \"function\" && typeof Symbol.iterator == \"symbol\" ? function(t) {\n    return typeof t;\n  } : function(t) {\n    return t && typeof Symbol == \"function\" && t.constructor === Symbol && t !== Symbol.prototype ? \"symbol\" : typeof t;\n  }, ko(e);\n}\nfunction Wv(e, t) {\n  var n = Object.keys(e);\n  if (Object.getOwnPropertySymbols) {\n    var r = Object.getOwnPropertySymbols(e);\n    t && (r = r.filter(function(i) {\n      return Object.getOwnPropertyDescriptor(e, i).enumerable;\n    })), n.push.apply(n, r);\n  }\n  return n;\n}\nfunction ot(e) {\n  for (var t = 1; t < arguments.length; t++) {\n    var n = arguments[t] != null ? arguments[t] : {};\n    t % 2 ? Wv(Object(n), !0).forEach(function(r) {\n      pG(e, r, n[r]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Wv(Object(n)).forEach(function(r) {\n      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));\n    });\n  }\n  return e;\n}\nfunction pG(e, t, n) {\n  return t = hG(t), t in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;\n}\nfunction hG(e) {\n  var t = gG(e, \"string\");\n  return ko(t) == \"symbol\" ? t : String(t);\n}\nfunction gG(e, t) {\n  if (ko(e) != \"object\" || !e)\n    return e;\n  var n = e[Symbol.toPrimitive];\n  if (n !== void 0) {\n    var r = n.call(e, t || \"default\");\n    if (ko(r) != \"object\")\n      return r;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (t === \"string\" ? String : Number)(e);\n}\nfunction vG(e, t, n, r, i) {\n  for (var o = (r || []).slice(), a = o.length, s = t.start, u = t.end, c = function(d) {\n    var p = o[d], g, h = function() {\n      return g === void 0 && (g = n(p, d)), g;\n    };\n    if (d === a - 1) {\n      var v = e * (p.coordinate + e * h() / 2 - u);\n      o[d] = p = ot(ot({}, p), {}, {\n        tickCoord: v > 0 ? p.coordinate - v * e : p.coordinate\n      });\n    } else\n      o[d] = p = ot(ot({}, p), {}, {\n        tickCoord: p.coordinate\n      });\n    var w = Ps(e, p.tickCoord, h, s, u);\n    w && (u = p.tickCoord - e * (h() / 2 + i), o[d] = ot(ot({}, p), {}, {\n      isShow: !0\n    }));\n  }, f = a - 1; f >= 0; f--)\n    c(f);\n  return o;\n}\nfunction mG(e, t, n, r, i, o) {\n  var a = (r || []).slice(), s = a.length, u = t.start, c = t.end;\n  if (o) {\n    var f = r[s - 1], l = n(f, s - 1), d = e * (f.coordinate + e * l / 2 - c);\n    a[s - 1] = f = ot(ot({}, f), {}, {\n      tickCoord: d > 0 ? f.coordinate - d * e : f.coordinate\n    });\n    var p = Ps(e, f.tickCoord, function() {\n      return l;\n    }, u, c);\n    p && (c = f.tickCoord - e * (l / 2 + i), a[s - 1] = ot(ot({}, f), {}, {\n      isShow: !0\n    }));\n  }\n  for (var g = o ? s - 1 : s, h = function(b) {\n    var x = a[b], m, y = function() {\n      return m === void 0 && (m = n(x, b)), m;\n    };\n    if (b === 0) {\n      var S = e * (x.coordinate - e * y() / 2 - u);\n      a[b] = x = ot(ot({}, x), {}, {\n        tickCoord: S < 0 ? x.coordinate - S * e : x.coordinate\n      });\n    } else\n      a[b] = x = ot(ot({}, x), {}, {\n        tickCoord: x.coordinate\n      });\n    var $ = Ps(e, x.tickCoord, y, u, c);\n    $ && (u = x.tickCoord + e * (y() / 2 + i), a[b] = ot(ot({}, x), {}, {\n      isShow: !0\n    }));\n  }, v = 0; v < g; v++)\n    h(v);\n  return a;\n}\nfunction wd(e, t, n) {\n  var r = e.tick, i = e.ticks, o = e.viewBox, a = e.minTickGap, s = e.orientation, u = e.interval, c = e.tickFormatter, f = e.unit, l = e.angle;\n  if (!i || !i.length || !r)\n    return [];\n  if (K(u) || yn.isSsr)\n    return fG(i, typeof u == \"number\" && K(u) ? u : 0);\n  var d = [], p = s === \"top\" || s === \"bottom\" ? \"width\" : \"height\", g = f && p === \"width\" ? Gi(f, {\n    fontSize: t,\n    letterSpacing: n\n  }) : {\n    width: 0,\n    height: 0\n  }, h = function(x, m) {\n    var y = pe(c) ? c(x.value, m) : x.value;\n    return p === \"width\" ? cG(Gi(y, {\n      fontSize: t,\n      letterSpacing: n\n    }), g, l) : Gi(y, {\n      fontSize: t,\n      letterSpacing: n\n    })[p];\n  }, v = i.length >= 2 ? Kt(i[1].coordinate - i[0].coordinate) : 1, w = lG(o, v, p);\n  return u === \"equidistantPreserveStart\" ? dG(v, w, h, i, a) : (u === \"preserveStart\" || u === \"preserveStartEnd\" ? d = mG(v, w, h, i, a, u === \"preserveStartEnd\") : d = vG(v, w, h, i, a), d.filter(function(b) {\n    return b.isShow;\n  }));\n}\nvar yG = [\"viewBox\"], bG = [\"viewBox\"], wG = [\"ticks\"];\nfunction Qr(e) {\n  \"@babel/helpers - typeof\";\n  return Qr = typeof Symbol == \"function\" && typeof Symbol.iterator == \"symbol\" ? function(t) {\n    return typeof t;\n  } : function(t) {\n    return t && typeof Symbol == \"function\" && t.constructor === Symbol && t !== Symbol.prototype ? \"symbol\" : typeof t;\n  }, Qr(e);\n}\nfunction Er() {\n  return Er = Object.assign ? Object.assign.bind() : function(e) {\n    for (var t = 1; t < arguments.length; t++) {\n      var n = arguments[t];\n      for (var r in n)\n        Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);\n    }\n    return e;\n  }, Er.apply(this, arguments);\n}\nfunction Uv(e, t) {\n  var n = Object.keys(e);\n  if (Object.getOwnPropertySymbols) {\n    var r = Object.getOwnPropertySymbols(e);\n    t && (r = r.filter(function(i) {\n      return Object.getOwnPropertyDescriptor(e, i).enumerable;\n    })), n.push.apply(n, r);\n  }\n  return n;\n}\nfunction lt(e) {\n  for (var t = 1; t < arguments.length; t++) {\n    var n = arguments[t] != null ? arguments[t] : {};\n    t % 2 ? Uv(Object(n), !0).forEach(function(r) {\n      xd(e, r, n[r]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Uv(Object(n)).forEach(function(r) {\n      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));\n    });\n  }\n  return e;\n}\nfunction rc(e, t) {\n  if (e == null)\n    return {};\n  var n = xG(e, t), r, i;\n  if (Object.getOwnPropertySymbols) {\n    var o = Object.getOwnPropertySymbols(e);\n    for (i = 0; i < o.length; i++)\n      r = o[i], !(t.indexOf(r) >= 0) && Object.prototype.propertyIsEnumerable.call(e, r) && (n[r] = e[r]);\n  }\n  return n;\n}\nfunction xG(e, t) {\n  if (e == null)\n    return {};\n  var n = {}, r = Object.keys(e), i, o;\n  for (o = 0; o < r.length; o++)\n    i = r[o], !(t.indexOf(i) >= 0) && (n[i] = e[i]);\n  return n;\n}\nfunction SG(e, t) {\n  if (!(e instanceof t))\n    throw new TypeError(\"Cannot call a class as a function\");\n}\nfunction Hv(e, t) {\n  for (var n = 0; n < t.length; n++) {\n    var r = t[n];\n    r.enumerable = r.enumerable || !1, r.configurable = !0, \"value\" in r && (r.writable = !0), Object.defineProperty(e, Ew(r.key), r);\n  }\n}\nfunction $G(e, t, n) {\n  return t && Hv(e.prototype, t), n && Hv(e, n), Object.defineProperty(e, \"prototype\", { writable: !1 }), e;\n}\nfunction OG(e, t, n) {\n  return t = Cs(t), _G(e, Cw() ? Reflect.construct(t, n || [], Cs(e).constructor) : t.apply(e, n));\n}\nfunction _G(e, t) {\n  if (t && (Qr(t) === \"object\" || typeof t == \"function\"))\n    return t;\n  if (t !== void 0)\n    throw new TypeError(\"Derived constructors may only return object or undefined\");\n  return AG(e);\n}\nfunction AG(e) {\n  if (e === void 0)\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  return e;\n}\nfunction Cw() {\n  try {\n    var e = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {\n    }));\n  } catch {\n  }\n  return (Cw = function() {\n    return !!e;\n  })();\n}\nfunction Cs(e) {\n  return Cs = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(n) {\n    return n.__proto__ || Object.getPrototypeOf(n);\n  }, Cs(e);\n}\nfunction PG(e, t) {\n  if (typeof t != \"function\" && t !== null)\n    throw new TypeError(\"Super expression must either be null or a function\");\n  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, writable: !0, configurable: !0 } }), Object.defineProperty(e, \"prototype\", { writable: !1 }), t && Fl(e, t);\n}\nfunction Fl(e, t) {\n  return Fl = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(r, i) {\n    return r.__proto__ = i, r;\n  }, Fl(e, t);\n}\nfunction xd(e, t, n) {\n  return t = Ew(t), t in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;\n}\nfunction Ew(e) {\n  var t = CG(e, \"string\");\n  return Qr(t) == \"symbol\" ? t : String(t);\n}\nfunction CG(e, t) {\n  if (Qr(e) != \"object\" || !e)\n    return e;\n  var n = e[Symbol.toPrimitive];\n  if (n !== void 0) {\n    var r = n.call(e, t || \"default\");\n    if (Qr(r) != \"object\")\n      return r;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (t === \"string\" ? String : Number)(e);\n}\nvar wi = /* @__PURE__ */ function(e) {\n  PG(t, e);\n  function t(n) {\n    var r;\n    return SG(this, t), r = OG(this, t, [n]), r.state = {\n      fontSize: \"\",\n      letterSpacing: \"\"\n    }, r;\n  }\n  return $G(t, [{\n    key: \"shouldComponentUpdate\",\n    value: function(r, i) {\n      var o = r.viewBox, a = rc(r, yG), s = this.props, u = s.viewBox, c = rc(s, bG);\n      return !Rr(o, u) || !Rr(a, c) || !Rr(i, this.state);\n    }\n  }, {\n    key: \"componentDidMount\",\n    value: function() {\n      var r = this.layerReference;\n      if (r) {\n        var i = r.getElementsByClassName(\"recharts-cartesian-axis-tick-value\")[0];\n        i && this.setState({\n          fontSize: window.getComputedStyle(i).fontSize,\n          letterSpacing: window.getComputedStyle(i).letterSpacing\n        });\n      }\n    }\n    /**\n     * Calculate the coordinates of endpoints in ticks\n     * @param  {Object} data The data of a simple tick\n     * @return {Object} (x1, y1): The coordinate of endpoint close to tick text\n     *  (x2, y2): The coordinate of endpoint close to axis\n     */\n  }, {\n    key: \"getTickLineCoord\",\n    value: function(r) {\n      var i = this.props, o = i.x, a = i.y, s = i.width, u = i.height, c = i.orientation, f = i.tickSize, l = i.mirror, d = i.tickMargin, p, g, h, v, w, b, x = l ? -1 : 1, m = r.tickSize || f, y = K(r.tickCoord) ? r.tickCoord : r.coordinate;\n      switch (c) {\n        case \"top\":\n          p = g = r.coordinate, v = a + +!l * u, h = v - x * m, b = h - x * d, w = y;\n          break;\n        case \"left\":\n          h = v = r.coordinate, g = o + +!l * s, p = g - x * m, w = p - x * d, b = y;\n          break;\n        case \"right\":\n          h = v = r.coordinate, g = o + +l * s, p = g + x * m, w = p + x * d, b = y;\n          break;\n        default:\n          p = g = r.coordinate, v = a + +l * u, h = v + x * m, b = h + x * d, w = y;\n          break;\n      }\n      return {\n        line: {\n          x1: p,\n          y1: h,\n          x2: g,\n          y2: v\n        },\n        tick: {\n          x: w,\n          y: b\n        }\n      };\n    }\n  }, {\n    key: \"getTickTextAnchor\",\n    value: function() {\n      var r = this.props, i = r.orientation, o = r.mirror, a;\n      switch (i) {\n        case \"left\":\n          a = o ? \"start\" : \"end\";\n          break;\n        case \"right\":\n          a = o ? \"end\" : \"start\";\n          break;\n        default:\n          a = \"middle\";\n          break;\n      }\n      return a;\n    }\n  }, {\n    key: \"getTickVerticalAnchor\",\n    value: function() {\n      var r = this.props, i = r.orientation, o = r.mirror, a = \"end\";\n      switch (i) {\n        case \"left\":\n        case \"right\":\n          a = \"middle\";\n          break;\n        case \"top\":\n          a = o ? \"start\" : \"end\";\n          break;\n        default:\n          a = o ? \"end\" : \"start\";\n          break;\n      }\n      return a;\n    }\n  }, {\n    key: \"renderAxisLine\",\n    value: function() {\n      var r = this.props, i = r.x, o = r.y, a = r.width, s = r.height, u = r.orientation, c = r.mirror, f = r.axisLine, l = lt(lt(lt({}, ye(this.props, !1)), ye(f, !1)), {}, {\n        fill: \"none\"\n      });\n      if (u === \"top\" || u === \"bottom\") {\n        var d = +(u === \"top\" && !c || u === \"bottom\" && c);\n        l = lt(lt({}, l), {}, {\n          x1: i,\n          y1: o + d * s,\n          x2: i + a,\n          y2: o + d * s\n        });\n      } else {\n        var p = +(u === \"left\" && !c || u === \"right\" && c);\n        l = lt(lt({}, l), {}, {\n          x1: i + p * a,\n          y1: o,\n          x2: i + p * a,\n          y2: o + s\n        });\n      }\n      return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"line\", Er({}, l, {\n        className: $e(\"recharts-cartesian-axis-line\", jt(f, \"className\"))\n      }));\n    }\n  }, {\n    key: \"renderTicks\",\n    value: (\n      /**\n       * render the ticks\n       * @param {Array} ticks The ticks to actually render (overrides what was passed in props)\n       * @param {string} fontSize Fontsize to consider for tick spacing\n       * @param {string} letterSpacing Letterspacing to consider for tick spacing\n       * @return {ReactComponent} renderedTicks\n       */\n      function(r, i, o) {\n        var a = this, s = this.props, u = s.tickLine, c = s.stroke, f = s.tick, l = s.tickFormatter, d = s.unit, p = wd(lt(lt({}, this.props), {}, {\n          ticks: r\n        }), i, o), g = this.getTickTextAnchor(), h = this.getTickVerticalAnchor(), v = ye(this.props, !1), w = ye(f, !1), b = lt(lt({}, v), {}, {\n          fill: \"none\"\n        }, ye(u, !1)), x = p.map(function(m, y) {\n          var S = a.getTickLineCoord(m), $ = S.line, O = S.tick, T = lt(lt(lt(lt({\n            textAnchor: g,\n            verticalAnchor: h\n          }, v), {}, {\n            stroke: \"none\",\n            fill: c\n          }, w), O), {}, {\n            index: y,\n            payload: m,\n            visibleTicksCount: p.length,\n            tickFormatter: l\n          });\n          return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(We, Er({\n            className: \"recharts-cartesian-axis-tick\",\n            key: \"tick-\".concat(m.value, \"-\").concat(m.coordinate, \"-\").concat(m.tickCoord)\n          }, Fa(a.props, m, y)), u && /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"line\", Er({}, b, $, {\n            className: $e(\"recharts-cartesian-axis-tick-line\", jt(u, \"className\"))\n          })), f && t.renderTickItem(f, T, \"\".concat(pe(l) ? l(m.value, y) : m.value).concat(d || \"\")));\n        });\n        return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"g\", {\n          className: \"recharts-cartesian-axis-ticks\"\n        }, x);\n      }\n    )\n  }, {\n    key: \"render\",\n    value: function() {\n      var r = this, i = this.props, o = i.axisLine, a = i.width, s = i.height, u = i.ticksGenerator, c = i.className, f = i.hide;\n      if (f)\n        return null;\n      var l = this.props, d = l.ticks, p = rc(l, wG), g = d;\n      return pe(u) && (g = d && d.length > 0 ? u(this.props) : u(p)), a <= 0 || s <= 0 || !g || !g.length ? null : /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(We, {\n        className: $e(\"recharts-cartesian-axis\", c),\n        ref: function(v) {\n          r.layerReference = v;\n        }\n      }, o && this.renderAxisLine(), this.renderTicks(g, this.state.fontSize, this.state.letterSpacing), at.renderCallByParent(this.props));\n    }\n  }], [{\n    key: \"renderTickItem\",\n    value: function(r, i, o) {\n      var a;\n      return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.isValidElement(r) ? a = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.cloneElement(r, i) : pe(r) ? a = r(i) : a = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(Ja, Er({}, i, {\n        className: \"recharts-cartesian-axis-tick-value\"\n      }), o), a;\n    }\n  }]), t;\n}(react__WEBPACK_IMPORTED_MODULE_0__.Component);\nxd(wi, \"displayName\", \"CartesianAxis\");\nxd(wi, \"defaultProps\", {\n  x: 0,\n  y: 0,\n  width: 0,\n  height: 0,\n  viewBox: {\n    x: 0,\n    y: 0,\n    width: 0,\n    height: 0\n  },\n  // The orientation of axis\n  orientation: \"bottom\",\n  // The ticks\n  ticks: [],\n  stroke: \"#666\",\n  tickLine: !0,\n  axisLine: !0,\n  tick: !0,\n  mirror: !1,\n  minTickGap: 5,\n  // The width or height of tick\n  tickSize: 6,\n  tickMargin: 2,\n  interval: \"preserveEnd\"\n});\nvar EG = [\"x1\", \"y1\", \"x2\", \"y2\", \"key\"], TG = [\"offset\"];\nfunction dr(e) {\n  \"@babel/helpers - typeof\";\n  return dr = typeof Symbol == \"function\" && typeof Symbol.iterator == \"symbol\" ? function(t) {\n    return typeof t;\n  } : function(t) {\n    return t && typeof Symbol == \"function\" && t.constructor === Symbol && t !== Symbol.prototype ? \"symbol\" : typeof t;\n  }, dr(e);\n}\nfunction qv(e, t) {\n  var n = Object.keys(e);\n  if (Object.getOwnPropertySymbols) {\n    var r = Object.getOwnPropertySymbols(e);\n    t && (r = r.filter(function(i) {\n      return Object.getOwnPropertyDescriptor(e, i).enumerable;\n    })), n.push.apply(n, r);\n  }\n  return n;\n}\nfunction st(e) {\n  for (var t = 1; t < arguments.length; t++) {\n    var n = arguments[t] != null ? arguments[t] : {};\n    t % 2 ? qv(Object(n), !0).forEach(function(r) {\n      MG(e, r, n[r]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : qv(Object(n)).forEach(function(r) {\n      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));\n    });\n  }\n  return e;\n}\nfunction MG(e, t, n) {\n  return t = RG(t), t in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;\n}\nfunction RG(e) {\n  var t = IG(e, \"string\");\n  return dr(t) == \"symbol\" ? t : String(t);\n}\nfunction IG(e, t) {\n  if (dr(e) != \"object\" || !e)\n    return e;\n  var n = e[Symbol.toPrimitive];\n  if (n !== void 0) {\n    var r = n.call(e, t || \"default\");\n    if (dr(r) != \"object\")\n      return r;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (t === \"string\" ? String : Number)(e);\n}\nfunction or() {\n  return or = Object.assign ? Object.assign.bind() : function(e) {\n    for (var t = 1; t < arguments.length; t++) {\n      var n = arguments[t];\n      for (var r in n)\n        Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);\n    }\n    return e;\n  }, or.apply(this, arguments);\n}\nfunction Kv(e, t) {\n  if (e == null)\n    return {};\n  var n = jG(e, t), r, i;\n  if (Object.getOwnPropertySymbols) {\n    var o = Object.getOwnPropertySymbols(e);\n    for (i = 0; i < o.length; i++)\n      r = o[i], !(t.indexOf(r) >= 0) && Object.prototype.propertyIsEnumerable.call(e, r) && (n[r] = e[r]);\n  }\n  return n;\n}\nfunction jG(e, t) {\n  if (e == null)\n    return {};\n  var n = {}, r = Object.keys(e), i, o;\n  for (o = 0; o < r.length; o++)\n    i = r[o], !(t.indexOf(i) >= 0) && (n[i] = e[i]);\n  return n;\n}\nvar kG = function(t) {\n  var n = t.fill;\n  if (!n || n === \"none\")\n    return null;\n  var r = t.fillOpacity, i = t.x, o = t.y, a = t.width, s = t.height;\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"rect\", {\n    x: i,\n    y: o,\n    width: a,\n    height: s,\n    stroke: \"none\",\n    fill: n,\n    fillOpacity: r,\n    className: \"recharts-cartesian-grid-bg\"\n  });\n};\nfunction Tw(e, t) {\n  var n;\n  if (/* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.isValidElement(e))\n    n = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.cloneElement(e, t);\n  else if (pe(e))\n    n = e(t);\n  else {\n    var r = t.x1, i = t.y1, o = t.x2, a = t.y2, s = t.key, u = Kv(t, EG), c = ye(u, !1);\n    c.offset;\n    var f = Kv(c, TG);\n    n = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"line\", or({}, f, {\n      x1: r,\n      y1: i,\n      x2: o,\n      y2: a,\n      fill: \"none\",\n      key: s\n    }));\n  }\n  return n;\n}\nfunction DG(e) {\n  var t = e.x, n = e.width, r = e.horizontal, i = r === void 0 ? !0 : r, o = e.horizontalPoints;\n  if (!i || !o || !o.length)\n    return null;\n  var a = o.map(function(s, u) {\n    var c = st(st({}, e), {}, {\n      x1: t,\n      y1: s,\n      x2: t + n,\n      y2: s,\n      key: \"line-\".concat(u),\n      index: u\n    });\n    return Tw(i, c);\n  });\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"g\", {\n    className: \"recharts-cartesian-grid-horizontal\"\n  }, a);\n}\nfunction NG(e) {\n  var t = e.y, n = e.height, r = e.vertical, i = r === void 0 ? !0 : r, o = e.verticalPoints;\n  if (!i || !o || !o.length)\n    return null;\n  var a = o.map(function(s, u) {\n    var c = st(st({}, e), {}, {\n      x1: s,\n      y1: t,\n      x2: s,\n      y2: t + n,\n      key: \"line-\".concat(u),\n      index: u\n    });\n    return Tw(i, c);\n  });\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"g\", {\n    className: \"recharts-cartesian-grid-vertical\"\n  }, a);\n}\nfunction FG(e) {\n  var t = e.horizontalFill, n = e.fillOpacity, r = e.x, i = e.y, o = e.width, a = e.height, s = e.horizontalPoints, u = e.horizontal, c = u === void 0 ? !0 : u;\n  if (!c || !t || !t.length)\n    return null;\n  var f = s.map(function(d) {\n    return Math.round(d + i - i);\n  }).sort(function(d, p) {\n    return d - p;\n  });\n  i !== f[0] && f.unshift(0);\n  var l = f.map(function(d, p) {\n    var g = !f[p + 1], h = g ? i + a - d : f[p + 1] - d;\n    if (h <= 0)\n      return null;\n    var v = p % t.length;\n    return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"rect\", {\n      key: \"react-\".concat(p),\n      y: d,\n      x: r,\n      height: h,\n      width: o,\n      stroke: \"none\",\n      fill: t[v],\n      fillOpacity: n,\n      className: \"recharts-cartesian-grid-bg\"\n    });\n  });\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"g\", {\n    className: \"recharts-cartesian-gridstripes-horizontal\"\n  }, l);\n}\nfunction LG(e) {\n  var t = e.vertical, n = t === void 0 ? !0 : t, r = e.verticalFill, i = e.fillOpacity, o = e.x, a = e.y, s = e.width, u = e.height, c = e.verticalPoints;\n  if (!n || !r || !r.length)\n    return null;\n  var f = c.map(function(d) {\n    return Math.round(d + o - o);\n  }).sort(function(d, p) {\n    return d - p;\n  });\n  o !== f[0] && f.unshift(0);\n  var l = f.map(function(d, p) {\n    var g = !f[p + 1], h = g ? o + s - d : f[p + 1] - d;\n    if (h <= 0)\n      return null;\n    var v = p % r.length;\n    return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"rect\", {\n      key: \"react-\".concat(p),\n      x: d,\n      y: a,\n      width: h,\n      height: u,\n      stroke: \"none\",\n      fill: r[v],\n      fillOpacity: i,\n      className: \"recharts-cartesian-grid-bg\"\n    });\n  });\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"g\", {\n    className: \"recharts-cartesian-gridstripes-vertical\"\n  }, l);\n}\nvar BG = function(t, n) {\n  var r = t.xAxis, i = t.width, o = t.height, a = t.offset;\n  return H0(wd(st(st(st({}, wi.defaultProps), r), {}, {\n    ticks: mn(r, !0),\n    viewBox: {\n      x: 0,\n      y: 0,\n      width: i,\n      height: o\n    }\n  })), a.left, a.left + a.width, n);\n}, zG = function(t, n) {\n  var r = t.yAxis, i = t.width, o = t.height, a = t.offset;\n  return H0(wd(st(st(st({}, wi.defaultProps), r), {}, {\n    ticks: mn(r, !0),\n    viewBox: {\n      x: 0,\n      y: 0,\n      width: i,\n      height: o\n    }\n  })), a.top, a.top + a.height, n);\n}, Ar = {\n  horizontal: !0,\n  vertical: !0,\n  // The ordinates of horizontal grid lines\n  horizontalPoints: [],\n  // The abscissas of vertical grid lines\n  verticalPoints: [],\n  stroke: \"#ccc\",\n  fill: \"none\",\n  // The fill of colors of grid lines\n  verticalFill: [],\n  horizontalFill: []\n};\nfunction Mw(e) {\n  var t, n, r, i, o, a, s = md(), u = yd(), c = W5(), f = st(st({}, e), {}, {\n    stroke: (t = e.stroke) !== null && t !== void 0 ? t : Ar.stroke,\n    fill: (n = e.fill) !== null && n !== void 0 ? n : Ar.fill,\n    horizontal: (r = e.horizontal) !== null && r !== void 0 ? r : Ar.horizontal,\n    horizontalFill: (i = e.horizontalFill) !== null && i !== void 0 ? i : Ar.horizontalFill,\n    vertical: (o = e.vertical) !== null && o !== void 0 ? o : Ar.vertical,\n    verticalFill: (a = e.verticalFill) !== null && a !== void 0 ? a : Ar.verticalFill,\n    x: K(e.x) ? e.x : c.left,\n    y: K(e.y) ? e.y : c.top,\n    width: K(e.width) ? e.width : c.width,\n    height: K(e.height) ? e.height : c.height\n  }), l = f.x, d = f.y, p = f.width, g = f.height, h = f.syncWithTicks, v = f.horizontalValues, w = f.verticalValues, b = z5(), x = V5();\n  if (!K(p) || p <= 0 || !K(g) || g <= 0 || !K(l) || l !== +l || !K(d) || d !== +d)\n    return null;\n  var m = f.verticalCoordinatesGenerator || BG, y = f.horizontalCoordinatesGenerator || zG, S = f.horizontalPoints, $ = f.verticalPoints;\n  if ((!S || !S.length) && pe(y)) {\n    var O = v && v.length, T = y({\n      yAxis: x ? st(st({}, x), {}, {\n        ticks: O ? v : x.ticks\n      }) : void 0,\n      width: s,\n      height: u,\n      offset: c\n    }, O ? !0 : h);\n    Fr(Array.isArray(T), \"horizontalCoordinatesGenerator should return Array but instead it returned [\".concat(dr(T), \"]\")), Array.isArray(T) && (S = T);\n  }\n  if ((!$ || !$.length) && pe(m)) {\n    var M = w && w.length, E = m({\n      xAxis: b ? st(st({}, b), {}, {\n        ticks: M ? w : b.ticks\n      }) : void 0,\n      width: s,\n      height: u,\n      offset: c\n    }, M ? !0 : h);\n    Fr(Array.isArray(E), \"verticalCoordinatesGenerator should return Array but instead it returned [\".concat(dr(E), \"]\")), Array.isArray(E) && ($ = E);\n  }\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"g\", {\n    className: \"recharts-cartesian-grid\"\n  }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(kG, {\n    fill: f.fill,\n    fillOpacity: f.fillOpacity,\n    x: f.x,\n    y: f.y,\n    width: f.width,\n    height: f.height\n  }), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(DG, or({}, f, {\n    offset: c,\n    horizontalPoints: S,\n    xAxis: b,\n    yAxis: x\n  })), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(NG, or({}, f, {\n    offset: c,\n    verticalPoints: $,\n    xAxis: b,\n    yAxis: x\n  })), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(FG, or({}, f, {\n    horizontalPoints: S\n  })), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(LG, or({}, f, {\n    verticalPoints: $\n  })));\n}\nMw.displayName = \"CartesianGrid\";\nvar VG = [\"type\", \"layout\", \"connectNulls\", \"ref\"];\nfunction ei(e) {\n  \"@babel/helpers - typeof\";\n  return ei = typeof Symbol == \"function\" && typeof Symbol.iterator == \"symbol\" ? function(t) {\n    return typeof t;\n  } : function(t) {\n    return t && typeof Symbol == \"function\" && t.constructor === Symbol && t !== Symbol.prototype ? \"symbol\" : typeof t;\n  }, ei(e);\n}\nfunction GG(e, t) {\n  if (e == null)\n    return {};\n  var n = WG(e, t), r, i;\n  if (Object.getOwnPropertySymbols) {\n    var o = Object.getOwnPropertySymbols(e);\n    for (i = 0; i < o.length; i++)\n      r = o[i], !(t.indexOf(r) >= 0) && Object.prototype.propertyIsEnumerable.call(e, r) && (n[r] = e[r]);\n  }\n  return n;\n}\nfunction WG(e, t) {\n  if (e == null)\n    return {};\n  var n = {}, r = Object.keys(e), i, o;\n  for (o = 0; o < r.length; o++)\n    i = r[o], !(t.indexOf(i) >= 0) && (n[i] = e[i]);\n  return n;\n}\nfunction qi() {\n  return qi = Object.assign ? Object.assign.bind() : function(e) {\n    for (var t = 1; t < arguments.length; t++) {\n      var n = arguments[t];\n      for (var r in n)\n        Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);\n    }\n    return e;\n  }, qi.apply(this, arguments);\n}\nfunction Yv(e, t) {\n  var n = Object.keys(e);\n  if (Object.getOwnPropertySymbols) {\n    var r = Object.getOwnPropertySymbols(e);\n    t && (r = r.filter(function(i) {\n      return Object.getOwnPropertyDescriptor(e, i).enumerable;\n    })), n.push.apply(n, r);\n  }\n  return n;\n}\nfunction yt(e) {\n  for (var t = 1; t < arguments.length; t++) {\n    var n = arguments[t] != null ? arguments[t] : {};\n    t % 2 ? Yv(Object(n), !0).forEach(function(r) {\n      Ut(e, r, n[r]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Yv(Object(n)).forEach(function(r) {\n      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));\n    });\n  }\n  return e;\n}\nfunction Pr(e) {\n  return KG(e) || qG(e) || HG(e) || UG();\n}\nfunction UG() {\n  throw new TypeError(`Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);\n}\nfunction HG(e, t) {\n  if (e) {\n    if (typeof e == \"string\")\n      return Ll(e, t);\n    var n = Object.prototype.toString.call(e).slice(8, -1);\n    if (n === \"Object\" && e.constructor && (n = e.constructor.name), n === \"Map\" || n === \"Set\")\n      return Array.from(e);\n    if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))\n      return Ll(e, t);\n  }\n}\nfunction qG(e) {\n  if (typeof Symbol < \"u\" && e[Symbol.iterator] != null || e[\"@@iterator\"] != null)\n    return Array.from(e);\n}\nfunction KG(e) {\n  if (Array.isArray(e))\n    return Ll(e);\n}\nfunction Ll(e, t) {\n  (t == null || t > e.length) && (t = e.length);\n  for (var n = 0, r = new Array(t); n < t; n++)\n    r[n] = e[n];\n  return r;\n}\nfunction YG(e, t) {\n  if (!(e instanceof t))\n    throw new TypeError(\"Cannot call a class as a function\");\n}\nfunction Xv(e, t) {\n  for (var n = 0; n < t.length; n++) {\n    var r = t[n];\n    r.enumerable = r.enumerable || !1, r.configurable = !0, \"value\" in r && (r.writable = !0), Object.defineProperty(e, Iw(r.key), r);\n  }\n}\nfunction XG(e, t, n) {\n  return t && Xv(e.prototype, t), n && Xv(e, n), Object.defineProperty(e, \"prototype\", { writable: !1 }), e;\n}\nfunction ZG(e, t, n) {\n  return t = Es(t), JG(e, Rw() ? Reflect.construct(t, n || [], Es(e).constructor) : t.apply(e, n));\n}\nfunction JG(e, t) {\n  if (t && (ei(t) === \"object\" || typeof t == \"function\"))\n    return t;\n  if (t !== void 0)\n    throw new TypeError(\"Derived constructors may only return object or undefined\");\n  return In(e);\n}\nfunction Rw() {\n  try {\n    var e = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {\n    }));\n  } catch {\n  }\n  return (Rw = function() {\n    return !!e;\n  })();\n}\nfunction Es(e) {\n  return Es = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(n) {\n    return n.__proto__ || Object.getPrototypeOf(n);\n  }, Es(e);\n}\nfunction In(e) {\n  if (e === void 0)\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  return e;\n}\nfunction QG(e, t) {\n  if (typeof t != \"function\" && t !== null)\n    throw new TypeError(\"Super expression must either be null or a function\");\n  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, writable: !0, configurable: !0 } }), Object.defineProperty(e, \"prototype\", { writable: !1 }), t && Bl(e, t);\n}\nfunction Bl(e, t) {\n  return Bl = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(r, i) {\n    return r.__proto__ = i, r;\n  }, Bl(e, t);\n}\nfunction Ut(e, t, n) {\n  return t = Iw(t), t in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;\n}\nfunction Iw(e) {\n  var t = eW(e, \"string\");\n  return ei(t) == \"symbol\" ? t : String(t);\n}\nfunction eW(e, t) {\n  if (ei(e) != \"object\" || !e)\n    return e;\n  var n = e[Symbol.toPrimitive];\n  if (n !== void 0) {\n    var r = n.call(e, t || \"default\");\n    if (ei(r) != \"object\")\n      return r;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (t === \"string\" ? String : Number)(e);\n}\nvar ti = /* @__PURE__ */ function(e) {\n  QG(t, e);\n  function t() {\n    var n;\n    YG(this, t);\n    for (var r = arguments.length, i = new Array(r), o = 0; o < r; o++)\n      i[o] = arguments[o];\n    return n = ZG(this, t, [].concat(i)), Ut(In(n), \"state\", {\n      isAnimationFinished: !0,\n      totalLength: 0\n    }), Ut(In(n), \"generateSimpleStrokeDasharray\", function(a, s) {\n      return \"\".concat(s, \"px \").concat(a - s, \"px\");\n    }), Ut(In(n), \"getStrokeDasharray\", function(a, s, u) {\n      var c = u.reduce(function(w, b) {\n        return w + b;\n      });\n      if (!c)\n        return n.generateSimpleStrokeDasharray(s, a);\n      for (var f = Math.floor(a / c), l = a % c, d = s - a, p = [], g = 0, h = 0; g < u.length; h += u[g], ++g)\n        if (h + u[g] > l) {\n          p = [].concat(Pr(u.slice(0, g)), [l - h]);\n          break;\n        }\n      var v = p.length % 2 === 0 ? [0, d] : [d];\n      return [].concat(Pr(t.repeat(u, f)), Pr(p), v).map(function(w) {\n        return \"\".concat(w, \"px\");\n      }).join(\", \");\n    }), Ut(In(n), \"id\", Uo(\"recharts-line-\")), Ut(In(n), \"pathRef\", function(a) {\n      n.mainCurve = a;\n    }), Ut(In(n), \"handleAnimationEnd\", function() {\n      n.setState({\n        isAnimationFinished: !0\n      }), n.props.onAnimationEnd && n.props.onAnimationEnd();\n    }), Ut(In(n), \"handleAnimationStart\", function() {\n      n.setState({\n        isAnimationFinished: !1\n      }), n.props.onAnimationStart && n.props.onAnimationStart();\n    }), n;\n  }\n  return XG(t, [{\n    key: \"componentDidMount\",\n    value: function() {\n      if (this.props.isAnimationActive) {\n        var r = this.getTotalLength();\n        this.setState({\n          totalLength: r\n        });\n      }\n    }\n  }, {\n    key: \"componentDidUpdate\",\n    value: function() {\n      if (this.props.isAnimationActive) {\n        var r = this.getTotalLength();\n        r !== this.state.totalLength && this.setState({\n          totalLength: r\n        });\n      }\n    }\n  }, {\n    key: \"getTotalLength\",\n    value: function() {\n      var r = this.mainCurve;\n      try {\n        return r && r.getTotalLength && r.getTotalLength() || 0;\n      } catch {\n        return 0;\n      }\n    }\n  }, {\n    key: \"renderErrorBar\",\n    value: function(r, i) {\n      if (this.props.isAnimationActive && !this.state.isAnimationFinished)\n        return null;\n      var o = this.props, a = o.points, s = o.xAxis, u = o.yAxis, c = o.layout, f = o.children, l = kt(f, Zo);\n      if (!l)\n        return null;\n      var d = function(h, v) {\n        return {\n          x: h.x,\n          y: h.y,\n          value: h.value,\n          errorVal: At(h.payload, v)\n        };\n      }, p = {\n        clipPath: r ? \"url(#clipPath-\".concat(i, \")\") : null\n      };\n      return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(We, p, l.map(function(g) {\n        return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.cloneElement(g, {\n          key: \"bar-\".concat(g.props.dataKey),\n          data: a,\n          xAxis: s,\n          yAxis: u,\n          layout: c,\n          dataPointFormatter: d\n        });\n      }));\n    }\n  }, {\n    key: \"renderDots\",\n    value: function(r, i, o) {\n      var a = this.props.isAnimationActive;\n      if (a && !this.state.isAnimationFinished)\n        return null;\n      var s = this.props, u = s.dot, c = s.points, f = s.dataKey, l = ye(this.props, !1), d = ye(u, !0), p = c.map(function(h, v) {\n        var w = yt(yt(yt({\n          key: \"dot-\".concat(v),\n          r: 3\n        }, l), d), {}, {\n          value: h.value,\n          dataKey: f,\n          cx: h.x,\n          cy: h.y,\n          index: v,\n          payload: h.payload\n        });\n        return t.renderDotItem(u, w);\n      }), g = {\n        clipPath: r ? \"url(#clipPath-\".concat(i ? \"\" : \"dots-\").concat(o, \")\") : null\n      };\n      return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(We, qi({\n        className: \"recharts-line-dots\",\n        key: \"dots\"\n      }, g), p);\n    }\n  }, {\n    key: \"renderCurveStatically\",\n    value: function(r, i, o, a) {\n      var s = this.props, u = s.type, c = s.layout, f = s.connectNulls;\n      s.ref;\n      var l = GG(s, VG), d = yt(yt(yt({}, ye(l, !0)), {}, {\n        fill: \"none\",\n        className: \"recharts-line-curve\",\n        clipPath: i ? \"url(#clipPath-\".concat(o, \")\") : null,\n        points: r\n      }, a), {}, {\n        type: u,\n        layout: c,\n        connectNulls: f\n      });\n      return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(bl, qi({}, d, {\n        pathRef: this.pathRef\n      }));\n    }\n  }, {\n    key: \"renderCurveWithAnimation\",\n    value: function(r, i) {\n      var o = this, a = this.props, s = a.points, u = a.strokeDasharray, c = a.isAnimationActive, f = a.animationBegin, l = a.animationDuration, d = a.animationEasing, p = a.animationId, g = a.animateNewValues, h = a.width, v = a.height, w = this.state, b = w.prevPoints, x = w.totalLength;\n      return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(_n, {\n        begin: f,\n        duration: l,\n        isActive: c,\n        easing: d,\n        from: {\n          t: 0\n        },\n        to: {\n          t: 1\n        },\n        key: \"line-\".concat(p),\n        onAnimationEnd: this.handleAnimationEnd,\n        onAnimationStart: this.handleAnimationStart\n      }, function(m) {\n        var y = m.t;\n        if (b) {\n          var S = b.length / s.length, $ = s.map(function(A, j) {\n            var R = Math.floor(j * S);\n            if (b[R]) {\n              var N = b[R], k = Ht(N.x, A.x), F = Ht(N.y, A.y);\n              return yt(yt({}, A), {}, {\n                x: k(y),\n                y: F(y)\n              });\n            }\n            if (g) {\n              var V = Ht(h * 2, A.x), L = Ht(v / 2, A.y);\n              return yt(yt({}, A), {}, {\n                x: V(y),\n                y: L(y)\n              });\n            }\n            return yt(yt({}, A), {}, {\n              x: A.x,\n              y: A.y\n            });\n          });\n          return o.renderCurveStatically($, r, i);\n        }\n        var O = Ht(0, x), T = O(y), M;\n        if (u) {\n          var E = \"\".concat(u).split(/[,\\s]+/gim).map(function(A) {\n            return parseFloat(A);\n          });\n          M = o.getStrokeDasharray(T, x, E);\n        } else\n          M = o.generateSimpleStrokeDasharray(x, T);\n        return o.renderCurveStatically(s, r, i, {\n          strokeDasharray: M\n        });\n      });\n    }\n  }, {\n    key: \"renderCurve\",\n    value: function(r, i) {\n      var o = this.props, a = o.points, s = o.isAnimationActive, u = this.state, c = u.prevPoints, f = u.totalLength;\n      return s && a && a.length && (!c && f > 0 || !tu(c, a)) ? this.renderCurveWithAnimation(r, i) : this.renderCurveStatically(a, r, i);\n    }\n  }, {\n    key: \"render\",\n    value: function() {\n      var r, i = this.props, o = i.hide, a = i.dot, s = i.points, u = i.className, c = i.xAxis, f = i.yAxis, l = i.top, d = i.left, p = i.width, g = i.height, h = i.isAnimationActive, v = i.id;\n      if (o || !s || !s.length)\n        return null;\n      var w = this.state.isAnimationFinished, b = s.length === 1, x = $e(\"recharts-line\", u), m = c && c.allowDataOverflow, y = f && f.allowDataOverflow, S = m || y, $ = me(v) ? this.id : v, O = (r = ye(a, !1)) !== null && r !== void 0 ? r : {\n        r: 3,\n        strokeWidth: 2\n      }, T = O.r, M = T === void 0 ? 3 : T, E = O.strokeWidth, A = E === void 0 ? 2 : E, j = nE(a) ? a : {}, R = j.clipDot, N = R === void 0 ? !0 : R, k = M * 2 + A;\n      return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(We, {\n        className: x\n      }, m || y ? /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"defs\", null, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"clipPath\", {\n        id: \"clipPath-\".concat($)\n      }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"rect\", {\n        x: m ? d : d - p / 2,\n        y: y ? l : l - g / 2,\n        width: m ? p : p * 2,\n        height: y ? g : g * 2\n      })), !N && /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"clipPath\", {\n        id: \"clipPath-dots-\".concat($)\n      }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"rect\", {\n        x: d - k / 2,\n        y: l - k / 2,\n        width: p + k,\n        height: g + k\n      }))) : null, !b && this.renderCurve(S, $), this.renderErrorBar(S, $), (b || a) && this.renderDots(S, N, $), (!h || w) && Bn.renderCallByParent(this.props, s));\n    }\n  }], [{\n    key: \"getDerivedStateFromProps\",\n    value: function(r, i) {\n      return r.animationId !== i.prevAnimationId ? {\n        prevAnimationId: r.animationId,\n        curPoints: r.points,\n        prevPoints: i.curPoints\n      } : r.points !== i.curPoints ? {\n        curPoints: r.points\n      } : null;\n    }\n  }, {\n    key: \"repeat\",\n    value: function(r, i) {\n      for (var o = r.length % 2 !== 0 ? [].concat(Pr(r), [0]) : r, a = [], s = 0; s < i; ++s)\n        a = [].concat(Pr(a), Pr(o));\n      return a;\n    }\n  }, {\n    key: \"renderDotItem\",\n    value: function(r, i) {\n      var o;\n      if (/* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.isValidElement(r))\n        o = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.cloneElement(r, i);\n      else if (pe(r))\n        o = r(i);\n      else {\n        var a = $e(\"recharts-line-dot\", typeof r != \"boolean\" ? r.className : \"\");\n        o = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(pd, qi({}, i, {\n          className: a\n        }));\n      }\n      return o;\n    }\n  }]), t;\n}(react__WEBPACK_IMPORTED_MODULE_0__.PureComponent);\nUt(ti, \"displayName\", \"Line\");\nUt(ti, \"defaultProps\", {\n  xAxisId: 0,\n  yAxisId: 0,\n  connectNulls: !1,\n  activeDot: !0,\n  dot: !0,\n  legendType: \"line\",\n  stroke: \"#3182bd\",\n  strokeWidth: 1,\n  fill: \"#fff\",\n  points: [],\n  isAnimationActive: !yn.isSsr,\n  animateNewValues: !0,\n  animationBegin: 0,\n  animationDuration: 1500,\n  animationEasing: \"ease\",\n  hide: !1,\n  label: !1\n});\nUt(ti, \"getComposedData\", function(e) {\n  var t = e.props, n = e.xAxis, r = e.yAxis, i = e.xAxisTicks, o = e.yAxisTicks, a = e.dataKey, s = e.bandSize, u = e.displayedData, c = e.offset, f = t.layout, l = u.map(function(d, p) {\n    var g = At(d, a);\n    return f === \"horizontal\" ? {\n      x: _g({\n        axis: n,\n        ticks: i,\n        bandSize: s,\n        entry: d,\n        index: p\n      }),\n      y: me(g) ? null : r.scale(g),\n      value: g,\n      payload: d\n    } : {\n      x: me(g) ? null : n.scale(g),\n      y: _g({\n        axis: r,\n        ticks: o,\n        bandSize: s,\n        entry: d,\n        index: p\n      }),\n      value: g,\n      payload: d\n    };\n  });\n  return yt({\n    points: l,\n    layout: f\n  }, c);\n});\nfunction zl() {\n  return zl = Object.assign ? Object.assign.bind() : function(e) {\n    for (var t = 1; t < arguments.length; t++) {\n      var n = arguments[t];\n      for (var r in n)\n        Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);\n    }\n    return e;\n  }, zl.apply(this, arguments);\n}\nvar su = function(t) {\n  var n = t.xAxisId, r = md(), i = yd(), o = _w(n);\n  return o == null ? null : (\n    // @ts-expect-error the axisOptions type is not exactly what CartesianAxis is expecting.\n    /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(wi, zl({}, o, {\n      className: $e(\"recharts-\".concat(o.axisType, \" \").concat(o.axisType), o.className),\n      viewBox: {\n        x: 0,\n        y: 0,\n        width: r,\n        height: i\n      },\n      ticksGenerator: function(s) {\n        return mn(s, !0);\n      }\n    }))\n  );\n};\nsu.displayName = \"XAxis\";\nsu.defaultProps = {\n  allowDecimals: !0,\n  hide: !1,\n  orientation: \"bottom\",\n  width: 0,\n  height: 30,\n  mirror: !1,\n  xAxisId: 0,\n  tickCount: 5,\n  type: \"category\",\n  padding: {\n    left: 0,\n    right: 0\n  },\n  allowDataOverflow: !1,\n  scale: \"auto\",\n  reversed: !1,\n  allowDuplicatedCategory: !0\n};\nfunction Vl() {\n  return Vl = Object.assign ? Object.assign.bind() : function(e) {\n    for (var t = 1; t < arguments.length; t++) {\n      var n = arguments[t];\n      for (var r in n)\n        Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);\n    }\n    return e;\n  }, Vl.apply(this, arguments);\n}\nvar uu = function(t) {\n  var n = t.yAxisId, r = md(), i = yd(), o = Aw(n);\n  return o == null ? null : (\n    // @ts-expect-error the axisOptions type is not exactly what CartesianAxis is expecting.\n    /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(wi, Vl({}, o, {\n      className: $e(\"recharts-\".concat(o.axisType, \" \").concat(o.axisType), o.className),\n      viewBox: {\n        x: 0,\n        y: 0,\n        width: r,\n        height: i\n      },\n      ticksGenerator: function(s) {\n        return mn(s, !0);\n      }\n    }))\n  );\n};\nuu.displayName = \"YAxis\";\nuu.defaultProps = {\n  allowDuplicatedCategory: !0,\n  allowDecimals: !0,\n  hide: !1,\n  orientation: \"left\",\n  width: 60,\n  height: 0,\n  mirror: !1,\n  yAxisId: 0,\n  tickCount: 5,\n  type: \"number\",\n  padding: {\n    top: 0,\n    bottom: 0\n  },\n  allowDataOverflow: !1,\n  scale: \"auto\",\n  reversed: !1\n};\nfunction Zv(e) {\n  return iW(e) || rW(e) || nW(e) || tW();\n}\nfunction tW() {\n  throw new TypeError(`Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);\n}\nfunction nW(e, t) {\n  if (e) {\n    if (typeof e == \"string\")\n      return Gl(e, t);\n    var n = Object.prototype.toString.call(e).slice(8, -1);\n    if (n === \"Object\" && e.constructor && (n = e.constructor.name), n === \"Map\" || n === \"Set\")\n      return Array.from(e);\n    if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))\n      return Gl(e, t);\n  }\n}\nfunction rW(e) {\n  if (typeof Symbol < \"u\" && e[Symbol.iterator] != null || e[\"@@iterator\"] != null)\n    return Array.from(e);\n}\nfunction iW(e) {\n  if (Array.isArray(e))\n    return Gl(e);\n}\nfunction Gl(e, t) {\n  (t == null || t > e.length) && (t = e.length);\n  for (var n = 0, r = new Array(t); n < t; n++)\n    r[n] = e[n];\n  return r;\n}\nvar Wl = function(t, n, r, i, o) {\n  var a = kt(t, bd), s = kt(t, Qo), u = [].concat(Zv(a), Zv(s)), c = kt(t, ea), f = \"\".concat(i, \"Id\"), l = i[0], d = n;\n  if (u.length && (d = u.reduce(function(h, v) {\n    if (v.props[f] === r && sn(v.props, \"extendDomain\") && K(v.props[l])) {\n      var w = v.props[l];\n      return [Math.min(h[0], w), Math.max(h[1], w)];\n    }\n    return h;\n  }, d)), c.length) {\n    var p = \"\".concat(l, \"1\"), g = \"\".concat(l, \"2\");\n    d = c.reduce(function(h, v) {\n      if (v.props[f] === r && sn(v.props, \"extendDomain\") && K(v.props[p]) && K(v.props[g])) {\n        var w = v.props[p], b = v.props[g];\n        return [Math.min(h[0], w, b), Math.max(h[1], w, b)];\n      }\n      return h;\n    }, d);\n  }\n  return o && o.length && (d = o.reduce(function(h, v) {\n    return K(v) ? [Math.min(h[0], v), Math.max(h[1], v)] : h;\n  }, d)), d;\n}, jw = { exports: {} };\n(function(e) {\n  var t = Object.prototype.hasOwnProperty, n = \"~\";\n  function r() {\n  }\n  Object.create && (r.prototype = /* @__PURE__ */ Object.create(null), new r().__proto__ || (n = !1));\n  function i(u, c, f) {\n    this.fn = u, this.context = c, this.once = f || !1;\n  }\n  function o(u, c, f, l, d) {\n    if (typeof f != \"function\")\n      throw new TypeError(\"The listener must be a function\");\n    var p = new i(f, l || u, d), g = n ? n + c : c;\n    return u._events[g] ? u._events[g].fn ? u._events[g] = [u._events[g], p] : u._events[g].push(p) : (u._events[g] = p, u._eventsCount++), u;\n  }\n  function a(u, c) {\n    --u._eventsCount === 0 ? u._events = new r() : delete u._events[c];\n  }\n  function s() {\n    this._events = new r(), this._eventsCount = 0;\n  }\n  s.prototype.eventNames = function() {\n    var c = [], f, l;\n    if (this._eventsCount === 0)\n      return c;\n    for (l in f = this._events)\n      t.call(f, l) && c.push(n ? l.slice(1) : l);\n    return Object.getOwnPropertySymbols ? c.concat(Object.getOwnPropertySymbols(f)) : c;\n  }, s.prototype.listeners = function(c) {\n    var f = n ? n + c : c, l = this._events[f];\n    if (!l)\n      return [];\n    if (l.fn)\n      return [l.fn];\n    for (var d = 0, p = l.length, g = new Array(p); d < p; d++)\n      g[d] = l[d].fn;\n    return g;\n  }, s.prototype.listenerCount = function(c) {\n    var f = n ? n + c : c, l = this._events[f];\n    return l ? l.fn ? 1 : l.length : 0;\n  }, s.prototype.emit = function(c, f, l, d, p, g) {\n    var h = n ? n + c : c;\n    if (!this._events[h])\n      return !1;\n    var v = this._events[h], w = arguments.length, b, x;\n    if (v.fn) {\n      switch (v.once && this.removeListener(c, v.fn, void 0, !0), w) {\n        case 1:\n          return v.fn.call(v.context), !0;\n        case 2:\n          return v.fn.call(v.context, f), !0;\n        case 3:\n          return v.fn.call(v.context, f, l), !0;\n        case 4:\n          return v.fn.call(v.context, f, l, d), !0;\n        case 5:\n          return v.fn.call(v.context, f, l, d, p), !0;\n        case 6:\n          return v.fn.call(v.context, f, l, d, p, g), !0;\n      }\n      for (x = 1, b = new Array(w - 1); x < w; x++)\n        b[x - 1] = arguments[x];\n      v.fn.apply(v.context, b);\n    } else {\n      var m = v.length, y;\n      for (x = 0; x < m; x++)\n        switch (v[x].once && this.removeListener(c, v[x].fn, void 0, !0), w) {\n          case 1:\n            v[x].fn.call(v[x].context);\n            break;\n          case 2:\n            v[x].fn.call(v[x].context, f);\n            break;\n          case 3:\n            v[x].fn.call(v[x].context, f, l);\n            break;\n          case 4:\n            v[x].fn.call(v[x].context, f, l, d);\n            break;\n          default:\n            if (!b)\n              for (y = 1, b = new Array(w - 1); y < w; y++)\n                b[y - 1] = arguments[y];\n            v[x].fn.apply(v[x].context, b);\n        }\n    }\n    return !0;\n  }, s.prototype.on = function(c, f, l) {\n    return o(this, c, f, l, !1);\n  }, s.prototype.once = function(c, f, l) {\n    return o(this, c, f, l, !0);\n  }, s.prototype.removeListener = function(c, f, l, d) {\n    var p = n ? n + c : c;\n    if (!this._events[p])\n      return this;\n    if (!f)\n      return a(this, p), this;\n    var g = this._events[p];\n    if (g.fn)\n      g.fn === f && (!d || g.once) && (!l || g.context === l) && a(this, p);\n    else {\n      for (var h = 0, v = [], w = g.length; h < w; h++)\n        (g[h].fn !== f || d && !g[h].once || l && g[h].context !== l) && v.push(g[h]);\n      v.length ? this._events[p] = v.length === 1 ? v[0] : v : a(this, p);\n    }\n    return this;\n  }, s.prototype.removeAllListeners = function(c) {\n    var f;\n    return c ? (f = n ? n + c : c, this._events[f] && a(this, f)) : (this._events = new r(), this._eventsCount = 0), this;\n  }, s.prototype.off = s.prototype.removeListener, s.prototype.addListener = s.prototype.on, s.prefixed = n, s.EventEmitter = s, e.exports = s;\n})(jw);\nvar oW = jw.exports;\nconst aW = /* @__PURE__ */ je(oW);\nvar ic = new aW(), oc = \"recharts.syncMouseEvents\";\nfunction Do(e) {\n  \"@babel/helpers - typeof\";\n  return Do = typeof Symbol == \"function\" && typeof Symbol.iterator == \"symbol\" ? function(t) {\n    return typeof t;\n  } : function(t) {\n    return t && typeof Symbol == \"function\" && t.constructor === Symbol && t !== Symbol.prototype ? \"symbol\" : typeof t;\n  }, Do(e);\n}\nfunction sW(e, t) {\n  if (!(e instanceof t))\n    throw new TypeError(\"Cannot call a class as a function\");\n}\nfunction uW(e, t) {\n  for (var n = 0; n < t.length; n++) {\n    var r = t[n];\n    r.enumerable = r.enumerable || !1, r.configurable = !0, \"value\" in r && (r.writable = !0), Object.defineProperty(e, kw(r.key), r);\n  }\n}\nfunction cW(e, t, n) {\n  return t && uW(e.prototype, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e;\n}\nfunction ac(e, t, n) {\n  return t = kw(t), t in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;\n}\nfunction kw(e) {\n  var t = lW(e, \"string\");\n  return Do(t) == \"symbol\" ? t : String(t);\n}\nfunction lW(e, t) {\n  if (Do(e) != \"object\" || !e)\n    return e;\n  var n = e[Symbol.toPrimitive];\n  if (n !== void 0) {\n    var r = n.call(e, t || \"default\");\n    if (Do(r) != \"object\")\n      return r;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (t === \"string\" ? String : Number)(e);\n}\nvar fW = /* @__PURE__ */ function() {\n  function e() {\n    sW(this, e), ac(this, \"activeIndex\", 0), ac(this, \"coordinateList\", []), ac(this, \"layout\", \"horizontal\");\n  }\n  return cW(e, [{\n    key: \"setDetails\",\n    value: function(n) {\n      var r, i = n.coordinateList, o = i === void 0 ? null : i, a = n.container, s = a === void 0 ? null : a, u = n.layout, c = u === void 0 ? null : u, f = n.offset, l = f === void 0 ? null : f, d = n.mouseHandlerCallback, p = d === void 0 ? null : d;\n      this.coordinateList = (r = o ?? this.coordinateList) !== null && r !== void 0 ? r : [], this.container = s ?? this.container, this.layout = c ?? this.layout, this.offset = l ?? this.offset, this.mouseHandlerCallback = p ?? this.mouseHandlerCallback, this.activeIndex = Math.min(Math.max(this.activeIndex, 0), this.coordinateList.length - 1);\n    }\n  }, {\n    key: \"focus\",\n    value: function() {\n      this.spoofMouse();\n    }\n  }, {\n    key: \"keyboardEvent\",\n    value: function(n) {\n      if (this.coordinateList.length !== 0)\n        switch (n.key) {\n          case \"ArrowRight\": {\n            if (this.layout !== \"horizontal\")\n              return;\n            this.activeIndex = Math.min(this.activeIndex + 1, this.coordinateList.length - 1), this.spoofMouse();\n            break;\n          }\n          case \"ArrowLeft\": {\n            if (this.layout !== \"horizontal\")\n              return;\n            this.activeIndex = Math.max(this.activeIndex - 1, 0), this.spoofMouse();\n            break;\n          }\n        }\n    }\n  }, {\n    key: \"setIndex\",\n    value: function(n) {\n      this.activeIndex = n;\n    }\n  }, {\n    key: \"spoofMouse\",\n    value: function() {\n      var n, r;\n      if (this.layout === \"horizontal\" && this.coordinateList.length !== 0) {\n        var i = this.container.getBoundingClientRect(), o = i.x, a = i.y, s = i.height, u = this.coordinateList[this.activeIndex].coordinate, c = ((n = window) === null || n === void 0 ? void 0 : n.scrollX) || 0, f = ((r = window) === null || r === void 0 ? void 0 : r.scrollY) || 0, l = o + u + c, d = a + this.offset.top + s / 2 + f;\n        this.mouseHandlerCallback({\n          pageX: l,\n          pageY: d\n        });\n      }\n    }\n  }]), e;\n}();\nfunction dW(e, t, n) {\n  if (n === \"number\" && t === !0 && Array.isArray(e)) {\n    var r = e == null ? void 0 : e[0], i = e == null ? void 0 : e[1];\n    if (r && i && K(r) && K(i))\n      return !0;\n  }\n  return !1;\n}\nfunction pW(e, t, n, r) {\n  var i = r / 2;\n  return {\n    stroke: \"none\",\n    fill: \"#ccc\",\n    x: e === \"horizontal\" ? t.x - i : n.left + 0.5,\n    y: e === \"horizontal\" ? n.top + 0.5 : t.y - i,\n    width: e === \"horizontal\" ? r : n.width - 1,\n    height: e === \"horizontal\" ? n.height - 1 : r\n  };\n}\nfunction Dw(e) {\n  var t = e.cx, n = e.cy, r = e.radius, i = e.startAngle, o = e.endAngle, a = nt(t, n, r, i), s = nt(t, n, r, o);\n  return {\n    points: [a, s],\n    cx: t,\n    cy: n,\n    radius: r,\n    startAngle: i,\n    endAngle: o\n  };\n}\nfunction hW(e, t, n) {\n  var r, i, o, a;\n  if (e === \"horizontal\")\n    r = t.x, o = r, i = n.top, a = n.top + n.height;\n  else if (e === \"vertical\")\n    i = t.y, a = i, r = n.left, o = n.left + n.width;\n  else if (t.cx != null && t.cy != null)\n    if (e === \"centric\") {\n      var s = t.cx, u = t.cy, c = t.innerRadius, f = t.outerRadius, l = t.angle, d = nt(s, u, c, l), p = nt(s, u, f, l);\n      r = d.x, i = d.y, o = p.x, a = p.y;\n    } else\n      return Dw(t);\n  return [{\n    x: r,\n    y: i\n  }, {\n    x: o,\n    y: a\n  }];\n}\nfunction No(e) {\n  \"@babel/helpers - typeof\";\n  return No = typeof Symbol == \"function\" && typeof Symbol.iterator == \"symbol\" ? function(t) {\n    return typeof t;\n  } : function(t) {\n    return t && typeof Symbol == \"function\" && t.constructor === Symbol && t !== Symbol.prototype ? \"symbol\" : typeof t;\n  }, No(e);\n}\nfunction Jv(e, t) {\n  var n = Object.keys(e);\n  if (Object.getOwnPropertySymbols) {\n    var r = Object.getOwnPropertySymbols(e);\n    t && (r = r.filter(function(i) {\n      return Object.getOwnPropertyDescriptor(e, i).enumerable;\n    })), n.push.apply(n, r);\n  }\n  return n;\n}\nfunction xa(e) {\n  for (var t = 1; t < arguments.length; t++) {\n    var n = arguments[t] != null ? arguments[t] : {};\n    t % 2 ? Jv(Object(n), !0).forEach(function(r) {\n      gW(e, r, n[r]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Jv(Object(n)).forEach(function(r) {\n      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));\n    });\n  }\n  return e;\n}\nfunction gW(e, t, n) {\n  return t = vW(t), t in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;\n}\nfunction vW(e) {\n  var t = mW(e, \"string\");\n  return No(t) == \"symbol\" ? t : String(t);\n}\nfunction mW(e, t) {\n  if (No(e) != \"object\" || !e)\n    return e;\n  var n = e[Symbol.toPrimitive];\n  if (n !== void 0) {\n    var r = n.call(e, t || \"default\");\n    if (No(r) != \"object\")\n      return r;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (t === \"string\" ? String : Number)(e);\n}\nfunction yW(e) {\n  var t = e.element, n = e.tooltipEventType, r = e.isActive, i = e.activeCoordinate, o = e.activePayload, a = e.offset, s = e.activeTooltipIndex, u = e.tooltipAxisBandSize, c = e.layout, f = e.chartName;\n  if (!t || !t.props.cursor || !r || !i || f !== \"ScatterChart\" && n !== \"axis\")\n    return null;\n  var l, d = bl;\n  if (f === \"ScatterChart\")\n    l = i, d = e9;\n  else if (f === \"BarChart\")\n    l = pW(c, i, a, u), d = dd;\n  else if (c === \"radial\") {\n    var p = Dw(i), g = p.cx, h = p.cy, v = p.radius, w = p.startAngle, b = p.endAngle;\n    l = {\n      cx: g,\n      cy: h,\n      startAngle: w,\n      endAngle: b,\n      innerRadius: v,\n      outerRadius: v\n    }, d = Z0;\n  } else\n    l = {\n      points: hW(c, i, a)\n    }, d = bl;\n  var x = xa(xa(xa(xa({\n    stroke: \"#ccc\",\n    pointerEvents: \"none\"\n  }, a), l), ye(t.props.cursor, !1)), {}, {\n    payload: o,\n    payloadIndex: s,\n    className: $e(\"recharts-tooltip-cursor\", t.props.cursor.className)\n  });\n  return /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.isValidElement)(t.props.cursor) ? /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.cloneElement)(t.props.cursor, x) : /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(d, x);\n}\nvar bW = [\"item\"], wW = [\"children\", \"className\", \"width\", \"height\", \"style\", \"compact\", \"title\", \"desc\"];\nfunction ni(e) {\n  \"@babel/helpers - typeof\";\n  return ni = typeof Symbol == \"function\" && typeof Symbol.iterator == \"symbol\" ? function(t) {\n    return typeof t;\n  } : function(t) {\n    return t && typeof Symbol == \"function\" && t.constructor === Symbol && t !== Symbol.prototype ? \"symbol\" : typeof t;\n  }, ni(e);\n}\nfunction Ki() {\n  return Ki = Object.assign ? Object.assign.bind() : function(e) {\n    for (var t = 1; t < arguments.length; t++) {\n      var n = arguments[t];\n      for (var r in n)\n        Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);\n    }\n    return e;\n  }, Ki.apply(this, arguments);\n}\nfunction Qv(e, t) {\n  return $W(e) || SW(e, t) || Fw(e, t) || xW();\n}\nfunction xW() {\n  throw new TypeError(`Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);\n}\nfunction SW(e, t) {\n  var n = e == null ? null : typeof Symbol < \"u\" && e[Symbol.iterator] || e[\"@@iterator\"];\n  if (n != null) {\n    var r, i, o, a, s = [], u = !0, c = !1;\n    try {\n      if (o = (n = n.call(e)).next, t !== 0)\n        for (; !(u = (r = o.call(n)).done) && (s.push(r.value), s.length !== t); u = !0)\n          ;\n    } catch (f) {\n      c = !0, i = f;\n    } finally {\n      try {\n        if (!u && n.return != null && (a = n.return(), Object(a) !== a))\n          return;\n      } finally {\n        if (c)\n          throw i;\n      }\n    }\n    return s;\n  }\n}\nfunction $W(e) {\n  if (Array.isArray(e))\n    return e;\n}\nfunction em(e, t) {\n  if (e == null)\n    return {};\n  var n = OW(e, t), r, i;\n  if (Object.getOwnPropertySymbols) {\n    var o = Object.getOwnPropertySymbols(e);\n    for (i = 0; i < o.length; i++)\n      r = o[i], !(t.indexOf(r) >= 0) && Object.prototype.propertyIsEnumerable.call(e, r) && (n[r] = e[r]);\n  }\n  return n;\n}\nfunction OW(e, t) {\n  if (e == null)\n    return {};\n  var n = {}, r = Object.keys(e), i, o;\n  for (o = 0; o < r.length; o++)\n    i = r[o], !(t.indexOf(i) >= 0) && (n[i] = e[i]);\n  return n;\n}\nfunction _W(e, t) {\n  if (!(e instanceof t))\n    throw new TypeError(\"Cannot call a class as a function\");\n}\nfunction AW(e, t) {\n  for (var n = 0; n < t.length; n++) {\n    var r = t[n];\n    r.enumerable = r.enumerable || !1, r.configurable = !0, \"value\" in r && (r.writable = !0), Object.defineProperty(e, Lw(r.key), r);\n  }\n}\nfunction PW(e, t, n) {\n  return t && AW(e.prototype, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e;\n}\nfunction CW(e, t, n) {\n  return t = Ts(t), EW(e, Nw() ? Reflect.construct(t, n || [], Ts(e).constructor) : t.apply(e, n));\n}\nfunction EW(e, t) {\n  if (t && (ni(t) === \"object\" || typeof t == \"function\"))\n    return t;\n  if (t !== void 0)\n    throw new TypeError(\"Derived constructors may only return object or undefined\");\n  return Se(e);\n}\nfunction Nw() {\n  try {\n    var e = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {\n    }));\n  } catch {\n  }\n  return (Nw = function() {\n    return !!e;\n  })();\n}\nfunction Ts(e) {\n  return Ts = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(n) {\n    return n.__proto__ || Object.getPrototypeOf(n);\n  }, Ts(e);\n}\nfunction Se(e) {\n  if (e === void 0)\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  return e;\n}\nfunction TW(e, t) {\n  if (typeof t != \"function\" && t !== null)\n    throw new TypeError(\"Super expression must either be null or a function\");\n  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, writable: !0, configurable: !0 } }), Object.defineProperty(e, \"prototype\", { writable: !1 }), t && Ul(e, t);\n}\nfunction Ul(e, t) {\n  return Ul = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(r, i) {\n    return r.__proto__ = i, r;\n  }, Ul(e, t);\n}\nfunction ri(e) {\n  return IW(e) || RW(e) || Fw(e) || MW();\n}\nfunction MW() {\n  throw new TypeError(`Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);\n}\nfunction Fw(e, t) {\n  if (e) {\n    if (typeof e == \"string\")\n      return Hl(e, t);\n    var n = Object.prototype.toString.call(e).slice(8, -1);\n    if (n === \"Object\" && e.constructor && (n = e.constructor.name), n === \"Map\" || n === \"Set\")\n      return Array.from(e);\n    if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))\n      return Hl(e, t);\n  }\n}\nfunction RW(e) {\n  if (typeof Symbol < \"u\" && e[Symbol.iterator] != null || e[\"@@iterator\"] != null)\n    return Array.from(e);\n}\nfunction IW(e) {\n  if (Array.isArray(e))\n    return Hl(e);\n}\nfunction Hl(e, t) {\n  (t == null || t > e.length) && (t = e.length);\n  for (var n = 0, r = new Array(t); n < t; n++)\n    r[n] = e[n];\n  return r;\n}\nfunction tm(e, t) {\n  var n = Object.keys(e);\n  if (Object.getOwnPropertySymbols) {\n    var r = Object.getOwnPropertySymbols(e);\n    t && (r = r.filter(function(i) {\n      return Object.getOwnPropertyDescriptor(e, i).enumerable;\n    })), n.push.apply(n, r);\n  }\n  return n;\n}\nfunction z(e) {\n  for (var t = 1; t < arguments.length; t++) {\n    var n = arguments[t] != null ? arguments[t] : {};\n    t % 2 ? tm(Object(n), !0).forEach(function(r) {\n      se(e, r, n[r]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : tm(Object(n)).forEach(function(r) {\n      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));\n    });\n  }\n  return e;\n}\nfunction se(e, t, n) {\n  return t = Lw(t), t in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;\n}\nfunction Lw(e) {\n  var t = jW(e, \"string\");\n  return ni(t) == \"symbol\" ? t : String(t);\n}\nfunction jW(e, t) {\n  if (ni(e) != \"object\" || !e)\n    return e;\n  var n = e[Symbol.toPrimitive];\n  if (n !== void 0) {\n    var r = n.call(e, t || \"default\");\n    if (ni(r) != \"object\")\n      return r;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (t === \"string\" ? String : Number)(e);\n}\nvar kW = {\n  xAxis: [\"bottom\", \"top\"],\n  yAxis: [\"left\", \"right\"]\n}, DW = {\n  width: \"100%\",\n  height: \"100%\"\n}, Bw = {\n  x: 0,\n  y: 0\n};\nfunction Sa(e) {\n  return e;\n}\nvar NW = function(t, n) {\n  return n === \"horizontal\" ? t.x : n === \"vertical\" ? t.y : n === \"centric\" ? t.angle : t.radius;\n}, FW = function(t, n, r, i) {\n  var o = n.find(function(f) {\n    return f && f.index === r;\n  });\n  if (o) {\n    if (t === \"horizontal\")\n      return {\n        x: o.coordinate,\n        y: i.y\n      };\n    if (t === \"vertical\")\n      return {\n        x: i.x,\n        y: o.coordinate\n      };\n    if (t === \"centric\") {\n      var a = o.coordinate, s = i.radius;\n      return z(z(z({}, i), nt(i.cx, i.cy, s, a)), {}, {\n        angle: a,\n        radius: s\n      });\n    }\n    var u = o.coordinate, c = i.angle;\n    return z(z(z({}, i), nt(i.cx, i.cy, u, c)), {}, {\n      angle: c,\n      radius: u\n    });\n  }\n  return Bw;\n}, cu = function(t, n) {\n  var r = n.graphicalItems, i = n.dataStartIndex, o = n.dataEndIndex, a = (r ?? []).reduce(function(s, u) {\n    var c = u.props.data;\n    return c && c.length ? [].concat(ri(s), ri(c)) : s;\n  }, []);\n  return a.length > 0 ? a : t && t.length && K(i) && K(o) ? t.slice(i, o + 1) : [];\n};\nfunction zw(e) {\n  return e === \"number\" ? [0, \"auto\"] : void 0;\n}\nvar ql = function(t, n, r, i) {\n  var o = t.graphicalItems, a = t.tooltipAxis, s = cu(n, t);\n  return r < 0 || !o || !o.length || r >= s.length ? null : o.reduce(function(u, c) {\n    var f, l = (f = c.props.data) !== null && f !== void 0 ? f : n;\n    l && t.dataStartIndex + t.dataEndIndex !== 0 && (l = l.slice(t.dataStartIndex, t.dataEndIndex + 1));\n    var d;\n    if (a.dataKey && !a.allowDuplicatedCategory) {\n      var p = l === void 0 ? s : l;\n      d = Da(p, a.dataKey, i);\n    } else\n      d = l && l[r] || s[r];\n    return d ? [].concat(ri(u), [K0(c, d)]) : u;\n  }, []);\n}, nm = function(t, n, r, i) {\n  var o = i || {\n    x: t.chartX,\n    y: t.chartY\n  }, a = NW(o, r), s = t.orderedTooltipTicks, u = t.tooltipAxis, c = t.tooltipTicks, f = G6(a, s, c, u);\n  if (f >= 0 && c) {\n    var l = c[f] && c[f].value, d = ql(t, n, f, l), p = FW(r, s, f, o);\n    return {\n      activeTooltipIndex: f,\n      activeLabel: l,\n      activePayload: d,\n      activeCoordinate: p\n    };\n  }\n  return null;\n}, LW = function(t, n) {\n  var r = n.axes, i = n.graphicalItems, o = n.axisType, a = n.axisIdKey, s = n.stackGroups, u = n.dataStartIndex, c = n.dataEndIndex, f = t.layout, l = t.children, d = t.stackOffset, p = U0(f, o);\n  return r.reduce(function(g, h) {\n    var v, w = h.props, b = w.type, x = w.dataKey, m = w.allowDataOverflow, y = w.allowDuplicatedCategory, S = w.scale, $ = w.ticks, O = w.includeHidden, T = h.props[a];\n    if (g[T])\n      return g;\n    var M = cu(t.data, {\n      graphicalItems: i.filter(function(G) {\n        return G.props[a] === T;\n      }),\n      dataStartIndex: u,\n      dataEndIndex: c\n    }), E = M.length, A, j, R;\n    dW(h.props.domain, m, b) && (A = hl(h.props.domain, null, m), p && (b === \"number\" || S !== \"auto\") && (R = Ui(M, x, \"category\")));\n    var N = zw(b);\n    if (!A || A.length === 0) {\n      var k, F = (k = h.props.domain) !== null && k !== void 0 ? k : N;\n      if (x) {\n        if (A = Ui(M, x, b), b === \"category\" && p) {\n          var V = qC(A);\n          y && V ? (j = A, A = xs(0, E)) : y || (A = Eg(F, A, h).reduce(function(G, q) {\n            return G.indexOf(q) >= 0 ? G : [].concat(ri(G), [q]);\n          }, []));\n        } else if (b === \"category\")\n          y ? A = A.filter(function(G) {\n            return G !== \"\" && !me(G);\n          }) : A = Eg(F, A, h).reduce(function(G, q) {\n            return G.indexOf(q) >= 0 || q === \"\" || me(q) ? G : [].concat(ri(G), [q]);\n          }, []);\n        else if (b === \"number\") {\n          var L = K6(M, i.filter(function(G) {\n            return G.props[a] === T && (O || !G.props.hide);\n          }), x, o, f);\n          L && (A = L);\n        }\n        p && (b === \"number\" || S !== \"auto\") && (R = Ui(M, x, \"category\"));\n      } else\n        p ? A = xs(0, E) : s && s[T] && s[T].hasStack && b === \"number\" ? A = d === \"expand\" ? [0, 1] : q0(s[T].stackGroups, u, c) : A = W0(M, i.filter(function(G) {\n          return G.props[a] === T && (O || !G.props.hide);\n        }), b, f, !0);\n      if (b === \"number\")\n        A = Wl(l, A, T, o, $), F && (A = hl(F, A, m));\n      else if (b === \"category\" && F) {\n        var I = F, D = A.every(function(G) {\n          return I.indexOf(G) >= 0;\n        });\n        D && (A = I);\n      }\n    }\n    return z(z({}, g), {}, se({}, T, z(z({}, h.props), {}, {\n      axisType: o,\n      domain: A,\n      categoricalDomain: R,\n      duplicateDomain: j,\n      originalDomain: (v = h.props.domain) !== null && v !== void 0 ? v : N,\n      isCategorical: p,\n      layout: f\n    })));\n  }, {});\n}, BW = function(t, n) {\n  var r = n.graphicalItems, i = n.Axis, o = n.axisType, a = n.axisIdKey, s = n.stackGroups, u = n.dataStartIndex, c = n.dataEndIndex, f = t.layout, l = t.children, d = cu(t.data, {\n    graphicalItems: r,\n    dataStartIndex: u,\n    dataEndIndex: c\n  }), p = d.length, g = U0(f, o), h = -1;\n  return r.reduce(function(v, w) {\n    var b = w.props[a], x = zw(\"number\");\n    if (!v[b]) {\n      h++;\n      var m;\n      return g ? m = xs(0, p) : s && s[b] && s[b].hasStack ? (m = q0(s[b].stackGroups, u, c), m = Wl(l, m, b, o)) : (m = hl(x, W0(d, r.filter(function(y) {\n        return y.props[a] === b && !y.props.hide;\n      }), \"number\", f), i.defaultProps.allowDataOverflow), m = Wl(l, m, b, o)), z(z({}, v), {}, se({}, b, z(z({\n        axisType: o\n      }, i.defaultProps), {}, {\n        hide: !0,\n        orientation: jt(kW, \"\".concat(o, \".\").concat(h % 2), null),\n        domain: m,\n        originalDomain: x,\n        isCategorical: g,\n        layout: f\n        // specify scale when no Axis\n        // scale: isCategorical ? 'band' : 'linear',\n      })));\n    }\n    return v;\n  }, {});\n}, zW = function(t, n) {\n  var r = n.axisType, i = r === void 0 ? \"xAxis\" : r, o = n.AxisComp, a = n.graphicalItems, s = n.stackGroups, u = n.dataStartIndex, c = n.dataEndIndex, f = t.children, l = \"\".concat(i, \"Id\"), d = kt(f, o), p = {};\n  return d && d.length ? p = LW(t, {\n    axes: d,\n    graphicalItems: a,\n    axisType: i,\n    axisIdKey: l,\n    stackGroups: s,\n    dataStartIndex: u,\n    dataEndIndex: c\n  }) : a && a.length && (p = BW(t, {\n    Axis: o,\n    graphicalItems: a,\n    axisType: i,\n    axisIdKey: l,\n    stackGroups: s,\n    dataStartIndex: u,\n    dataEndIndex: c\n  })), p;\n}, VW = function(t) {\n  var n = kn(t), r = mn(n, !1, !0);\n  return {\n    tooltipTicks: r,\n    orderedTooltipTicks: Ff(r, function(i) {\n      return i.coordinate;\n    }),\n    tooltipAxis: n,\n    tooltipAxisBandSize: fs(n, r)\n  };\n}, rm = function(t) {\n  var n = t.children, r = t.defaultShowTooltip, i = wt(n, Xr), o = 0, a = 0;\n  return t.data && t.data.length !== 0 && (a = t.data.length - 1), i && i.props && (i.props.startIndex >= 0 && (o = i.props.startIndex), i.props.endIndex >= 0 && (a = i.props.endIndex)), {\n    chartX: 0,\n    chartY: 0,\n    dataStartIndex: o,\n    dataEndIndex: a,\n    activeTooltipIndex: -1,\n    isTooltipActive: !!r\n  };\n}, GW = function(t) {\n  return !t || !t.length ? !1 : t.some(function(n) {\n    var r = Fn(n && n.type);\n    return r && r.indexOf(\"Bar\") >= 0;\n  });\n}, im = function(t) {\n  return t === \"horizontal\" ? {\n    numericAxisName: \"yAxis\",\n    cateAxisName: \"xAxis\"\n  } : t === \"vertical\" ? {\n    numericAxisName: \"xAxis\",\n    cateAxisName: \"yAxis\"\n  } : t === \"centric\" ? {\n    numericAxisName: \"radiusAxis\",\n    cateAxisName: \"angleAxis\"\n  } : {\n    numericAxisName: \"angleAxis\",\n    cateAxisName: \"radiusAxis\"\n  };\n}, WW = function(t, n) {\n  var r = t.props, i = t.graphicalItems, o = t.xAxisMap, a = o === void 0 ? {} : o, s = t.yAxisMap, u = s === void 0 ? {} : s, c = r.width, f = r.height, l = r.children, d = r.margin || {}, p = wt(l, Xr), g = wt(l, Vr), h = Object.keys(u).reduce(function(y, S) {\n    var $ = u[S], O = $.orientation;\n    return !$.mirror && !$.hide ? z(z({}, y), {}, se({}, O, y[O] + $.width)) : y;\n  }, {\n    left: d.left || 0,\n    right: d.right || 0\n  }), v = Object.keys(a).reduce(function(y, S) {\n    var $ = a[S], O = $.orientation;\n    return !$.mirror && !$.hide ? z(z({}, y), {}, se({}, O, jt(y, \"\".concat(O)) + $.height)) : y;\n  }, {\n    top: d.top || 0,\n    bottom: d.bottom || 0\n  }), w = z(z({}, v), h), b = w.bottom;\n  p && (w.bottom += p.props.height || Xr.defaultProps.height), g && n && (w = H6(w, i, r, n));\n  var x = c - w.left - w.right, m = f - w.top - w.bottom;\n  return z(z({\n    brushBottom: b\n  }, w), {}, {\n    // never return negative values for height and width\n    width: Math.max(x, 0),\n    height: Math.max(m, 0)\n  });\n}, UW = function(t, n) {\n  if (n === \"xAxis\")\n    return t[n].width;\n  if (n === \"yAxis\")\n    return t[n].height;\n}, HW = function(t) {\n  var n, r = t.chartName, i = t.GraphicalChild, o = t.defaultTooltipEventType, a = o === void 0 ? \"axis\" : o, s = t.validateTooltipEventTypes, u = s === void 0 ? [\"axis\"] : s, c = t.axisComponents, f = t.legendContent, l = t.formatAxisMap, d = t.defaultProps, p = function(v, w) {\n    var b = w.graphicalItems, x = w.stackGroups, m = w.offset, y = w.updateId, S = w.dataStartIndex, $ = w.dataEndIndex, O = v.barSize, T = v.layout, M = v.barGap, E = v.barCategoryGap, A = v.maxBarSize, j = im(T), R = j.numericAxisName, N = j.cateAxisName, k = GW(b), F = [];\n    return b.forEach(function(V, L) {\n      var I = cu(v.data, {\n        graphicalItems: [V],\n        dataStartIndex: S,\n        dataEndIndex: $\n      }), D = V.props, G = D.dataKey, q = D.maxBarSize, J = V.props[\"\".concat(R, \"Id\")], ne = V.props[\"\".concat(N, \"Id\")], te = {}, ee = c.reduce(function(Vt, rt) {\n        var Xn, xi, Si = w[\"\".concat(rt.axisType, \"Map\")], $i = V.props[\"\".concat(rt.axisType, \"Id\")];\n        Si && Si[$i] || rt.axisType === \"zAxis\" || ( true ? gt(!1, \"Specifying a(n) \".concat(rt.axisType, \"Id requires a corresponding \").concat(\n          rt.axisType,\n          \"Id on the targeted graphical component \"\n        ).concat((Xn = V == null || (xi = V.type) === null || xi === void 0 ? void 0 : xi.displayName) !== null && Xn !== void 0 ? Xn : \"\")) : 0);\n        var Oi = Si[$i];\n        return z(z({}, Vt), {}, se(se({}, rt.axisType, Oi), \"\".concat(rt.axisType, \"Ticks\"), mn(Oi)));\n      }, te), ie = ee[N], B = ee[\"\".concat(N, \"Ticks\")], U = x && x[J] && x[J].hasStack && a8(V, x[J].stackGroups), re = Fn(V.type).indexOf(\"Bar\") >= 0, C = fs(ie, B), ge = [], le = k && W6({\n        barSize: O,\n        stackGroups: x,\n        totalSize: UW(ee, N)\n      });\n      if (re) {\n        var xe, Ee, Ze = me(q) ? A : q, dt = (xe = (Ee = fs(ie, B, !0)) !== null && Ee !== void 0 ? Ee : Ze) !== null && xe !== void 0 ? xe : 0;\n        ge = U6({\n          barGap: M,\n          barCategoryGap: E,\n          bandSize: dt !== C ? dt : C,\n          sizeList: le[ne],\n          maxBarSize: Ze\n        }), dt !== C && (ge = ge.map(function(Vt) {\n          return z(z({}, Vt), {}, {\n            position: z(z({}, Vt.position), {}, {\n              offset: Vt.position.offset - dt / 2\n            })\n          });\n        }));\n      }\n      var zt = V && V.type && V.type.getComposedData;\n      zt && F.push({\n        props: z(z({}, zt(z(z({}, ee), {}, {\n          displayedData: I,\n          props: v,\n          dataKey: G,\n          item: V,\n          bandSize: C,\n          barPosition: ge,\n          offset: m,\n          stackedData: U,\n          layout: T,\n          dataStartIndex: S,\n          dataEndIndex: $\n        }))), {}, se(se(se({\n          key: V.key || \"item-\".concat(L)\n        }, R, ee[R]), N, ee[N]), \"animationId\", y)),\n        childIndex: oE(V, v.children),\n        item: V\n      });\n    }), F;\n  }, g = function(v, w) {\n    var b = v.props, x = v.dataStartIndex, m = v.dataEndIndex, y = v.updateId;\n    if (!Op({\n      props: b\n    }))\n      return null;\n    var S = b.children, $ = b.layout, O = b.stackOffset, T = b.data, M = b.reverseStackOrder, E = im($), A = E.numericAxisName, j = E.cateAxisName, R = kt(S, i), N = r8(T, R, \"\".concat(A, \"Id\"), \"\".concat(j, \"Id\"), O, M), k = c.reduce(function(D, G) {\n      var q = \"\".concat(G.axisType, \"Map\");\n      return z(z({}, D), {}, se({}, q, zW(b, z(z({}, G), {}, {\n        graphicalItems: R,\n        stackGroups: G.axisType === A && N,\n        dataStartIndex: x,\n        dataEndIndex: m\n      }))));\n    }, {}), F = WW(z(z({}, k), {}, {\n      props: b,\n      graphicalItems: R\n    }), w == null ? void 0 : w.legendBBox);\n    Object.keys(k).forEach(function(D) {\n      k[D] = l(b, k[D], F, D.replace(\"Map\", \"\"), r);\n    });\n    var V = k[\"\".concat(j, \"Map\")], L = VW(V), I = p(b, z(z({}, k), {}, {\n      dataStartIndex: x,\n      dataEndIndex: m,\n      updateId: y,\n      graphicalItems: R,\n      stackGroups: N,\n      offset: F\n    }));\n    return z(z({\n      formattedGraphicalItems: I,\n      graphicalItems: R,\n      offset: F,\n      stackGroups: N\n    }, L), k);\n  };\n  return n = /* @__PURE__ */ function(h) {\n    TW(v, h);\n    function v(w) {\n      var b, x, m;\n      return _W(this, v), m = CW(this, v, [w]), se(Se(m), \"eventEmitterSymbol\", Symbol(\"rechartsEventEmitter\")), se(Se(m), \"accessibilityManager\", new fW()), se(Se(m), \"handleLegendBBoxUpdate\", function(y) {\n        if (y) {\n          var S = m.state, $ = S.dataStartIndex, O = S.dataEndIndex, T = S.updateId;\n          m.setState(z({\n            legendBBox: y\n          }, g({\n            props: m.props,\n            dataStartIndex: $,\n            dataEndIndex: O,\n            updateId: T\n          }, z(z({}, m.state), {}, {\n            legendBBox: y\n          }))));\n        }\n      }), se(Se(m), \"handleReceiveSyncEvent\", function(y, S, $) {\n        if (m.props.syncId === y) {\n          if ($ === m.eventEmitterSymbol && typeof m.props.syncMethod != \"function\")\n            return;\n          m.applySyncEvent(S);\n        }\n      }), se(Se(m), \"handleBrushChange\", function(y) {\n        var S = y.startIndex, $ = y.endIndex;\n        if (S !== m.state.dataStartIndex || $ !== m.state.dataEndIndex) {\n          var O = m.state.updateId;\n          m.setState(function() {\n            return z({\n              dataStartIndex: S,\n              dataEndIndex: $\n            }, g({\n              props: m.props,\n              dataStartIndex: S,\n              dataEndIndex: $,\n              updateId: O\n            }, m.state));\n          }), m.triggerSyncEvent({\n            dataStartIndex: S,\n            dataEndIndex: $\n          });\n        }\n      }), se(Se(m), \"handleMouseEnter\", function(y) {\n        var S = m.getMouseInfo(y);\n        if (S) {\n          var $ = z(z({}, S), {}, {\n            isTooltipActive: !0\n          });\n          m.setState($), m.triggerSyncEvent($);\n          var O = m.props.onMouseEnter;\n          pe(O) && O($, y);\n        }\n      }), se(Se(m), \"triggeredAfterMouseMove\", function(y) {\n        var S = m.getMouseInfo(y), $ = S ? z(z({}, S), {}, {\n          isTooltipActive: !0\n        }) : {\n          isTooltipActive: !1\n        };\n        m.setState($), m.triggerSyncEvent($);\n        var O = m.props.onMouseMove;\n        pe(O) && O($, y);\n      }), se(Se(m), \"handleItemMouseEnter\", function(y) {\n        m.setState(function() {\n          return {\n            isTooltipActive: !0,\n            activeItem: y,\n            activePayload: y.tooltipPayload,\n            activeCoordinate: y.tooltipPosition || {\n              x: y.cx,\n              y: y.cy\n            }\n          };\n        });\n      }), se(Se(m), \"handleItemMouseLeave\", function() {\n        m.setState(function() {\n          return {\n            isTooltipActive: !1\n          };\n        });\n      }), se(Se(m), \"handleMouseMove\", function(y) {\n        y.persist(), m.throttleTriggeredAfterMouseMove(y);\n      }), se(Se(m), \"handleMouseLeave\", function(y) {\n        m.throttleTriggeredAfterMouseMove.cancel();\n        var S = {\n          isTooltipActive: !1\n        };\n        m.setState(S), m.triggerSyncEvent(S);\n        var $ = m.props.onMouseLeave;\n        pe($) && $(S, y);\n      }), se(Se(m), \"handleOuterEvent\", function(y) {\n        var S = iE(y), $ = jt(m.props, \"\".concat(S));\n        if (S && pe($)) {\n          var O, T;\n          /.*touch.*/i.test(S) ? T = m.getMouseInfo(y.changedTouches[0]) : T = m.getMouseInfo(y), $((O = T) !== null && O !== void 0 ? O : {}, y);\n        }\n      }), se(Se(m), \"handleClick\", function(y) {\n        var S = m.getMouseInfo(y);\n        if (S) {\n          var $ = z(z({}, S), {}, {\n            isTooltipActive: !0\n          });\n          m.setState($), m.triggerSyncEvent($);\n          var O = m.props.onClick;\n          pe(O) && O($, y);\n        }\n      }), se(Se(m), \"handleMouseDown\", function(y) {\n        var S = m.props.onMouseDown;\n        if (pe(S)) {\n          var $ = m.getMouseInfo(y);\n          S($, y);\n        }\n      }), se(Se(m), \"handleMouseUp\", function(y) {\n        var S = m.props.onMouseUp;\n        if (pe(S)) {\n          var $ = m.getMouseInfo(y);\n          S($, y);\n        }\n      }), se(Se(m), \"handleTouchMove\", function(y) {\n        y.changedTouches != null && y.changedTouches.length > 0 && m.throttleTriggeredAfterMouseMove(y.changedTouches[0]);\n      }), se(Se(m), \"handleTouchStart\", function(y) {\n        y.changedTouches != null && y.changedTouches.length > 0 && m.handleMouseDown(y.changedTouches[0]);\n      }), se(Se(m), \"handleTouchEnd\", function(y) {\n        y.changedTouches != null && y.changedTouches.length > 0 && m.handleMouseUp(y.changedTouches[0]);\n      }), se(Se(m), \"triggerSyncEvent\", function(y) {\n        m.props.syncId !== void 0 && ic.emit(oc, m.props.syncId, y, m.eventEmitterSymbol);\n      }), se(Se(m), \"applySyncEvent\", function(y) {\n        var S = m.props, $ = S.layout, O = S.syncMethod, T = m.state.updateId, M = y.dataStartIndex, E = y.dataEndIndex;\n        if (y.dataStartIndex !== void 0 || y.dataEndIndex !== void 0)\n          m.setState(z({\n            dataStartIndex: M,\n            dataEndIndex: E\n          }, g({\n            props: m.props,\n            dataStartIndex: M,\n            dataEndIndex: E,\n            updateId: T\n          }, m.state)));\n        else if (y.activeTooltipIndex !== void 0) {\n          var A = y.chartX, j = y.chartY, R = y.activeTooltipIndex, N = m.state, k = N.offset, F = N.tooltipTicks;\n          if (!k)\n            return;\n          if (typeof O == \"function\")\n            R = O(F, y);\n          else if (O === \"value\") {\n            R = -1;\n            for (var V = 0; V < F.length; V++)\n              if (F[V].value === y.activeLabel) {\n                R = V;\n                break;\n              }\n          }\n          var L = z(z({}, k), {}, {\n            x: k.left,\n            y: k.top\n          }), I = Math.min(A, L.x + L.width), D = Math.min(j, L.y + L.height), G = F[R] && F[R].value, q = ql(m.state, m.props.data, R), J = F[R] ? {\n            x: $ === \"horizontal\" ? F[R].coordinate : I,\n            y: $ === \"horizontal\" ? D : F[R].coordinate\n          } : Bw;\n          m.setState(z(z({}, y), {}, {\n            activeLabel: G,\n            activeCoordinate: J,\n            activePayload: q,\n            activeTooltipIndex: R\n          }));\n        } else\n          m.setState(y);\n      }), se(Se(m), \"renderCursor\", function(y) {\n        var S, $ = m.state, O = $.isTooltipActive, T = $.activeCoordinate, M = $.activePayload, E = $.offset, A = $.activeTooltipIndex, j = $.tooltipAxisBandSize, R = m.getTooltipEventType(), N = (S = y.props.active) !== null && S !== void 0 ? S : O, k = m.props.layout, F = y.key || \"_recharts-cursor\";\n        return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(yW, {\n          key: F,\n          activeCoordinate: T,\n          activePayload: M,\n          activeTooltipIndex: A,\n          chartName: r,\n          element: y,\n          isActive: N,\n          layout: k,\n          offset: E,\n          tooltipAxisBandSize: j,\n          tooltipEventType: R\n        });\n      }), se(Se(m), \"renderPolarAxis\", function(y, S, $) {\n        var O = jt(y, \"type.axisType\"), T = jt(m.state, \"\".concat(O, \"Map\")), M = T && T[y.props[\"\".concat(O, \"Id\")]];\n        return /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.cloneElement)(y, z(z({}, M), {}, {\n          className: $e(O, M.className),\n          key: y.key || \"\".concat(S, \"-\").concat($),\n          ticks: mn(M, !0)\n        }));\n      }), se(Se(m), \"renderPolarGrid\", function(y) {\n        var S = y.props, $ = S.radialLines, O = S.polarAngles, T = S.polarRadius, M = m.state, E = M.radiusAxisMap, A = M.angleAxisMap, j = kn(E), R = kn(A), N = R.cx, k = R.cy, F = R.innerRadius, V = R.outerRadius;\n        return /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.cloneElement)(y, {\n          polarAngles: Array.isArray(O) ? O : mn(R, !0).map(function(L) {\n            return L.coordinate;\n          }),\n          polarRadius: Array.isArray(T) ? T : mn(j, !0).map(function(L) {\n            return L.coordinate;\n          }),\n          cx: N,\n          cy: k,\n          innerRadius: F,\n          outerRadius: V,\n          key: y.key || \"polar-grid\",\n          radialLines: $\n        });\n      }), se(Se(m), \"renderLegend\", function() {\n        var y = m.state.formattedGraphicalItems, S = m.props, $ = S.children, O = S.width, T = S.height, M = m.props.margin || {}, E = O - (M.left || 0) - (M.right || 0), A = V0({\n          children: $,\n          formattedGraphicalItems: y,\n          legendWidth: E,\n          legendContent: f\n        });\n        if (!A)\n          return null;\n        var j = A.item, R = em(A, bW);\n        return /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.cloneElement)(j, z(z({}, R), {}, {\n          chartWidth: O,\n          chartHeight: T,\n          margin: M,\n          onBBoxUpdate: m.handleLegendBBoxUpdate\n        }));\n      }), se(Se(m), \"renderTooltip\", function() {\n        var y, S = m.props, $ = S.children, O = S.accessibilityLayer, T = wt($, tn);\n        if (!T)\n          return null;\n        var M = m.state, E = M.isTooltipActive, A = M.activeCoordinate, j = M.activePayload, R = M.activeLabel, N = M.offset, k = (y = T.props.active) !== null && y !== void 0 ? y : E;\n        return /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.cloneElement)(T, {\n          viewBox: z(z({}, N), {}, {\n            x: N.left,\n            y: N.top\n          }),\n          active: k,\n          label: R,\n          payload: k ? j : [],\n          coordinate: A,\n          accessibilityLayer: O\n        });\n      }), se(Se(m), \"renderBrush\", function(y) {\n        var S = m.props, $ = S.margin, O = S.data, T = m.state, M = T.offset, E = T.dataStartIndex, A = T.dataEndIndex, j = T.updateId;\n        return /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.cloneElement)(y, {\n          key: y.key || \"_recharts-brush\",\n          onChange: ma(m.handleBrushChange, y.props.onChange),\n          data: O,\n          x: K(y.props.x) ? y.props.x : M.left,\n          y: K(y.props.y) ? y.props.y : M.top + M.height + M.brushBottom - ($.bottom || 0),\n          width: K(y.props.width) ? y.props.width : M.width,\n          startIndex: E,\n          endIndex: A,\n          updateId: \"brush-\".concat(j)\n        });\n      }), se(Se(m), \"renderReferenceElement\", function(y, S, $) {\n        if (!y)\n          return null;\n        var O = Se(m), T = O.clipPathId, M = m.state, E = M.xAxisMap, A = M.yAxisMap, j = M.offset, R = y.props, N = R.xAxisId, k = R.yAxisId;\n        return /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.cloneElement)(y, {\n          key: y.key || \"\".concat(S, \"-\").concat($),\n          xAxis: E[N],\n          yAxis: A[k],\n          viewBox: {\n            x: j.left,\n            y: j.top,\n            width: j.width,\n            height: j.height\n          },\n          clipPathId: T\n        });\n      }), se(Se(m), \"renderActivePoints\", function(y) {\n        var S = y.item, $ = y.activePoint, O = y.basePoint, T = y.childIndex, M = y.isRange, E = [], A = S.props.key, j = S.item.props, R = j.activeDot, N = j.dataKey, k = z(z({\n          index: T,\n          dataKey: N,\n          cx: $.x,\n          cy: $.y,\n          r: 4,\n          fill: ld(S.item),\n          strokeWidth: 2,\n          stroke: \"#fff\",\n          payload: $.payload,\n          value: $.value,\n          key: \"\".concat(A, \"-activePoint-\").concat(T)\n        }, ye(R, !1)), Na(R));\n        return E.push(v.renderActiveDot(R, k)), O ? E.push(v.renderActiveDot(R, z(z({}, k), {}, {\n          cx: O.x,\n          cy: O.y,\n          key: \"\".concat(A, \"-basePoint-\").concat(T)\n        }))) : M && E.push(null), E;\n      }), se(Se(m), \"renderGraphicChild\", function(y, S, $) {\n        var O = m.filterFormatItem(y, S, $);\n        if (!O)\n          return null;\n        var T = m.getTooltipEventType(), M = m.state, E = M.isTooltipActive, A = M.tooltipAxis, j = M.activeTooltipIndex, R = M.activeLabel, N = m.props.children, k = wt(N, tn), F = O.props, V = F.points, L = F.isRange, I = F.baseLine, D = O.item.props, G = D.activeDot, q = D.hide, J = D.activeBar, ne = D.activeShape, te = !!(!q && E && k && (G || J || ne)), ee = {};\n        T !== \"axis\" && k && k.props.trigger === \"click\" ? ee = {\n          onClick: ma(m.handleItemMouseEnter, y.props.onClick)\n        } : T !== \"axis\" && (ee = {\n          onMouseLeave: ma(m.handleItemMouseLeave, y.props.onMouseLeave),\n          onMouseEnter: ma(m.handleItemMouseEnter, y.props.onMouseEnter)\n        });\n        var ie = /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.cloneElement)(y, z(z({}, O.props), ee));\n        function B(rt) {\n          return typeof A.dataKey == \"function\" ? A.dataKey(rt.payload) : null;\n        }\n        if (te)\n          if (j >= 0) {\n            var U, re;\n            if (A.dataKey && !A.allowDuplicatedCategory) {\n              var C = typeof A.dataKey == \"function\" ? B : \"payload.\".concat(A.dataKey.toString());\n              U = Da(V, C, R), re = L && I && Da(I, C, R);\n            } else\n              U = V == null ? void 0 : V[j], re = L && I && I[j];\n            if (ne || J) {\n              var ge = y.props.activeIndex !== void 0 ? y.props.activeIndex : j;\n              return [/* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.cloneElement)(y, z(z(z({}, O.props), ee), {}, {\n                activeIndex: ge\n              })), null, null];\n            }\n            if (!me(U))\n              return [ie].concat(ri(m.renderActivePoints({\n                item: O,\n                activePoint: U,\n                basePoint: re,\n                childIndex: j,\n                isRange: L\n              })));\n          } else {\n            var le, xe = (le = m.getItemByXY(m.state.activeCoordinate)) !== null && le !== void 0 ? le : {\n              graphicalItem: ie\n            }, Ee = xe.graphicalItem, Ze = Ee.item, dt = Ze === void 0 ? y : Ze, zt = Ee.childIndex, Vt = z(z(z({}, O.props), ee), {}, {\n              activeIndex: zt\n            });\n            return [/* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.cloneElement)(dt, Vt), null, null];\n          }\n        return L ? [ie, null, null] : [ie, null];\n      }), se(Se(m), \"renderCustomized\", function(y, S, $) {\n        return /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.cloneElement)(y, z(z({\n          key: \"recharts-customized-\".concat($)\n        }, m.props), m.state));\n      }), se(Se(m), \"renderMap\", {\n        CartesianGrid: {\n          handler: Sa,\n          once: !0\n        },\n        ReferenceArea: {\n          handler: m.renderReferenceElement\n        },\n        ReferenceLine: {\n          handler: Sa\n        },\n        ReferenceDot: {\n          handler: m.renderReferenceElement\n        },\n        XAxis: {\n          handler: Sa\n        },\n        YAxis: {\n          handler: Sa\n        },\n        Brush: {\n          handler: m.renderBrush,\n          once: !0\n        },\n        Bar: {\n          handler: m.renderGraphicChild\n        },\n        Line: {\n          handler: m.renderGraphicChild\n        },\n        Area: {\n          handler: m.renderGraphicChild\n        },\n        Radar: {\n          handler: m.renderGraphicChild\n        },\n        RadialBar: {\n          handler: m.renderGraphicChild\n        },\n        Scatter: {\n          handler: m.renderGraphicChild\n        },\n        Pie: {\n          handler: m.renderGraphicChild\n        },\n        Funnel: {\n          handler: m.renderGraphicChild\n        },\n        Tooltip: {\n          handler: m.renderCursor,\n          once: !0\n        },\n        PolarGrid: {\n          handler: m.renderPolarGrid,\n          once: !0\n        },\n        PolarAngleAxis: {\n          handler: m.renderPolarAxis\n        },\n        PolarRadiusAxis: {\n          handler: m.renderPolarAxis\n        },\n        Customized: {\n          handler: m.renderCustomized\n        }\n      }), m.clipPathId = \"\".concat((b = w.id) !== null && b !== void 0 ? b : Uo(\"recharts\"), \"-clip\"), m.throttleTriggeredAfterMouseMove = vF(m.triggeredAfterMouseMove, (x = w.throttleDelay) !== null && x !== void 0 ? x : 1e3 / 60), m.state = {}, m;\n    }\n    return PW(v, [{\n      key: \"componentDidMount\",\n      value: function() {\n        var b, x;\n        this.addListener(), this.accessibilityManager.setDetails({\n          container: this.container,\n          offset: {\n            left: (b = this.props.margin.left) !== null && b !== void 0 ? b : 0,\n            top: (x = this.props.margin.top) !== null && x !== void 0 ? x : 0\n          },\n          coordinateList: this.state.tooltipTicks,\n          mouseHandlerCallback: this.triggeredAfterMouseMove,\n          layout: this.props.layout\n        }), this.displayDefaultTooltip();\n      }\n    }, {\n      key: \"displayDefaultTooltip\",\n      value: function() {\n        var b = this.props, x = b.children, m = b.data, y = b.height, S = b.layout, $ = wt(x, tn);\n        if ($) {\n          var O = $.props.defaultIndex;\n          if (!(typeof O != \"number\" || O < 0 || O > this.state.tooltipTicks.length)) {\n            var T = this.state.tooltipTicks[O] && this.state.tooltipTicks[O].value, M = ql(this.state, m, O, T), E = this.state.tooltipTicks[O].coordinate, A = (this.state.offset.top + y) / 2, j = S === \"horizontal\", R = j ? {\n              x: E,\n              y: A\n            } : {\n              y: E,\n              x: A\n            }, N = this.state.formattedGraphicalItems.find(function(F) {\n              var V = F.item;\n              return V.type.name === \"Scatter\";\n            });\n            N && (R = z(z({}, R), N.props.points[O].tooltipPosition), M = N.props.points[O].tooltipPayload);\n            var k = {\n              activeTooltipIndex: O,\n              isTooltipActive: !0,\n              activeLabel: T,\n              activePayload: M,\n              activeCoordinate: R\n            };\n            this.setState(k), this.renderCursor($), this.accessibilityManager.setIndex(O);\n          }\n        }\n      }\n    }, {\n      key: \"getSnapshotBeforeUpdate\",\n      value: function(b, x) {\n        if (!this.props.accessibilityLayer)\n          return null;\n        if (this.state.tooltipTicks !== x.tooltipTicks && this.accessibilityManager.setDetails({\n          coordinateList: this.state.tooltipTicks\n        }), this.props.layout !== b.layout && this.accessibilityManager.setDetails({\n          layout: this.props.layout\n        }), this.props.margin !== b.margin) {\n          var m, y;\n          this.accessibilityManager.setDetails({\n            offset: {\n              left: (m = this.props.margin.left) !== null && m !== void 0 ? m : 0,\n              top: (y = this.props.margin.top) !== null && y !== void 0 ? y : 0\n            }\n          });\n        }\n        return null;\n      }\n    }, {\n      key: \"componentDidUpdate\",\n      value: function(b) {\n        Ec([wt(b.children, tn)], [wt(this.props.children, tn)]) || this.displayDefaultTooltip();\n      }\n    }, {\n      key: \"componentWillUnmount\",\n      value: function() {\n        this.removeListener(), this.throttleTriggeredAfterMouseMove.cancel();\n      }\n    }, {\n      key: \"getTooltipEventType\",\n      value: function() {\n        var b = wt(this.props.children, tn);\n        if (b && typeof b.props.shared == \"boolean\") {\n          var x = b.props.shared ? \"axis\" : \"item\";\n          return u.indexOf(x) >= 0 ? x : a;\n        }\n        return a;\n      }\n      /**\n       * Get the information of mouse in chart, return null when the mouse is not in the chart\n       * @param  {MousePointer} event    The event object\n       * @return {Object}          Mouse data\n       */\n    }, {\n      key: \"getMouseInfo\",\n      value: function(b) {\n        if (!this.container)\n          return null;\n        var x = this.container, m = x.getBoundingClientRect(), y = $F(m), S = {\n          chartX: Math.round(b.pageX - y.left),\n          chartY: Math.round(b.pageY - y.top)\n        }, $ = m.width / x.offsetWidth || 1, O = this.inRange(S.chartX, S.chartY, $);\n        if (!O)\n          return null;\n        var T = this.state, M = T.xAxisMap, E = T.yAxisMap, A = this.getTooltipEventType();\n        if (A !== \"axis\" && M && E) {\n          var j = kn(M).scale, R = kn(E).scale, N = j && j.invert ? j.invert(S.chartX) : null, k = R && R.invert ? R.invert(S.chartY) : null;\n          return z(z({}, S), {}, {\n            xValue: N,\n            yValue: k\n          });\n        }\n        var F = nm(this.state, this.props.data, this.props.layout, O);\n        return F ? z(z({}, S), F) : null;\n      }\n    }, {\n      key: \"inRange\",\n      value: function(b, x) {\n        var m = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1, y = this.props.layout, S = b / m, $ = x / m;\n        if (y === \"horizontal\" || y === \"vertical\") {\n          var O = this.state.offset, T = S >= O.left && S <= O.left + O.width && $ >= O.top && $ <= O.top + O.height;\n          return T ? {\n            x: S,\n            y: $\n          } : null;\n        }\n        var M = this.state, E = M.angleAxisMap, A = M.radiusAxisMap;\n        if (E && A) {\n          var j = kn(E);\n          return Rg({\n            x: S,\n            y: $\n          }, j);\n        }\n        return null;\n      }\n    }, {\n      key: \"parseEventsOfWrapper\",\n      value: function() {\n        var b = this.props.children, x = this.getTooltipEventType(), m = wt(b, tn), y = {};\n        m && x === \"axis\" && (m.props.trigger === \"click\" ? y = {\n          onClick: this.handleClick\n        } : y = {\n          onMouseEnter: this.handleMouseEnter,\n          onMouseMove: this.handleMouseMove,\n          onMouseLeave: this.handleMouseLeave,\n          onTouchMove: this.handleTouchMove,\n          onTouchStart: this.handleTouchStart,\n          onTouchEnd: this.handleTouchEnd\n        });\n        var S = Na(this.props, this.handleOuterEvent);\n        return z(z({}, S), y);\n      }\n    }, {\n      key: \"addListener\",\n      value: function() {\n        ic.on(oc, this.handleReceiveSyncEvent);\n      }\n    }, {\n      key: \"removeListener\",\n      value: function() {\n        ic.removeListener(oc, this.handleReceiveSyncEvent);\n      }\n    }, {\n      key: \"filterFormatItem\",\n      value: function(b, x, m) {\n        for (var y = this.state.formattedGraphicalItems, S = 0, $ = y.length; S < $; S++) {\n          var O = y[S];\n          if (O.item === b || O.props.key === b.key || x === Fn(O.item.type) && m === O.childIndex)\n            return O;\n        }\n        return null;\n      }\n    }, {\n      key: \"renderClipPath\",\n      value: function() {\n        var b = this.clipPathId, x = this.state.offset, m = x.left, y = x.top, S = x.height, $ = x.width;\n        return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"defs\", null, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"clipPath\", {\n          id: b\n        }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"rect\", {\n          x: m,\n          y,\n          height: S,\n          width: $\n        })));\n      }\n    }, {\n      key: \"getXScales\",\n      value: function() {\n        var b = this.state.xAxisMap;\n        return b ? Object.entries(b).reduce(function(x, m) {\n          var y = Qv(m, 2), S = y[0], $ = y[1];\n          return z(z({}, x), {}, se({}, S, $.scale));\n        }, {}) : null;\n      }\n    }, {\n      key: \"getYScales\",\n      value: function() {\n        var b = this.state.yAxisMap;\n        return b ? Object.entries(b).reduce(function(x, m) {\n          var y = Qv(m, 2), S = y[0], $ = y[1];\n          return z(z({}, x), {}, se({}, S, $.scale));\n        }, {}) : null;\n      }\n    }, {\n      key: \"getXScaleByAxisId\",\n      value: function(b) {\n        var x;\n        return (x = this.state.xAxisMap) === null || x === void 0 || (x = x[b]) === null || x === void 0 ? void 0 : x.scale;\n      }\n    }, {\n      key: \"getYScaleByAxisId\",\n      value: function(b) {\n        var x;\n        return (x = this.state.yAxisMap) === null || x === void 0 || (x = x[b]) === null || x === void 0 ? void 0 : x.scale;\n      }\n    }, {\n      key: \"getItemByXY\",\n      value: function(b) {\n        var x = this.state, m = x.formattedGraphicalItems, y = x.activeItem;\n        if (m && m.length)\n          for (var S = 0, $ = m.length; S < $; S++) {\n            var O = m[S], T = O.props, M = O.item, E = Fn(M.type);\n            if (E === \"Bar\") {\n              var A = (T.data || []).find(function(k) {\n                return W7(b, k);\n              });\n              if (A)\n                return {\n                  graphicalItem: O,\n                  payload: A\n                };\n            } else if (E === \"RadialBar\") {\n              var j = (T.data || []).find(function(k) {\n                return Rg(b, k);\n              });\n              if (j)\n                return {\n                  graphicalItem: O,\n                  payload: j\n                };\n            } else if (iu(O, y) || ou(O, y) || Eo(O, y)) {\n              var R = q9({\n                graphicalItem: O,\n                activeTooltipItem: y,\n                itemData: M.props.data\n              }), N = M.props.activeIndex === void 0 ? R : M.props.activeIndex;\n              return {\n                graphicalItem: z(z({}, O), {}, {\n                  childIndex: N\n                }),\n                payload: Eo(O, y) ? M.props.data[R] : O.props.data[R]\n              };\n            }\n          }\n        return null;\n      }\n    }, {\n      key: \"render\",\n      value: function() {\n        var b = this;\n        if (!Op(this))\n          return null;\n        var x = this.props, m = x.children, y = x.className, S = x.width, $ = x.height, O = x.style, T = x.compact, M = x.title, E = x.desc, A = em(x, wW), j = ye(A, !1);\n        if (T)\n          return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(Dv, {\n            state: this.state,\n            width: this.props.width,\n            height: this.props.height,\n            clipPathId: this.clipPathId\n          }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(Mc, Ki({}, j, {\n            width: S,\n            height: $,\n            title: M,\n            desc: E\n          }), this.renderClipPath(), Ap(m, this.renderMap)));\n        if (this.props.accessibilityLayer) {\n          var R, N;\n          j.tabIndex = (R = this.props.tabIndex) !== null && R !== void 0 ? R : 0, j.role = (N = this.props.role) !== null && N !== void 0 ? N : \"application\", j.onKeyDown = function(F) {\n            b.accessibilityManager.keyboardEvent(F);\n          }, j.onFocus = function() {\n            b.accessibilityManager.focus();\n          };\n        }\n        var k = this.parseEventsOfWrapper();\n        return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(Dv, {\n          state: this.state,\n          width: this.props.width,\n          height: this.props.height,\n          clipPathId: this.clipPathId\n        }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", Ki({\n          className: $e(\"recharts-wrapper\", y),\n          style: z({\n            position: \"relative\",\n            cursor: \"default\",\n            width: S,\n            height: $\n          }, O)\n        }, k, {\n          ref: function(V) {\n            b.container = V;\n          }\n        }), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(Mc, Ki({}, j, {\n          width: S,\n          height: $,\n          title: M,\n          desc: E,\n          style: DW\n        }), this.renderClipPath(), Ap(m, this.renderMap)), this.renderLegend(), this.renderTooltip()));\n      }\n    }]), v;\n  }(react__WEBPACK_IMPORTED_MODULE_0__.Component), se(n, \"displayName\", r), se(n, \"defaultProps\", z({\n    layout: \"horizontal\",\n    stackOffset: \"none\",\n    barCategoryGap: \"10%\",\n    barGap: 4,\n    margin: {\n      top: 5,\n      right: 5,\n      bottom: 5,\n      left: 5\n    },\n    reverseStackOrder: !1,\n    syncMethod: \"index\"\n  }, d)), se(n, \"getDerivedStateFromProps\", function(h, v) {\n    var w = h.dataKey, b = h.data, x = h.children, m = h.width, y = h.height, S = h.layout, $ = h.stackOffset, O = h.margin, T = v.dataStartIndex, M = v.dataEndIndex;\n    if (v.updateId === void 0) {\n      var E = rm(h);\n      return z(z(z({}, E), {}, {\n        updateId: 0\n      }, g(z(z({\n        props: h\n      }, E), {}, {\n        updateId: 0\n      }), v)), {}, {\n        prevDataKey: w,\n        prevData: b,\n        prevWidth: m,\n        prevHeight: y,\n        prevLayout: S,\n        prevStackOffset: $,\n        prevMargin: O,\n        prevChildren: x\n      });\n    }\n    if (w !== v.prevDataKey || b !== v.prevData || m !== v.prevWidth || y !== v.prevHeight || S !== v.prevLayout || $ !== v.prevStackOffset || !Rr(O, v.prevMargin)) {\n      var A = rm(h), j = {\n        // (chartX, chartY) are (0,0) in default state, but we want to keep the last mouse position to avoid\n        // any flickering\n        chartX: v.chartX,\n        chartY: v.chartY,\n        // The tooltip should stay active when it was active in the previous render. If this is not\n        // the case, the tooltip disappears and immediately re-appears, causing a flickering effect\n        isTooltipActive: v.isTooltipActive\n      }, R = z(z({}, nm(v, b, S)), {}, {\n        updateId: v.updateId + 1\n      }), N = z(z(z({}, A), j), R);\n      return z(z(z({}, N), g(z({\n        props: h\n      }, N), v)), {}, {\n        prevDataKey: w,\n        prevData: b,\n        prevWidth: m,\n        prevHeight: y,\n        prevLayout: S,\n        prevStackOffset: $,\n        prevMargin: O,\n        prevChildren: x\n      });\n    }\n    if (!Ec(x, v.prevChildren)) {\n      var k, F, V, L, I = wt(x, Xr), D = I && (k = (F = I.props) === null || F === void 0 ? void 0 : F.startIndex) !== null && k !== void 0 ? k : T, G = I && (V = (L = I.props) === null || L === void 0 ? void 0 : L.endIndex) !== null && V !== void 0 ? V : M, q = D !== T || G !== M, J = !me(b), ne = J && !q ? v.updateId : v.updateId + 1;\n      return z(z({\n        updateId: ne\n      }, g(z(z({\n        props: h\n      }, v), {}, {\n        updateId: ne,\n        dataStartIndex: D,\n        dataEndIndex: G\n      }), v)), {}, {\n        prevChildren: x,\n        dataStartIndex: D,\n        dataEndIndex: G\n      });\n    }\n    return null;\n  }), se(n, \"renderActiveDot\", function(h, v) {\n    var w;\n    return /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.isValidElement)(h) ? w = /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.cloneElement)(h, v) : pe(h) ? w = h(v) : w = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(pd, v), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(We, {\n      className: \"recharts-active-dot\",\n      key: v.key\n    }, w);\n  }), n;\n}, qW = HW({\n  chartName: \"LineChart\",\n  GraphicalChild: ti,\n  axisComponents: [{\n    axisType: \"xAxis\",\n    AxisComp: su\n  }, {\n    axisType: \"yAxis\",\n    AxisComp: uu\n  }],\n  formatAxisMap: v5\n});\nconst tH = ({ data: e }) => /* @__PURE__ */ X(\"div\", { style: { width: \"100%\", height: \"100%\" }, children: /* @__PURE__ */ ze(qW, { width: 500, height: 300, data: e, children: [\n  /* @__PURE__ */ X(Mw, { strokeDasharray: \"3 3\" }),\n  /* @__PURE__ */ X(su, { dataKey: \"name\", padding: { left: 30, right: 30 } }),\n  /* @__PURE__ */ X(uu, {}),\n  /* @__PURE__ */ X(tn, {}),\n  /* @__PURE__ */ X(Vr, {}),\n  /* @__PURE__ */ X(\n    ti,\n    {\n      type: \"monotone\",\n      dataKey: \"pv\",\n      stroke: \"#8884d8\",\n      activeDot: { r: 8 }\n    }\n  ),\n  /* @__PURE__ */ X(ti, { type: \"monotone\", dataKey: \"uv\", stroke: \"#82ca9d\" })\n] }) });\n/**\n   * table-core\n   *\n   * Copyright (c) TanStack\n   *\n   * This source code is licensed under the MIT license found in the\n   * LICENSE.md file in the root directory of this source tree.\n   *\n   * @license MIT\n   */\nfunction Nn(e, t) {\n  return typeof e == \"function\" ? e(t) : e;\n}\nfunction Pt(e, t) {\n  return (n) => {\n    t.setState((r) => ({\n      ...r,\n      [e]: Nn(n, r[e])\n    }));\n  };\n}\nfunction lu(e) {\n  return e instanceof Function;\n}\nfunction KW(e) {\n  return Array.isArray(e) && e.every((t) => typeof t == \"number\");\n}\nfunction YW(e, t) {\n  const n = [], r = (i) => {\n    i.forEach((o) => {\n      n.push(o);\n      const a = t(o);\n      a != null && a.length && r(a);\n    });\n  };\n  return r(e), n;\n}\nfunction oe(e, t, n) {\n  let r = [], i;\n  return (o) => {\n    let a;\n    n.key && n.debug && (a = Date.now());\n    const s = e(o);\n    if (!(s.length !== r.length || s.some((f, l) => r[l] !== f)))\n      return i;\n    r = s;\n    let c;\n    if (n.key && n.debug && (c = Date.now()), i = t(...s), n == null || n.onChange == null || n.onChange(i), n.key && n.debug && n != null && n.debug()) {\n      const f = Math.round((Date.now() - a) * 100) / 100, l = Math.round((Date.now() - c) * 100) / 100, d = l / 16, p = (g, h) => {\n        for (g = String(g); g.length < h; )\n          g = \" \" + g;\n        return g;\n      };\n      console.info(`%c ${p(l, 5)} /${p(f, 5)} ms`, `\n            font-size: .6rem;\n            font-weight: bold;\n            color: hsl(${Math.max(0, Math.min(120 - 120 * d, 120))}deg 100% 31%);`, n == null ? void 0 : n.key);\n    }\n    return i;\n  };\n}\nfunction ae(e, t, n, r) {\n  return {\n    debug: () => {\n      var i;\n      return (i = e == null ? void 0 : e.debugAll) != null ? i : e[t];\n    },\n    key:  true && n,\n    onChange: r\n  };\n}\nfunction XW(e, t, n, r) {\n  const i = () => {\n    var a;\n    return (a = o.getValue()) != null ? a : e.options.renderFallbackValue;\n  }, o = {\n    id: `${t.id}_${n.id}`,\n    row: t,\n    column: n,\n    getValue: () => t.getValue(r),\n    renderValue: i,\n    getContext: oe(() => [e, n, t, o], (a, s, u, c) => ({\n      table: a,\n      column: s,\n      row: u,\n      cell: c,\n      getValue: c.getValue,\n      renderValue: c.renderValue\n    }), ae(e.options, \"debugCells\", \"cell.getContext\"))\n  };\n  return e._features.forEach((a) => {\n    a.createCell == null || a.createCell(o, n, t, e);\n  }, {}), o;\n}\nfunction ZW(e, t, n, r) {\n  var i, o;\n  const s = {\n    ...e._getDefaultColumnDef(),\n    ...t\n  }, u = s.accessorKey;\n  let c = (i = (o = s.id) != null ? o : u ? u.replace(\".\", \"_\") : void 0) != null ? i : typeof s.header == \"string\" ? s.header : void 0, f;\n  if (s.accessorFn ? f = s.accessorFn : u && (u.includes(\".\") ? f = (d) => {\n    let p = d;\n    for (const h of u.split(\".\")) {\n      var g;\n      p = (g = p) == null ? void 0 : g[h],  true && p === void 0 && console.warn(`\"${h}\" in deeply nested key \"${u}\" returned undefined.`);\n    }\n    return p;\n  } : f = (d) => d[s.accessorKey]), !c)\n    throw  true ? new Error(s.accessorFn ? \"Columns require an id when using an accessorFn\" : \"Columns require an id when using a non-string header\") : 0;\n  let l = {\n    id: `${String(c)}`,\n    accessorFn: f,\n    parent: r,\n    depth: n,\n    columnDef: s,\n    columns: [],\n    getFlatColumns: oe(() => [!0], () => {\n      var d;\n      return [l, ...(d = l.columns) == null ? void 0 : d.flatMap((p) => p.getFlatColumns())];\n    }, ae(e.options, \"debugColumns\", \"column.getFlatColumns\")),\n    getLeafColumns: oe(() => [e._getOrderColumnsFn()], (d) => {\n      var p;\n      if ((p = l.columns) != null && p.length) {\n        let g = l.columns.flatMap((h) => h.getLeafColumns());\n        return d(g);\n      }\n      return [l];\n    }, ae(e.options, \"debugColumns\", \"column.getLeafColumns\"))\n  };\n  for (const d of e._features)\n    d.createColumn == null || d.createColumn(l, e);\n  return l;\n}\nconst it = \"debugHeaders\";\nfunction om(e, t, n) {\n  var r;\n  let o = {\n    id: (r = n.id) != null ? r : t.id,\n    column: t,\n    index: n.index,\n    isPlaceholder: !!n.isPlaceholder,\n    placeholderId: n.placeholderId,\n    depth: n.depth,\n    subHeaders: [],\n    colSpan: 0,\n    rowSpan: 0,\n    headerGroup: null,\n    getLeafHeaders: () => {\n      const a = [], s = (u) => {\n        u.subHeaders && u.subHeaders.length && u.subHeaders.map(s), a.push(u);\n      };\n      return s(o), a;\n    },\n    getContext: () => ({\n      table: e,\n      header: o,\n      column: t\n    })\n  };\n  return e._features.forEach((a) => {\n    a.createHeader == null || a.createHeader(o, e);\n  }), o;\n}\nconst JW = {\n  createTable: (e) => {\n    e.getHeaderGroups = oe(() => [e.getAllColumns(), e.getVisibleLeafColumns(), e.getState().columnPinning.left, e.getState().columnPinning.right], (t, n, r, i) => {\n      var o, a;\n      const s = (o = r == null ? void 0 : r.map((l) => n.find((d) => d.id === l)).filter(Boolean)) != null ? o : [], u = (a = i == null ? void 0 : i.map((l) => n.find((d) => d.id === l)).filter(Boolean)) != null ? a : [], c = n.filter((l) => !(r != null && r.includes(l.id)) && !(i != null && i.includes(l.id)));\n      return $a(t, [...s, ...c, ...u], e);\n    }, ae(e.options, it, \"getHeaderGroups\")), e.getCenterHeaderGroups = oe(() => [e.getAllColumns(), e.getVisibleLeafColumns(), e.getState().columnPinning.left, e.getState().columnPinning.right], (t, n, r, i) => (n = n.filter((o) => !(r != null && r.includes(o.id)) && !(i != null && i.includes(o.id))), $a(t, n, e, \"center\")), ae(e.options, it, \"getCenterHeaderGroups\")), e.getLeftHeaderGroups = oe(() => [e.getAllColumns(), e.getVisibleLeafColumns(), e.getState().columnPinning.left], (t, n, r) => {\n      var i;\n      const o = (i = r == null ? void 0 : r.map((a) => n.find((s) => s.id === a)).filter(Boolean)) != null ? i : [];\n      return $a(t, o, e, \"left\");\n    }, ae(e.options, it, \"getLeftHeaderGroups\")), e.getRightHeaderGroups = oe(() => [e.getAllColumns(), e.getVisibleLeafColumns(), e.getState().columnPinning.right], (t, n, r) => {\n      var i;\n      const o = (i = r == null ? void 0 : r.map((a) => n.find((s) => s.id === a)).filter(Boolean)) != null ? i : [];\n      return $a(t, o, e, \"right\");\n    }, ae(e.options, it, \"getRightHeaderGroups\")), e.getFooterGroups = oe(() => [e.getHeaderGroups()], (t) => [...t].reverse(), ae(e.options, it, \"getFooterGroups\")), e.getLeftFooterGroups = oe(() => [e.getLeftHeaderGroups()], (t) => [...t].reverse(), ae(e.options, it, \"getLeftFooterGroups\")), e.getCenterFooterGroups = oe(() => [e.getCenterHeaderGroups()], (t) => [...t].reverse(), ae(e.options, it, \"getCenterFooterGroups\")), e.getRightFooterGroups = oe(() => [e.getRightHeaderGroups()], (t) => [...t].reverse(), ae(e.options, it, \"getRightFooterGroups\")), e.getFlatHeaders = oe(() => [e.getHeaderGroups()], (t) => t.map((n) => n.headers).flat(), ae(e.options, it, \"getFlatHeaders\")), e.getLeftFlatHeaders = oe(() => [e.getLeftHeaderGroups()], (t) => t.map((n) => n.headers).flat(), ae(e.options, it, \"getLeftFlatHeaders\")), e.getCenterFlatHeaders = oe(() => [e.getCenterHeaderGroups()], (t) => t.map((n) => n.headers).flat(), ae(e.options, it, \"getCenterFlatHeaders\")), e.getRightFlatHeaders = oe(() => [e.getRightHeaderGroups()], (t) => t.map((n) => n.headers).flat(), ae(e.options, it, \"getRightFlatHeaders\")), e.getCenterLeafHeaders = oe(() => [e.getCenterFlatHeaders()], (t) => t.filter((n) => {\n      var r;\n      return !((r = n.subHeaders) != null && r.length);\n    }), ae(e.options, it, \"getCenterLeafHeaders\")), e.getLeftLeafHeaders = oe(() => [e.getLeftFlatHeaders()], (t) => t.filter((n) => {\n      var r;\n      return !((r = n.subHeaders) != null && r.length);\n    }), ae(e.options, it, \"getLeftLeafHeaders\")), e.getRightLeafHeaders = oe(() => [e.getRightFlatHeaders()], (t) => t.filter((n) => {\n      var r;\n      return !((r = n.subHeaders) != null && r.length);\n    }), ae(e.options, it, \"getRightLeafHeaders\")), e.getLeafHeaders = oe(() => [e.getLeftHeaderGroups(), e.getCenterHeaderGroups(), e.getRightHeaderGroups()], (t, n, r) => {\n      var i, o, a, s, u, c;\n      return [...(i = (o = t[0]) == null ? void 0 : o.headers) != null ? i : [], ...(a = (s = n[0]) == null ? void 0 : s.headers) != null ? a : [], ...(u = (c = r[0]) == null ? void 0 : c.headers) != null ? u : []].map((f) => f.getLeafHeaders()).flat();\n    }, ae(e.options, it, \"getLeafHeaders\"));\n  }\n};\nfunction $a(e, t, n, r) {\n  var i, o;\n  let a = 0;\n  const s = function(d, p) {\n    p === void 0 && (p = 1), a = Math.max(a, p), d.filter((g) => g.getIsVisible()).forEach((g) => {\n      var h;\n      (h = g.columns) != null && h.length && s(g.columns, p + 1);\n    }, 0);\n  };\n  s(e);\n  let u = [];\n  const c = (d, p) => {\n    const g = {\n      depth: p,\n      id: [r, `${p}`].filter(Boolean).join(\"_\"),\n      headers: []\n    }, h = [];\n    d.forEach((v) => {\n      const w = [...h].reverse()[0], b = v.column.depth === g.depth;\n      let x, m = !1;\n      if (b && v.column.parent ? x = v.column.parent : (x = v.column, m = !0), w && (w == null ? void 0 : w.column) === x)\n        w.subHeaders.push(v);\n      else {\n        const y = om(n, x, {\n          id: [r, p, x.id, v == null ? void 0 : v.id].filter(Boolean).join(\"_\"),\n          isPlaceholder: m,\n          placeholderId: m ? `${h.filter((S) => S.column === x).length}` : void 0,\n          depth: p,\n          index: h.length\n        });\n        y.subHeaders.push(v), h.push(y);\n      }\n      g.headers.push(v), v.headerGroup = g;\n    }), u.push(g), p > 0 && c(h, p - 1);\n  }, f = t.map((d, p) => om(n, d, {\n    depth: a,\n    index: p\n  }));\n  c(f, a - 1), u.reverse();\n  const l = (d) => d.filter((g) => g.column.getIsVisible()).map((g) => {\n    let h = 0, v = 0, w = [0];\n    g.subHeaders && g.subHeaders.length ? (w = [], l(g.subHeaders).forEach((x) => {\n      let {\n        colSpan: m,\n        rowSpan: y\n      } = x;\n      h += m, w.push(y);\n    })) : h = 1;\n    const b = Math.min(...w);\n    return v = v + b, g.colSpan = h, g.rowSpan = v, {\n      colSpan: h,\n      rowSpan: v\n    };\n  });\n  return l((i = (o = u[0]) == null ? void 0 : o.headers) != null ? i : []), u;\n}\nconst Sd = (e, t, n, r, i, o, a) => {\n  let s = {\n    id: t,\n    index: r,\n    original: n,\n    depth: i,\n    parentId: a,\n    _valuesCache: {},\n    _uniqueValuesCache: {},\n    getValue: (u) => {\n      if (s._valuesCache.hasOwnProperty(u))\n        return s._valuesCache[u];\n      const c = e.getColumn(u);\n      if (c != null && c.accessorFn)\n        return s._valuesCache[u] = c.accessorFn(s.original, r), s._valuesCache[u];\n    },\n    getUniqueValues: (u) => {\n      if (s._uniqueValuesCache.hasOwnProperty(u))\n        return s._uniqueValuesCache[u];\n      const c = e.getColumn(u);\n      if (c != null && c.accessorFn)\n        return c.columnDef.getUniqueValues ? (s._uniqueValuesCache[u] = c.columnDef.getUniqueValues(s.original, r), s._uniqueValuesCache[u]) : (s._uniqueValuesCache[u] = [s.getValue(u)], s._uniqueValuesCache[u]);\n    },\n    renderValue: (u) => {\n      var c;\n      return (c = s.getValue(u)) != null ? c : e.options.renderFallbackValue;\n    },\n    subRows: [],\n    getLeafRows: () => YW(s.subRows, (u) => u.subRows),\n    getParentRow: () => s.parentId ? e.getRow(s.parentId, !0) : void 0,\n    getParentRows: () => {\n      let u = [], c = s;\n      for (; ; ) {\n        const f = c.getParentRow();\n        if (!f)\n          break;\n        u.push(f), c = f;\n      }\n      return u.reverse();\n    },\n    getAllCells: oe(() => [e.getAllLeafColumns()], (u) => u.map((c) => XW(e, s, c, c.id)), ae(e.options, \"debugRows\", \"getAllCells\")),\n    _getAllCellsByColumnId: oe(() => [s.getAllCells()], (u) => u.reduce((c, f) => (c[f.column.id] = f, c), {}), ae(e.options, \"debugRows\", \"getAllCellsByColumnId\"))\n  };\n  for (let u = 0; u < e._features.length; u++) {\n    const c = e._features[u];\n    c == null || c.createRow == null || c.createRow(s, e);\n  }\n  return s;\n}, QW = {\n  createColumn: (e, t) => {\n    e._getFacetedRowModel = t.options.getFacetedRowModel && t.options.getFacetedRowModel(t, e.id), e.getFacetedRowModel = () => e._getFacetedRowModel ? e._getFacetedRowModel() : t.getPreFilteredRowModel(), e._getFacetedUniqueValues = t.options.getFacetedUniqueValues && t.options.getFacetedUniqueValues(t, e.id), e.getFacetedUniqueValues = () => e._getFacetedUniqueValues ? e._getFacetedUniqueValues() : /* @__PURE__ */ new Map(), e._getFacetedMinMaxValues = t.options.getFacetedMinMaxValues && t.options.getFacetedMinMaxValues(t, e.id), e.getFacetedMinMaxValues = () => {\n      if (e._getFacetedMinMaxValues)\n        return e._getFacetedMinMaxValues();\n    };\n  }\n}, Vw = (e, t, n) => {\n  var r;\n  const i = n.toLowerCase();\n  return !!(!((r = e.getValue(t)) == null || (r = r.toString()) == null || (r = r.toLowerCase()) == null) && r.includes(i));\n};\nVw.autoRemove = (e) => Xt(e);\nconst Gw = (e, t, n) => {\n  var r;\n  return !!(!((r = e.getValue(t)) == null || (r = r.toString()) == null) && r.includes(n));\n};\nGw.autoRemove = (e) => Xt(e);\nconst Ww = (e, t, n) => {\n  var r;\n  return ((r = e.getValue(t)) == null || (r = r.toString()) == null ? void 0 : r.toLowerCase()) === (n == null ? void 0 : n.toLowerCase());\n};\nWw.autoRemove = (e) => Xt(e);\nconst Uw = (e, t, n) => {\n  var r;\n  return (r = e.getValue(t)) == null ? void 0 : r.includes(n);\n};\nUw.autoRemove = (e) => Xt(e) || !(e != null && e.length);\nconst Hw = (e, t, n) => !n.some((r) => {\n  var i;\n  return !((i = e.getValue(t)) != null && i.includes(r));\n});\nHw.autoRemove = (e) => Xt(e) || !(e != null && e.length);\nconst qw = (e, t, n) => n.some((r) => {\n  var i;\n  return (i = e.getValue(t)) == null ? void 0 : i.includes(r);\n});\nqw.autoRemove = (e) => Xt(e) || !(e != null && e.length);\nconst Kw = (e, t, n) => e.getValue(t) === n;\nKw.autoRemove = (e) => Xt(e);\nconst Yw = (e, t, n) => e.getValue(t) == n;\nYw.autoRemove = (e) => Xt(e);\nconst $d = (e, t, n) => {\n  let [r, i] = n;\n  const o = e.getValue(t);\n  return o >= r && o <= i;\n};\n$d.resolveFilterValue = (e) => {\n  let [t, n] = e, r = typeof t != \"number\" ? parseFloat(t) : t, i = typeof n != \"number\" ? parseFloat(n) : n, o = t === null || Number.isNaN(r) ? -1 / 0 : r, a = n === null || Number.isNaN(i) ? 1 / 0 : i;\n  if (o > a) {\n    const s = o;\n    o = a, a = s;\n  }\n  return [o, a];\n};\n$d.autoRemove = (e) => Xt(e) || Xt(e[0]) && Xt(e[1]);\nconst hn = {\n  includesString: Vw,\n  includesStringSensitive: Gw,\n  equalsString: Ww,\n  arrIncludes: Uw,\n  arrIncludesAll: Hw,\n  arrIncludesSome: qw,\n  equals: Kw,\n  weakEquals: Yw,\n  inNumberRange: $d\n};\nfunction Xt(e) {\n  return e == null || e === \"\";\n}\nconst eU = {\n  getDefaultColumnDef: () => ({\n    filterFn: \"auto\"\n  }),\n  getInitialState: (e) => ({\n    columnFilters: [],\n    ...e\n  }),\n  getDefaultOptions: (e) => ({\n    onColumnFiltersChange: Pt(\"columnFilters\", e),\n    filterFromLeafRows: !1,\n    maxLeafRowFilterDepth: 100\n  }),\n  createColumn: (e, t) => {\n    e.getAutoFilterFn = () => {\n      const n = t.getCoreRowModel().flatRows[0], r = n == null ? void 0 : n.getValue(e.id);\n      return typeof r == \"string\" ? hn.includesString : typeof r == \"number\" ? hn.inNumberRange : typeof r == \"boolean\" || r !== null && typeof r == \"object\" ? hn.equals : Array.isArray(r) ? hn.arrIncludes : hn.weakEquals;\n    }, e.getFilterFn = () => {\n      var n, r;\n      return lu(e.columnDef.filterFn) ? e.columnDef.filterFn : e.columnDef.filterFn === \"auto\" ? e.getAutoFilterFn() : (\n        // @ts-ignore\n        (n = (r = t.options.filterFns) == null ? void 0 : r[e.columnDef.filterFn]) != null ? n : hn[e.columnDef.filterFn]\n      );\n    }, e.getCanFilter = () => {\n      var n, r, i;\n      return ((n = e.columnDef.enableColumnFilter) != null ? n : !0) && ((r = t.options.enableColumnFilters) != null ? r : !0) && ((i = t.options.enableFilters) != null ? i : !0) && !!e.accessorFn;\n    }, e.getIsFiltered = () => e.getFilterIndex() > -1, e.getFilterValue = () => {\n      var n;\n      return (n = t.getState().columnFilters) == null || (n = n.find((r) => r.id === e.id)) == null ? void 0 : n.value;\n    }, e.getFilterIndex = () => {\n      var n, r;\n      return (n = (r = t.getState().columnFilters) == null ? void 0 : r.findIndex((i) => i.id === e.id)) != null ? n : -1;\n    }, e.setFilterValue = (n) => {\n      t.setColumnFilters((r) => {\n        const i = e.getFilterFn(), o = r == null ? void 0 : r.find((f) => f.id === e.id), a = Nn(n, o ? o.value : void 0);\n        if (am(i, a, e)) {\n          var s;\n          return (s = r == null ? void 0 : r.filter((f) => f.id !== e.id)) != null ? s : [];\n        }\n        const u = {\n          id: e.id,\n          value: a\n        };\n        if (o) {\n          var c;\n          return (c = r == null ? void 0 : r.map((f) => f.id === e.id ? u : f)) != null ? c : [];\n        }\n        return r != null && r.length ? [...r, u] : [u];\n      });\n    };\n  },\n  createRow: (e, t) => {\n    e.columnFilters = {}, e.columnFiltersMeta = {};\n  },\n  createTable: (e) => {\n    e.setColumnFilters = (t) => {\n      const n = e.getAllLeafColumns(), r = (i) => {\n        var o;\n        return (o = Nn(t, i)) == null ? void 0 : o.filter((a) => {\n          const s = n.find((u) => u.id === a.id);\n          if (s) {\n            const u = s.getFilterFn();\n            if (am(u, a.value, s))\n              return !1;\n          }\n          return !0;\n        });\n      };\n      e.options.onColumnFiltersChange == null || e.options.onColumnFiltersChange(r);\n    }, e.resetColumnFilters = (t) => {\n      var n, r;\n      e.setColumnFilters(t ? [] : (n = (r = e.initialState) == null ? void 0 : r.columnFilters) != null ? n : []);\n    }, e.getPreFilteredRowModel = () => e.getCoreRowModel(), e.getFilteredRowModel = () => (!e._getFilteredRowModel && e.options.getFilteredRowModel && (e._getFilteredRowModel = e.options.getFilteredRowModel(e)), e.options.manualFiltering || !e._getFilteredRowModel ? e.getPreFilteredRowModel() : e._getFilteredRowModel());\n  }\n};\nfunction am(e, t, n) {\n  return (e && e.autoRemove ? e.autoRemove(t, n) : !1) || typeof t > \"u\" || typeof t == \"string\" && !t;\n}\nconst tU = (e, t, n) => n.reduce((r, i) => {\n  const o = i.getValue(e);\n  return r + (typeof o == \"number\" ? o : 0);\n}, 0), nU = (e, t, n) => {\n  let r;\n  return n.forEach((i) => {\n    const o = i.getValue(e);\n    o != null && (r > o || r === void 0 && o >= o) && (r = o);\n  }), r;\n}, rU = (e, t, n) => {\n  let r;\n  return n.forEach((i) => {\n    const o = i.getValue(e);\n    o != null && (r < o || r === void 0 && o >= o) && (r = o);\n  }), r;\n}, iU = (e, t, n) => {\n  let r, i;\n  return n.forEach((o) => {\n    const a = o.getValue(e);\n    a != null && (r === void 0 ? a >= a && (r = i = a) : (r > a && (r = a), i < a && (i = a)));\n  }), [r, i];\n}, oU = (e, t) => {\n  let n = 0, r = 0;\n  if (t.forEach((i) => {\n    let o = i.getValue(e);\n    o != null && (o = +o) >= o && (++n, r += o);\n  }), n)\n    return r / n;\n}, aU = (e, t) => {\n  if (!t.length)\n    return;\n  const n = t.map((o) => o.getValue(e));\n  if (!KW(n))\n    return;\n  if (n.length === 1)\n    return n[0];\n  const r = Math.floor(n.length / 2), i = n.sort((o, a) => o - a);\n  return n.length % 2 !== 0 ? i[r] : (i[r - 1] + i[r]) / 2;\n}, sU = (e, t) => Array.from(new Set(t.map((n) => n.getValue(e))).values()), uU = (e, t) => new Set(t.map((n) => n.getValue(e))).size, cU = (e, t) => t.length, sc = {\n  sum: tU,\n  min: nU,\n  max: rU,\n  extent: iU,\n  mean: oU,\n  median: aU,\n  unique: sU,\n  uniqueCount: uU,\n  count: cU\n}, lU = {\n  getDefaultColumnDef: () => ({\n    aggregatedCell: (e) => {\n      var t, n;\n      return (t = (n = e.getValue()) == null || n.toString == null ? void 0 : n.toString()) != null ? t : null;\n    },\n    aggregationFn: \"auto\"\n  }),\n  getInitialState: (e) => ({\n    grouping: [],\n    ...e\n  }),\n  getDefaultOptions: (e) => ({\n    onGroupingChange: Pt(\"grouping\", e),\n    groupedColumnMode: \"reorder\"\n  }),\n  createColumn: (e, t) => {\n    e.toggleGrouping = () => {\n      t.setGrouping((n) => n != null && n.includes(e.id) ? n.filter((r) => r !== e.id) : [...n ?? [], e.id]);\n    }, e.getCanGroup = () => {\n      var n, r;\n      return ((n = e.columnDef.enableGrouping) != null ? n : !0) && ((r = t.options.enableGrouping) != null ? r : !0) && (!!e.accessorFn || !!e.columnDef.getGroupingValue);\n    }, e.getIsGrouped = () => {\n      var n;\n      return (n = t.getState().grouping) == null ? void 0 : n.includes(e.id);\n    }, e.getGroupedIndex = () => {\n      var n;\n      return (n = t.getState().grouping) == null ? void 0 : n.indexOf(e.id);\n    }, e.getToggleGroupingHandler = () => {\n      const n = e.getCanGroup();\n      return () => {\n        n && e.toggleGrouping();\n      };\n    }, e.getAutoAggregationFn = () => {\n      const n = t.getCoreRowModel().flatRows[0], r = n == null ? void 0 : n.getValue(e.id);\n      if (typeof r == \"number\")\n        return sc.sum;\n      if (Object.prototype.toString.call(r) === \"[object Date]\")\n        return sc.extent;\n    }, e.getAggregationFn = () => {\n      var n, r;\n      if (!e)\n        throw new Error();\n      return lu(e.columnDef.aggregationFn) ? e.columnDef.aggregationFn : e.columnDef.aggregationFn === \"auto\" ? e.getAutoAggregationFn() : (n = (r = t.options.aggregationFns) == null ? void 0 : r[e.columnDef.aggregationFn]) != null ? n : sc[e.columnDef.aggregationFn];\n    };\n  },\n  createTable: (e) => {\n    e.setGrouping = (t) => e.options.onGroupingChange == null ? void 0 : e.options.onGroupingChange(t), e.resetGrouping = (t) => {\n      var n, r;\n      e.setGrouping(t ? [] : (n = (r = e.initialState) == null ? void 0 : r.grouping) != null ? n : []);\n    }, e.getPreGroupedRowModel = () => e.getFilteredRowModel(), e.getGroupedRowModel = () => (!e._getGroupedRowModel && e.options.getGroupedRowModel && (e._getGroupedRowModel = e.options.getGroupedRowModel(e)), e.options.manualGrouping || !e._getGroupedRowModel ? e.getPreGroupedRowModel() : e._getGroupedRowModel());\n  },\n  createRow: (e, t) => {\n    e.getIsGrouped = () => !!e.groupingColumnId, e.getGroupingValue = (n) => {\n      if (e._groupingValuesCache.hasOwnProperty(n))\n        return e._groupingValuesCache[n];\n      const r = t.getColumn(n);\n      return r != null && r.columnDef.getGroupingValue ? (e._groupingValuesCache[n] = r.columnDef.getGroupingValue(e.original), e._groupingValuesCache[n]) : e.getValue(n);\n    }, e._groupingValuesCache = {};\n  },\n  createCell: (e, t, n, r) => {\n    e.getIsGrouped = () => t.getIsGrouped() && t.id === n.groupingColumnId, e.getIsPlaceholder = () => !e.getIsGrouped() && t.getIsGrouped(), e.getIsAggregated = () => {\n      var i;\n      return !e.getIsGrouped() && !e.getIsPlaceholder() && !!((i = n.subRows) != null && i.length);\n    };\n  }\n};\nfunction fU(e, t, n) {\n  if (!(t != null && t.length) || !n)\n    return e;\n  const r = e.filter((o) => !t.includes(o.id));\n  return n === \"remove\" ? r : [...t.map((o) => e.find((a) => a.id === o)).filter(Boolean), ...r];\n}\nconst dU = {\n  getInitialState: (e) => ({\n    columnOrder: [],\n    ...e\n  }),\n  getDefaultOptions: (e) => ({\n    onColumnOrderChange: Pt(\"columnOrder\", e)\n  }),\n  createColumn: (e, t) => {\n    e.getIndex = oe((n) => [Yi(t, n)], (n) => n.findIndex((r) => r.id === e.id), ae(t.options, \"debugColumns\", \"getIndex\")), e.getIsFirstColumn = (n) => {\n      var r;\n      return ((r = Yi(t, n)[0]) == null ? void 0 : r.id) === e.id;\n    }, e.getIsLastColumn = (n) => {\n      var r;\n      const i = Yi(t, n);\n      return ((r = i[i.length - 1]) == null ? void 0 : r.id) === e.id;\n    };\n  },\n  createTable: (e) => {\n    e.setColumnOrder = (t) => e.options.onColumnOrderChange == null ? void 0 : e.options.onColumnOrderChange(t), e.resetColumnOrder = (t) => {\n      var n;\n      e.setColumnOrder(t ? [] : (n = e.initialState.columnOrder) != null ? n : []);\n    }, e._getOrderColumnsFn = oe(() => [e.getState().columnOrder, e.getState().grouping, e.options.groupedColumnMode], (t, n, r) => (i) => {\n      let o = [];\n      if (!(t != null && t.length))\n        o = i;\n      else {\n        const a = [...t], s = [...i];\n        for (; s.length && a.length; ) {\n          const u = a.shift(), c = s.findIndex((f) => f.id === u);\n          c > -1 && o.push(s.splice(c, 1)[0]);\n        }\n        o = [...o, ...s];\n      }\n      return fU(o, n, r);\n    }, ae(e.options, \"debugTable\", \"_getOrderColumnsFn\"));\n  }\n}, uc = () => ({\n  left: [],\n  right: []\n}), pU = {\n  getInitialState: (e) => ({\n    columnPinning: uc(),\n    ...e\n  }),\n  getDefaultOptions: (e) => ({\n    onColumnPinningChange: Pt(\"columnPinning\", e)\n  }),\n  createColumn: (e, t) => {\n    e.pin = (n) => {\n      const r = e.getLeafColumns().map((i) => i.id).filter(Boolean);\n      t.setColumnPinning((i) => {\n        var o, a;\n        if (n === \"right\") {\n          var s, u;\n          return {\n            left: ((s = i == null ? void 0 : i.left) != null ? s : []).filter((l) => !(r != null && r.includes(l))),\n            right: [...((u = i == null ? void 0 : i.right) != null ? u : []).filter((l) => !(r != null && r.includes(l))), ...r]\n          };\n        }\n        if (n === \"left\") {\n          var c, f;\n          return {\n            left: [...((c = i == null ? void 0 : i.left) != null ? c : []).filter((l) => !(r != null && r.includes(l))), ...r],\n            right: ((f = i == null ? void 0 : i.right) != null ? f : []).filter((l) => !(r != null && r.includes(l)))\n          };\n        }\n        return {\n          left: ((o = i == null ? void 0 : i.left) != null ? o : []).filter((l) => !(r != null && r.includes(l))),\n          right: ((a = i == null ? void 0 : i.right) != null ? a : []).filter((l) => !(r != null && r.includes(l)))\n        };\n      });\n    }, e.getCanPin = () => e.getLeafColumns().some((r) => {\n      var i, o, a;\n      return ((i = r.columnDef.enablePinning) != null ? i : !0) && ((o = (a = t.options.enableColumnPinning) != null ? a : t.options.enablePinning) != null ? o : !0);\n    }), e.getIsPinned = () => {\n      const n = e.getLeafColumns().map((s) => s.id), {\n        left: r,\n        right: i\n      } = t.getState().columnPinning, o = n.some((s) => r == null ? void 0 : r.includes(s)), a = n.some((s) => i == null ? void 0 : i.includes(s));\n      return o ? \"left\" : a ? \"right\" : !1;\n    }, e.getPinnedIndex = () => {\n      var n, r;\n      const i = e.getIsPinned();\n      return i ? (n = (r = t.getState().columnPinning) == null || (r = r[i]) == null ? void 0 : r.indexOf(e.id)) != null ? n : -1 : 0;\n    };\n  },\n  createRow: (e, t) => {\n    e.getCenterVisibleCells = oe(() => [e._getAllVisibleCells(), t.getState().columnPinning.left, t.getState().columnPinning.right], (n, r, i) => {\n      const o = [...r ?? [], ...i ?? []];\n      return n.filter((a) => !o.includes(a.column.id));\n    }, ae(t.options, \"debugRows\", \"getCenterVisibleCells\")), e.getLeftVisibleCells = oe(() => [e._getAllVisibleCells(), t.getState().columnPinning.left], (n, r) => (r ?? []).map((o) => n.find((a) => a.column.id === o)).filter(Boolean).map((o) => ({\n      ...o,\n      position: \"left\"\n    })), ae(t.options, \"debugRows\", \"getLeftVisibleCells\")), e.getRightVisibleCells = oe(() => [e._getAllVisibleCells(), t.getState().columnPinning.right], (n, r) => (r ?? []).map((o) => n.find((a) => a.column.id === o)).filter(Boolean).map((o) => ({\n      ...o,\n      position: \"right\"\n    })), ae(t.options, \"debugRows\", \"getRightVisibleCells\"));\n  },\n  createTable: (e) => {\n    e.setColumnPinning = (t) => e.options.onColumnPinningChange == null ? void 0 : e.options.onColumnPinningChange(t), e.resetColumnPinning = (t) => {\n      var n, r;\n      return e.setColumnPinning(t ? uc() : (n = (r = e.initialState) == null ? void 0 : r.columnPinning) != null ? n : uc());\n    }, e.getIsSomeColumnsPinned = (t) => {\n      var n;\n      const r = e.getState().columnPinning;\n      if (!t) {\n        var i, o;\n        return !!((i = r.left) != null && i.length || (o = r.right) != null && o.length);\n      }\n      return !!((n = r[t]) != null && n.length);\n    }, e.getLeftLeafColumns = oe(() => [e.getAllLeafColumns(), e.getState().columnPinning.left], (t, n) => (n ?? []).map((r) => t.find((i) => i.id === r)).filter(Boolean), ae(e.options, \"debugColumns\", \"getLeftLeafColumns\")), e.getRightLeafColumns = oe(() => [e.getAllLeafColumns(), e.getState().columnPinning.right], (t, n) => (n ?? []).map((r) => t.find((i) => i.id === r)).filter(Boolean), ae(e.options, \"debugColumns\", \"getRightLeafColumns\")), e.getCenterLeafColumns = oe(() => [e.getAllLeafColumns(), e.getState().columnPinning.left, e.getState().columnPinning.right], (t, n, r) => {\n      const i = [...n ?? [], ...r ?? []];\n      return t.filter((o) => !i.includes(o.id));\n    }, ae(e.options, \"debugColumns\", \"getCenterLeafColumns\"));\n  }\n}, Oa = {\n  size: 150,\n  minSize: 20,\n  maxSize: Number.MAX_SAFE_INTEGER\n}, cc = () => ({\n  startOffset: null,\n  startSize: null,\n  deltaOffset: null,\n  deltaPercentage: null,\n  isResizingColumn: !1,\n  columnSizingStart: []\n}), hU = {\n  getDefaultColumnDef: () => Oa,\n  getInitialState: (e) => ({\n    columnSizing: {},\n    columnSizingInfo: cc(),\n    ...e\n  }),\n  getDefaultOptions: (e) => ({\n    columnResizeMode: \"onEnd\",\n    columnResizeDirection: \"ltr\",\n    onColumnSizingChange: Pt(\"columnSizing\", e),\n    onColumnSizingInfoChange: Pt(\"columnSizingInfo\", e)\n  }),\n  createColumn: (e, t) => {\n    e.getSize = () => {\n      var n, r, i;\n      const o = t.getState().columnSizing[e.id];\n      return Math.min(Math.max((n = e.columnDef.minSize) != null ? n : Oa.minSize, (r = o ?? e.columnDef.size) != null ? r : Oa.size), (i = e.columnDef.maxSize) != null ? i : Oa.maxSize);\n    }, e.getStart = oe((n) => [n, Yi(t, n), t.getState().columnSizing], (n, r) => r.slice(0, e.getIndex(n)).reduce((i, o) => i + o.getSize(), 0), ae(t.options, \"debugColumns\", \"getStart\")), e.getAfter = oe((n) => [n, Yi(t, n), t.getState().columnSizing], (n, r) => r.slice(e.getIndex(n) + 1).reduce((i, o) => i + o.getSize(), 0), ae(t.options, \"debugColumns\", \"getAfter\")), e.resetSize = () => {\n      t.setColumnSizing((n) => {\n        let {\n          [e.id]: r,\n          ...i\n        } = n;\n        return i;\n      });\n    }, e.getCanResize = () => {\n      var n, r;\n      return ((n = e.columnDef.enableResizing) != null ? n : !0) && ((r = t.options.enableColumnResizing) != null ? r : !0);\n    }, e.getIsResizing = () => t.getState().columnSizingInfo.isResizingColumn === e.id;\n  },\n  createHeader: (e, t) => {\n    e.getSize = () => {\n      let n = 0;\n      const r = (i) => {\n        if (i.subHeaders.length)\n          i.subHeaders.forEach(r);\n        else {\n          var o;\n          n += (o = i.column.getSize()) != null ? o : 0;\n        }\n      };\n      return r(e), n;\n    }, e.getStart = () => {\n      if (e.index > 0) {\n        const n = e.headerGroup.headers[e.index - 1];\n        return n.getStart() + n.getSize();\n      }\n      return 0;\n    }, e.getResizeHandler = (n) => {\n      const r = t.getColumn(e.column.id), i = r == null ? void 0 : r.getCanResize();\n      return (o) => {\n        if (!r || !i || (o.persist == null || o.persist(), lc(o) && o.touches && o.touches.length > 1))\n          return;\n        const a = e.getSize(), s = e ? e.getLeafHeaders().map((w) => [w.column.id, w.column.getSize()]) : [[r.id, r.getSize()]], u = lc(o) ? Math.round(o.touches[0].clientX) : o.clientX, c = {}, f = (w, b) => {\n          typeof b == \"number\" && (t.setColumnSizingInfo((x) => {\n            var m, y;\n            const S = t.options.columnResizeDirection === \"rtl\" ? -1 : 1, $ = (b - ((m = x == null ? void 0 : x.startOffset) != null ? m : 0)) * S, O = Math.max($ / ((y = x == null ? void 0 : x.startSize) != null ? y : 0), -0.999999);\n            return x.columnSizingStart.forEach((T) => {\n              let [M, E] = T;\n              c[M] = Math.round(Math.max(E + E * O, 0) * 100) / 100;\n            }), {\n              ...x,\n              deltaOffset: $,\n              deltaPercentage: O\n            };\n          }), (t.options.columnResizeMode === \"onChange\" || w === \"end\") && t.setColumnSizing((x) => ({\n            ...x,\n            ...c\n          })));\n        }, l = (w) => f(\"move\", w), d = (w) => {\n          f(\"end\", w), t.setColumnSizingInfo((b) => ({\n            ...b,\n            isResizingColumn: !1,\n            startOffset: null,\n            startSize: null,\n            deltaOffset: null,\n            deltaPercentage: null,\n            columnSizingStart: []\n          }));\n        }, p = n || typeof document < \"u\" ? document : null, g = {\n          moveHandler: (w) => l(w.clientX),\n          upHandler: (w) => {\n            p == null || p.removeEventListener(\"mousemove\", g.moveHandler), p == null || p.removeEventListener(\"mouseup\", g.upHandler), d(w.clientX);\n          }\n        }, h = {\n          moveHandler: (w) => (w.cancelable && (w.preventDefault(), w.stopPropagation()), l(w.touches[0].clientX), !1),\n          upHandler: (w) => {\n            var b;\n            p == null || p.removeEventListener(\"touchmove\", h.moveHandler), p == null || p.removeEventListener(\"touchend\", h.upHandler), w.cancelable && (w.preventDefault(), w.stopPropagation()), d((b = w.touches[0]) == null ? void 0 : b.clientX);\n          }\n        }, v = gU() ? {\n          passive: !1\n        } : !1;\n        lc(o) ? (p == null || p.addEventListener(\"touchmove\", h.moveHandler, v), p == null || p.addEventListener(\"touchend\", h.upHandler, v)) : (p == null || p.addEventListener(\"mousemove\", g.moveHandler, v), p == null || p.addEventListener(\"mouseup\", g.upHandler, v)), t.setColumnSizingInfo((w) => ({\n          ...w,\n          startOffset: u,\n          startSize: a,\n          deltaOffset: 0,\n          deltaPercentage: 0,\n          columnSizingStart: s,\n          isResizingColumn: r.id\n        }));\n      };\n    };\n  },\n  createTable: (e) => {\n    e.setColumnSizing = (t) => e.options.onColumnSizingChange == null ? void 0 : e.options.onColumnSizingChange(t), e.setColumnSizingInfo = (t) => e.options.onColumnSizingInfoChange == null ? void 0 : e.options.onColumnSizingInfoChange(t), e.resetColumnSizing = (t) => {\n      var n;\n      e.setColumnSizing(t ? {} : (n = e.initialState.columnSizing) != null ? n : {});\n    }, e.resetHeaderSizeInfo = (t) => {\n      var n;\n      e.setColumnSizingInfo(t ? cc() : (n = e.initialState.columnSizingInfo) != null ? n : cc());\n    }, e.getTotalSize = () => {\n      var t, n;\n      return (t = (n = e.getHeaderGroups()[0]) == null ? void 0 : n.headers.reduce((r, i) => r + i.getSize(), 0)) != null ? t : 0;\n    }, e.getLeftTotalSize = () => {\n      var t, n;\n      return (t = (n = e.getLeftHeaderGroups()[0]) == null ? void 0 : n.headers.reduce((r, i) => r + i.getSize(), 0)) != null ? t : 0;\n    }, e.getCenterTotalSize = () => {\n      var t, n;\n      return (t = (n = e.getCenterHeaderGroups()[0]) == null ? void 0 : n.headers.reduce((r, i) => r + i.getSize(), 0)) != null ? t : 0;\n    }, e.getRightTotalSize = () => {\n      var t, n;\n      return (t = (n = e.getRightHeaderGroups()[0]) == null ? void 0 : n.headers.reduce((r, i) => r + i.getSize(), 0)) != null ? t : 0;\n    };\n  }\n};\nlet _a = null;\nfunction gU() {\n  if (typeof _a == \"boolean\")\n    return _a;\n  let e = !1;\n  try {\n    const t = {\n      get passive() {\n        return e = !0, !1;\n      }\n    }, n = () => {\n    };\n    window.addEventListener(\"test\", n, t), window.removeEventListener(\"test\", n);\n  } catch {\n    e = !1;\n  }\n  return _a = e, _a;\n}\nfunction lc(e) {\n  return e.type === \"touchstart\";\n}\nconst vU = {\n  getInitialState: (e) => ({\n    columnVisibility: {},\n    ...e\n  }),\n  getDefaultOptions: (e) => ({\n    onColumnVisibilityChange: Pt(\"columnVisibility\", e)\n  }),\n  createColumn: (e, t) => {\n    e.toggleVisibility = (n) => {\n      e.getCanHide() && t.setColumnVisibility((r) => ({\n        ...r,\n        [e.id]: n ?? !e.getIsVisible()\n      }));\n    }, e.getIsVisible = () => {\n      var n, r;\n      const i = e.columns;\n      return (n = i.length ? i.some((o) => o.getIsVisible()) : (r = t.getState().columnVisibility) == null ? void 0 : r[e.id]) != null ? n : !0;\n    }, e.getCanHide = () => {\n      var n, r;\n      return ((n = e.columnDef.enableHiding) != null ? n : !0) && ((r = t.options.enableHiding) != null ? r : !0);\n    }, e.getToggleVisibilityHandler = () => (n) => {\n      e.toggleVisibility == null || e.toggleVisibility(n.target.checked);\n    };\n  },\n  createRow: (e, t) => {\n    e._getAllVisibleCells = oe(() => [e.getAllCells(), t.getState().columnVisibility], (n) => n.filter((r) => r.column.getIsVisible()), ae(t.options, \"debugRows\", \"_getAllVisibleCells\")), e.getVisibleCells = oe(() => [e.getLeftVisibleCells(), e.getCenterVisibleCells(), e.getRightVisibleCells()], (n, r, i) => [...n, ...r, ...i], ae(t.options, \"debugRows\", \"getVisibleCells\"));\n  },\n  createTable: (e) => {\n    const t = (n, r) => oe(() => [r(), r().filter((i) => i.getIsVisible()).map((i) => i.id).join(\"_\")], (i) => i.filter((o) => o.getIsVisible == null ? void 0 : o.getIsVisible()), ae(e.options, \"debugColumns\", n));\n    e.getVisibleFlatColumns = t(\"getVisibleFlatColumns\", () => e.getAllFlatColumns()), e.getVisibleLeafColumns = t(\"getVisibleLeafColumns\", () => e.getAllLeafColumns()), e.getLeftVisibleLeafColumns = t(\"getLeftVisibleLeafColumns\", () => e.getLeftLeafColumns()), e.getRightVisibleLeafColumns = t(\"getRightVisibleLeafColumns\", () => e.getRightLeafColumns()), e.getCenterVisibleLeafColumns = t(\"getCenterVisibleLeafColumns\", () => e.getCenterLeafColumns()), e.setColumnVisibility = (n) => e.options.onColumnVisibilityChange == null ? void 0 : e.options.onColumnVisibilityChange(n), e.resetColumnVisibility = (n) => {\n      var r;\n      e.setColumnVisibility(n ? {} : (r = e.initialState.columnVisibility) != null ? r : {});\n    }, e.toggleAllColumnsVisible = (n) => {\n      var r;\n      n = (r = n) != null ? r : !e.getIsAllColumnsVisible(), e.setColumnVisibility(e.getAllLeafColumns().reduce((i, o) => ({\n        ...i,\n        [o.id]: n || !(o.getCanHide != null && o.getCanHide())\n      }), {}));\n    }, e.getIsAllColumnsVisible = () => !e.getAllLeafColumns().some((n) => !(n.getIsVisible != null && n.getIsVisible())), e.getIsSomeColumnsVisible = () => e.getAllLeafColumns().some((n) => n.getIsVisible == null ? void 0 : n.getIsVisible()), e.getToggleAllColumnsVisibilityHandler = () => (n) => {\n      var r;\n      e.toggleAllColumnsVisible((r = n.target) == null ? void 0 : r.checked);\n    };\n  }\n};\nfunction Yi(e, t) {\n  return t ? t === \"center\" ? e.getCenterVisibleLeafColumns() : t === \"left\" ? e.getLeftVisibleLeafColumns() : e.getRightVisibleLeafColumns() : e.getVisibleLeafColumns();\n}\nconst mU = {\n  createTable: (e) => {\n    e._getGlobalFacetedRowModel = e.options.getFacetedRowModel && e.options.getFacetedRowModel(e, \"__global__\"), e.getGlobalFacetedRowModel = () => e.options.manualFiltering || !e._getGlobalFacetedRowModel ? e.getPreFilteredRowModel() : e._getGlobalFacetedRowModel(), e._getGlobalFacetedUniqueValues = e.options.getFacetedUniqueValues && e.options.getFacetedUniqueValues(e, \"__global__\"), e.getGlobalFacetedUniqueValues = () => e._getGlobalFacetedUniqueValues ? e._getGlobalFacetedUniqueValues() : /* @__PURE__ */ new Map(), e._getGlobalFacetedMinMaxValues = e.options.getFacetedMinMaxValues && e.options.getFacetedMinMaxValues(e, \"__global__\"), e.getGlobalFacetedMinMaxValues = () => {\n      if (e._getGlobalFacetedMinMaxValues)\n        return e._getGlobalFacetedMinMaxValues();\n    };\n  }\n}, yU = {\n  getInitialState: (e) => ({\n    globalFilter: void 0,\n    ...e\n  }),\n  getDefaultOptions: (e) => ({\n    onGlobalFilterChange: Pt(\"globalFilter\", e),\n    globalFilterFn: \"auto\",\n    getColumnCanGlobalFilter: (t) => {\n      var n;\n      const r = (n = e.getCoreRowModel().flatRows[0]) == null || (n = n._getAllCellsByColumnId()[t.id]) == null ? void 0 : n.getValue();\n      return typeof r == \"string\" || typeof r == \"number\";\n    }\n  }),\n  createColumn: (e, t) => {\n    e.getCanGlobalFilter = () => {\n      var n, r, i, o;\n      return ((n = e.columnDef.enableGlobalFilter) != null ? n : !0) && ((r = t.options.enableGlobalFilter) != null ? r : !0) && ((i = t.options.enableFilters) != null ? i : !0) && ((o = t.options.getColumnCanGlobalFilter == null ? void 0 : t.options.getColumnCanGlobalFilter(e)) != null ? o : !0) && !!e.accessorFn;\n    };\n  },\n  createTable: (e) => {\n    e.getGlobalAutoFilterFn = () => hn.includesString, e.getGlobalFilterFn = () => {\n      var t, n;\n      const {\n        globalFilterFn: r\n      } = e.options;\n      return lu(r) ? r : r === \"auto\" ? e.getGlobalAutoFilterFn() : (t = (n = e.options.filterFns) == null ? void 0 : n[r]) != null ? t : hn[r];\n    }, e.setGlobalFilter = (t) => {\n      e.options.onGlobalFilterChange == null || e.options.onGlobalFilterChange(t);\n    }, e.resetGlobalFilter = (t) => {\n      e.setGlobalFilter(t ? void 0 : e.initialState.globalFilter);\n    };\n  }\n}, bU = {\n  getInitialState: (e) => ({\n    expanded: {},\n    ...e\n  }),\n  getDefaultOptions: (e) => ({\n    onExpandedChange: Pt(\"expanded\", e),\n    paginateExpandedRows: !0\n  }),\n  createTable: (e) => {\n    let t = !1, n = !1;\n    e._autoResetExpanded = () => {\n      var r, i;\n      if (!t) {\n        e._queue(() => {\n          t = !0;\n        });\n        return;\n      }\n      if ((r = (i = e.options.autoResetAll) != null ? i : e.options.autoResetExpanded) != null ? r : !e.options.manualExpanding) {\n        if (n)\n          return;\n        n = !0, e._queue(() => {\n          e.resetExpanded(), n = !1;\n        });\n      }\n    }, e.setExpanded = (r) => e.options.onExpandedChange == null ? void 0 : e.options.onExpandedChange(r), e.toggleAllRowsExpanded = (r) => {\n      r ?? !e.getIsAllRowsExpanded() ? e.setExpanded(!0) : e.setExpanded({});\n    }, e.resetExpanded = (r) => {\n      var i, o;\n      e.setExpanded(r ? {} : (i = (o = e.initialState) == null ? void 0 : o.expanded) != null ? i : {});\n    }, e.getCanSomeRowsExpand = () => e.getPrePaginationRowModel().flatRows.some((r) => r.getCanExpand()), e.getToggleAllRowsExpandedHandler = () => (r) => {\n      r.persist == null || r.persist(), e.toggleAllRowsExpanded();\n    }, e.getIsSomeRowsExpanded = () => {\n      const r = e.getState().expanded;\n      return r === !0 || Object.values(r).some(Boolean);\n    }, e.getIsAllRowsExpanded = () => {\n      const r = e.getState().expanded;\n      return typeof r == \"boolean\" ? r === !0 : !(!Object.keys(r).length || e.getRowModel().flatRows.some((i) => !i.getIsExpanded()));\n    }, e.getExpandedDepth = () => {\n      let r = 0;\n      return (e.getState().expanded === !0 ? Object.keys(e.getRowModel().rowsById) : Object.keys(e.getState().expanded)).forEach((o) => {\n        const a = o.split(\".\");\n        r = Math.max(r, a.length);\n      }), r;\n    }, e.getPreExpandedRowModel = () => e.getSortedRowModel(), e.getExpandedRowModel = () => (!e._getExpandedRowModel && e.options.getExpandedRowModel && (e._getExpandedRowModel = e.options.getExpandedRowModel(e)), e.options.manualExpanding || !e._getExpandedRowModel ? e.getPreExpandedRowModel() : e._getExpandedRowModel());\n  },\n  createRow: (e, t) => {\n    e.toggleExpanded = (n) => {\n      t.setExpanded((r) => {\n        var i;\n        const o = r === !0 ? !0 : !!(r != null && r[e.id]);\n        let a = {};\n        if (r === !0 ? Object.keys(t.getRowModel().rowsById).forEach((s) => {\n          a[s] = !0;\n        }) : a = r, n = (i = n) != null ? i : !o, !o && n)\n          return {\n            ...a,\n            [e.id]: !0\n          };\n        if (o && !n) {\n          const {\n            [e.id]: s,\n            ...u\n          } = a;\n          return u;\n        }\n        return r;\n      });\n    }, e.getIsExpanded = () => {\n      var n;\n      const r = t.getState().expanded;\n      return !!((n = t.options.getIsRowExpanded == null ? void 0 : t.options.getIsRowExpanded(e)) != null ? n : r === !0 || r != null && r[e.id]);\n    }, e.getCanExpand = () => {\n      var n, r, i;\n      return (n = t.options.getRowCanExpand == null ? void 0 : t.options.getRowCanExpand(e)) != null ? n : ((r = t.options.enableExpanding) != null ? r : !0) && !!((i = e.subRows) != null && i.length);\n    }, e.getIsAllParentsExpanded = () => {\n      let n = !0, r = e;\n      for (; n && r.parentId; )\n        r = t.getRow(r.parentId, !0), n = r.getIsExpanded();\n      return n;\n    }, e.getToggleExpandedHandler = () => {\n      const n = e.getCanExpand();\n      return () => {\n        n && e.toggleExpanded();\n      };\n    };\n  }\n}, Kl = 0, Yl = 10, fc = () => ({\n  pageIndex: Kl,\n  pageSize: Yl\n}), wU = {\n  getInitialState: (e) => ({\n    ...e,\n    pagination: {\n      ...fc(),\n      ...e == null ? void 0 : e.pagination\n    }\n  }),\n  getDefaultOptions: (e) => ({\n    onPaginationChange: Pt(\"pagination\", e)\n  }),\n  createTable: (e) => {\n    let t = !1, n = !1;\n    e._autoResetPageIndex = () => {\n      var r, i;\n      if (!t) {\n        e._queue(() => {\n          t = !0;\n        });\n        return;\n      }\n      if ((r = (i = e.options.autoResetAll) != null ? i : e.options.autoResetPageIndex) != null ? r : !e.options.manualPagination) {\n        if (n)\n          return;\n        n = !0, e._queue(() => {\n          e.resetPageIndex(), n = !1;\n        });\n      }\n    }, e.setPagination = (r) => {\n      const i = (o) => Nn(r, o);\n      return e.options.onPaginationChange == null ? void 0 : e.options.onPaginationChange(i);\n    }, e.resetPagination = (r) => {\n      var i;\n      e.setPagination(r ? fc() : (i = e.initialState.pagination) != null ? i : fc());\n    }, e.setPageIndex = (r) => {\n      e.setPagination((i) => {\n        let o = Nn(r, i.pageIndex);\n        const a = typeof e.options.pageCount > \"u\" || e.options.pageCount === -1 ? Number.MAX_SAFE_INTEGER : e.options.pageCount - 1;\n        return o = Math.max(0, Math.min(o, a)), {\n          ...i,\n          pageIndex: o\n        };\n      });\n    }, e.resetPageIndex = (r) => {\n      var i, o;\n      e.setPageIndex(r ? Kl : (i = (o = e.initialState) == null || (o = o.pagination) == null ? void 0 : o.pageIndex) != null ? i : Kl);\n    }, e.resetPageSize = (r) => {\n      var i, o;\n      e.setPageSize(r ? Yl : (i = (o = e.initialState) == null || (o = o.pagination) == null ? void 0 : o.pageSize) != null ? i : Yl);\n    }, e.setPageSize = (r) => {\n      e.setPagination((i) => {\n        const o = Math.max(1, Nn(r, i.pageSize)), a = i.pageSize * i.pageIndex, s = Math.floor(a / o);\n        return {\n          ...i,\n          pageIndex: s,\n          pageSize: o\n        };\n      });\n    }, e.setPageCount = (r) => e.setPagination((i) => {\n      var o;\n      let a = Nn(r, (o = e.options.pageCount) != null ? o : -1);\n      return typeof a == \"number\" && (a = Math.max(-1, a)), {\n        ...i,\n        pageCount: a\n      };\n    }), e.getPageOptions = oe(() => [e.getPageCount()], (r) => {\n      let i = [];\n      return r && r > 0 && (i = [...new Array(r)].fill(null).map((o, a) => a)), i;\n    }, ae(e.options, \"debugTable\", \"getPageOptions\")), e.getCanPreviousPage = () => e.getState().pagination.pageIndex > 0, e.getCanNextPage = () => {\n      const {\n        pageIndex: r\n      } = e.getState().pagination, i = e.getPageCount();\n      return i === -1 ? !0 : i === 0 ? !1 : r < i - 1;\n    }, e.previousPage = () => e.setPageIndex((r) => r - 1), e.nextPage = () => e.setPageIndex((r) => r + 1), e.firstPage = () => e.setPageIndex(0), e.lastPage = () => e.setPageIndex(e.getPageCount() - 1), e.getPrePaginationRowModel = () => e.getExpandedRowModel(), e.getPaginationRowModel = () => (!e._getPaginationRowModel && e.options.getPaginationRowModel && (e._getPaginationRowModel = e.options.getPaginationRowModel(e)), e.options.manualPagination || !e._getPaginationRowModel ? e.getPrePaginationRowModel() : e._getPaginationRowModel()), e.getPageCount = () => {\n      var r;\n      return (r = e.options.pageCount) != null ? r : Math.ceil(e.getRowCount() / e.getState().pagination.pageSize);\n    }, e.getRowCount = () => {\n      var r;\n      return (r = e.options.rowCount) != null ? r : e.getPrePaginationRowModel().rows.length;\n    };\n  }\n}, dc = () => ({\n  top: [],\n  bottom: []\n}), xU = {\n  getInitialState: (e) => ({\n    rowPinning: dc(),\n    ...e\n  }),\n  getDefaultOptions: (e) => ({\n    onRowPinningChange: Pt(\"rowPinning\", e)\n  }),\n  createRow: (e, t) => {\n    e.pin = (n, r, i) => {\n      const o = r ? e.getLeafRows().map((u) => {\n        let {\n          id: c\n        } = u;\n        return c;\n      }) : [], a = i ? e.getParentRows().map((u) => {\n        let {\n          id: c\n        } = u;\n        return c;\n      }) : [], s = /* @__PURE__ */ new Set([...a, e.id, ...o]);\n      t.setRowPinning((u) => {\n        var c, f;\n        if (n === \"bottom\") {\n          var l, d;\n          return {\n            top: ((l = u == null ? void 0 : u.top) != null ? l : []).filter((h) => !(s != null && s.has(h))),\n            bottom: [...((d = u == null ? void 0 : u.bottom) != null ? d : []).filter((h) => !(s != null && s.has(h))), ...Array.from(s)]\n          };\n        }\n        if (n === \"top\") {\n          var p, g;\n          return {\n            top: [...((p = u == null ? void 0 : u.top) != null ? p : []).filter((h) => !(s != null && s.has(h))), ...Array.from(s)],\n            bottom: ((g = u == null ? void 0 : u.bottom) != null ? g : []).filter((h) => !(s != null && s.has(h)))\n          };\n        }\n        return {\n          top: ((c = u == null ? void 0 : u.top) != null ? c : []).filter((h) => !(s != null && s.has(h))),\n          bottom: ((f = u == null ? void 0 : u.bottom) != null ? f : []).filter((h) => !(s != null && s.has(h)))\n        };\n      });\n    }, e.getCanPin = () => {\n      var n;\n      const {\n        enableRowPinning: r,\n        enablePinning: i\n      } = t.options;\n      return typeof r == \"function\" ? r(e) : (n = r ?? i) != null ? n : !0;\n    }, e.getIsPinned = () => {\n      const n = [e.id], {\n        top: r,\n        bottom: i\n      } = t.getState().rowPinning, o = n.some((s) => r == null ? void 0 : r.includes(s)), a = n.some((s) => i == null ? void 0 : i.includes(s));\n      return o ? \"top\" : a ? \"bottom\" : !1;\n    }, e.getPinnedIndex = () => {\n      var n, r;\n      const i = e.getIsPinned();\n      if (!i)\n        return -1;\n      const o = (n = t._getPinnedRows(i)) == null ? void 0 : n.map((a) => {\n        let {\n          id: s\n        } = a;\n        return s;\n      });\n      return (r = o == null ? void 0 : o.indexOf(e.id)) != null ? r : -1;\n    };\n  },\n  createTable: (e) => {\n    e.setRowPinning = (t) => e.options.onRowPinningChange == null ? void 0 : e.options.onRowPinningChange(t), e.resetRowPinning = (t) => {\n      var n, r;\n      return e.setRowPinning(t ? dc() : (n = (r = e.initialState) == null ? void 0 : r.rowPinning) != null ? n : dc());\n    }, e.getIsSomeRowsPinned = (t) => {\n      var n;\n      const r = e.getState().rowPinning;\n      if (!t) {\n        var i, o;\n        return !!((i = r.top) != null && i.length || (o = r.bottom) != null && o.length);\n      }\n      return !!((n = r[t]) != null && n.length);\n    }, e._getPinnedRows = oe((t) => [e.getRowModel().rows, e.getState().rowPinning[t], t], (t, n, r) => {\n      var i;\n      return ((i = e.options.keepPinnedRows) == null || i ? (\n        //get all rows that are pinned even if they would not be otherwise visible\n        //account for expanded parent rows, but not pagination or filtering\n        (n ?? []).map((a) => {\n          const s = e.getRow(a, !0);\n          return s.getIsAllParentsExpanded() ? s : null;\n        })\n      ) : (\n        //else get only visible rows that are pinned\n        (n ?? []).map((a) => t.find((s) => s.id === a))\n      )).filter(Boolean).map((a) => ({\n        ...a,\n        position: r\n      }));\n    }, ae(e.options, \"debugRows\", \"_getPinnedRows\")), e.getTopRows = () => e._getPinnedRows(\"top\"), e.getBottomRows = () => e._getPinnedRows(\"bottom\"), e.getCenterRows = oe(() => [e.getRowModel().rows, e.getState().rowPinning.top, e.getState().rowPinning.bottom], (t, n, r) => {\n      const i = /* @__PURE__ */ new Set([...n ?? [], ...r ?? []]);\n      return t.filter((o) => !i.has(o.id));\n    }, ae(e.options, \"debugRows\", \"getCenterRows\"));\n  }\n}, SU = {\n  getInitialState: (e) => ({\n    rowSelection: {},\n    ...e\n  }),\n  getDefaultOptions: (e) => ({\n    onRowSelectionChange: Pt(\"rowSelection\", e),\n    enableRowSelection: !0,\n    enableMultiRowSelection: !0,\n    enableSubRowSelection: !0\n    // enableGroupingRowSelection: false,\n    // isAdditiveSelectEvent: (e: unknown) => !!e.metaKey,\n    // isInclusiveSelectEvent: (e: unknown) => !!e.shiftKey,\n  }),\n  createTable: (e) => {\n    e.setRowSelection = (t) => e.options.onRowSelectionChange == null ? void 0 : e.options.onRowSelectionChange(t), e.resetRowSelection = (t) => {\n      var n;\n      return e.setRowSelection(t ? {} : (n = e.initialState.rowSelection) != null ? n : {});\n    }, e.toggleAllRowsSelected = (t) => {\n      e.setRowSelection((n) => {\n        t = typeof t < \"u\" ? t : !e.getIsAllRowsSelected();\n        const r = {\n          ...n\n        }, i = e.getPreGroupedRowModel().flatRows;\n        return t ? i.forEach((o) => {\n          o.getCanSelect() && (r[o.id] = !0);\n        }) : i.forEach((o) => {\n          delete r[o.id];\n        }), r;\n      });\n    }, e.toggleAllPageRowsSelected = (t) => e.setRowSelection((n) => {\n      const r = typeof t < \"u\" ? t : !e.getIsAllPageRowsSelected(), i = {\n        ...n\n      };\n      return e.getRowModel().rows.forEach((o) => {\n        Xl(i, o.id, r, !0, e);\n      }), i;\n    }), e.getPreSelectedRowModel = () => e.getCoreRowModel(), e.getSelectedRowModel = oe(() => [e.getState().rowSelection, e.getCoreRowModel()], (t, n) => Object.keys(t).length ? pc(e, n) : {\n      rows: [],\n      flatRows: [],\n      rowsById: {}\n    }, ae(e.options, \"debugTable\", \"getSelectedRowModel\")), e.getFilteredSelectedRowModel = oe(() => [e.getState().rowSelection, e.getFilteredRowModel()], (t, n) => Object.keys(t).length ? pc(e, n) : {\n      rows: [],\n      flatRows: [],\n      rowsById: {}\n    }, ae(e.options, \"debugTable\", \"getFilteredSelectedRowModel\")), e.getGroupedSelectedRowModel = oe(() => [e.getState().rowSelection, e.getSortedRowModel()], (t, n) => Object.keys(t).length ? pc(e, n) : {\n      rows: [],\n      flatRows: [],\n      rowsById: {}\n    }, ae(e.options, \"debugTable\", \"getGroupedSelectedRowModel\")), e.getIsAllRowsSelected = () => {\n      const t = e.getFilteredRowModel().flatRows, {\n        rowSelection: n\n      } = e.getState();\n      let r = !!(t.length && Object.keys(n).length);\n      return r && t.some((i) => i.getCanSelect() && !n[i.id]) && (r = !1), r;\n    }, e.getIsAllPageRowsSelected = () => {\n      const t = e.getPaginationRowModel().flatRows.filter((i) => i.getCanSelect()), {\n        rowSelection: n\n      } = e.getState();\n      let r = !!t.length;\n      return r && t.some((i) => !n[i.id]) && (r = !1), r;\n    }, e.getIsSomeRowsSelected = () => {\n      var t;\n      const n = Object.keys((t = e.getState().rowSelection) != null ? t : {}).length;\n      return n > 0 && n < e.getFilteredRowModel().flatRows.length;\n    }, e.getIsSomePageRowsSelected = () => {\n      const t = e.getPaginationRowModel().flatRows;\n      return e.getIsAllPageRowsSelected() ? !1 : t.filter((n) => n.getCanSelect()).some((n) => n.getIsSelected() || n.getIsSomeSelected());\n    }, e.getToggleAllRowsSelectedHandler = () => (t) => {\n      e.toggleAllRowsSelected(t.target.checked);\n    }, e.getToggleAllPageRowsSelectedHandler = () => (t) => {\n      e.toggleAllPageRowsSelected(t.target.checked);\n    };\n  },\n  createRow: (e, t) => {\n    e.toggleSelected = (n, r) => {\n      const i = e.getIsSelected();\n      t.setRowSelection((o) => {\n        var a;\n        if (n = typeof n < \"u\" ? n : !i, e.getCanSelect() && i === n)\n          return o;\n        const s = {\n          ...o\n        };\n        return Xl(s, e.id, n, (a = r == null ? void 0 : r.selectChildren) != null ? a : !0, t), s;\n      });\n    }, e.getIsSelected = () => {\n      const {\n        rowSelection: n\n      } = t.getState();\n      return Od(e, n);\n    }, e.getIsSomeSelected = () => {\n      const {\n        rowSelection: n\n      } = t.getState();\n      return Zl(e, n) === \"some\";\n    }, e.getIsAllSubRowsSelected = () => {\n      const {\n        rowSelection: n\n      } = t.getState();\n      return Zl(e, n) === \"all\";\n    }, e.getCanSelect = () => {\n      var n;\n      return typeof t.options.enableRowSelection == \"function\" ? t.options.enableRowSelection(e) : (n = t.options.enableRowSelection) != null ? n : !0;\n    }, e.getCanSelectSubRows = () => {\n      var n;\n      return typeof t.options.enableSubRowSelection == \"function\" ? t.options.enableSubRowSelection(e) : (n = t.options.enableSubRowSelection) != null ? n : !0;\n    }, e.getCanMultiSelect = () => {\n      var n;\n      return typeof t.options.enableMultiRowSelection == \"function\" ? t.options.enableMultiRowSelection(e) : (n = t.options.enableMultiRowSelection) != null ? n : !0;\n    }, e.getToggleSelectedHandler = () => {\n      const n = e.getCanSelect();\n      return (r) => {\n        var i;\n        n && e.toggleSelected((i = r.target) == null ? void 0 : i.checked);\n      };\n    };\n  }\n}, Xl = (e, t, n, r, i) => {\n  var o;\n  const a = i.getRow(t, !0);\n  n ? (a.getCanMultiSelect() || Object.keys(e).forEach((s) => delete e[s]), a.getCanSelect() && (e[t] = !0)) : delete e[t], r && (o = a.subRows) != null && o.length && a.getCanSelectSubRows() && a.subRows.forEach((s) => Xl(e, s.id, n, r, i));\n};\nfunction pc(e, t) {\n  const n = e.getState().rowSelection, r = [], i = {}, o = function(a, s) {\n    return a.map((u) => {\n      var c;\n      const f = Od(u, n);\n      if (f && (r.push(u), i[u.id] = u), (c = u.subRows) != null && c.length && (u = {\n        ...u,\n        subRows: o(u.subRows)\n      }), f)\n        return u;\n    }).filter(Boolean);\n  };\n  return {\n    rows: o(t.rows),\n    flatRows: r,\n    rowsById: i\n  };\n}\nfunction Od(e, t) {\n  var n;\n  return (n = t[e.id]) != null ? n : !1;\n}\nfunction Zl(e, t, n) {\n  var r;\n  if (!((r = e.subRows) != null && r.length))\n    return !1;\n  let i = !0, o = !1;\n  return e.subRows.forEach((a) => {\n    if (!(o && !i) && (a.getCanSelect() && (Od(a, t) ? o = !0 : i = !1), a.subRows && a.subRows.length)) {\n      const s = Zl(a, t);\n      s === \"all\" ? o = !0 : (s === \"some\" && (o = !0), i = !1);\n    }\n  }), i ? \"all\" : o ? \"some\" : !1;\n}\nconst Jl = /([0-9]+)/gm, $U = (e, t, n) => Xw(Gn(e.getValue(n)).toLowerCase(), Gn(t.getValue(n)).toLowerCase()), OU = (e, t, n) => Xw(Gn(e.getValue(n)), Gn(t.getValue(n))), _U = (e, t, n) => _d(Gn(e.getValue(n)).toLowerCase(), Gn(t.getValue(n)).toLowerCase()), AU = (e, t, n) => _d(Gn(e.getValue(n)), Gn(t.getValue(n))), PU = (e, t, n) => {\n  const r = e.getValue(n), i = t.getValue(n);\n  return r > i ? 1 : r < i ? -1 : 0;\n}, CU = (e, t, n) => _d(e.getValue(n), t.getValue(n));\nfunction _d(e, t) {\n  return e === t ? 0 : e > t ? 1 : -1;\n}\nfunction Gn(e) {\n  return typeof e == \"number\" ? isNaN(e) || e === 1 / 0 || e === -1 / 0 ? \"\" : String(e) : typeof e == \"string\" ? e : \"\";\n}\nfunction Xw(e, t) {\n  const n = e.split(Jl).filter(Boolean), r = t.split(Jl).filter(Boolean);\n  for (; n.length && r.length; ) {\n    const i = n.shift(), o = r.shift(), a = parseInt(i, 10), s = parseInt(o, 10), u = [a, s].sort();\n    if (isNaN(u[0])) {\n      if (i > o)\n        return 1;\n      if (o > i)\n        return -1;\n      continue;\n    }\n    if (isNaN(u[1]))\n      return isNaN(a) ? -1 : 1;\n    if (a > s)\n      return 1;\n    if (s > a)\n      return -1;\n  }\n  return n.length - r.length;\n}\nconst Bi = {\n  alphanumeric: $U,\n  alphanumericCaseSensitive: OU,\n  text: _U,\n  textCaseSensitive: AU,\n  datetime: PU,\n  basic: CU\n}, EU = {\n  getInitialState: (e) => ({\n    sorting: [],\n    ...e\n  }),\n  getDefaultColumnDef: () => ({\n    sortingFn: \"auto\",\n    sortUndefined: 1\n  }),\n  getDefaultOptions: (e) => ({\n    onSortingChange: Pt(\"sorting\", e),\n    isMultiSortEvent: (t) => t.shiftKey\n  }),\n  createColumn: (e, t) => {\n    e.getAutoSortingFn = () => {\n      const n = t.getFilteredRowModel().flatRows.slice(10);\n      let r = !1;\n      for (const i of n) {\n        const o = i == null ? void 0 : i.getValue(e.id);\n        if (Object.prototype.toString.call(o) === \"[object Date]\")\n          return Bi.datetime;\n        if (typeof o == \"string\" && (r = !0, o.split(Jl).length > 1))\n          return Bi.alphanumeric;\n      }\n      return r ? Bi.text : Bi.basic;\n    }, e.getAutoSortDir = () => {\n      const n = t.getFilteredRowModel().flatRows[0];\n      return typeof (n == null ? void 0 : n.getValue(e.id)) == \"string\" ? \"asc\" : \"desc\";\n    }, e.getSortingFn = () => {\n      var n, r;\n      if (!e)\n        throw new Error();\n      return lu(e.columnDef.sortingFn) ? e.columnDef.sortingFn : e.columnDef.sortingFn === \"auto\" ? e.getAutoSortingFn() : (n = (r = t.options.sortingFns) == null ? void 0 : r[e.columnDef.sortingFn]) != null ? n : Bi[e.columnDef.sortingFn];\n    }, e.toggleSorting = (n, r) => {\n      const i = e.getNextSortingOrder(), o = typeof n < \"u\" && n !== null;\n      t.setSorting((a) => {\n        const s = a == null ? void 0 : a.find((p) => p.id === e.id), u = a == null ? void 0 : a.findIndex((p) => p.id === e.id);\n        let c = [], f, l = o ? n : i === \"desc\";\n        if (a != null && a.length && e.getCanMultiSort() && r ? s ? f = \"toggle\" : f = \"add\" : a != null && a.length && u !== a.length - 1 ? f = \"replace\" : s ? f = \"toggle\" : f = \"replace\", f === \"toggle\" && (o || i || (f = \"remove\")), f === \"add\") {\n          var d;\n          c = [...a, {\n            id: e.id,\n            desc: l\n          }], c.splice(0, c.length - ((d = t.options.maxMultiSortColCount) != null ? d : Number.MAX_SAFE_INTEGER));\n        } else\n          f === \"toggle\" ? c = a.map((p) => p.id === e.id ? {\n            ...p,\n            desc: l\n          } : p) : f === \"remove\" ? c = a.filter((p) => p.id !== e.id) : c = [{\n            id: e.id,\n            desc: l\n          }];\n        return c;\n      });\n    }, e.getFirstSortDir = () => {\n      var n, r;\n      return ((n = (r = e.columnDef.sortDescFirst) != null ? r : t.options.sortDescFirst) != null ? n : e.getAutoSortDir() === \"desc\") ? \"desc\" : \"asc\";\n    }, e.getNextSortingOrder = (n) => {\n      var r, i;\n      const o = e.getFirstSortDir(), a = e.getIsSorted();\n      return a ? a !== o && ((r = t.options.enableSortingRemoval) == null || r) && // If enableSortRemove, enable in general\n      (!(n && (i = t.options.enableMultiRemove) != null) || i) ? !1 : a === \"desc\" ? \"asc\" : \"desc\" : o;\n    }, e.getCanSort = () => {\n      var n, r;\n      return ((n = e.columnDef.enableSorting) != null ? n : !0) && ((r = t.options.enableSorting) != null ? r : !0) && !!e.accessorFn;\n    }, e.getCanMultiSort = () => {\n      var n, r;\n      return (n = (r = e.columnDef.enableMultiSort) != null ? r : t.options.enableMultiSort) != null ? n : !!e.accessorFn;\n    }, e.getIsSorted = () => {\n      var n;\n      const r = (n = t.getState().sorting) == null ? void 0 : n.find((i) => i.id === e.id);\n      return r ? r.desc ? \"desc\" : \"asc\" : !1;\n    }, e.getSortIndex = () => {\n      var n, r;\n      return (n = (r = t.getState().sorting) == null ? void 0 : r.findIndex((i) => i.id === e.id)) != null ? n : -1;\n    }, e.clearSorting = () => {\n      t.setSorting((n) => n != null && n.length ? n.filter((r) => r.id !== e.id) : []);\n    }, e.getToggleSortingHandler = () => {\n      const n = e.getCanSort();\n      return (r) => {\n        n && (r.persist == null || r.persist(), e.toggleSorting == null || e.toggleSorting(void 0, e.getCanMultiSort() ? t.options.isMultiSortEvent == null ? void 0 : t.options.isMultiSortEvent(r) : !1));\n      };\n    };\n  },\n  createTable: (e) => {\n    e.setSorting = (t) => e.options.onSortingChange == null ? void 0 : e.options.onSortingChange(t), e.resetSorting = (t) => {\n      var n, r;\n      e.setSorting(t ? [] : (n = (r = e.initialState) == null ? void 0 : r.sorting) != null ? n : []);\n    }, e.getPreSortedRowModel = () => e.getGroupedRowModel(), e.getSortedRowModel = () => (!e._getSortedRowModel && e.options.getSortedRowModel && (e._getSortedRowModel = e.options.getSortedRowModel(e)), e.options.manualSorting || !e._getSortedRowModel ? e.getPreSortedRowModel() : e._getSortedRowModel());\n  }\n}, TU = [\n  JW,\n  vU,\n  dU,\n  pU,\n  QW,\n  eU,\n  mU,\n  //depends on ColumnFaceting\n  yU,\n  //depends on ColumnFiltering\n  EU,\n  lU,\n  //depends on RowSorting\n  bU,\n  wU,\n  xU,\n  SU,\n  hU\n];\nfunction MU(e) {\n  var t, n;\n   true && (e.debugAll || e.debugTable) && console.info(\"Creating Table Instance...\");\n  const r = [...TU, ...(t = e._features) != null ? t : []];\n  let i = {\n    _features: r\n  };\n  const o = i._features.reduce((d, p) => Object.assign(d, p.getDefaultOptions == null ? void 0 : p.getDefaultOptions(i)), {}), a = (d) => i.options.mergeOptions ? i.options.mergeOptions(o, d) : {\n    ...o,\n    ...d\n  };\n  let u = {\n    ...{},\n    ...(n = e.initialState) != null ? n : {}\n  };\n  i._features.forEach((d) => {\n    var p;\n    u = (p = d.getInitialState == null ? void 0 : d.getInitialState(u)) != null ? p : u;\n  });\n  const c = [];\n  let f = !1;\n  const l = {\n    _features: r,\n    options: {\n      ...o,\n      ...e\n    },\n    initialState: u,\n    _queue: (d) => {\n      c.push(d), f || (f = !0, Promise.resolve().then(() => {\n        for (; c.length; )\n          c.shift()();\n        f = !1;\n      }).catch((p) => setTimeout(() => {\n        throw p;\n      })));\n    },\n    reset: () => {\n      i.setState(i.initialState);\n    },\n    setOptions: (d) => {\n      const p = Nn(d, i.options);\n      i.options = a(p);\n    },\n    getState: () => i.options.state,\n    setState: (d) => {\n      i.options.onStateChange == null || i.options.onStateChange(d);\n    },\n    _getRowId: (d, p, g) => {\n      var h;\n      return (h = i.options.getRowId == null ? void 0 : i.options.getRowId(d, p, g)) != null ? h : `${g ? [g.id, p].join(\".\") : p}`;\n    },\n    getCoreRowModel: () => (i._getCoreRowModel || (i._getCoreRowModel = i.options.getCoreRowModel(i)), i._getCoreRowModel()),\n    // The final calls start at the bottom of the model,\n    // expanded rows, which then work their way up\n    getRowModel: () => i.getPaginationRowModel(),\n    //in next version, we should just pass in the row model as the optional 2nd arg\n    getRow: (d, p) => {\n      let g = (p ? i.getPrePaginationRowModel() : i.getRowModel()).rowsById[d];\n      if (!g && (g = i.getCoreRowModel().rowsById[d], !g))\n        throw  true ? new Error(`getRow could not find row with ID: ${d}`) : 0;\n      return g;\n    },\n    _getDefaultColumnDef: oe(() => [i.options.defaultColumn], (d) => {\n      var p;\n      return d = (p = d) != null ? p : {}, {\n        header: (g) => {\n          const h = g.header.column.columnDef;\n          return h.accessorKey ? h.accessorKey : h.accessorFn ? h.id : null;\n        },\n        // footer: props => props.header.column.id,\n        cell: (g) => {\n          var h, v;\n          return (h = (v = g.renderValue()) == null || v.toString == null ? void 0 : v.toString()) != null ? h : null;\n        },\n        ...i._features.reduce((g, h) => Object.assign(g, h.getDefaultColumnDef == null ? void 0 : h.getDefaultColumnDef()), {}),\n        ...d\n      };\n    }, ae(e, \"debugColumns\", \"_getDefaultColumnDef\")),\n    _getColumnDefs: () => i.options.columns,\n    getAllColumns: oe(() => [i._getColumnDefs()], (d) => {\n      const p = function(g, h, v) {\n        return v === void 0 && (v = 0), g.map((w) => {\n          const b = ZW(i, w, v, h), x = w;\n          return b.columns = x.columns ? p(x.columns, b, v + 1) : [], b;\n        });\n      };\n      return p(d);\n    }, ae(e, \"debugColumns\", \"getAllColumns\")),\n    getAllFlatColumns: oe(() => [i.getAllColumns()], (d) => d.flatMap((p) => p.getFlatColumns()), ae(e, \"debugColumns\", \"getAllFlatColumns\")),\n    _getAllFlatColumnsById: oe(() => [i.getAllFlatColumns()], (d) => d.reduce((p, g) => (p[g.id] = g, p), {}), ae(e, \"debugColumns\", \"getAllFlatColumnsById\")),\n    getAllLeafColumns: oe(() => [i.getAllColumns(), i._getOrderColumnsFn()], (d, p) => {\n      let g = d.flatMap((h) => h.getLeafColumns());\n      return p(g);\n    }, ae(e, \"debugColumns\", \"getAllLeafColumns\")),\n    getColumn: (d) => {\n      const p = i._getAllFlatColumnsById()[d];\n      return  true && !p && console.error(`[Table] Column with id '${d}' does not exist.`), p;\n    }\n  };\n  Object.assign(i, l);\n  for (let d = 0; d < i._features.length; d++) {\n    const p = i._features[d];\n    p == null || p.createTable == null || p.createTable(i);\n  }\n  return i;\n}\nfunction RU() {\n  return (e) => oe(() => [e.options.data], (t) => {\n    const n = {\n      rows: [],\n      flatRows: [],\n      rowsById: {}\n    }, r = function(i, o, a) {\n      o === void 0 && (o = 0);\n      const s = [];\n      for (let c = 0; c < i.length; c++) {\n        const f = Sd(e, e._getRowId(i[c], c, a), i[c], c, o, void 0, a == null ? void 0 : a.id);\n        if (n.flatRows.push(f), n.rowsById[f.id] = f, s.push(f), e.options.getSubRows) {\n          var u;\n          f.originalSubRows = e.options.getSubRows(i[c], c), (u = f.originalSubRows) != null && u.length && (f.subRows = r(f.originalSubRows, o + 1, f));\n        }\n      }\n      return s;\n    };\n    return n.rows = r(t), n;\n  }, ae(e.options, \"debugTable\", \"getRowModel\", () => e._autoResetPageIndex()));\n}\nfunction IU(e) {\n  const t = [], n = (r) => {\n    var i;\n    t.push(r), (i = r.subRows) != null && i.length && r.getIsExpanded() && r.subRows.forEach(n);\n  };\n  return e.rows.forEach(n), {\n    rows: t,\n    flatRows: e.flatRows,\n    rowsById: e.rowsById\n  };\n}\nfunction jU(e, t, n) {\n  return n.options.filterFromLeafRows ? kU(e, t, n) : DU(e, t, n);\n}\nfunction kU(e, t, n) {\n  var r;\n  const i = [], o = {}, a = (r = n.options.maxLeafRowFilterDepth) != null ? r : 100, s = function(u, c) {\n    c === void 0 && (c = 0);\n    const f = [];\n    for (let d = 0; d < u.length; d++) {\n      var l;\n      let p = u[d];\n      const g = Sd(n, p.id, p.original, p.index, p.depth, void 0, p.parentId);\n      if (g.columnFilters = p.columnFilters, (l = p.subRows) != null && l.length && c < a) {\n        if (g.subRows = s(p.subRows, c + 1), p = g, t(p) && !g.subRows.length) {\n          f.push(p), o[p.id] = p, i.push(p);\n          continue;\n        }\n        if (t(p) || g.subRows.length) {\n          f.push(p), o[p.id] = p, i.push(p);\n          continue;\n        }\n      } else\n        p = g, t(p) && (f.push(p), o[p.id] = p, i.push(p));\n    }\n    return f;\n  };\n  return {\n    rows: s(e),\n    flatRows: i,\n    rowsById: o\n  };\n}\nfunction DU(e, t, n) {\n  var r;\n  const i = [], o = {}, a = (r = n.options.maxLeafRowFilterDepth) != null ? r : 100, s = function(u, c) {\n    c === void 0 && (c = 0);\n    const f = [];\n    for (let d = 0; d < u.length; d++) {\n      let p = u[d];\n      if (t(p)) {\n        var l;\n        if ((l = p.subRows) != null && l.length && c < a) {\n          const h = Sd(n, p.id, p.original, p.index, p.depth, void 0, p.parentId);\n          h.subRows = s(p.subRows, c + 1), p = h;\n        }\n        f.push(p), i.push(p), o[p.id] = p;\n      }\n    }\n    return f;\n  };\n  return {\n    rows: s(e),\n    flatRows: i,\n    rowsById: o\n  };\n}\nfunction NU() {\n  return (e) => oe(() => [e.getPreFilteredRowModel(), e.getState().columnFilters, e.getState().globalFilter], (t, n, r) => {\n    if (!t.rows.length || !(n != null && n.length) && !r) {\n      for (let d = 0; d < t.flatRows.length; d++)\n        t.flatRows[d].columnFilters = {}, t.flatRows[d].columnFiltersMeta = {};\n      return t;\n    }\n    const i = [], o = [];\n    (n ?? []).forEach((d) => {\n      var p;\n      const g = e.getColumn(d.id);\n      if (!g)\n        return;\n      const h = g.getFilterFn();\n      if (!h) {\n         true && console.warn(`Could not find a valid 'column.filterFn' for column with the ID: ${g.id}.`);\n        return;\n      }\n      i.push({\n        id: d.id,\n        filterFn: h,\n        resolvedValue: (p = h.resolveFilterValue == null ? void 0 : h.resolveFilterValue(d.value)) != null ? p : d.value\n      });\n    });\n    const a = (n ?? []).map((d) => d.id), s = e.getGlobalFilterFn(), u = e.getAllLeafColumns().filter((d) => d.getCanGlobalFilter());\n    r && s && u.length && (a.push(\"__global__\"), u.forEach((d) => {\n      var p;\n      o.push({\n        id: d.id,\n        filterFn: s,\n        resolvedValue: (p = s.resolveFilterValue == null ? void 0 : s.resolveFilterValue(r)) != null ? p : r\n      });\n    }));\n    let c, f;\n    for (let d = 0; d < t.flatRows.length; d++) {\n      const p = t.flatRows[d];\n      if (p.columnFilters = {}, i.length)\n        for (let g = 0; g < i.length; g++) {\n          c = i[g];\n          const h = c.id;\n          p.columnFilters[h] = c.filterFn(p, h, c.resolvedValue, (v) => {\n            p.columnFiltersMeta[h] = v;\n          });\n        }\n      if (o.length) {\n        for (let g = 0; g < o.length; g++) {\n          f = o[g];\n          const h = f.id;\n          if (f.filterFn(p, h, f.resolvedValue, (v) => {\n            p.columnFiltersMeta[h] = v;\n          })) {\n            p.columnFilters.__global__ = !0;\n            break;\n          }\n        }\n        p.columnFilters.__global__ !== !0 && (p.columnFilters.__global__ = !1);\n      }\n    }\n    const l = (d) => {\n      for (let p = 0; p < a.length; p++)\n        if (d.columnFilters[a[p]] === !1)\n          return !1;\n      return !0;\n    };\n    return jU(t.rows, l, e);\n  }, ae(e.options, \"debugTable\", \"getFilteredRowModel\", () => e._autoResetPageIndex()));\n}\nfunction FU(e) {\n  return (t) => oe(() => [t.getState().pagination, t.getPrePaginationRowModel(), t.options.paginateExpandedRows ? void 0 : t.getState().expanded], (n, r) => {\n    if (!r.rows.length)\n      return r;\n    const {\n      pageSize: i,\n      pageIndex: o\n    } = n;\n    let {\n      rows: a,\n      flatRows: s,\n      rowsById: u\n    } = r;\n    const c = i * o, f = c + i;\n    a = a.slice(c, f);\n    let l;\n    t.options.paginateExpandedRows ? l = {\n      rows: a,\n      flatRows: s,\n      rowsById: u\n    } : l = IU({\n      rows: a,\n      flatRows: s,\n      rowsById: u\n    }), l.flatRows = [];\n    const d = (p) => {\n      l.flatRows.push(p), p.subRows.length && p.subRows.forEach(d);\n    };\n    return l.rows.forEach(d), l;\n  }, ae(t.options, \"debugTable\", \"getPaginationRowModel\"));\n}\nfunction LU() {\n  return (e) => oe(() => [e.getState().sorting, e.getPreSortedRowModel()], (t, n) => {\n    if (!n.rows.length || !(t != null && t.length))\n      return n;\n    const r = e.getState().sorting, i = [], o = r.filter((u) => {\n      var c;\n      return (c = e.getColumn(u.id)) == null ? void 0 : c.getCanSort();\n    }), a = {};\n    o.forEach((u) => {\n      const c = e.getColumn(u.id);\n      c && (a[u.id] = {\n        sortUndefined: c.columnDef.sortUndefined,\n        invertSorting: c.columnDef.invertSorting,\n        sortingFn: c.getSortingFn()\n      });\n    });\n    const s = (u) => {\n      const c = u.map((f) => ({\n        ...f\n      }));\n      return c.sort((f, l) => {\n        for (let p = 0; p < o.length; p += 1) {\n          var d;\n          const g = o[p], h = a[g.id], v = h.sortUndefined, w = (d = g == null ? void 0 : g.desc) != null ? d : !1;\n          let b = 0;\n          if (v) {\n            const x = f.getValue(g.id), m = l.getValue(g.id), y = x === void 0, S = m === void 0;\n            if (y || S) {\n              if (v === \"first\")\n                return y ? -1 : 1;\n              if (v === \"last\")\n                return y ? 1 : -1;\n              b = y && S ? 0 : y ? v : -v;\n            }\n          }\n          if (b === 0 && (b = h.sortingFn(f, l, g.id)), b !== 0)\n            return w && (b *= -1), h.invertSorting && (b *= -1), b;\n        }\n        return f.index - l.index;\n      }), c.forEach((f) => {\n        var l;\n        i.push(f), (l = f.subRows) != null && l.length && (f.subRows = s(f.subRows));\n      }), c;\n    };\n    return {\n      rows: s(n.rows),\n      flatRows: i,\n      rowsById: n.rowsById\n    };\n  }, ae(e.options, \"debugTable\", \"getSortedRowModel\", () => e._autoResetPageIndex()));\n}\n/**\n   * react-table\n   *\n   * Copyright (c) TanStack\n   *\n   * This source code is licensed under the MIT license found in the\n   * LICENSE.md file in the root directory of this source tree.\n   *\n   * @license MIT\n   */\nfunction sm(e, t) {\n  return e ? BU(e) ? /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(e, t) : e : null;\n}\nfunction BU(e) {\n  return zU(e) || typeof e == \"function\" || VU(e);\n}\nfunction zU(e) {\n  return typeof e == \"function\" && (() => {\n    const t = Object.getPrototypeOf(e);\n    return t.prototype && t.prototype.isReactComponent;\n  })();\n}\nfunction VU(e) {\n  return typeof e == \"object\" && typeof e.$$typeof == \"symbol\" && [\"react.memo\", \"react.forward_ref\"].includes(e.$$typeof.description);\n}\nfunction GU(e) {\n  const t = {\n    state: {},\n    // Dummy state\n    onStateChange: () => {\n    },\n    // noop\n    renderFallbackValue: null,\n    ...e\n  }, [n] = react__WEBPACK_IMPORTED_MODULE_0__.useState(() => ({\n    current: MU(t)\n  })), [r, i] = react__WEBPACK_IMPORTED_MODULE_0__.useState(() => n.current.initialState);\n  return n.current.setOptions((o) => ({\n    ...o,\n    ...e,\n    state: {\n      ...r,\n      ...e.state\n    },\n    // Similarly, we'll maintain both our internal state and any user-provided\n    // state.\n    onStateChange: (a) => {\n      i(a), e.onStateChange == null || e.onStateChange(a);\n    }\n  })), n.current;\n}\nconst Zw = react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(\n  ({ className: e, type: t, ...n }, r) => /* @__PURE__ */ X(\n    \"input\",\n    {\n      type: t,\n      className: Le(\n        \"flex h-10 w-full rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background file:border-0 file:bg-transparent file:text-sm file:font-medium placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50\",\n        e\n      ),\n      ref: r,\n      ...n\n    }\n  )\n);\nZw.displayName = \"Input\";\nconst Jw = react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(({ className: e, ...t }, n) => /* @__PURE__ */ X(\"div\", { className: \"relative w-full overflow-auto\", children: /* @__PURE__ */ X(\n  \"table\",\n  {\n    ref: n,\n    className: Le(\"w-full caption-bottom text-sm\", e),\n    ...t\n  }\n) }));\nJw.displayName = \"Table\";\nconst Qw = react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(({ className: e, ...t }, n) => /* @__PURE__ */ X(\"thead\", { ref: n, className: Le(\"[&_tr]:border-b\", e), ...t }));\nQw.displayName = \"TableHeader\";\nconst ex = react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(({ className: e, ...t }, n) => /* @__PURE__ */ X(\n  \"tbody\",\n  {\n    ref: n,\n    className: Le(\"[&_tr:last-child]:border-0\", e),\n    ...t\n  }\n));\nex.displayName = \"TableBody\";\nconst WU = react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(({ className: e, ...t }, n) => /* @__PURE__ */ X(\n  \"tfoot\",\n  {\n    ref: n,\n    className: Le(\n      \"border-t bg-muted/50 font-medium [&>tr]:last:border-b-0\",\n      e\n    ),\n    ...t\n  }\n));\nWU.displayName = \"TableFooter\";\nconst Ta = react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(({ className: e, ...t }, n) => /* @__PURE__ */ X(\n  \"tr\",\n  {\n    ref: n,\n    className: Le(\n      \"border-b transition-colors hover:bg-muted/50 data-[state=selected]:bg-muted\",\n      e\n    ),\n    ...t\n  }\n));\nTa.displayName = \"TableRow\";\nconst tx = react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(({ className: e, ...t }, n) => /* @__PURE__ */ X(\n  \"th\",\n  {\n    ref: n,\n    className: Le(\n      \"h-12 px-4 text-left align-middle font-medium text-muted-foreground [&:has([role=checkbox])]:pr-0\",\n      e\n    ),\n    ...t\n  }\n));\ntx.displayName = \"TableHead\";\nconst Ql = react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(({ className: e, ...t }, n) => /* @__PURE__ */ X(\n  \"td\",\n  {\n    ref: n,\n    className: Le(\"p-4 align-middle [&:has([role=checkbox])]:pr-0\", e),\n    ...t\n  }\n));\nQl.displayName = \"TableCell\";\nconst UU = react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(({ className: e, ...t }, n) => /* @__PURE__ */ X(\n  \"caption\",\n  {\n    ref: n,\n    className: Le(\"mt-4 text-sm text-muted-foreground\", e),\n    ...t\n  }\n));\nUU.displayName = \"TableCaption\";\nfunction nH({\n  inputPlaceHolder: e,\n  data: t,\n  columnToSearchData: n,\n  columns: r,\n  nextButtonPaginationText: i,\n  noResultText: o,\n  previousButtonPaginationText: a,\n  rowsSelectedText: s\n}) {\n  var w, b;\n  const [u, c] = react__WEBPACK_IMPORTED_MODULE_0__.useState([]), [f, l] = react__WEBPACK_IMPORTED_MODULE_0__.useState(\n    []\n  ), [d, p] = react__WEBPACK_IMPORTED_MODULE_0__.useState({}), [g, h] = react__WEBPACK_IMPORTED_MODULE_0__.useState({}), v = GU({\n    data: t,\n    columns: r,\n    onSortingChange: c,\n    onColumnFiltersChange: l,\n    getCoreRowModel: RU(),\n    getPaginationRowModel: FU(),\n    getSortedRowModel: LU(),\n    getFilteredRowModel: NU(),\n    onColumnVisibilityChange: p,\n    onRowSelectionChange: h,\n    state: {\n      sorting: u,\n      columnFilters: f,\n      columnVisibility: d,\n      rowSelection: g\n    }\n  });\n  return /* @__PURE__ */ ze(\"div\", { className: \"w-full\", children: [\n    /* @__PURE__ */ ze(\"div\", { className: \"flex items-center py-4\", children: [\n      /* @__PURE__ */ X(\n        Zw,\n        {\n          placeholder: e,\n          value: ((w = v.getColumn(n)) == null ? void 0 : w.getFilterValue()) ?? \"\",\n          onChange: (x) => {\n            var m;\n            return (m = v.getColumn(n)) == null ? void 0 : m.setFilterValue(x.target.value);\n          },\n          className: \"max-w-sm\"\n        }\n      ),\n      /* @__PURE__ */ ze(Ey, { children: [\n        /* @__PURE__ */ X(Ty, { asChild: !0, children: /* @__PURE__ */ ze(ar, { variant: \"outline\", className: \"ml-auto\", children: [\n          \"Columns \",\n          /* @__PURE__ */ X(h1, { className: \"ml-2 h-4 w-4\" })\n        ] }) }),\n        /* @__PURE__ */ X(gf, { align: \"end\", children: v.getAllColumns().filter((x) => x.getCanHide()).map((x) => /* @__PURE__ */ X(\n          My,\n          {\n            className: \"capitalize\",\n            checked: x.getIsVisible(),\n            onCheckedChange: (m) => x.toggleVisibility(!!m),\n            children: x.id\n          },\n          x.id\n        )) })\n      ] })\n    ] }),\n    /* @__PURE__ */ X(\"div\", { className: \"rounded-md border\", children: /* @__PURE__ */ ze(Jw, { children: [\n      /* @__PURE__ */ X(Qw, { children: v.getHeaderGroups().map((x) => /* @__PURE__ */ X(Ta, { children: x.headers.map((m) => /* @__PURE__ */ X(tx, { children: m.isPlaceholder ? null : sm(\n        m.column.columnDef.header,\n        m.getContext()\n      ) }, m.id)) }, x.id)) }),\n      /* @__PURE__ */ X(ex, { children: (b = v.getRowModel().rows) != null && b.length ? v.getRowModel().rows.map((x) => /* @__PURE__ */ X(\n        Ta,\n        {\n          \"data-state\": x.getIsSelected() && \"selected\",\n          children: x.getVisibleCells().map((m) => /* @__PURE__ */ X(Ql, { children: sm(\n            m.column.columnDef.cell,\n            m.getContext()\n          ) }, m.id))\n        },\n        x.id\n      )) : /* @__PURE__ */ X(Ta, { children: /* @__PURE__ */ X(\n        Ql,\n        {\n          colSpan: r.length,\n          className: \"h-24 text-center\",\n          children: o\n        }\n      ) }) })\n    ] }) }),\n    /* @__PURE__ */ ze(\"div\", { className: \"flex items-center justify-end space-x-2 py-4\", children: [\n      /* @__PURE__ */ ze(\"div\", { className: \"flex-1 text-sm text-muted-foreground\", children: [\n        v.getFilteredSelectedRowModel().rows.length,\n        \" of\",\n        \" \",\n        v.getFilteredRowModel().rows.length,\n        \" \",\n        s,\n        \".\"\n      ] }),\n      /* @__PURE__ */ ze(\"div\", { className: \"space-x-2\", children: [\n        /* @__PURE__ */ X(\n          ar,\n          {\n            variant: \"outline\",\n            size: \"sm\",\n            onClick: () => v.previousPage(),\n            disabled: !v.getCanPreviousPage(),\n            children: a\n          }\n        ),\n        /* @__PURE__ */ X(\n          ar,\n          {\n            variant: \"outline\",\n            size: \"sm\",\n            onClick: () => v.nextPage(),\n            disabled: !v.getCanNextPage(),\n            children: i\n          }\n        )\n      ] })\n    ] })\n  ] });\n}\n\n//# sourceMappingURL=hazley-ui.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9oYXpsZXktdWkvZGlzdC9oYXpsZXktdWkuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQTJCO0FBQ3NUO0FBQ2pUO0FBQ2dCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxhQUFhO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLGtDQUFDLDRMQUE0TDtBQUN2TTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLEtBQXFDO0FBQzdELFlBQVksa0NBQUM7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRkFBaUYsUUFBUTtBQUN6RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxhQUFhO0FBQ2Isc0JBQXNCO0FBQ3RCO0FBQ0EsYUFBYTtBQUNiLHNCQUFzQjtBQUN0QjtBQUNBLGFBQWE7QUFDYix1QkFBdUI7QUFDdkI7QUFDQSxhQUFhO0FBQ2IsdUJBQXVCO0FBQ3ZCO0FBQ0EsYUFBYTtBQUNiLGdDQUFnQztBQUNoQztBQUNBLGFBQWE7QUFDYiwwQkFBMEI7QUFDMUI7QUFDQSxhQUFhO0FBQ2IsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLDRDQUE0Qyx5Q0FBeUM7QUFDckY7QUFDQSxpQkFBaUIsb0JBQW9CO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQ7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrR0FBa0c7QUFDbEc7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxzR0FBc0c7QUFDdEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUc7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGlCQUFpQixJQUFJO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVELGtEQUFFO0FBQ3pELENBQUMsT0FBTyx3Q0FBTztBQUNmLENBQUM7QUFDRDtBQUNBO0FBQ0EsaUJBQWlCLDJDQUFVO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EseUJBQXlCLEVBQUU7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsSUFBSSw0QkFBNEI7QUFDaEMsa0JBQWtCLGNBQWM7QUFDaEM7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLHNIQUFzSDtBQUN0SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLGlCQUFpQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsbUJBQW1CO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLGlCQUFpQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNB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QUFDQTtBQUNBO0FBQ0E7QUFDQSx1RUFBdUU7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsU0FBUztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixLQUFLO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsU0FBUztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsU0FBUztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDO0FBQ0Q7QUFDQSwrREFBK0QsU0FBUztBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLG9CQUFvQjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGFBQWE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLEtBQXFDO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLE1BQXFDLEdBQUcsQ0FBaUI7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLENBQUM7QUFDRDtBQUNBLENBQUM7QUFDRDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLCtCQUErQixTQUFTLE9BQU87QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxVQUFVLGtDQUFrQztBQUM1QztBQUNBO0FBQ0EsVUFBVSxpQ0FBaUM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IscURBQUU7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0gsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFD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Q0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsT0FBTztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNB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QSxHQUFHO0FBQ0gsQ0FBQyxDQUFDLGdEQUFFO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsU0FBUztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsU0FBUztBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLFNBQVM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxTQUFTO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFLFNBQVM7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUU7QUFDRjtBQUNBLGlDQUFpQyxTQUFTO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLENBQUMsa0JBQWtCO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsS0FBSztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsU0FBUztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLEtBQUs7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLFNBQVM7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsS0FBSztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxTQUFTO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsbUJBQW1CO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLFNBQVM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELE9BQU87QUFDNUQsa0NBQWtDLGdCQUFnQjtBQUNsRDtBQUNBLGFBQWEsZ0JBQWdCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRkFBa0YsU0FBUztBQUMzRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhMQUE4TCxJQUFJLCtCQUErQixHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsa0NBQWtDLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxtQ0FBbUMsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxtQ0FBbUMsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxrQ0FBa0MsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLG1DQUFtQyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHO0FBQzFmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLGFBQWEsV0FBVyxFQUFFLFdBQVcsRUFBRSxXQUFXO0FBQ2xEO0FBQ0E7QUFDQSxhQUFhLFdBQVcsRUFBRSxXQUFXLEVBQUUsV0FBVyxFQUFFLG1EQUFtRDtBQUN2RztBQUNBO0FBQ0E7QUFDQSxZQUFZLDJCQUEyQixFQUFFLFdBQVcsSUFBSSxXQUFXLElBQUksV0FBVyxFQUFFLHFCQUFxQixFQUFFLEdBQUc7QUFDOUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLGNBQWMsMkJBQTJCLEVBQUUsV0FBVyxJQUFJLGlCQUFpQixLQUFLLGlCQUFpQixHQUFHLHFCQUFxQixFQUFFLEdBQUc7QUFDOUg7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsT0FBTztBQUNyQjtBQUNBLFNBQVMsT0FBTztBQUNoQjtBQUNBO0FBQ0EsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEIsaURBQWlELGtEQUFrRDtBQUNuRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0Isc0NBQXNDO0FBQ3JFLGtLQUFrSyxtQkFBbUI7QUFDckw7QUFDQSx1QkFBdUIsT0FBTztBQUM5QjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRFQUE0RSxPQUFPO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwRUFBMEUsU0FBUztBQUNuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQsd0hBQXdIO0FBQ25MO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLE9BQU87QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxTQUFTO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSw4REFBOEQsU0FBUztBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixzQkFBc0IsT0FBTztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLGVBQWUsUUFBUTtBQUN2QiwwQkFBMEIsUUFBUTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixTQUFTO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixTQUFTO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxhQUFhLGFBQWE7QUFDMUI7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLGVBQWUsVUFBVTtBQUN6QixpQkFBaUIsaUJBQWlCO0FBQ2xDO0FBQ0E7QUFDQSxlQUFlLFVBQVU7QUFDekIsaUJBQWlCLGdCQUFnQjtBQUNqQztBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVFQUF1RSxXQUFXO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RCxTQUFTO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxXQUFXLHlCQUF5QixvREFBb0Q7QUFDeEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNILHdCQUF3QixlQUFlO0FBQ3ZDLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyx3QkFBd0IsaUJBQWlCO0FBQzFDO0FBQ0E7QUFDQSxpQ0FBaUMsU0FBUztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixlQUFlLEVBQUU7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0IsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFLE9BQU87QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGFBQWE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUNBLENBQUM7QUFDRDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxPQUFPO0FBQ3pDO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQztBQUNEO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsQ0FB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QUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDO0FBQ0Q7QUFDQTtBQUNBLG9CQUFvQixzQkFBc0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGdEQUFlLFVBQVU7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixzQkFBc0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGdEQUFlLFVBQVU7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsT0FBTztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDLFNBQVM7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxPQUFPO0FBQzNEO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxPQUFPO0FBQy9DO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxrQkFBa0IsT0FBTztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsT0FBTztBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxPQUFPO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixjQUFjO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwRUFBMEUsY0FBYztBQUN4RjtBQUNBO0FBQ0EsMkRBQTJELDBEQUEwRDtBQUNySDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNM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QUNMO0FBQ0EsNkdBQTZHO0FBQzdHO0FBQ0Esa0JBQWtCLHdCQUF3QjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIO0FBQ0Esd0JBQXdCO0FBQ3hCLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHNCQUFzQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNB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LENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLENBQUM7QUFDRDtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxvREFBb0Q7QUFDMUYsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsNEVBQTRFO0FBQzVFO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFEO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsc0JBQXNCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FB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cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9oYXpsZXktdWkvZGlzdC9oYXpsZXktdWkuanM/ZWM0OSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBIIGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IFAsIHsgdXNlQ2FsbGJhY2sgYXMgdXQsIGZvcndhcmRSZWYgYXMgaGUsIENoaWxkcmVuIGFzICR0LCBpc1ZhbGlkRWxlbWVudCBhcyB2dCwgY3JlYXRlRWxlbWVudCBhcyBZLCBjbG9uZUVsZW1lbnQgYXMgR2UsIEZyYWdtZW50IGFzIHVtLCBjcmVhdGVDb250ZXh0IGFzIFp0LCB1c2VNZW1vIGFzIFhpLCB1c2VDb250ZXh0IGFzIE50LCB1c2VSZWYgYXMgX2UsIHVzZUVmZmVjdCBhcyBGZSwgdXNlU3RhdGUgYXMgWWUsIHVzZUxheW91dEVmZmVjdCBhcyBjbSwgdXNlUmVkdWNlciBhcyB3eCwgUHVyZUNvbXBvbmVudCBhcyBXbiwgQ29tcG9uZW50IGFzIGxtIH0gZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgKiBhcyB4eCBmcm9tIFwicmVhY3QtZG9tXCI7XG5pbXBvcnQgU3gsIHsgZmx1c2hTeW5jIGFzIGZtIH0gZnJvbSBcInJlYWN0LWRvbVwiO1xudmFyIHRhID0gdHlwZW9mIGdsb2JhbFRoaXMgPCBcInVcIiA/IGdsb2JhbFRoaXMgOiB0eXBlb2Ygd2luZG93IDwgXCJ1XCIgPyB3aW5kb3cgOiB0eXBlb2YgZ2xvYmFsIDwgXCJ1XCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiA8IFwidVwiID8gc2VsZiA6IHt9O1xuZnVuY3Rpb24gamUoZSkge1xuICByZXR1cm4gZSAmJiBlLl9fZXNNb2R1bGUgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGUsIFwiZGVmYXVsdFwiKSA/IGUuZGVmYXVsdCA6IGU7XG59XG52YXIgaGMgPSB7IGV4cG9ydHM6IHt9IH0sIEFpID0ge307XG4vKipcbiAqIEBsaWNlbnNlIFJlYWN0XG4gKiByZWFjdC1qc3gtcnVudGltZS5wcm9kdWN0aW9uLm1pbi5qc1xuICpcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG52YXIga2Q7XG5mdW5jdGlvbiAkeCgpIHtcbiAgaWYgKGtkKVxuICAgIHJldHVybiBBaTtcbiAga2QgPSAxO1xuICB2YXIgZSA9IFAsIHQgPSBTeW1ib2wuZm9yKFwicmVhY3QuZWxlbWVudFwiKSwgbiA9IFN5bWJvbC5mb3IoXCJyZWFjdC5mcmFnbWVudFwiKSwgciA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHksIGkgPSBlLl9fU0VDUkVUX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVELlJlYWN0Q3VycmVudE93bmVyLCBvID0geyBrZXk6ICEwLCByZWY6ICEwLCBfX3NlbGY6ICEwLCBfX3NvdXJjZTogITAgfTtcbiAgZnVuY3Rpb24gYShzLCB1LCBjKSB7XG4gICAgdmFyIGYsIGwgPSB7fSwgZCA9IG51bGwsIHAgPSBudWxsO1xuICAgIGMgIT09IHZvaWQgMCAmJiAoZCA9IFwiXCIgKyBjKSwgdS5rZXkgIT09IHZvaWQgMCAmJiAoZCA9IFwiXCIgKyB1LmtleSksIHUucmVmICE9PSB2b2lkIDAgJiYgKHAgPSB1LnJlZik7XG4gICAgZm9yIChmIGluIHUpXG4gICAgICByLmNhbGwodSwgZikgJiYgIW8uaGFzT3duUHJvcGVydHkoZikgJiYgKGxbZl0gPSB1W2ZdKTtcbiAgICBpZiAocyAmJiBzLmRlZmF1bHRQcm9wcylcbiAgICAgIGZvciAoZiBpbiB1ID0gcy5kZWZhdWx0UHJvcHMsIHUpXG4gICAgICAgIGxbZl0gPT09IHZvaWQgMCAmJiAobFtmXSA9IHVbZl0pO1xuICAgIHJldHVybiB7ICQkdHlwZW9mOiB0LCB0eXBlOiBzLCBrZXk6IGQsIHJlZjogcCwgcHJvcHM6IGwsIF9vd25lcjogaS5jdXJyZW50IH07XG4gIH1cbiAgcmV0dXJuIEFpLkZyYWdtZW50ID0gbiwgQWkuanN4ID0gYSwgQWkuanN4cyA9IGEsIEFpO1xufVxudmFyIFBpID0ge307XG4vKipcbiAqIEBsaWNlbnNlIFJlYWN0XG4gKiByZWFjdC1qc3gtcnVudGltZS5kZXZlbG9wbWVudC5qc1xuICpcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG52YXIgRGQ7XG5mdW5jdGlvbiBPeCgpIHtcbiAgcmV0dXJuIERkIHx8IChEZCA9IDEsIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiBmdW5jdGlvbigpIHtcbiAgICB2YXIgZSA9IFAsIHQgPSBTeW1ib2wuZm9yKFwicmVhY3QuZWxlbWVudFwiKSwgbiA9IFN5bWJvbC5mb3IoXCJyZWFjdC5wb3J0YWxcIiksIHIgPSBTeW1ib2wuZm9yKFwicmVhY3QuZnJhZ21lbnRcIiksIGkgPSBTeW1ib2wuZm9yKFwicmVhY3Quc3RyaWN0X21vZGVcIiksIG8gPSBTeW1ib2wuZm9yKFwicmVhY3QucHJvZmlsZXJcIiksIGEgPSBTeW1ib2wuZm9yKFwicmVhY3QucHJvdmlkZXJcIiksIHMgPSBTeW1ib2wuZm9yKFwicmVhY3QuY29udGV4dFwiKSwgdSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5mb3J3YXJkX3JlZlwiKSwgYyA9IFN5bWJvbC5mb3IoXCJyZWFjdC5zdXNwZW5zZVwiKSwgZiA9IFN5bWJvbC5mb3IoXCJyZWFjdC5zdXNwZW5zZV9saXN0XCIpLCBsID0gU3ltYm9sLmZvcihcInJlYWN0Lm1lbW9cIiksIGQgPSBTeW1ib2wuZm9yKFwicmVhY3QubGF6eVwiKSwgcCA9IFN5bWJvbC5mb3IoXCJyZWFjdC5vZmZzY3JlZW5cIiksIGcgPSBTeW1ib2wuaXRlcmF0b3IsIGggPSBcIkBAaXRlcmF0b3JcIjtcbiAgICBmdW5jdGlvbiB2KF8pIHtcbiAgICAgIGlmIChfID09PSBudWxsIHx8IHR5cGVvZiBfICE9IFwib2JqZWN0XCIpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgdmFyIFcgPSBnICYmIF9bZ10gfHwgX1toXTtcbiAgICAgIHJldHVybiB0eXBlb2YgVyA9PSBcImZ1bmN0aW9uXCIgPyBXIDogbnVsbDtcbiAgICB9XG4gICAgdmFyIHcgPSBlLl9fU0VDUkVUX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVEO1xuICAgIGZ1bmN0aW9uIGIoXykge1xuICAgICAge1xuICAgICAgICBmb3IgKHZhciBXID0gYXJndW1lbnRzLmxlbmd0aCwgWiA9IG5ldyBBcnJheShXID4gMSA/IFcgLSAxIDogMCksIHVlID0gMTsgdWUgPCBXOyB1ZSsrKVxuICAgICAgICAgIFpbdWUgLSAxXSA9IGFyZ3VtZW50c1t1ZV07XG4gICAgICAgIHgoXCJlcnJvclwiLCBfLCBaKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24geChfLCBXLCBaKSB7XG4gICAgICB7XG4gICAgICAgIHZhciB1ZSA9IHcuUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSwgQWUgPSB1ZS5nZXRTdGFja0FkZGVuZHVtKCk7XG4gICAgICAgIEFlICE9PSBcIlwiICYmIChXICs9IFwiJXNcIiwgWiA9IFouY29uY2F0KFtBZV0pKTtcbiAgICAgICAgdmFyIE1lID0gWi5tYXAoZnVuY3Rpb24oYmUpIHtcbiAgICAgICAgICByZXR1cm4gU3RyaW5nKGJlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIE1lLnVuc2hpZnQoXCJXYXJuaW5nOiBcIiArIFcpLCBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkuY2FsbChjb25zb2xlW19dLCBjb25zb2xlLCBNZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHZhciBtID0gITEsIHkgPSAhMSwgUyA9ICExLCAkID0gITEsIE8gPSAhMSwgVDtcbiAgICBUID0gU3ltYm9sLmZvcihcInJlYWN0Lm1vZHVsZS5yZWZlcmVuY2VcIik7XG4gICAgZnVuY3Rpb24gTShfKSB7XG4gICAgICByZXR1cm4gISEodHlwZW9mIF8gPT0gXCJzdHJpbmdcIiB8fCB0eXBlb2YgXyA9PSBcImZ1bmN0aW9uXCIgfHwgXyA9PT0gciB8fCBfID09PSBvIHx8IE8gfHwgXyA9PT0gaSB8fCBfID09PSBjIHx8IF8gPT09IGYgfHwgJCB8fCBfID09PSBwIHx8IG0gfHwgeSB8fCBTIHx8IHR5cGVvZiBfID09IFwib2JqZWN0XCIgJiYgXyAhPT0gbnVsbCAmJiAoXy4kJHR5cGVvZiA9PT0gZCB8fCBfLiQkdHlwZW9mID09PSBsIHx8IF8uJCR0eXBlb2YgPT09IGEgfHwgXy4kJHR5cGVvZiA9PT0gcyB8fCBfLiQkdHlwZW9mID09PSB1IHx8IC8vIFRoaXMgbmVlZHMgdG8gaW5jbHVkZSBhbGwgcG9zc2libGUgbW9kdWxlIHJlZmVyZW5jZSBvYmplY3RcbiAgICAgIC8vIHR5cGVzIHN1cHBvcnRlZCBieSBhbnkgRmxpZ2h0IGNvbmZpZ3VyYXRpb24gYW55d2hlcmUgc2luY2VcbiAgICAgIC8vIHdlIGRvbid0IGtub3cgd2hpY2ggRmxpZ2h0IGJ1aWxkIHRoaXMgd2lsbCBlbmQgdXAgYmVpbmcgdXNlZFxuICAgICAgLy8gd2l0aC5cbiAgICAgIF8uJCR0eXBlb2YgPT09IFQgfHwgXy5nZXRNb2R1bGVJZCAhPT0gdm9pZCAwKSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIEUoXywgVywgWikge1xuICAgICAgdmFyIHVlID0gXy5kaXNwbGF5TmFtZTtcbiAgICAgIGlmICh1ZSlcbiAgICAgICAgcmV0dXJuIHVlO1xuICAgICAgdmFyIEFlID0gVy5kaXNwbGF5TmFtZSB8fCBXLm5hbWUgfHwgXCJcIjtcbiAgICAgIHJldHVybiBBZSAhPT0gXCJcIiA/IFogKyBcIihcIiArIEFlICsgXCIpXCIgOiBaO1xuICAgIH1cbiAgICBmdW5jdGlvbiBBKF8pIHtcbiAgICAgIHJldHVybiBfLmRpc3BsYXlOYW1lIHx8IFwiQ29udGV4dFwiO1xuICAgIH1cbiAgICBmdW5jdGlvbiBqKF8pIHtcbiAgICAgIGlmIChfID09IG51bGwpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgaWYgKHR5cGVvZiBfLnRhZyA9PSBcIm51bWJlclwiICYmIGIoXCJSZWNlaXZlZCBhbiB1bmV4cGVjdGVkIG9iamVjdCBpbiBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoKS4gVGhpcyBpcyBsaWtlbHkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiKSwgdHlwZW9mIF8gPT0gXCJmdW5jdGlvblwiKVxuICAgICAgICByZXR1cm4gXy5kaXNwbGF5TmFtZSB8fCBfLm5hbWUgfHwgbnVsbDtcbiAgICAgIGlmICh0eXBlb2YgXyA9PSBcInN0cmluZ1wiKVxuICAgICAgICByZXR1cm4gXztcbiAgICAgIHN3aXRjaCAoXykge1xuICAgICAgICBjYXNlIHI6XG4gICAgICAgICAgcmV0dXJuIFwiRnJhZ21lbnRcIjtcbiAgICAgICAgY2FzZSBuOlxuICAgICAgICAgIHJldHVybiBcIlBvcnRhbFwiO1xuICAgICAgICBjYXNlIG86XG4gICAgICAgICAgcmV0dXJuIFwiUHJvZmlsZXJcIjtcbiAgICAgICAgY2FzZSBpOlxuICAgICAgICAgIHJldHVybiBcIlN0cmljdE1vZGVcIjtcbiAgICAgICAgY2FzZSBjOlxuICAgICAgICAgIHJldHVybiBcIlN1c3BlbnNlXCI7XG4gICAgICAgIGNhc2UgZjpcbiAgICAgICAgICByZXR1cm4gXCJTdXNwZW5zZUxpc3RcIjtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgXyA9PSBcIm9iamVjdFwiKVxuICAgICAgICBzd2l0Y2ggKF8uJCR0eXBlb2YpIHtcbiAgICAgICAgICBjYXNlIHM6XG4gICAgICAgICAgICB2YXIgVyA9IF87XG4gICAgICAgICAgICByZXR1cm4gQShXKSArIFwiLkNvbnN1bWVyXCI7XG4gICAgICAgICAgY2FzZSBhOlxuICAgICAgICAgICAgdmFyIFogPSBfO1xuICAgICAgICAgICAgcmV0dXJuIEEoWi5fY29udGV4dCkgKyBcIi5Qcm92aWRlclwiO1xuICAgICAgICAgIGNhc2UgdTpcbiAgICAgICAgICAgIHJldHVybiBFKF8sIF8ucmVuZGVyLCBcIkZvcndhcmRSZWZcIik7XG4gICAgICAgICAgY2FzZSBsOlxuICAgICAgICAgICAgdmFyIHVlID0gXy5kaXNwbGF5TmFtZSB8fCBudWxsO1xuICAgICAgICAgICAgcmV0dXJuIHVlICE9PSBudWxsID8gdWUgOiBqKF8udHlwZSkgfHwgXCJNZW1vXCI7XG4gICAgICAgICAgY2FzZSBkOiB7XG4gICAgICAgICAgICB2YXIgQWUgPSBfLCBNZSA9IEFlLl9wYXlsb2FkLCBiZSA9IEFlLl9pbml0O1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgcmV0dXJuIGooYmUoTWUpKTtcbiAgICAgICAgICAgIH0gY2F0Y2gge1xuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB2YXIgUiA9IE9iamVjdC5hc3NpZ24sIE4gPSAwLCBrLCBGLCBWLCBMLCBJLCBELCBHO1xuICAgIGZ1bmN0aW9uIHEoKSB7XG4gICAgfVxuICAgIHEuX19yZWFjdERpc2FibGVkTG9nID0gITA7XG4gICAgZnVuY3Rpb24gSigpIHtcbiAgICAgIHtcbiAgICAgICAgaWYgKE4gPT09IDApIHtcbiAgICAgICAgICBrID0gY29uc29sZS5sb2csIEYgPSBjb25zb2xlLmluZm8sIFYgPSBjb25zb2xlLndhcm4sIEwgPSBjb25zb2xlLmVycm9yLCBJID0gY29uc29sZS5ncm91cCwgRCA9IGNvbnNvbGUuZ3JvdXBDb2xsYXBzZWQsIEcgPSBjb25zb2xlLmdyb3VwRW5kO1xuICAgICAgICAgIHZhciBfID0ge1xuICAgICAgICAgICAgY29uZmlndXJhYmxlOiAhMCxcbiAgICAgICAgICAgIGVudW1lcmFibGU6ICEwLFxuICAgICAgICAgICAgdmFsdWU6IHEsXG4gICAgICAgICAgICB3cml0YWJsZTogITBcbiAgICAgICAgICB9O1xuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGNvbnNvbGUsIHtcbiAgICAgICAgICAgIGluZm86IF8sXG4gICAgICAgICAgICBsb2c6IF8sXG4gICAgICAgICAgICB3YXJuOiBfLFxuICAgICAgICAgICAgZXJyb3I6IF8sXG4gICAgICAgICAgICBncm91cDogXyxcbiAgICAgICAgICAgIGdyb3VwQ29sbGFwc2VkOiBfLFxuICAgICAgICAgICAgZ3JvdXBFbmQ6IF9cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBOKys7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIG5lKCkge1xuICAgICAge1xuICAgICAgICBpZiAoTi0tLCBOID09PSAwKSB7XG4gICAgICAgICAgdmFyIF8gPSB7XG4gICAgICAgICAgICBjb25maWd1cmFibGU6ICEwLFxuICAgICAgICAgICAgZW51bWVyYWJsZTogITAsXG4gICAgICAgICAgICB3cml0YWJsZTogITBcbiAgICAgICAgICB9O1xuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGNvbnNvbGUsIHtcbiAgICAgICAgICAgIGxvZzogUih7fSwgXywge1xuICAgICAgICAgICAgICB2YWx1ZToga1xuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBpbmZvOiBSKHt9LCBfLCB7XG4gICAgICAgICAgICAgIHZhbHVlOiBGXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIHdhcm46IFIoe30sIF8sIHtcbiAgICAgICAgICAgICAgdmFsdWU6IFZcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgZXJyb3I6IFIoe30sIF8sIHtcbiAgICAgICAgICAgICAgdmFsdWU6IExcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgZ3JvdXA6IFIoe30sIF8sIHtcbiAgICAgICAgICAgICAgdmFsdWU6IElcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgZ3JvdXBDb2xsYXBzZWQ6IFIoe30sIF8sIHtcbiAgICAgICAgICAgICAgdmFsdWU6IERcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgZ3JvdXBFbmQ6IFIoe30sIF8sIHtcbiAgICAgICAgICAgICAgdmFsdWU6IEdcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgTiA8IDAgJiYgYihcImRpc2FibGVkRGVwdGggZmVsbCBiZWxvdyB6ZXJvLiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS5cIik7XG4gICAgICB9XG4gICAgfVxuICAgIHZhciB0ZSA9IHcuUmVhY3RDdXJyZW50RGlzcGF0Y2hlciwgZWU7XG4gICAgZnVuY3Rpb24gaWUoXywgVywgWikge1xuICAgICAge1xuICAgICAgICBpZiAoZWUgPT09IHZvaWQgMClcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgICAgICB9IGNhdGNoIChBZSkge1xuICAgICAgICAgICAgdmFyIHVlID0gQWUuc3RhY2sudHJpbSgpLm1hdGNoKC9cXG4oICooYXQgKT8pLyk7XG4gICAgICAgICAgICBlZSA9IHVlICYmIHVlWzFdIHx8IFwiXCI7XG4gICAgICAgICAgfVxuICAgICAgICByZXR1cm4gYFxuYCArIGVlICsgXztcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIEIgPSAhMSwgVTtcbiAgICB7XG4gICAgICB2YXIgcmUgPSB0eXBlb2YgV2Vha01hcCA9PSBcImZ1bmN0aW9uXCIgPyBXZWFrTWFwIDogTWFwO1xuICAgICAgVSA9IG5ldyByZSgpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBDKF8sIFcpIHtcbiAgICAgIGlmICghXyB8fCBCKVxuICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgIHtcbiAgICAgICAgdmFyIFogPSBVLmdldChfKTtcbiAgICAgICAgaWYgKFogIT09IHZvaWQgMClcbiAgICAgICAgICByZXR1cm4gWjtcbiAgICAgIH1cbiAgICAgIHZhciB1ZTtcbiAgICAgIEIgPSAhMDtcbiAgICAgIHZhciBBZSA9IEVycm9yLnByZXBhcmVTdGFja1RyYWNlO1xuICAgICAgRXJyb3IucHJlcGFyZVN0YWNrVHJhY2UgPSB2b2lkIDA7XG4gICAgICB2YXIgTWU7XG4gICAgICBNZSA9IHRlLmN1cnJlbnQsIHRlLmN1cnJlbnQgPSBudWxsLCBKKCk7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAoVykge1xuICAgICAgICAgIHZhciBiZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIGlmIChPYmplY3QuZGVmaW5lUHJvcGVydHkoYmUucHJvdG90eXBlLCBcInByb3BzXCIsIHtcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSksIHR5cGVvZiBSZWZsZWN0ID09IFwib2JqZWN0XCIgJiYgUmVmbGVjdC5jb25zdHJ1Y3QpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIFJlZmxlY3QuY29uc3RydWN0KGJlLCBbXSk7XG4gICAgICAgICAgICB9IGNhdGNoIChwdCkge1xuICAgICAgICAgICAgICB1ZSA9IHB0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgUmVmbGVjdC5jb25zdHJ1Y3QoXywgW10sIGJlKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgYmUuY2FsbCgpO1xuICAgICAgICAgICAgfSBjYXRjaCAocHQpIHtcbiAgICAgICAgICAgICAgdWUgPSBwdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF8uY2FsbChiZS5wcm90b3R5cGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgICAgICB9IGNhdGNoIChwdCkge1xuICAgICAgICAgICAgdWUgPSBwdDtcbiAgICAgICAgICB9XG4gICAgICAgICAgXygpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChwdCkge1xuICAgICAgICBpZiAocHQgJiYgdWUgJiYgdHlwZW9mIHB0LnN0YWNrID09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICBmb3IgKHZhciB2ZSA9IHB0LnN0YWNrLnNwbGl0KGBcbmApLCBjdCA9IHVlLnN0YWNrLnNwbGl0KGBcbmApLCBWZSA9IHZlLmxlbmd0aCAtIDEsIFVlID0gY3QubGVuZ3RoIC0gMTsgVmUgPj0gMSAmJiBVZSA+PSAwICYmIHZlW1ZlXSAhPT0gY3RbVWVdOyApXG4gICAgICAgICAgICBVZS0tO1xuICAgICAgICAgIGZvciAoOyBWZSA+PSAxICYmIFVlID49IDA7IFZlLS0sIFVlLS0pXG4gICAgICAgICAgICBpZiAodmVbVmVdICE9PSBjdFtVZV0pIHtcbiAgICAgICAgICAgICAgaWYgKFZlICE9PSAxIHx8IFVlICE9PSAxKVxuICAgICAgICAgICAgICAgIGRvXG4gICAgICAgICAgICAgICAgICBpZiAoVmUtLSwgVWUtLSwgVWUgPCAwIHx8IHZlW1ZlXSAhPT0gY3RbVWVdKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBDdCA9IGBcbmAgKyB2ZVtWZV0ucmVwbGFjZShcIiBhdCBuZXcgXCIsIFwiIGF0IFwiKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF8uZGlzcGxheU5hbWUgJiYgQ3QuaW5jbHVkZXMoXCI8YW5vbnltb3VzPlwiKSAmJiAoQ3QgPSBDdC5yZXBsYWNlKFwiPGFub255bW91cz5cIiwgXy5kaXNwbGF5TmFtZSkpLCB0eXBlb2YgXyA9PSBcImZ1bmN0aW9uXCIgJiYgVS5zZXQoXywgQ3QpLCBDdDtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB3aGlsZSAoVmUgPj0gMSAmJiBVZSA+PSAwKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIEIgPSAhMSwgdGUuY3VycmVudCA9IE1lLCBuZSgpLCBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZSA9IEFlO1xuICAgICAgfVxuICAgICAgdmFyIHdyID0gXyA/IF8uZGlzcGxheU5hbWUgfHwgXy5uYW1lIDogXCJcIiwgWm4gPSB3ciA/IGllKHdyKSA6IFwiXCI7XG4gICAgICByZXR1cm4gdHlwZW9mIF8gPT0gXCJmdW5jdGlvblwiICYmIFUuc2V0KF8sIFpuKSwgWm47XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdlKF8sIFcsIFopIHtcbiAgICAgIHJldHVybiBDKF8sICExKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gbGUoXykge1xuICAgICAgdmFyIFcgPSBfLnByb3RvdHlwZTtcbiAgICAgIHJldHVybiAhIShXICYmIFcuaXNSZWFjdENvbXBvbmVudCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHhlKF8sIFcsIFopIHtcbiAgICAgIGlmIChfID09IG51bGwpXG4gICAgICAgIHJldHVybiBcIlwiO1xuICAgICAgaWYgKHR5cGVvZiBfID09IFwiZnVuY3Rpb25cIilcbiAgICAgICAgcmV0dXJuIEMoXywgbGUoXykpO1xuICAgICAgaWYgKHR5cGVvZiBfID09IFwic3RyaW5nXCIpXG4gICAgICAgIHJldHVybiBpZShfKTtcbiAgICAgIHN3aXRjaCAoXykge1xuICAgICAgICBjYXNlIGM6XG4gICAgICAgICAgcmV0dXJuIGllKFwiU3VzcGVuc2VcIik7XG4gICAgICAgIGNhc2UgZjpcbiAgICAgICAgICByZXR1cm4gaWUoXCJTdXNwZW5zZUxpc3RcIik7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIF8gPT0gXCJvYmplY3RcIilcbiAgICAgICAgc3dpdGNoIChfLiQkdHlwZW9mKSB7XG4gICAgICAgICAgY2FzZSB1OlxuICAgICAgICAgICAgcmV0dXJuIGdlKF8ucmVuZGVyKTtcbiAgICAgICAgICBjYXNlIGw6XG4gICAgICAgICAgICByZXR1cm4geGUoXy50eXBlLCBXLCBaKTtcbiAgICAgICAgICBjYXNlIGQ6IHtcbiAgICAgICAgICAgIHZhciB1ZSA9IF8sIEFlID0gdWUuX3BheWxvYWQsIE1lID0gdWUuX2luaXQ7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICByZXR1cm4geGUoTWUoQWUpLCBXLCBaKTtcbiAgICAgICAgICAgIH0gY2F0Y2gge1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgcmV0dXJuIFwiXCI7XG4gICAgfVxuICAgIHZhciBFZSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHksIFplID0ge30sIGR0ID0gdy5SZWFjdERlYnVnQ3VycmVudEZyYW1lO1xuICAgIGZ1bmN0aW9uIHp0KF8pIHtcbiAgICAgIGlmIChfKSB7XG4gICAgICAgIHZhciBXID0gXy5fb3duZXIsIFogPSB4ZShfLnR5cGUsIF8uX3NvdXJjZSwgVyA/IFcudHlwZSA6IG51bGwpO1xuICAgICAgICBkdC5zZXRFeHRyYVN0YWNrRnJhbWUoWik7XG4gICAgICB9IGVsc2VcbiAgICAgICAgZHQuc2V0RXh0cmFTdGFja0ZyYW1lKG51bGwpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBWdChfLCBXLCBaLCB1ZSwgQWUpIHtcbiAgICAgIHtcbiAgICAgICAgdmFyIE1lID0gRnVuY3Rpb24uY2FsbC5iaW5kKEVlKTtcbiAgICAgICAgZm9yICh2YXIgYmUgaW4gXylcbiAgICAgICAgICBpZiAoTWUoXywgYmUpKSB7XG4gICAgICAgICAgICB2YXIgdmUgPSB2b2lkIDA7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBpZiAodHlwZW9mIF9bYmVdICE9IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgIHZhciBjdCA9IEVycm9yKCh1ZSB8fCBcIlJlYWN0IGNsYXNzXCIpICsgXCI6IFwiICsgWiArIFwiIHR5cGUgYFwiICsgYmUgKyBcImAgaXMgaW52YWxpZDsgaXQgbXVzdCBiZSBhIGZ1bmN0aW9uLCB1c3VhbGx5IGZyb20gdGhlIGBwcm9wLXR5cGVzYCBwYWNrYWdlLCBidXQgcmVjZWl2ZWQgYFwiICsgdHlwZW9mIF9bYmVdICsgXCJgLlRoaXMgb2Z0ZW4gaGFwcGVucyBiZWNhdXNlIG9mIHR5cG9zIHN1Y2ggYXMgYFByb3BUeXBlcy5mdW5jdGlvbmAgaW5zdGVhZCBvZiBgUHJvcFR5cGVzLmZ1bmNgLlwiKTtcbiAgICAgICAgICAgICAgICB0aHJvdyBjdC5uYW1lID0gXCJJbnZhcmlhbnQgVmlvbGF0aW9uXCIsIGN0O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHZlID0gX1tiZV0oVywgYmUsIHVlLCBaLCBudWxsLCBcIlNFQ1JFVF9ET19OT1RfUEFTU19USElTX09SX1lPVV9XSUxMX0JFX0ZJUkVEXCIpO1xuICAgICAgICAgICAgfSBjYXRjaCAoVmUpIHtcbiAgICAgICAgICAgICAgdmUgPSBWZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZlICYmICEodmUgaW5zdGFuY2VvZiBFcnJvcikgJiYgKHp0KEFlKSwgYihcIiVzOiB0eXBlIHNwZWNpZmljYXRpb24gb2YgJXMgYCVzYCBpcyBpbnZhbGlkOyB0aGUgdHlwZSBjaGVja2VyIGZ1bmN0aW9uIG11c3QgcmV0dXJuIGBudWxsYCBvciBhbiBgRXJyb3JgIGJ1dCByZXR1cm5lZCBhICVzLiBZb3UgbWF5IGhhdmUgZm9yZ290dGVuIHRvIHBhc3MgYW4gYXJndW1lbnQgdG8gdGhlIHR5cGUgY2hlY2tlciBjcmVhdG9yIChhcnJheU9mLCBpbnN0YW5jZU9mLCBvYmplY3RPZiwgb25lT2YsIG9uZU9mVHlwZSwgYW5kIHNoYXBlIGFsbCByZXF1aXJlIGFuIGFyZ3VtZW50KS5cIiwgdWUgfHwgXCJSZWFjdCBjbGFzc1wiLCBaLCBiZSwgdHlwZW9mIHZlKSwgenQobnVsbCkpLCB2ZSBpbnN0YW5jZW9mIEVycm9yICYmICEodmUubWVzc2FnZSBpbiBaZSkgJiYgKFplW3ZlLm1lc3NhZ2VdID0gITAsIHp0KEFlKSwgYihcIkZhaWxlZCAlcyB0eXBlOiAlc1wiLCBaLCB2ZS5tZXNzYWdlKSwgenQobnVsbCkpO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIHJ0ID0gQXJyYXkuaXNBcnJheTtcbiAgICBmdW5jdGlvbiBYbihfKSB7XG4gICAgICByZXR1cm4gcnQoXyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHhpKF8pIHtcbiAgICAgIHtcbiAgICAgICAgdmFyIFcgPSB0eXBlb2YgU3ltYm9sID09IFwiZnVuY3Rpb25cIiAmJiBTeW1ib2wudG9TdHJpbmdUYWcsIFogPSBXICYmIF9bU3ltYm9sLnRvU3RyaW5nVGFnXSB8fCBfLmNvbnN0cnVjdG9yLm5hbWUgfHwgXCJPYmplY3RcIjtcbiAgICAgICAgcmV0dXJuIFo7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIFNpKF8pIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiAkaShfKSwgITE7XG4gICAgICB9IGNhdGNoIHtcbiAgICAgICAgcmV0dXJuICEwO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiAkaShfKSB7XG4gICAgICByZXR1cm4gXCJcIiArIF87XG4gICAgfVxuICAgIGZ1bmN0aW9uIE9pKF8pIHtcbiAgICAgIGlmIChTaShfKSlcbiAgICAgICAgcmV0dXJuIGIoXCJUaGUgcHJvdmlkZWQga2V5IGlzIGFuIHVuc3VwcG9ydGVkIHR5cGUgJXMuIFRoaXMgdmFsdWUgbXVzdCBiZSBjb2VyY2VkIHRvIGEgc3RyaW5nIGJlZm9yZSBiZWZvcmUgdXNpbmcgaXQgaGVyZS5cIiwgeGkoXykpLCAkaShfKTtcbiAgICB9XG4gICAgdmFyIF9pID0gdy5SZWFjdEN1cnJlbnRPd25lciwgbnggPSB7XG4gICAgICBrZXk6ICEwLFxuICAgICAgcmVmOiAhMCxcbiAgICAgIF9fc2VsZjogITAsXG4gICAgICBfX3NvdXJjZTogITBcbiAgICB9LCBBZCwgUGQsIGZ1O1xuICAgIGZ1ID0ge307XG4gICAgZnVuY3Rpb24gcngoXykge1xuICAgICAgaWYgKEVlLmNhbGwoXywgXCJyZWZcIikpIHtcbiAgICAgICAgdmFyIFcgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKF8sIFwicmVmXCIpLmdldDtcbiAgICAgICAgaWYgKFcgJiYgVy5pc1JlYWN0V2FybmluZylcbiAgICAgICAgICByZXR1cm4gITE7XG4gICAgICB9XG4gICAgICByZXR1cm4gXy5yZWYgIT09IHZvaWQgMDtcbiAgICB9XG4gICAgZnVuY3Rpb24gaXgoXykge1xuICAgICAgaWYgKEVlLmNhbGwoXywgXCJrZXlcIikpIHtcbiAgICAgICAgdmFyIFcgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKF8sIFwia2V5XCIpLmdldDtcbiAgICAgICAgaWYgKFcgJiYgVy5pc1JlYWN0V2FybmluZylcbiAgICAgICAgICByZXR1cm4gITE7XG4gICAgICB9XG4gICAgICByZXR1cm4gXy5rZXkgIT09IHZvaWQgMDtcbiAgICB9XG4gICAgZnVuY3Rpb24gb3goXywgVykge1xuICAgICAgaWYgKHR5cGVvZiBfLnJlZiA9PSBcInN0cmluZ1wiICYmIF9pLmN1cnJlbnQgJiYgVyAmJiBfaS5jdXJyZW50LnN0YXRlTm9kZSAhPT0gVykge1xuICAgICAgICB2YXIgWiA9IGooX2kuY3VycmVudC50eXBlKTtcbiAgICAgICAgZnVbWl0gfHwgKGIoJ0NvbXBvbmVudCBcIiVzXCIgY29udGFpbnMgdGhlIHN0cmluZyByZWYgXCIlc1wiLiBTdXBwb3J0IGZvciBzdHJpbmcgcmVmcyB3aWxsIGJlIHJlbW92ZWQgaW4gYSBmdXR1cmUgbWFqb3IgcmVsZWFzZS4gVGhpcyBjYXNlIGNhbm5vdCBiZSBhdXRvbWF0aWNhbGx5IGNvbnZlcnRlZCB0byBhbiBhcnJvdyBmdW5jdGlvbi4gV2UgYXNrIHlvdSB0byBtYW51YWxseSBmaXggdGhpcyBjYXNlIGJ5IHVzaW5nIHVzZVJlZigpIG9yIGNyZWF0ZVJlZigpIGluc3RlYWQuIExlYXJuIG1vcmUgYWJvdXQgdXNpbmcgcmVmcyBzYWZlbHkgaGVyZTogaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3N0cmljdC1tb2RlLXN0cmluZy1yZWYnLCBqKF9pLmN1cnJlbnQudHlwZSksIF8ucmVmKSwgZnVbWl0gPSAhMCk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGF4KF8sIFcpIHtcbiAgICAgIHtcbiAgICAgICAgdmFyIFogPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICBBZCB8fCAoQWQgPSAhMCwgYihcIiVzOiBga2V5YCBpcyBub3QgYSBwcm9wLiBUcnlpbmcgdG8gYWNjZXNzIGl0IHdpbGwgcmVzdWx0IGluIGB1bmRlZmluZWRgIGJlaW5nIHJldHVybmVkLiBJZiB5b3UgbmVlZCB0byBhY2Nlc3MgdGhlIHNhbWUgdmFsdWUgd2l0aGluIHRoZSBjaGlsZCBjb21wb25lbnQsIHlvdSBzaG91bGQgcGFzcyBpdCBhcyBhIGRpZmZlcmVudCBwcm9wLiAoaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3NwZWNpYWwtcHJvcHMpXCIsIFcpKTtcbiAgICAgICAgfTtcbiAgICAgICAgWi5pc1JlYWN0V2FybmluZyA9ICEwLCBPYmplY3QuZGVmaW5lUHJvcGVydHkoXywgXCJrZXlcIiwge1xuICAgICAgICAgIGdldDogWixcbiAgICAgICAgICBjb25maWd1cmFibGU6ICEwXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBzeChfLCBXKSB7XG4gICAgICB7XG4gICAgICAgIHZhciBaID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgUGQgfHwgKFBkID0gITAsIGIoXCIlczogYHJlZmAgaXMgbm90IGEgcHJvcC4gVHJ5aW5nIHRvIGFjY2VzcyBpdCB3aWxsIHJlc3VsdCBpbiBgdW5kZWZpbmVkYCBiZWluZyByZXR1cm5lZC4gSWYgeW91IG5lZWQgdG8gYWNjZXNzIHRoZSBzYW1lIHZhbHVlIHdpdGhpbiB0aGUgY2hpbGQgY29tcG9uZW50LCB5b3Ugc2hvdWxkIHBhc3MgaXQgYXMgYSBkaWZmZXJlbnQgcHJvcC4gKGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9zcGVjaWFsLXByb3BzKVwiLCBXKSk7XG4gICAgICAgIH07XG4gICAgICAgIFouaXNSZWFjdFdhcm5pbmcgPSAhMCwgT2JqZWN0LmRlZmluZVByb3BlcnR5KF8sIFwicmVmXCIsIHtcbiAgICAgICAgICBnZXQ6IFosXG4gICAgICAgICAgY29uZmlndXJhYmxlOiAhMFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIHV4ID0gZnVuY3Rpb24oXywgVywgWiwgdWUsIEFlLCBNZSwgYmUpIHtcbiAgICAgIHZhciB2ZSA9IHtcbiAgICAgICAgLy8gVGhpcyB0YWcgYWxsb3dzIHVzIHRvIHVuaXF1ZWx5IGlkZW50aWZ5IHRoaXMgYXMgYSBSZWFjdCBFbGVtZW50XG4gICAgICAgICQkdHlwZW9mOiB0LFxuICAgICAgICAvLyBCdWlsdC1pbiBwcm9wZXJ0aWVzIHRoYXQgYmVsb25nIG9uIHRoZSBlbGVtZW50XG4gICAgICAgIHR5cGU6IF8sXG4gICAgICAgIGtleTogVyxcbiAgICAgICAgcmVmOiBaLFxuICAgICAgICBwcm9wczogYmUsXG4gICAgICAgIC8vIFJlY29yZCB0aGUgY29tcG9uZW50IHJlc3BvbnNpYmxlIGZvciBjcmVhdGluZyB0aGlzIGVsZW1lbnQuXG4gICAgICAgIF9vd25lcjogTWVcbiAgICAgIH07XG4gICAgICByZXR1cm4gdmUuX3N0b3JlID0ge30sIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh2ZS5fc3RvcmUsIFwidmFsaWRhdGVkXCIsIHtcbiAgICAgICAgY29uZmlndXJhYmxlOiAhMSxcbiAgICAgICAgZW51bWVyYWJsZTogITEsXG4gICAgICAgIHdyaXRhYmxlOiAhMCxcbiAgICAgICAgdmFsdWU6ICExXG4gICAgICB9KSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KHZlLCBcIl9zZWxmXCIsIHtcbiAgICAgICAgY29uZmlndXJhYmxlOiAhMSxcbiAgICAgICAgZW51bWVyYWJsZTogITEsXG4gICAgICAgIHdyaXRhYmxlOiAhMSxcbiAgICAgICAgdmFsdWU6IHVlXG4gICAgICB9KSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KHZlLCBcIl9zb3VyY2VcIiwge1xuICAgICAgICBjb25maWd1cmFibGU6ICExLFxuICAgICAgICBlbnVtZXJhYmxlOiAhMSxcbiAgICAgICAgd3JpdGFibGU6ICExLFxuICAgICAgICB2YWx1ZTogQWVcbiAgICAgIH0pLCBPYmplY3QuZnJlZXplICYmIChPYmplY3QuZnJlZXplKHZlLnByb3BzKSwgT2JqZWN0LmZyZWV6ZSh2ZSkpLCB2ZTtcbiAgICB9O1xuICAgIGZ1bmN0aW9uIGN4KF8sIFcsIFosIHVlLCBBZSkge1xuICAgICAge1xuICAgICAgICB2YXIgTWUsIGJlID0ge30sIHZlID0gbnVsbCwgY3QgPSBudWxsO1xuICAgICAgICBaICE9PSB2b2lkIDAgJiYgKE9pKFopLCB2ZSA9IFwiXCIgKyBaKSwgaXgoVykgJiYgKE9pKFcua2V5KSwgdmUgPSBcIlwiICsgVy5rZXkpLCByeChXKSAmJiAoY3QgPSBXLnJlZiwgb3goVywgQWUpKTtcbiAgICAgICAgZm9yIChNZSBpbiBXKVxuICAgICAgICAgIEVlLmNhbGwoVywgTWUpICYmICFueC5oYXNPd25Qcm9wZXJ0eShNZSkgJiYgKGJlW01lXSA9IFdbTWVdKTtcbiAgICAgICAgaWYgKF8gJiYgXy5kZWZhdWx0UHJvcHMpIHtcbiAgICAgICAgICB2YXIgVmUgPSBfLmRlZmF1bHRQcm9wcztcbiAgICAgICAgICBmb3IgKE1lIGluIFZlKVxuICAgICAgICAgICAgYmVbTWVdID09PSB2b2lkIDAgJiYgKGJlW01lXSA9IFZlW01lXSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZlIHx8IGN0KSB7XG4gICAgICAgICAgdmFyIFVlID0gdHlwZW9mIF8gPT0gXCJmdW5jdGlvblwiID8gXy5kaXNwbGF5TmFtZSB8fCBfLm5hbWUgfHwgXCJVbmtub3duXCIgOiBfO1xuICAgICAgICAgIHZlICYmIGF4KGJlLCBVZSksIGN0ICYmIHN4KGJlLCBVZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHV4KF8sIHZlLCBjdCwgQWUsIHVlLCBfaS5jdXJyZW50LCBiZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHZhciBkdSA9IHcuUmVhY3RDdXJyZW50T3duZXIsIENkID0gdy5SZWFjdERlYnVnQ3VycmVudEZyYW1lO1xuICAgIGZ1bmN0aW9uIGJyKF8pIHtcbiAgICAgIGlmIChfKSB7XG4gICAgICAgIHZhciBXID0gXy5fb3duZXIsIFogPSB4ZShfLnR5cGUsIF8uX3NvdXJjZSwgVyA/IFcudHlwZSA6IG51bGwpO1xuICAgICAgICBDZC5zZXRFeHRyYVN0YWNrRnJhbWUoWik7XG4gICAgICB9IGVsc2VcbiAgICAgICAgQ2Quc2V0RXh0cmFTdGFja0ZyYW1lKG51bGwpO1xuICAgIH1cbiAgICB2YXIgcHU7XG4gICAgcHUgPSAhMTtcbiAgICBmdW5jdGlvbiBodShfKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIF8gPT0gXCJvYmplY3RcIiAmJiBfICE9PSBudWxsICYmIF8uJCR0eXBlb2YgPT09IHQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIEVkKCkge1xuICAgICAge1xuICAgICAgICBpZiAoZHUuY3VycmVudCkge1xuICAgICAgICAgIHZhciBfID0gaihkdS5jdXJyZW50LnR5cGUpO1xuICAgICAgICAgIGlmIChfKVxuICAgICAgICAgICAgcmV0dXJuIGBcblxuQ2hlY2sgdGhlIHJlbmRlciBtZXRob2Qgb2YgXFxgYCArIF8gKyBcImAuXCI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGx4KF8pIHtcbiAgICAgIHJldHVybiBcIlwiO1xuICAgIH1cbiAgICB2YXIgVGQgPSB7fTtcbiAgICBmdW5jdGlvbiBmeChfKSB7XG4gICAgICB7XG4gICAgICAgIHZhciBXID0gRWQoKTtcbiAgICAgICAgaWYgKCFXKSB7XG4gICAgICAgICAgdmFyIFogPSB0eXBlb2YgXyA9PSBcInN0cmluZ1wiID8gXyA6IF8uZGlzcGxheU5hbWUgfHwgXy5uYW1lO1xuICAgICAgICAgIFogJiYgKFcgPSBgXG5cbkNoZWNrIHRoZSB0b3AtbGV2ZWwgcmVuZGVyIGNhbGwgdXNpbmcgPGAgKyBaICsgXCI+LlwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gVztcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gTWQoXywgVykge1xuICAgICAge1xuICAgICAgICBpZiAoIV8uX3N0b3JlIHx8IF8uX3N0b3JlLnZhbGlkYXRlZCB8fCBfLmtleSAhPSBudWxsKVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgXy5fc3RvcmUudmFsaWRhdGVkID0gITA7XG4gICAgICAgIHZhciBaID0gZngoVyk7XG4gICAgICAgIGlmIChUZFtaXSlcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIFRkW1pdID0gITA7XG4gICAgICAgIHZhciB1ZSA9IFwiXCI7XG4gICAgICAgIF8gJiYgXy5fb3duZXIgJiYgXy5fb3duZXIgIT09IGR1LmN1cnJlbnQgJiYgKHVlID0gXCIgSXQgd2FzIHBhc3NlZCBhIGNoaWxkIGZyb20gXCIgKyBqKF8uX293bmVyLnR5cGUpICsgXCIuXCIpLCBicihfKSwgYignRWFjaCBjaGlsZCBpbiBhIGxpc3Qgc2hvdWxkIGhhdmUgYSB1bmlxdWUgXCJrZXlcIiBwcm9wLiVzJXMgU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay93YXJuaW5nLWtleXMgZm9yIG1vcmUgaW5mb3JtYXRpb24uJywgWiwgdWUpLCBicihudWxsKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gUmQoXywgVykge1xuICAgICAge1xuICAgICAgICBpZiAodHlwZW9mIF8gIT0gXCJvYmplY3RcIilcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmIChYbihfKSlcbiAgICAgICAgICBmb3IgKHZhciBaID0gMDsgWiA8IF8ubGVuZ3RoOyBaKyspIHtcbiAgICAgICAgICAgIHZhciB1ZSA9IF9bWl07XG4gICAgICAgICAgICBodSh1ZSkgJiYgTWQodWUsIFcpO1xuICAgICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaHUoXykpXG4gICAgICAgICAgXy5fc3RvcmUgJiYgKF8uX3N0b3JlLnZhbGlkYXRlZCA9ICEwKTtcbiAgICAgICAgZWxzZSBpZiAoXykge1xuICAgICAgICAgIHZhciBBZSA9IHYoXyk7XG4gICAgICAgICAgaWYgKHR5cGVvZiBBZSA9PSBcImZ1bmN0aW9uXCIgJiYgQWUgIT09IF8uZW50cmllcylcbiAgICAgICAgICAgIGZvciAodmFyIE1lID0gQWUuY2FsbChfKSwgYmU7ICEoYmUgPSBNZS5uZXh0KCkpLmRvbmU7IClcbiAgICAgICAgICAgICAgaHUoYmUudmFsdWUpICYmIE1kKGJlLnZhbHVlLCBXKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBkeChfKSB7XG4gICAgICB7XG4gICAgICAgIHZhciBXID0gXy50eXBlO1xuICAgICAgICBpZiAoVyA9PSBudWxsIHx8IHR5cGVvZiBXID09IFwic3RyaW5nXCIpXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB2YXIgWjtcbiAgICAgICAgaWYgKHR5cGVvZiBXID09IFwiZnVuY3Rpb25cIilcbiAgICAgICAgICBaID0gVy5wcm9wVHlwZXM7XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBXID09IFwib2JqZWN0XCIgJiYgKFcuJCR0eXBlb2YgPT09IHUgfHwgLy8gTm90ZTogTWVtbyBvbmx5IGNoZWNrcyBvdXRlciBwcm9wcyBoZXJlLlxuICAgICAgICAvLyBJbm5lciBwcm9wcyBhcmUgY2hlY2tlZCBpbiB0aGUgcmVjb25jaWxlci5cbiAgICAgICAgVy4kJHR5cGVvZiA9PT0gbCkpXG4gICAgICAgICAgWiA9IFcucHJvcFR5cGVzO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAoWikge1xuICAgICAgICAgIHZhciB1ZSA9IGooVyk7XG4gICAgICAgICAgVnQoWiwgXy5wcm9wcywgXCJwcm9wXCIsIHVlLCBfKTtcbiAgICAgICAgfSBlbHNlIGlmIChXLlByb3BUeXBlcyAhPT0gdm9pZCAwICYmICFwdSkge1xuICAgICAgICAgIHB1ID0gITA7XG4gICAgICAgICAgdmFyIEFlID0gaihXKTtcbiAgICAgICAgICBiKFwiQ29tcG9uZW50ICVzIGRlY2xhcmVkIGBQcm9wVHlwZXNgIGluc3RlYWQgb2YgYHByb3BUeXBlc2AuIERpZCB5b3UgbWlzc3BlbGwgdGhlIHByb3BlcnR5IGFzc2lnbm1lbnQ/XCIsIEFlIHx8IFwiVW5rbm93blwiKTtcbiAgICAgICAgfVxuICAgICAgICB0eXBlb2YgVy5nZXREZWZhdWx0UHJvcHMgPT0gXCJmdW5jdGlvblwiICYmICFXLmdldERlZmF1bHRQcm9wcy5pc1JlYWN0Q2xhc3NBcHByb3ZlZCAmJiBiKFwiZ2V0RGVmYXVsdFByb3BzIGlzIG9ubHkgdXNlZCBvbiBjbGFzc2ljIFJlYWN0LmNyZWF0ZUNsYXNzIGRlZmluaXRpb25zLiBVc2UgYSBzdGF0aWMgcHJvcGVydHkgbmFtZWQgYGRlZmF1bHRQcm9wc2AgaW5zdGVhZC5cIik7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHB4KF8pIHtcbiAgICAgIHtcbiAgICAgICAgZm9yICh2YXIgVyA9IE9iamVjdC5rZXlzKF8ucHJvcHMpLCBaID0gMDsgWiA8IFcubGVuZ3RoOyBaKyspIHtcbiAgICAgICAgICB2YXIgdWUgPSBXW1pdO1xuICAgICAgICAgIGlmICh1ZSAhPT0gXCJjaGlsZHJlblwiICYmIHVlICE9PSBcImtleVwiKSB7XG4gICAgICAgICAgICBicihfKSwgYihcIkludmFsaWQgcHJvcCBgJXNgIHN1cHBsaWVkIHRvIGBSZWFjdC5GcmFnbWVudGAuIFJlYWN0LkZyYWdtZW50IGNhbiBvbmx5IGhhdmUgYGtleWAgYW5kIGBjaGlsZHJlbmAgcHJvcHMuXCIsIHVlKSwgYnIobnVsbCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgXy5yZWYgIT09IG51bGwgJiYgKGJyKF8pLCBiKFwiSW52YWxpZCBhdHRyaWJ1dGUgYHJlZmAgc3VwcGxpZWQgdG8gYFJlYWN0LkZyYWdtZW50YC5cIiksIGJyKG51bGwpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIElkID0ge307XG4gICAgZnVuY3Rpb24gamQoXywgVywgWiwgdWUsIEFlLCBNZSkge1xuICAgICAge1xuICAgICAgICB2YXIgYmUgPSBNKF8pO1xuICAgICAgICBpZiAoIWJlKSB7XG4gICAgICAgICAgdmFyIHZlID0gXCJcIjtcbiAgICAgICAgICAoXyA9PT0gdm9pZCAwIHx8IHR5cGVvZiBfID09IFwib2JqZWN0XCIgJiYgXyAhPT0gbnVsbCAmJiBPYmplY3Qua2V5cyhfKS5sZW5ndGggPT09IDApICYmICh2ZSArPSBcIiBZb3UgbGlrZWx5IGZvcmdvdCB0byBleHBvcnQgeW91ciBjb21wb25lbnQgZnJvbSB0aGUgZmlsZSBpdCdzIGRlZmluZWQgaW4sIG9yIHlvdSBtaWdodCBoYXZlIG1peGVkIHVwIGRlZmF1bHQgYW5kIG5hbWVkIGltcG9ydHMuXCIpO1xuICAgICAgICAgIHZhciBjdCA9IGx4KCk7XG4gICAgICAgICAgY3QgPyB2ZSArPSBjdCA6IHZlICs9IEVkKCk7XG4gICAgICAgICAgdmFyIFZlO1xuICAgICAgICAgIF8gPT09IG51bGwgPyBWZSA9IFwibnVsbFwiIDogWG4oXykgPyBWZSA9IFwiYXJyYXlcIiA6IF8gIT09IHZvaWQgMCAmJiBfLiQkdHlwZW9mID09PSB0ID8gKFZlID0gXCI8XCIgKyAoaihfLnR5cGUpIHx8IFwiVW5rbm93blwiKSArIFwiIC8+XCIsIHZlID0gXCIgRGlkIHlvdSBhY2NpZGVudGFsbHkgZXhwb3J0IGEgSlNYIGxpdGVyYWwgaW5zdGVhZCBvZiBhIGNvbXBvbmVudD9cIikgOiBWZSA9IHR5cGVvZiBfLCBiKFwiUmVhY3QuanN4OiB0eXBlIGlzIGludmFsaWQgLS0gZXhwZWN0ZWQgYSBzdHJpbmcgKGZvciBidWlsdC1pbiBjb21wb25lbnRzKSBvciBhIGNsYXNzL2Z1bmN0aW9uIChmb3IgY29tcG9zaXRlIGNvbXBvbmVudHMpIGJ1dCBnb3Q6ICVzLiVzXCIsIFZlLCB2ZSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIFVlID0gY3goXywgVywgWiwgQWUsIE1lKTtcbiAgICAgICAgaWYgKFVlID09IG51bGwpXG4gICAgICAgICAgcmV0dXJuIFVlO1xuICAgICAgICBpZiAoYmUpIHtcbiAgICAgICAgICB2YXIgQ3QgPSBXLmNoaWxkcmVuO1xuICAgICAgICAgIGlmIChDdCAhPT0gdm9pZCAwKVxuICAgICAgICAgICAgaWYgKHVlKVxuICAgICAgICAgICAgICBpZiAoWG4oQ3QpKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgd3IgPSAwOyB3ciA8IEN0Lmxlbmd0aDsgd3IrKylcbiAgICAgICAgICAgICAgICAgIFJkKEN0W3dyXSwgXyk7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmZyZWV6ZSAmJiBPYmplY3QuZnJlZXplKEN0KTtcbiAgICAgICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICAgICAgYihcIlJlYWN0LmpzeDogU3RhdGljIGNoaWxkcmVuIHNob3VsZCBhbHdheXMgYmUgYW4gYXJyYXkuIFlvdSBhcmUgbGlrZWx5IGV4cGxpY2l0bHkgY2FsbGluZyBSZWFjdC5qc3hzIG9yIFJlYWN0LmpzeERFVi4gVXNlIHRoZSBCYWJlbCB0cmFuc2Zvcm0gaW5zdGVhZC5cIik7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgIFJkKEN0LCBfKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoRWUuY2FsbChXLCBcImtleVwiKSkge1xuICAgICAgICAgIHZhciBabiA9IGooXyksIHB0ID0gT2JqZWN0LmtleXMoVykuZmlsdGVyKGZ1bmN0aW9uKGJ4KSB7XG4gICAgICAgICAgICByZXR1cm4gYnggIT09IFwia2V5XCI7XG4gICAgICAgICAgfSksIGd1ID0gcHQubGVuZ3RoID4gMCA/IFwie2tleTogc29tZUtleSwgXCIgKyBwdC5qb2luKFwiOiAuLi4sIFwiKSArIFwiOiAuLi59XCIgOiBcIntrZXk6IHNvbWVLZXl9XCI7XG4gICAgICAgICAgaWYgKCFJZFtabiArIGd1XSkge1xuICAgICAgICAgICAgdmFyIHl4ID0gcHQubGVuZ3RoID4gMCA/IFwie1wiICsgcHQuam9pbihcIjogLi4uLCBcIikgKyBcIjogLi4ufVwiIDogXCJ7fVwiO1xuICAgICAgICAgICAgYihgQSBwcm9wcyBvYmplY3QgY29udGFpbmluZyBhIFwia2V5XCIgcHJvcCBpcyBiZWluZyBzcHJlYWQgaW50byBKU1g6XG4gIGxldCBwcm9wcyA9ICVzO1xuICA8JXMgey4uLnByb3BzfSAvPlxuUmVhY3Qga2V5cyBtdXN0IGJlIHBhc3NlZCBkaXJlY3RseSB0byBKU1ggd2l0aG91dCB1c2luZyBzcHJlYWQ6XG4gIGxldCBwcm9wcyA9ICVzO1xuICA8JXMga2V5PXtzb21lS2V5fSB7Li4ucHJvcHN9IC8+YCwgZ3UsIFpuLCB5eCwgWm4pLCBJZFtabiArIGd1XSA9ICEwO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gXyA9PT0gciA/IHB4KFVlKSA6IGR4KFVlKSwgVWU7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGh4KF8sIFcsIFopIHtcbiAgICAgIHJldHVybiBqZChfLCBXLCBaLCAhMCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGd4KF8sIFcsIFopIHtcbiAgICAgIHJldHVybiBqZChfLCBXLCBaLCAhMSk7XG4gICAgfVxuICAgIHZhciB2eCA9IGd4LCBteCA9IGh4O1xuICAgIFBpLkZyYWdtZW50ID0gciwgUGkuanN4ID0gdngsIFBpLmpzeHMgPSBteDtcbiAgfSgpKSwgUGk7XG59XG5wcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBoYy5leHBvcnRzID0gJHgoKSA6IGhjLmV4cG9ydHMgPSBPeCgpO1xudmFyIGRtID0gaGMuZXhwb3J0cztcbmNvbnN0IFggPSBkbS5qc3gsIHplID0gZG0uanN4cztcbmZ1bmN0aW9uIGNlKCkge1xuICByZXR1cm4gY2UgPSBPYmplY3QuYXNzaWduID8gT2JqZWN0LmFzc2lnbi5iaW5kKCkgOiBmdW5jdGlvbihlKSB7XG4gICAgZm9yICh2YXIgdCA9IDE7IHQgPCBhcmd1bWVudHMubGVuZ3RoOyB0KyspIHtcbiAgICAgIHZhciBuID0gYXJndW1lbnRzW3RdO1xuICAgICAgZm9yICh2YXIgciBpbiBuKVxuICAgICAgICAoe30pLmhhc093blByb3BlcnR5LmNhbGwobiwgcikgJiYgKGVbcl0gPSBuW3JdKTtcbiAgICB9XG4gICAgcmV0dXJuIGU7XG4gIH0sIGNlLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59XG5mdW5jdGlvbiBfeChlLCB0KSB7XG4gIHR5cGVvZiBlID09IFwiZnVuY3Rpb25cIiA/IGUodCkgOiBlICE9IG51bGwgJiYgKGUuY3VycmVudCA9IHQpO1xufVxuZnVuY3Rpb24gTXMoLi4uZSkge1xuICByZXR1cm4gKHQpID0+IGUuZm9yRWFjaChcbiAgICAobikgPT4gX3gobiwgdClcbiAgKTtcbn1cbmZ1bmN0aW9uIF90KC4uLmUpIHtcbiAgcmV0dXJuIHV0KE1zKC4uLmUpLCBlKTtcbn1cbmNvbnN0IGtyID0gLyogQF9fUFVSRV9fICovIGhlKChlLCB0KSA9PiB7XG4gIGNvbnN0IHsgY2hpbGRyZW46IG4sIC4uLnIgfSA9IGUsIGkgPSAkdC50b0FycmF5KG4pLCBvID0gaS5maW5kKFB4KTtcbiAgaWYgKG8pIHtcbiAgICBjb25zdCBhID0gby5wcm9wcy5jaGlsZHJlbiwgcyA9IGkubWFwKCh1KSA9PiB1ID09PSBvID8gJHQuY291bnQoYSkgPiAxID8gJHQub25seShudWxsKSA6IC8qIEBfX1BVUkVfXyAqLyB2dChhKSA/IGEucHJvcHMuY2hpbGRyZW4gOiBudWxsIDogdSk7XG4gICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBZKGdjLCBjZSh7fSwgciwge1xuICAgICAgcmVmOiB0XG4gICAgfSksIC8qIEBfX1BVUkVfXyAqLyB2dChhKSA/IC8qIEBfX1BVUkVfXyAqLyBHZShhLCB2b2lkIDAsIHMpIDogbnVsbCk7XG4gIH1cbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBZKGdjLCBjZSh7fSwgciwge1xuICAgIHJlZjogdFxuICB9KSwgbik7XG59KTtcbmtyLmRpc3BsYXlOYW1lID0gXCJTbG90XCI7XG5jb25zdCBnYyA9IC8qIEBfX1BVUkVfXyAqLyBoZSgoZSwgdCkgPT4ge1xuICBjb25zdCB7IGNoaWxkcmVuOiBuLCAuLi5yIH0gPSBlO1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIHZ0KG4pID8gLyogQF9fUFVSRV9fICovIEdlKG4sIHtcbiAgICAuLi5DeChyLCBuLnByb3BzKSxcbiAgICByZWY6IHQgPyBNcyh0LCBuLnJlZikgOiBuLnJlZlxuICB9KSA6ICR0LmNvdW50KG4pID4gMSA/ICR0Lm9ubHkobnVsbCkgOiBudWxsO1xufSk7XG5nYy5kaXNwbGF5TmFtZSA9IFwiU2xvdENsb25lXCI7XG5jb25zdCBBeCA9ICh7IGNoaWxkcmVuOiBlIH0pID0+IC8qIEBfX1BVUkVfXyAqLyBZKHVtLCBudWxsLCBlKTtcbmZ1bmN0aW9uIFB4KGUpIHtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyB2dChlKSAmJiBlLnR5cGUgPT09IEF4O1xufVxuZnVuY3Rpb24gQ3goZSwgdCkge1xuICBjb25zdCBuID0ge1xuICAgIC4uLnRcbiAgfTtcbiAgZm9yIChjb25zdCByIGluIHQpIHtcbiAgICBjb25zdCBpID0gZVtyXSwgbyA9IHRbcl07XG4gICAgL15vbltBLVpdLy50ZXN0KHIpID8gaSAmJiBvID8gbltyXSA9ICguLi5zKSA9PiB7XG4gICAgICBvKC4uLnMpLCBpKC4uLnMpO1xuICAgIH0gOiBpICYmIChuW3JdID0gaSkgOiByID09PSBcInN0eWxlXCIgPyBuW3JdID0ge1xuICAgICAgLi4uaSxcbiAgICAgIC4uLm9cbiAgICB9IDogciA9PT0gXCJjbGFzc05hbWVcIiAmJiAobltyXSA9IFtcbiAgICAgIGksXG4gICAgICBvXG4gICAgXS5maWx0ZXIoQm9vbGVhbikuam9pbihcIiBcIikpO1xuICB9XG4gIHJldHVybiB7XG4gICAgLi4uZSxcbiAgICAuLi5uXG4gIH07XG59XG5mdW5jdGlvbiBwbShlKSB7XG4gIHZhciB0LCBuLCByID0gXCJcIjtcbiAgaWYgKHR5cGVvZiBlID09IFwic3RyaW5nXCIgfHwgdHlwZW9mIGUgPT0gXCJudW1iZXJcIilcbiAgICByICs9IGU7XG4gIGVsc2UgaWYgKHR5cGVvZiBlID09IFwib2JqZWN0XCIpXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZSkpXG4gICAgICBmb3IgKHQgPSAwOyB0IDwgZS5sZW5ndGg7IHQrKylcbiAgICAgICAgZVt0XSAmJiAobiA9IHBtKGVbdF0pKSAmJiAociAmJiAociArPSBcIiBcIiksIHIgKz0gbik7XG4gICAgZWxzZVxuICAgICAgZm9yICh0IGluIGUpXG4gICAgICAgIGVbdF0gJiYgKHIgJiYgKHIgKz0gXCIgXCIpLCByICs9IHQpO1xuICByZXR1cm4gcjtcbn1cbmZ1bmN0aW9uIEV4KCkge1xuICBmb3IgKHZhciBlLCB0LCBuID0gMCwgciA9IFwiXCI7IG4gPCBhcmd1bWVudHMubGVuZ3RoOyApXG4gICAgKGUgPSBhcmd1bWVudHNbbisrXSkgJiYgKHQgPSBwbShlKSkgJiYgKHIgJiYgKHIgKz0gXCIgXCIpLCByICs9IHQpO1xuICByZXR1cm4gcjtcbn1cbmNvbnN0IE5kID0gKGUpID0+IHR5cGVvZiBlID09IFwiYm9vbGVhblwiID8gXCJcIi5jb25jYXQoZSkgOiBlID09PSAwID8gXCIwXCIgOiBlLCBGZCA9IEV4LCBUeCA9IChlLCB0KSA9PiAobikgPT4ge1xuICB2YXIgcjtcbiAgaWYgKCh0ID09IG51bGwgPyB2b2lkIDAgOiB0LnZhcmlhbnRzKSA9PSBudWxsKVxuICAgIHJldHVybiBGZChlLCBuID09IG51bGwgPyB2b2lkIDAgOiBuLmNsYXNzLCBuID09IG51bGwgPyB2b2lkIDAgOiBuLmNsYXNzTmFtZSk7XG4gIGNvbnN0IHsgdmFyaWFudHM6IGksIGRlZmF1bHRWYXJpYW50czogbyB9ID0gdCwgYSA9IE9iamVjdC5rZXlzKGkpLm1hcCgoYykgPT4ge1xuICAgIGNvbnN0IGYgPSBuID09IG51bGwgPyB2b2lkIDAgOiBuW2NdLCBsID0gbyA9PSBudWxsID8gdm9pZCAwIDogb1tjXTtcbiAgICBpZiAoZiA9PT0gbnVsbClcbiAgICAgIHJldHVybiBudWxsO1xuICAgIGNvbnN0IGQgPSBOZChmKSB8fCBOZChsKTtcbiAgICByZXR1cm4gaVtjXVtkXTtcbiAgfSksIHMgPSBuICYmIE9iamVjdC5lbnRyaWVzKG4pLnJlZHVjZSgoYywgZikgPT4ge1xuICAgIGxldCBbbCwgZF0gPSBmO1xuICAgIHJldHVybiBkID09PSB2b2lkIDAgfHwgKGNbbF0gPSBkKSwgYztcbiAgfSwge30pLCB1ID0gdCA9PSBudWxsIHx8IChyID0gdC5jb21wb3VuZFZhcmlhbnRzKSA9PT0gbnVsbCB8fCByID09PSB2b2lkIDAgPyB2b2lkIDAgOiByLnJlZHVjZSgoYywgZikgPT4ge1xuICAgIGxldCB7IGNsYXNzOiBsLCBjbGFzc05hbWU6IGQsIC4uLnAgfSA9IGY7XG4gICAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKHApLmV2ZXJ5KChnKSA9PiB7XG4gICAgICBsZXQgW2gsIHZdID0gZztcbiAgICAgIHJldHVybiBBcnJheS5pc0FycmF5KHYpID8gdi5pbmNsdWRlcyh7XG4gICAgICAgIC4uLm8sXG4gICAgICAgIC4uLnNcbiAgICAgIH1baF0pIDoge1xuICAgICAgICAuLi5vLFxuICAgICAgICAuLi5zXG4gICAgICB9W2hdID09PSB2O1xuICAgIH0pID8gW1xuICAgICAgLi4uYyxcbiAgICAgIGwsXG4gICAgICBkXG4gICAgXSA6IGM7XG4gIH0sIFtdKTtcbiAgcmV0dXJuIEZkKGUsIGEsIHUsIG4gPT0gbnVsbCA/IHZvaWQgMCA6IG4uY2xhc3MsIG4gPT0gbnVsbCA/IHZvaWQgMCA6IG4uY2xhc3NOYW1lKTtcbn07XG5mdW5jdGlvbiBobShlKSB7XG4gIHZhciB0LCBuLCByID0gXCJcIjtcbiAgaWYgKHR5cGVvZiBlID09IFwic3RyaW5nXCIgfHwgdHlwZW9mIGUgPT0gXCJudW1iZXJcIilcbiAgICByICs9IGU7XG4gIGVsc2UgaWYgKHR5cGVvZiBlID09IFwib2JqZWN0XCIpXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZSkpIHtcbiAgICAgIHZhciBpID0gZS5sZW5ndGg7XG4gICAgICBmb3IgKHQgPSAwOyB0IDwgaTsgdCsrKVxuICAgICAgICBlW3RdICYmIChuID0gaG0oZVt0XSkpICYmIChyICYmIChyICs9IFwiIFwiKSwgciArPSBuKTtcbiAgICB9IGVsc2VcbiAgICAgIGZvciAobiBpbiBlKVxuICAgICAgICBlW25dICYmIChyICYmIChyICs9IFwiIFwiKSwgciArPSBuKTtcbiAgcmV0dXJuIHI7XG59XG5mdW5jdGlvbiAkZSgpIHtcbiAgZm9yICh2YXIgZSwgdCwgbiA9IDAsIHIgPSBcIlwiLCBpID0gYXJndW1lbnRzLmxlbmd0aDsgbiA8IGk7IG4rKylcbiAgICAoZSA9IGFyZ3VtZW50c1tuXSkgJiYgKHQgPSBobShlKSkgJiYgKHIgJiYgKHIgKz0gXCIgXCIpLCByICs9IHQpO1xuICByZXR1cm4gcjtcbn1cbmNvbnN0IGVmID0gXCItXCI7XG5mdW5jdGlvbiBNeChlKSB7XG4gIGNvbnN0IHQgPSBJeChlKSwge1xuICAgIGNvbmZsaWN0aW5nQ2xhc3NHcm91cHM6IG4sXG4gICAgY29uZmxpY3RpbmdDbGFzc0dyb3VwTW9kaWZpZXJzOiByXG4gIH0gPSBlO1xuICBmdW5jdGlvbiBpKGEpIHtcbiAgICBjb25zdCBzID0gYS5zcGxpdChlZik7XG4gICAgcmV0dXJuIHNbMF0gPT09IFwiXCIgJiYgcy5sZW5ndGggIT09IDEgJiYgcy5zaGlmdCgpLCBnbShzLCB0KSB8fCBSeChhKTtcbiAgfVxuICBmdW5jdGlvbiBvKGEsIHMpIHtcbiAgICBjb25zdCB1ID0gblthXSB8fCBbXTtcbiAgICByZXR1cm4gcyAmJiByW2FdID8gWy4uLnUsIC4uLnJbYV1dIDogdTtcbiAgfVxuICByZXR1cm4ge1xuICAgIGdldENsYXNzR3JvdXBJZDogaSxcbiAgICBnZXRDb25mbGljdGluZ0NsYXNzR3JvdXBJZHM6IG9cbiAgfTtcbn1cbmZ1bmN0aW9uIGdtKGUsIHQpIHtcbiAgdmFyIGE7XG4gIGlmIChlLmxlbmd0aCA9PT0gMClcbiAgICByZXR1cm4gdC5jbGFzc0dyb3VwSWQ7XG4gIGNvbnN0IG4gPSBlWzBdLCByID0gdC5uZXh0UGFydC5nZXQobiksIGkgPSByID8gZ20oZS5zbGljZSgxKSwgcikgOiB2b2lkIDA7XG4gIGlmIChpKVxuICAgIHJldHVybiBpO1xuICBpZiAodC52YWxpZGF0b3JzLmxlbmd0aCA9PT0gMClcbiAgICByZXR1cm47XG4gIGNvbnN0IG8gPSBlLmpvaW4oZWYpO1xuICByZXR1cm4gKGEgPSB0LnZhbGlkYXRvcnMuZmluZCgoe1xuICAgIHZhbGlkYXRvcjogc1xuICB9KSA9PiBzKG8pKSkgPT0gbnVsbCA/IHZvaWQgMCA6IGEuY2xhc3NHcm91cElkO1xufVxuY29uc3QgTGQgPSAvXlxcWyguKylcXF0kLztcbmZ1bmN0aW9uIFJ4KGUpIHtcbiAgaWYgKExkLnRlc3QoZSkpIHtcbiAgICBjb25zdCB0ID0gTGQuZXhlYyhlKVsxXSwgbiA9IHQgPT0gbnVsbCA/IHZvaWQgMCA6IHQuc3Vic3RyaW5nKDAsIHQuaW5kZXhPZihcIjpcIikpO1xuICAgIGlmIChuKVxuICAgICAgcmV0dXJuIFwiYXJiaXRyYXJ5Li5cIiArIG47XG4gIH1cbn1cbmZ1bmN0aW9uIEl4KGUpIHtcbiAgY29uc3Qge1xuICAgIHRoZW1lOiB0LFxuICAgIHByZWZpeDogblxuICB9ID0gZSwgciA9IHtcbiAgICBuZXh0UGFydDogLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSxcbiAgICB2YWxpZGF0b3JzOiBbXVxuICB9O1xuICByZXR1cm4ga3goT2JqZWN0LmVudHJpZXMoZS5jbGFzc0dyb3VwcyksIG4pLmZvckVhY2goKFtvLCBhXSkgPT4ge1xuICAgIHZjKGEsIHIsIG8sIHQpO1xuICB9KSwgcjtcbn1cbmZ1bmN0aW9uIHZjKGUsIHQsIG4sIHIpIHtcbiAgZS5mb3JFYWNoKChpKSA9PiB7XG4gICAgaWYgKHR5cGVvZiBpID09IFwic3RyaW5nXCIpIHtcbiAgICAgIGNvbnN0IG8gPSBpID09PSBcIlwiID8gdCA6IEJkKHQsIGkpO1xuICAgICAgby5jbGFzc0dyb3VwSWQgPSBuO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGkgPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICBpZiAoangoaSkpIHtcbiAgICAgICAgdmMoaShyKSwgdCwgbiwgcik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHQudmFsaWRhdG9ycy5wdXNoKHtcbiAgICAgICAgdmFsaWRhdG9yOiBpLFxuICAgICAgICBjbGFzc0dyb3VwSWQ6IG5cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBPYmplY3QuZW50cmllcyhpKS5mb3JFYWNoKChbbywgYV0pID0+IHtcbiAgICAgIHZjKGEsIEJkKHQsIG8pLCBuLCByKTtcbiAgICB9KTtcbiAgfSk7XG59XG5mdW5jdGlvbiBCZChlLCB0KSB7XG4gIGxldCBuID0gZTtcbiAgcmV0dXJuIHQuc3BsaXQoZWYpLmZvckVhY2goKHIpID0+IHtcbiAgICBuLm5leHRQYXJ0LmhhcyhyKSB8fCBuLm5leHRQYXJ0LnNldChyLCB7XG4gICAgICBuZXh0UGFydDogLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSxcbiAgICAgIHZhbGlkYXRvcnM6IFtdXG4gICAgfSksIG4gPSBuLm5leHRQYXJ0LmdldChyKTtcbiAgfSksIG47XG59XG5mdW5jdGlvbiBqeChlKSB7XG4gIHJldHVybiBlLmlzVGhlbWVHZXR0ZXI7XG59XG5mdW5jdGlvbiBreChlLCB0KSB7XG4gIHJldHVybiB0ID8gZS5tYXAoKFtuLCByXSkgPT4ge1xuICAgIGNvbnN0IGkgPSByLm1hcCgobykgPT4gdHlwZW9mIG8gPT0gXCJzdHJpbmdcIiA/IHQgKyBvIDogdHlwZW9mIG8gPT0gXCJvYmplY3RcIiA/IE9iamVjdC5mcm9tRW50cmllcyhPYmplY3QuZW50cmllcyhvKS5tYXAoKFthLCBzXSkgPT4gW3QgKyBhLCBzXSkpIDogbyk7XG4gICAgcmV0dXJuIFtuLCBpXTtcbiAgfSkgOiBlO1xufVxuZnVuY3Rpb24gRHgoZSkge1xuICBpZiAoZSA8IDEpXG4gICAgcmV0dXJuIHtcbiAgICAgIGdldDogKCkgPT4ge1xuICAgICAgfSxcbiAgICAgIHNldDogKCkgPT4ge1xuICAgICAgfVxuICAgIH07XG4gIGxldCB0ID0gMCwgbiA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCksIHIgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICBmdW5jdGlvbiBpKG8sIGEpIHtcbiAgICBuLnNldChvLCBhKSwgdCsrLCB0ID4gZSAmJiAodCA9IDAsIHIgPSBuLCBuID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBnZXQobykge1xuICAgICAgbGV0IGEgPSBuLmdldChvKTtcbiAgICAgIGlmIChhICE9PSB2b2lkIDApXG4gICAgICAgIHJldHVybiBhO1xuICAgICAgaWYgKChhID0gci5nZXQobykpICE9PSB2b2lkIDApXG4gICAgICAgIHJldHVybiBpKG8sIGEpLCBhO1xuICAgIH0sXG4gICAgc2V0KG8sIGEpIHtcbiAgICAgIG4uaGFzKG8pID8gbi5zZXQobywgYSkgOiBpKG8sIGEpO1xuICAgIH1cbiAgfTtcbn1cbmNvbnN0IHZtID0gXCIhXCI7XG5mdW5jdGlvbiBOeChlKSB7XG4gIGNvbnN0IHQgPSBlLnNlcGFyYXRvciwgbiA9IHQubGVuZ3RoID09PSAxLCByID0gdFswXSwgaSA9IHQubGVuZ3RoO1xuICByZXR1cm4gZnVuY3Rpb24oYSkge1xuICAgIGNvbnN0IHMgPSBbXTtcbiAgICBsZXQgdSA9IDAsIGMgPSAwLCBmO1xuICAgIGZvciAobGV0IGggPSAwOyBoIDwgYS5sZW5ndGg7IGgrKykge1xuICAgICAgbGV0IHYgPSBhW2hdO1xuICAgICAgaWYgKHUgPT09IDApIHtcbiAgICAgICAgaWYgKHYgPT09IHIgJiYgKG4gfHwgYS5zbGljZShoLCBoICsgaSkgPT09IHQpKSB7XG4gICAgICAgICAgcy5wdXNoKGEuc2xpY2UoYywgaCkpLCBjID0gaCArIGk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHYgPT09IFwiL1wiKSB7XG4gICAgICAgICAgZiA9IGg7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHYgPT09IFwiW1wiID8gdSsrIDogdiA9PT0gXCJdXCIgJiYgdS0tO1xuICAgIH1cbiAgICBjb25zdCBsID0gcy5sZW5ndGggPT09IDAgPyBhIDogYS5zdWJzdHJpbmcoYyksIGQgPSBsLnN0YXJ0c1dpdGgodm0pLCBwID0gZCA/IGwuc3Vic3RyaW5nKDEpIDogbCwgZyA9IGYgJiYgZiA+IGMgPyBmIC0gYyA6IHZvaWQgMDtcbiAgICByZXR1cm4ge1xuICAgICAgbW9kaWZpZXJzOiBzLFxuICAgICAgaGFzSW1wb3J0YW50TW9kaWZpZXI6IGQsXG4gICAgICBiYXNlQ2xhc3NOYW1lOiBwLFxuICAgICAgbWF5YmVQb3N0Zml4TW9kaWZpZXJQb3NpdGlvbjogZ1xuICAgIH07XG4gIH07XG59XG5mdW5jdGlvbiBGeChlKSB7XG4gIGlmIChlLmxlbmd0aCA8PSAxKVxuICAgIHJldHVybiBlO1xuICBjb25zdCB0ID0gW107XG4gIGxldCBuID0gW107XG4gIHJldHVybiBlLmZvckVhY2goKHIpID0+IHtcbiAgICByWzBdID09PSBcIltcIiA/ICh0LnB1c2goLi4ubi5zb3J0KCksIHIpLCBuID0gW10pIDogbi5wdXNoKHIpO1xuICB9KSwgdC5wdXNoKC4uLm4uc29ydCgpKSwgdDtcbn1cbmZ1bmN0aW9uIEx4KGUpIHtcbiAgcmV0dXJuIHtcbiAgICBjYWNoZTogRHgoZS5jYWNoZVNpemUpLFxuICAgIHNwbGl0TW9kaWZpZXJzOiBOeChlKSxcbiAgICAuLi5NeChlKVxuICB9O1xufVxuY29uc3QgQnggPSAvXFxzKy87XG5mdW5jdGlvbiB6eChlLCB0KSB7XG4gIGNvbnN0IHtcbiAgICBzcGxpdE1vZGlmaWVyczogbixcbiAgICBnZXRDbGFzc0dyb3VwSWQ6IHIsXG4gICAgZ2V0Q29uZmxpY3RpbmdDbGFzc0dyb3VwSWRzOiBpXG4gIH0gPSB0LCBvID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgcmV0dXJuIGUudHJpbSgpLnNwbGl0KEJ4KS5tYXAoKGEpID0+IHtcbiAgICBjb25zdCB7XG4gICAgICBtb2RpZmllcnM6IHMsXG4gICAgICBoYXNJbXBvcnRhbnRNb2RpZmllcjogdSxcbiAgICAgIGJhc2VDbGFzc05hbWU6IGMsXG4gICAgICBtYXliZVBvc3RmaXhNb2RpZmllclBvc2l0aW9uOiBmXG4gICAgfSA9IG4oYSk7XG4gICAgbGV0IGwgPSByKGYgPyBjLnN1YnN0cmluZygwLCBmKSA6IGMpLCBkID0gISFmO1xuICAgIGlmICghbCkge1xuICAgICAgaWYgKCFmKVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGlzVGFpbHdpbmRDbGFzczogITEsXG4gICAgICAgICAgb3JpZ2luYWxDbGFzc05hbWU6IGFcbiAgICAgICAgfTtcbiAgICAgIGlmIChsID0gcihjKSwgIWwpXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgaXNUYWlsd2luZENsYXNzOiAhMSxcbiAgICAgICAgICBvcmlnaW5hbENsYXNzTmFtZTogYVxuICAgICAgICB9O1xuICAgICAgZCA9ICExO1xuICAgIH1cbiAgICBjb25zdCBwID0gRngocykuam9pbihcIjpcIik7XG4gICAgcmV0dXJuIHtcbiAgICAgIGlzVGFpbHdpbmRDbGFzczogITAsXG4gICAgICBtb2RpZmllcklkOiB1ID8gcCArIHZtIDogcCxcbiAgICAgIGNsYXNzR3JvdXBJZDogbCxcbiAgICAgIG9yaWdpbmFsQ2xhc3NOYW1lOiBhLFxuICAgICAgaGFzUG9zdGZpeE1vZGlmaWVyOiBkXG4gICAgfTtcbiAgfSkucmV2ZXJzZSgpLmZpbHRlcigoYSkgPT4ge1xuICAgIGlmICghYS5pc1RhaWx3aW5kQ2xhc3MpXG4gICAgICByZXR1cm4gITA7XG4gICAgY29uc3Qge1xuICAgICAgbW9kaWZpZXJJZDogcyxcbiAgICAgIGNsYXNzR3JvdXBJZDogdSxcbiAgICAgIGhhc1Bvc3RmaXhNb2RpZmllcjogY1xuICAgIH0gPSBhLCBmID0gcyArIHU7XG4gICAgcmV0dXJuIG8uaGFzKGYpID8gITEgOiAoby5hZGQoZiksIGkodSwgYykuZm9yRWFjaCgobCkgPT4gby5hZGQocyArIGwpKSwgITApO1xuICB9KS5yZXZlcnNlKCkubWFwKChhKSA9PiBhLm9yaWdpbmFsQ2xhc3NOYW1lKS5qb2luKFwiIFwiKTtcbn1cbmZ1bmN0aW9uIFZ4KCkge1xuICBsZXQgZSA9IDAsIHQsIG4sIHIgPSBcIlwiO1xuICBmb3IgKDsgZSA8IGFyZ3VtZW50cy5sZW5ndGg7IClcbiAgICAodCA9IGFyZ3VtZW50c1tlKytdKSAmJiAobiA9IG1tKHQpKSAmJiAociAmJiAociArPSBcIiBcIiksIHIgKz0gbik7XG4gIHJldHVybiByO1xufVxuZnVuY3Rpb24gbW0oZSkge1xuICBpZiAodHlwZW9mIGUgPT0gXCJzdHJpbmdcIilcbiAgICByZXR1cm4gZTtcbiAgbGV0IHQsIG4gPSBcIlwiO1xuICBmb3IgKGxldCByID0gMDsgciA8IGUubGVuZ3RoOyByKyspXG4gICAgZVtyXSAmJiAodCA9IG1tKGVbcl0pKSAmJiAobiAmJiAobiArPSBcIiBcIiksIG4gKz0gdCk7XG4gIHJldHVybiBuO1xufVxuZnVuY3Rpb24gR3goZSwgLi4udCkge1xuICBsZXQgbiwgciwgaSwgbyA9IGE7XG4gIGZ1bmN0aW9uIGEodSkge1xuICAgIGNvbnN0IGMgPSB0LnJlZHVjZSgoZiwgbCkgPT4gbChmKSwgZSgpKTtcbiAgICByZXR1cm4gbiA9IEx4KGMpLCByID0gbi5jYWNoZS5nZXQsIGkgPSBuLmNhY2hlLnNldCwgbyA9IHMsIHModSk7XG4gIH1cbiAgZnVuY3Rpb24gcyh1KSB7XG4gICAgY29uc3QgYyA9IHIodSk7XG4gICAgaWYgKGMpXG4gICAgICByZXR1cm4gYztcbiAgICBjb25zdCBmID0gengodSwgbik7XG4gICAgcmV0dXJuIGkodSwgZiksIGY7XG4gIH1cbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBvKFZ4LmFwcGx5KG51bGwsIGFyZ3VtZW50cykpO1xuICB9O1xufVxuZnVuY3Rpb24ga2UoZSkge1xuICBjb25zdCB0ID0gKG4pID0+IG5bZV0gfHwgW107XG4gIHJldHVybiB0LmlzVGhlbWVHZXR0ZXIgPSAhMCwgdDtcbn1cbmNvbnN0IHltID0gL15cXFsoPzooW2Etei1dKyk6KT8oLispXFxdJC9pLCBXeCA9IC9eXFxkK1xcL1xcZCskLywgVXggPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldChbXCJweFwiLCBcImZ1bGxcIiwgXCJzY3JlZW5cIl0pLCBIeCA9IC9eKFxcZCsoXFwuXFxkKyk/KT8oeHN8c218bWR8bGd8eGwpJC8sIHF4ID0gL1xcZCsoJXxweHxyP2VtfFtzZGxdP3YoW2h3aWJdfG1pbnxtYXgpfHB0fHBjfGlufGNtfG1tfGNhcHxjaHxleHxyP2xofGNxKHd8aHxpfGJ8bWlufG1heCkpfFxcYihjYWxjfG1pbnxtYXh8Y2xhbXApXFwoLitcXCl8XjAkLywgS3ggPSAvXihyZ2JhP3xoc2xhP3xod2J8KG9rKT8obGFifGxjaCkpXFwoLitcXCkkLywgWXggPSAvXihpbnNldF8pPy0/KChcXGQrKT9cXC4/KFxcZCspW2Etel0rfDApXy0/KChcXGQrKT9cXC4/KFxcZCspW2Etel0rfDApLywgWHggPSAvXih1cmx8aW1hZ2V8aW1hZ2Utc2V0fGNyb3NzLWZhZGV8ZWxlbWVudHwocmVwZWF0aW5nLSk/KGxpbmVhcnxyYWRpYWx8Y29uaWMpLWdyYWRpZW50KVxcKC4rXFwpJC87XG5mdW5jdGlvbiBwbihlKSB7XG4gIHJldHVybiBucihlKSB8fCBVeC5oYXMoZSkgfHwgV3gudGVzdChlKTtcbn1cbmZ1bmN0aW9uIFRuKGUpIHtcbiAgcmV0dXJuIGlpKGUsIFwibGVuZ3RoXCIsIGkxKTtcbn1cbmZ1bmN0aW9uIG5yKGUpIHtcbiAgcmV0dXJuICEhZSAmJiAhTnVtYmVyLmlzTmFOKE51bWJlcihlKSk7XG59XG5mdW5jdGlvbiBuYShlKSB7XG4gIHJldHVybiBpaShlLCBcIm51bWJlclwiLCBucik7XG59XG5mdW5jdGlvbiBDaShlKSB7XG4gIHJldHVybiAhIWUgJiYgTnVtYmVyLmlzSW50ZWdlcihOdW1iZXIoZSkpO1xufVxuZnVuY3Rpb24gWngoZSkge1xuICByZXR1cm4gZS5lbmRzV2l0aChcIiVcIikgJiYgbnIoZS5zbGljZSgwLCAtMSkpO1xufVxuZnVuY3Rpb24gZmUoZSkge1xuICByZXR1cm4geW0udGVzdChlKTtcbn1cbmZ1bmN0aW9uIE1uKGUpIHtcbiAgcmV0dXJuIEh4LnRlc3QoZSk7XG59XG5jb25zdCBKeCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KFtcImxlbmd0aFwiLCBcInNpemVcIiwgXCJwZXJjZW50YWdlXCJdKTtcbmZ1bmN0aW9uIFF4KGUpIHtcbiAgcmV0dXJuIGlpKGUsIEp4LCBibSk7XG59XG5mdW5jdGlvbiBlMShlKSB7XG4gIHJldHVybiBpaShlLCBcInBvc2l0aW9uXCIsIGJtKTtcbn1cbmNvbnN0IHQxID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoW1wiaW1hZ2VcIiwgXCJ1cmxcIl0pO1xuZnVuY3Rpb24gbjEoZSkge1xuICByZXR1cm4gaWkoZSwgdDEsIGExKTtcbn1cbmZ1bmN0aW9uIHIxKGUpIHtcbiAgcmV0dXJuIGlpKGUsIFwiXCIsIG8xKTtcbn1cbmZ1bmN0aW9uIEVpKCkge1xuICByZXR1cm4gITA7XG59XG5mdW5jdGlvbiBpaShlLCB0LCBuKSB7XG4gIGNvbnN0IHIgPSB5bS5leGVjKGUpO1xuICByZXR1cm4gciA/IHJbMV0gPyB0eXBlb2YgdCA9PSBcInN0cmluZ1wiID8gclsxXSA9PT0gdCA6IHQuaGFzKHJbMV0pIDogbihyWzJdKSA6ICExO1xufVxuZnVuY3Rpb24gaTEoZSkge1xuICByZXR1cm4gcXgudGVzdChlKSAmJiAhS3gudGVzdChlKTtcbn1cbmZ1bmN0aW9uIGJtKCkge1xuICByZXR1cm4gITE7XG59XG5mdW5jdGlvbiBvMShlKSB7XG4gIHJldHVybiBZeC50ZXN0KGUpO1xufVxuZnVuY3Rpb24gYTEoZSkge1xuICByZXR1cm4gWHgudGVzdChlKTtcbn1cbmZ1bmN0aW9uIHMxKCkge1xuICBjb25zdCBlID0ga2UoXCJjb2xvcnNcIiksIHQgPSBrZShcInNwYWNpbmdcIiksIG4gPSBrZShcImJsdXJcIiksIHIgPSBrZShcImJyaWdodG5lc3NcIiksIGkgPSBrZShcImJvcmRlckNvbG9yXCIpLCBvID0ga2UoXCJib3JkZXJSYWRpdXNcIiksIGEgPSBrZShcImJvcmRlclNwYWNpbmdcIiksIHMgPSBrZShcImJvcmRlcldpZHRoXCIpLCB1ID0ga2UoXCJjb250cmFzdFwiKSwgYyA9IGtlKFwiZ3JheXNjYWxlXCIpLCBmID0ga2UoXCJodWVSb3RhdGVcIiksIGwgPSBrZShcImludmVydFwiKSwgZCA9IGtlKFwiZ2FwXCIpLCBwID0ga2UoXCJncmFkaWVudENvbG9yU3RvcHNcIiksIGcgPSBrZShcImdyYWRpZW50Q29sb3JTdG9wUG9zaXRpb25zXCIpLCBoID0ga2UoXCJpbnNldFwiKSwgdiA9IGtlKFwibWFyZ2luXCIpLCB3ID0ga2UoXCJvcGFjaXR5XCIpLCBiID0ga2UoXCJwYWRkaW5nXCIpLCB4ID0ga2UoXCJzYXR1cmF0ZVwiKSwgbSA9IGtlKFwic2NhbGVcIiksIHkgPSBrZShcInNlcGlhXCIpLCBTID0ga2UoXCJza2V3XCIpLCAkID0ga2UoXCJzcGFjZVwiKSwgTyA9IGtlKFwidHJhbnNsYXRlXCIpLCBUID0gKCkgPT4gW1wiYXV0b1wiLCBcImNvbnRhaW5cIiwgXCJub25lXCJdLCBNID0gKCkgPT4gW1wiYXV0b1wiLCBcImhpZGRlblwiLCBcImNsaXBcIiwgXCJ2aXNpYmxlXCIsIFwic2Nyb2xsXCJdLCBFID0gKCkgPT4gW1wiYXV0b1wiLCBmZSwgdF0sIEEgPSAoKSA9PiBbZmUsIHRdLCBqID0gKCkgPT4gW1wiXCIsIHBuLCBUbl0sIFIgPSAoKSA9PiBbXCJhdXRvXCIsIG5yLCBmZV0sIE4gPSAoKSA9PiBbXCJib3R0b21cIiwgXCJjZW50ZXJcIiwgXCJsZWZ0XCIsIFwibGVmdC1ib3R0b21cIiwgXCJsZWZ0LXRvcFwiLCBcInJpZ2h0XCIsIFwicmlnaHQtYm90dG9tXCIsIFwicmlnaHQtdG9wXCIsIFwidG9wXCJdLCBrID0gKCkgPT4gW1wic29saWRcIiwgXCJkYXNoZWRcIiwgXCJkb3R0ZWRcIiwgXCJkb3VibGVcIiwgXCJub25lXCJdLCBGID0gKCkgPT4gW1wibm9ybWFsXCIsIFwibXVsdGlwbHlcIiwgXCJzY3JlZW5cIiwgXCJvdmVybGF5XCIsIFwiZGFya2VuXCIsIFwibGlnaHRlblwiLCBcImNvbG9yLWRvZGdlXCIsIFwiY29sb3ItYnVyblwiLCBcImhhcmQtbGlnaHRcIiwgXCJzb2Z0LWxpZ2h0XCIsIFwiZGlmZmVyZW5jZVwiLCBcImV4Y2x1c2lvblwiLCBcImh1ZVwiLCBcInNhdHVyYXRpb25cIiwgXCJjb2xvclwiLCBcImx1bWlub3NpdHlcIl0sIFYgPSAoKSA9PiBbXCJzdGFydFwiLCBcImVuZFwiLCBcImNlbnRlclwiLCBcImJldHdlZW5cIiwgXCJhcm91bmRcIiwgXCJldmVubHlcIiwgXCJzdHJldGNoXCJdLCBMID0gKCkgPT4gW1wiXCIsIFwiMFwiLCBmZV0sIEkgPSAoKSA9PiBbXCJhdXRvXCIsIFwiYXZvaWRcIiwgXCJhbGxcIiwgXCJhdm9pZC1wYWdlXCIsIFwicGFnZVwiLCBcImxlZnRcIiwgXCJyaWdodFwiLCBcImNvbHVtblwiXSwgRCA9ICgpID0+IFtuciwgbmFdLCBHID0gKCkgPT4gW25yLCBmZV07XG4gIHJldHVybiB7XG4gICAgY2FjaGVTaXplOiA1MDAsXG4gICAgc2VwYXJhdG9yOiBcIjpcIixcbiAgICB0aGVtZToge1xuICAgICAgY29sb3JzOiBbRWldLFxuICAgICAgc3BhY2luZzogW3BuLCBUbl0sXG4gICAgICBibHVyOiBbXCJub25lXCIsIFwiXCIsIE1uLCBmZV0sXG4gICAgICBicmlnaHRuZXNzOiBEKCksXG4gICAgICBib3JkZXJDb2xvcjogW2VdLFxuICAgICAgYm9yZGVyUmFkaXVzOiBbXCJub25lXCIsIFwiXCIsIFwiZnVsbFwiLCBNbiwgZmVdLFxuICAgICAgYm9yZGVyU3BhY2luZzogQSgpLFxuICAgICAgYm9yZGVyV2lkdGg6IGooKSxcbiAgICAgIGNvbnRyYXN0OiBEKCksXG4gICAgICBncmF5c2NhbGU6IEwoKSxcbiAgICAgIGh1ZVJvdGF0ZTogRygpLFxuICAgICAgaW52ZXJ0OiBMKCksXG4gICAgICBnYXA6IEEoKSxcbiAgICAgIGdyYWRpZW50Q29sb3JTdG9wczogW2VdLFxuICAgICAgZ3JhZGllbnRDb2xvclN0b3BQb3NpdGlvbnM6IFtaeCwgVG5dLFxuICAgICAgaW5zZXQ6IEUoKSxcbiAgICAgIG1hcmdpbjogRSgpLFxuICAgICAgb3BhY2l0eTogRCgpLFxuICAgICAgcGFkZGluZzogQSgpLFxuICAgICAgc2F0dXJhdGU6IEQoKSxcbiAgICAgIHNjYWxlOiBEKCksXG4gICAgICBzZXBpYTogTCgpLFxuICAgICAgc2tldzogRygpLFxuICAgICAgc3BhY2U6IEEoKSxcbiAgICAgIHRyYW5zbGF0ZTogQSgpXG4gICAgfSxcbiAgICBjbGFzc0dyb3Vwczoge1xuICAgICAgLy8gTGF5b3V0XG4gICAgICAvKipcbiAgICAgICAqIEFzcGVjdCBSYXRpb1xuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2FzcGVjdC1yYXRpb1xuICAgICAgICovXG4gICAgICBhc3BlY3Q6IFt7XG4gICAgICAgIGFzcGVjdDogW1wiYXV0b1wiLCBcInNxdWFyZVwiLCBcInZpZGVvXCIsIGZlXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIENvbnRhaW5lclxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2NvbnRhaW5lclxuICAgICAgICovXG4gICAgICBjb250YWluZXI6IFtcImNvbnRhaW5lclwiXSxcbiAgICAgIC8qKlxuICAgICAgICogQ29sdW1uc1xuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2NvbHVtbnNcbiAgICAgICAqL1xuICAgICAgY29sdW1uczogW3tcbiAgICAgICAgY29sdW1uczogW01uXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIEJyZWFrIEFmdGVyXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvYnJlYWstYWZ0ZXJcbiAgICAgICAqL1xuICAgICAgXCJicmVhay1hZnRlclwiOiBbe1xuICAgICAgICBcImJyZWFrLWFmdGVyXCI6IEkoKVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIEJyZWFrIEJlZm9yZVxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2JyZWFrLWJlZm9yZVxuICAgICAgICovXG4gICAgICBcImJyZWFrLWJlZm9yZVwiOiBbe1xuICAgICAgICBcImJyZWFrLWJlZm9yZVwiOiBJKClcbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBCcmVhayBJbnNpZGVcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9icmVhay1pbnNpZGVcbiAgICAgICAqL1xuICAgICAgXCJicmVhay1pbnNpZGVcIjogW3tcbiAgICAgICAgXCJicmVhay1pbnNpZGVcIjogW1wiYXV0b1wiLCBcImF2b2lkXCIsIFwiYXZvaWQtcGFnZVwiLCBcImF2b2lkLWNvbHVtblwiXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIEJveCBEZWNvcmF0aW9uIEJyZWFrXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvYm94LWRlY29yYXRpb24tYnJlYWtcbiAgICAgICAqL1xuICAgICAgXCJib3gtZGVjb3JhdGlvblwiOiBbe1xuICAgICAgICBcImJveC1kZWNvcmF0aW9uXCI6IFtcInNsaWNlXCIsIFwiY2xvbmVcIl1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBCb3ggU2l6aW5nXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvYm94LXNpemluZ1xuICAgICAgICovXG4gICAgICBib3g6IFt7XG4gICAgICAgIGJveDogW1wiYm9yZGVyXCIsIFwiY29udGVudFwiXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIERpc3BsYXlcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9kaXNwbGF5XG4gICAgICAgKi9cbiAgICAgIGRpc3BsYXk6IFtcImJsb2NrXCIsIFwiaW5saW5lLWJsb2NrXCIsIFwiaW5saW5lXCIsIFwiZmxleFwiLCBcImlubGluZS1mbGV4XCIsIFwidGFibGVcIiwgXCJpbmxpbmUtdGFibGVcIiwgXCJ0YWJsZS1jYXB0aW9uXCIsIFwidGFibGUtY2VsbFwiLCBcInRhYmxlLWNvbHVtblwiLCBcInRhYmxlLWNvbHVtbi1ncm91cFwiLCBcInRhYmxlLWZvb3Rlci1ncm91cFwiLCBcInRhYmxlLWhlYWRlci1ncm91cFwiLCBcInRhYmxlLXJvdy1ncm91cFwiLCBcInRhYmxlLXJvd1wiLCBcImZsb3ctcm9vdFwiLCBcImdyaWRcIiwgXCJpbmxpbmUtZ3JpZFwiLCBcImNvbnRlbnRzXCIsIFwibGlzdC1pdGVtXCIsIFwiaGlkZGVuXCJdLFxuICAgICAgLyoqXG4gICAgICAgKiBGbG9hdHNcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9mbG9hdFxuICAgICAgICovXG4gICAgICBmbG9hdDogW3tcbiAgICAgICAgZmxvYXQ6IFtcInJpZ2h0XCIsIFwibGVmdFwiLCBcIm5vbmVcIiwgXCJzdGFydFwiLCBcImVuZFwiXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIENsZWFyXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvY2xlYXJcbiAgICAgICAqL1xuICAgICAgY2xlYXI6IFt7XG4gICAgICAgIGNsZWFyOiBbXCJsZWZ0XCIsIFwicmlnaHRcIiwgXCJib3RoXCIsIFwibm9uZVwiLCBcInN0YXJ0XCIsIFwiZW5kXCJdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogSXNvbGF0aW9uXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvaXNvbGF0aW9uXG4gICAgICAgKi9cbiAgICAgIGlzb2xhdGlvbjogW1wiaXNvbGF0ZVwiLCBcImlzb2xhdGlvbi1hdXRvXCJdLFxuICAgICAgLyoqXG4gICAgICAgKiBPYmplY3QgRml0XG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3Mvb2JqZWN0LWZpdFxuICAgICAgICovXG4gICAgICBcIm9iamVjdC1maXRcIjogW3tcbiAgICAgICAgb2JqZWN0OiBbXCJjb250YWluXCIsIFwiY292ZXJcIiwgXCJmaWxsXCIsIFwibm9uZVwiLCBcInNjYWxlLWRvd25cIl1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBPYmplY3QgUG9zaXRpb25cbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9vYmplY3QtcG9zaXRpb25cbiAgICAgICAqL1xuICAgICAgXCJvYmplY3QtcG9zaXRpb25cIjogW3tcbiAgICAgICAgb2JqZWN0OiBbLi4uTigpLCBmZV1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBPdmVyZmxvd1xuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL292ZXJmbG93XG4gICAgICAgKi9cbiAgICAgIG92ZXJmbG93OiBbe1xuICAgICAgICBvdmVyZmxvdzogTSgpXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogT3ZlcmZsb3cgWFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL292ZXJmbG93XG4gICAgICAgKi9cbiAgICAgIFwib3ZlcmZsb3cteFwiOiBbe1xuICAgICAgICBcIm92ZXJmbG93LXhcIjogTSgpXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogT3ZlcmZsb3cgWVxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL292ZXJmbG93XG4gICAgICAgKi9cbiAgICAgIFwib3ZlcmZsb3cteVwiOiBbe1xuICAgICAgICBcIm92ZXJmbG93LXlcIjogTSgpXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogT3ZlcnNjcm9sbCBCZWhhdmlvclxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL292ZXJzY3JvbGwtYmVoYXZpb3JcbiAgICAgICAqL1xuICAgICAgb3ZlcnNjcm9sbDogW3tcbiAgICAgICAgb3ZlcnNjcm9sbDogVCgpXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogT3ZlcnNjcm9sbCBCZWhhdmlvciBYXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3Mvb3ZlcnNjcm9sbC1iZWhhdmlvclxuICAgICAgICovXG4gICAgICBcIm92ZXJzY3JvbGwteFwiOiBbe1xuICAgICAgICBcIm92ZXJzY3JvbGwteFwiOiBUKClcbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBPdmVyc2Nyb2xsIEJlaGF2aW9yIFlcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9vdmVyc2Nyb2xsLWJlaGF2aW9yXG4gICAgICAgKi9cbiAgICAgIFwib3ZlcnNjcm9sbC15XCI6IFt7XG4gICAgICAgIFwib3ZlcnNjcm9sbC15XCI6IFQoKVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIFBvc2l0aW9uXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvcG9zaXRpb25cbiAgICAgICAqL1xuICAgICAgcG9zaXRpb246IFtcInN0YXRpY1wiLCBcImZpeGVkXCIsIFwiYWJzb2x1dGVcIiwgXCJyZWxhdGl2ZVwiLCBcInN0aWNreVwiXSxcbiAgICAgIC8qKlxuICAgICAgICogVG9wIC8gUmlnaHQgLyBCb3R0b20gLyBMZWZ0XG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvdG9wLXJpZ2h0LWJvdHRvbS1sZWZ0XG4gICAgICAgKi9cbiAgICAgIGluc2V0OiBbe1xuICAgICAgICBpbnNldDogW2hdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogUmlnaHQgLyBMZWZ0XG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvdG9wLXJpZ2h0LWJvdHRvbS1sZWZ0XG4gICAgICAgKi9cbiAgICAgIFwiaW5zZXQteFwiOiBbe1xuICAgICAgICBcImluc2V0LXhcIjogW2hdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogVG9wIC8gQm90dG9tXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvdG9wLXJpZ2h0LWJvdHRvbS1sZWZ0XG4gICAgICAgKi9cbiAgICAgIFwiaW5zZXQteVwiOiBbe1xuICAgICAgICBcImluc2V0LXlcIjogW2hdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogU3RhcnRcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy90b3AtcmlnaHQtYm90dG9tLWxlZnRcbiAgICAgICAqL1xuICAgICAgc3RhcnQ6IFt7XG4gICAgICAgIHN0YXJ0OiBbaF1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBFbmRcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy90b3AtcmlnaHQtYm90dG9tLWxlZnRcbiAgICAgICAqL1xuICAgICAgZW5kOiBbe1xuICAgICAgICBlbmQ6IFtoXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIFRvcFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3RvcC1yaWdodC1ib3R0b20tbGVmdFxuICAgICAgICovXG4gICAgICB0b3A6IFt7XG4gICAgICAgIHRvcDogW2hdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogUmlnaHRcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy90b3AtcmlnaHQtYm90dG9tLWxlZnRcbiAgICAgICAqL1xuICAgICAgcmlnaHQ6IFt7XG4gICAgICAgIHJpZ2h0OiBbaF1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBCb3R0b21cbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy90b3AtcmlnaHQtYm90dG9tLWxlZnRcbiAgICAgICAqL1xuICAgICAgYm90dG9tOiBbe1xuICAgICAgICBib3R0b206IFtoXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIExlZnRcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy90b3AtcmlnaHQtYm90dG9tLWxlZnRcbiAgICAgICAqL1xuICAgICAgbGVmdDogW3tcbiAgICAgICAgbGVmdDogW2hdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogVmlzaWJpbGl0eVxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3Zpc2liaWxpdHlcbiAgICAgICAqL1xuICAgICAgdmlzaWJpbGl0eTogW1widmlzaWJsZVwiLCBcImludmlzaWJsZVwiLCBcImNvbGxhcHNlXCJdLFxuICAgICAgLyoqXG4gICAgICAgKiBaLUluZGV4XG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3Mvei1pbmRleFxuICAgICAgICovXG4gICAgICB6OiBbe1xuICAgICAgICB6OiBbXCJhdXRvXCIsIENpLCBmZV1cbiAgICAgIH1dLFxuICAgICAgLy8gRmxleGJveCBhbmQgR3JpZFxuICAgICAgLyoqXG4gICAgICAgKiBGbGV4IEJhc2lzXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvZmxleC1iYXNpc1xuICAgICAgICovXG4gICAgICBiYXNpczogW3tcbiAgICAgICAgYmFzaXM6IEUoKVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIEZsZXggRGlyZWN0aW9uXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvZmxleC1kaXJlY3Rpb25cbiAgICAgICAqL1xuICAgICAgXCJmbGV4LWRpcmVjdGlvblwiOiBbe1xuICAgICAgICBmbGV4OiBbXCJyb3dcIiwgXCJyb3ctcmV2ZXJzZVwiLCBcImNvbFwiLCBcImNvbC1yZXZlcnNlXCJdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogRmxleCBXcmFwXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvZmxleC13cmFwXG4gICAgICAgKi9cbiAgICAgIFwiZmxleC13cmFwXCI6IFt7XG4gICAgICAgIGZsZXg6IFtcIndyYXBcIiwgXCJ3cmFwLXJldmVyc2VcIiwgXCJub3dyYXBcIl1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBGbGV4XG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvZmxleFxuICAgICAgICovXG4gICAgICBmbGV4OiBbe1xuICAgICAgICBmbGV4OiBbXCIxXCIsIFwiYXV0b1wiLCBcImluaXRpYWxcIiwgXCJub25lXCIsIGZlXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIEZsZXggR3Jvd1xuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2ZsZXgtZ3Jvd1xuICAgICAgICovXG4gICAgICBncm93OiBbe1xuICAgICAgICBncm93OiBMKClcbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBGbGV4IFNocmlua1xuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2ZsZXgtc2hyaW5rXG4gICAgICAgKi9cbiAgICAgIHNocmluazogW3tcbiAgICAgICAgc2hyaW5rOiBMKClcbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBPcmRlclxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL29yZGVyXG4gICAgICAgKi9cbiAgICAgIG9yZGVyOiBbe1xuICAgICAgICBvcmRlcjogW1wiZmlyc3RcIiwgXCJsYXN0XCIsIFwibm9uZVwiLCBDaSwgZmVdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogR3JpZCBUZW1wbGF0ZSBDb2x1bW5zXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvZ3JpZC10ZW1wbGF0ZS1jb2x1bW5zXG4gICAgICAgKi9cbiAgICAgIFwiZ3JpZC1jb2xzXCI6IFt7XG4gICAgICAgIFwiZ3JpZC1jb2xzXCI6IFtFaV1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBHcmlkIENvbHVtbiBTdGFydCAvIEVuZFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2dyaWQtY29sdW1uXG4gICAgICAgKi9cbiAgICAgIFwiY29sLXN0YXJ0LWVuZFwiOiBbe1xuICAgICAgICBjb2w6IFtcImF1dG9cIiwge1xuICAgICAgICAgIHNwYW46IFtcImZ1bGxcIiwgQ2ksIGZlXVxuICAgICAgICB9LCBmZV1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBHcmlkIENvbHVtbiBTdGFydFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2dyaWQtY29sdW1uXG4gICAgICAgKi9cbiAgICAgIFwiY29sLXN0YXJ0XCI6IFt7XG4gICAgICAgIFwiY29sLXN0YXJ0XCI6IFIoKVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIEdyaWQgQ29sdW1uIEVuZFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2dyaWQtY29sdW1uXG4gICAgICAgKi9cbiAgICAgIFwiY29sLWVuZFwiOiBbe1xuICAgICAgICBcImNvbC1lbmRcIjogUigpXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogR3JpZCBUZW1wbGF0ZSBSb3dzXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvZ3JpZC10ZW1wbGF0ZS1yb3dzXG4gICAgICAgKi9cbiAgICAgIFwiZ3JpZC1yb3dzXCI6IFt7XG4gICAgICAgIFwiZ3JpZC1yb3dzXCI6IFtFaV1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBHcmlkIFJvdyBTdGFydCAvIEVuZFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2dyaWQtcm93XG4gICAgICAgKi9cbiAgICAgIFwicm93LXN0YXJ0LWVuZFwiOiBbe1xuICAgICAgICByb3c6IFtcImF1dG9cIiwge1xuICAgICAgICAgIHNwYW46IFtDaSwgZmVdXG4gICAgICAgIH0sIGZlXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIEdyaWQgUm93IFN0YXJ0XG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvZ3JpZC1yb3dcbiAgICAgICAqL1xuICAgICAgXCJyb3ctc3RhcnRcIjogW3tcbiAgICAgICAgXCJyb3ctc3RhcnRcIjogUigpXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogR3JpZCBSb3cgRW5kXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvZ3JpZC1yb3dcbiAgICAgICAqL1xuICAgICAgXCJyb3ctZW5kXCI6IFt7XG4gICAgICAgIFwicm93LWVuZFwiOiBSKClcbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBHcmlkIEF1dG8gRmxvd1xuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2dyaWQtYXV0by1mbG93XG4gICAgICAgKi9cbiAgICAgIFwiZ3JpZC1mbG93XCI6IFt7XG4gICAgICAgIFwiZ3JpZC1mbG93XCI6IFtcInJvd1wiLCBcImNvbFwiLCBcImRlbnNlXCIsIFwicm93LWRlbnNlXCIsIFwiY29sLWRlbnNlXCJdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogR3JpZCBBdXRvIENvbHVtbnNcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9ncmlkLWF1dG8tY29sdW1uc1xuICAgICAgICovXG4gICAgICBcImF1dG8tY29sc1wiOiBbe1xuICAgICAgICBcImF1dG8tY29sc1wiOiBbXCJhdXRvXCIsIFwibWluXCIsIFwibWF4XCIsIFwiZnJcIiwgZmVdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogR3JpZCBBdXRvIFJvd3NcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9ncmlkLWF1dG8tcm93c1xuICAgICAgICovXG4gICAgICBcImF1dG8tcm93c1wiOiBbe1xuICAgICAgICBcImF1dG8tcm93c1wiOiBbXCJhdXRvXCIsIFwibWluXCIsIFwibWF4XCIsIFwiZnJcIiwgZmVdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogR2FwXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvZ2FwXG4gICAgICAgKi9cbiAgICAgIGdhcDogW3tcbiAgICAgICAgZ2FwOiBbZF1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBHYXAgWFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2dhcFxuICAgICAgICovXG4gICAgICBcImdhcC14XCI6IFt7XG4gICAgICAgIFwiZ2FwLXhcIjogW2RdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogR2FwIFlcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9nYXBcbiAgICAgICAqL1xuICAgICAgXCJnYXAteVwiOiBbe1xuICAgICAgICBcImdhcC15XCI6IFtkXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIEp1c3RpZnkgQ29udGVudFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2p1c3RpZnktY29udGVudFxuICAgICAgICovXG4gICAgICBcImp1c3RpZnktY29udGVudFwiOiBbe1xuICAgICAgICBqdXN0aWZ5OiBbXCJub3JtYWxcIiwgLi4uVigpXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIEp1c3RpZnkgSXRlbXNcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9qdXN0aWZ5LWl0ZW1zXG4gICAgICAgKi9cbiAgICAgIFwianVzdGlmeS1pdGVtc1wiOiBbe1xuICAgICAgICBcImp1c3RpZnktaXRlbXNcIjogW1wic3RhcnRcIiwgXCJlbmRcIiwgXCJjZW50ZXJcIiwgXCJzdHJldGNoXCJdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogSnVzdGlmeSBTZWxmXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvanVzdGlmeS1zZWxmXG4gICAgICAgKi9cbiAgICAgIFwianVzdGlmeS1zZWxmXCI6IFt7XG4gICAgICAgIFwianVzdGlmeS1zZWxmXCI6IFtcImF1dG9cIiwgXCJzdGFydFwiLCBcImVuZFwiLCBcImNlbnRlclwiLCBcInN0cmV0Y2hcIl1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBBbGlnbiBDb250ZW50XG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvYWxpZ24tY29udGVudFxuICAgICAgICovXG4gICAgICBcImFsaWduLWNvbnRlbnRcIjogW3tcbiAgICAgICAgY29udGVudDogW1wibm9ybWFsXCIsIC4uLlYoKSwgXCJiYXNlbGluZVwiXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIEFsaWduIEl0ZW1zXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvYWxpZ24taXRlbXNcbiAgICAgICAqL1xuICAgICAgXCJhbGlnbi1pdGVtc1wiOiBbe1xuICAgICAgICBpdGVtczogW1wic3RhcnRcIiwgXCJlbmRcIiwgXCJjZW50ZXJcIiwgXCJiYXNlbGluZVwiLCBcInN0cmV0Y2hcIl1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBBbGlnbiBTZWxmXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvYWxpZ24tc2VsZlxuICAgICAgICovXG4gICAgICBcImFsaWduLXNlbGZcIjogW3tcbiAgICAgICAgc2VsZjogW1wiYXV0b1wiLCBcInN0YXJ0XCIsIFwiZW5kXCIsIFwiY2VudGVyXCIsIFwic3RyZXRjaFwiLCBcImJhc2VsaW5lXCJdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogUGxhY2UgQ29udGVudFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3BsYWNlLWNvbnRlbnRcbiAgICAgICAqL1xuICAgICAgXCJwbGFjZS1jb250ZW50XCI6IFt7XG4gICAgICAgIFwicGxhY2UtY29udGVudFwiOiBbLi4uVigpLCBcImJhc2VsaW5lXCJdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogUGxhY2UgSXRlbXNcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9wbGFjZS1pdGVtc1xuICAgICAgICovXG4gICAgICBcInBsYWNlLWl0ZW1zXCI6IFt7XG4gICAgICAgIFwicGxhY2UtaXRlbXNcIjogW1wic3RhcnRcIiwgXCJlbmRcIiwgXCJjZW50ZXJcIiwgXCJiYXNlbGluZVwiLCBcInN0cmV0Y2hcIl1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBQbGFjZSBTZWxmXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvcGxhY2Utc2VsZlxuICAgICAgICovXG4gICAgICBcInBsYWNlLXNlbGZcIjogW3tcbiAgICAgICAgXCJwbGFjZS1zZWxmXCI6IFtcImF1dG9cIiwgXCJzdGFydFwiLCBcImVuZFwiLCBcImNlbnRlclwiLCBcInN0cmV0Y2hcIl1cbiAgICAgIH1dLFxuICAgICAgLy8gU3BhY2luZ1xuICAgICAgLyoqXG4gICAgICAgKiBQYWRkaW5nXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvcGFkZGluZ1xuICAgICAgICovXG4gICAgICBwOiBbe1xuICAgICAgICBwOiBbYl1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBQYWRkaW5nIFhcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9wYWRkaW5nXG4gICAgICAgKi9cbiAgICAgIHB4OiBbe1xuICAgICAgICBweDogW2JdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogUGFkZGluZyBZXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvcGFkZGluZ1xuICAgICAgICovXG4gICAgICBweTogW3tcbiAgICAgICAgcHk6IFtiXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIFBhZGRpbmcgU3RhcnRcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9wYWRkaW5nXG4gICAgICAgKi9cbiAgICAgIHBzOiBbe1xuICAgICAgICBwczogW2JdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogUGFkZGluZyBFbmRcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9wYWRkaW5nXG4gICAgICAgKi9cbiAgICAgIHBlOiBbe1xuICAgICAgICBwZTogW2JdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogUGFkZGluZyBUb3BcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9wYWRkaW5nXG4gICAgICAgKi9cbiAgICAgIHB0OiBbe1xuICAgICAgICBwdDogW2JdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogUGFkZGluZyBSaWdodFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3BhZGRpbmdcbiAgICAgICAqL1xuICAgICAgcHI6IFt7XG4gICAgICAgIHByOiBbYl1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBQYWRkaW5nIEJvdHRvbVxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3BhZGRpbmdcbiAgICAgICAqL1xuICAgICAgcGI6IFt7XG4gICAgICAgIHBiOiBbYl1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBQYWRkaW5nIExlZnRcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9wYWRkaW5nXG4gICAgICAgKi9cbiAgICAgIHBsOiBbe1xuICAgICAgICBwbDogW2JdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogTWFyZ2luXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvbWFyZ2luXG4gICAgICAgKi9cbiAgICAgIG06IFt7XG4gICAgICAgIG06IFt2XVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIE1hcmdpbiBYXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvbWFyZ2luXG4gICAgICAgKi9cbiAgICAgIG14OiBbe1xuICAgICAgICBteDogW3ZdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogTWFyZ2luIFlcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9tYXJnaW5cbiAgICAgICAqL1xuICAgICAgbXk6IFt7XG4gICAgICAgIG15OiBbdl1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBNYXJnaW4gU3RhcnRcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9tYXJnaW5cbiAgICAgICAqL1xuICAgICAgbXM6IFt7XG4gICAgICAgIG1zOiBbdl1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBNYXJnaW4gRW5kXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvbWFyZ2luXG4gICAgICAgKi9cbiAgICAgIG1lOiBbe1xuICAgICAgICBtZTogW3ZdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogTWFyZ2luIFRvcFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL21hcmdpblxuICAgICAgICovXG4gICAgICBtdDogW3tcbiAgICAgICAgbXQ6IFt2XVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIE1hcmdpbiBSaWdodFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL21hcmdpblxuICAgICAgICovXG4gICAgICBtcjogW3tcbiAgICAgICAgbXI6IFt2XVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIE1hcmdpbiBCb3R0b21cbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9tYXJnaW5cbiAgICAgICAqL1xuICAgICAgbWI6IFt7XG4gICAgICAgIG1iOiBbdl1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBNYXJnaW4gTGVmdFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL21hcmdpblxuICAgICAgICovXG4gICAgICBtbDogW3tcbiAgICAgICAgbWw6IFt2XVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIFNwYWNlIEJldHdlZW4gWFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3NwYWNlXG4gICAgICAgKi9cbiAgICAgIFwic3BhY2UteFwiOiBbe1xuICAgICAgICBcInNwYWNlLXhcIjogWyRdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogU3BhY2UgQmV0d2VlbiBYIFJldmVyc2VcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9zcGFjZVxuICAgICAgICovXG4gICAgICBcInNwYWNlLXgtcmV2ZXJzZVwiOiBbXCJzcGFjZS14LXJldmVyc2VcIl0sXG4gICAgICAvKipcbiAgICAgICAqIFNwYWNlIEJldHdlZW4gWVxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3NwYWNlXG4gICAgICAgKi9cbiAgICAgIFwic3BhY2UteVwiOiBbe1xuICAgICAgICBcInNwYWNlLXlcIjogWyRdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogU3BhY2UgQmV0d2VlbiBZIFJldmVyc2VcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9zcGFjZVxuICAgICAgICovXG4gICAgICBcInNwYWNlLXktcmV2ZXJzZVwiOiBbXCJzcGFjZS15LXJldmVyc2VcIl0sXG4gICAgICAvLyBTaXppbmdcbiAgICAgIC8qKlxuICAgICAgICogV2lkdGhcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy93aWR0aFxuICAgICAgICovXG4gICAgICB3OiBbe1xuICAgICAgICB3OiBbXCJhdXRvXCIsIFwibWluXCIsIFwibWF4XCIsIFwiZml0XCIsIFwic3Z3XCIsIFwibHZ3XCIsIFwiZHZ3XCIsIGZlLCB0XVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIE1pbi1XaWR0aFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL21pbi13aWR0aFxuICAgICAgICovXG4gICAgICBcIm1pbi13XCI6IFt7XG4gICAgICAgIFwibWluLXdcIjogW2ZlLCB0LCBcIm1pblwiLCBcIm1heFwiLCBcImZpdFwiXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIE1heC1XaWR0aFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL21heC13aWR0aFxuICAgICAgICovXG4gICAgICBcIm1heC13XCI6IFt7XG4gICAgICAgIFwibWF4LXdcIjogW2ZlLCB0LCBcIm5vbmVcIiwgXCJmdWxsXCIsIFwibWluXCIsIFwibWF4XCIsIFwiZml0XCIsIFwicHJvc2VcIiwge1xuICAgICAgICAgIHNjcmVlbjogW01uXVxuICAgICAgICB9LCBNbl1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBIZWlnaHRcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9oZWlnaHRcbiAgICAgICAqL1xuICAgICAgaDogW3tcbiAgICAgICAgaDogW2ZlLCB0LCBcImF1dG9cIiwgXCJtaW5cIiwgXCJtYXhcIiwgXCJmaXRcIiwgXCJzdmhcIiwgXCJsdmhcIiwgXCJkdmhcIl1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBNaW4tSGVpZ2h0XG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvbWluLWhlaWdodFxuICAgICAgICovXG4gICAgICBcIm1pbi1oXCI6IFt7XG4gICAgICAgIFwibWluLWhcIjogW2ZlLCB0LCBcIm1pblwiLCBcIm1heFwiLCBcImZpdFwiLCBcInN2aFwiLCBcImx2aFwiLCBcImR2aFwiXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIE1heC1IZWlnaHRcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9tYXgtaGVpZ2h0XG4gICAgICAgKi9cbiAgICAgIFwibWF4LWhcIjogW3tcbiAgICAgICAgXCJtYXgtaFwiOiBbZmUsIHQsIFwibWluXCIsIFwibWF4XCIsIFwiZml0XCIsIFwic3ZoXCIsIFwibHZoXCIsIFwiZHZoXCJdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogU2l6ZVxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3NpemVcbiAgICAgICAqL1xuICAgICAgc2l6ZTogW3tcbiAgICAgICAgc2l6ZTogW2ZlLCB0LCBcImF1dG9cIiwgXCJtaW5cIiwgXCJtYXhcIiwgXCJmaXRcIl1cbiAgICAgIH1dLFxuICAgICAgLy8gVHlwb2dyYXBoeVxuICAgICAgLyoqXG4gICAgICAgKiBGb250IFNpemVcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9mb250LXNpemVcbiAgICAgICAqL1xuICAgICAgXCJmb250LXNpemVcIjogW3tcbiAgICAgICAgdGV4dDogW1wiYmFzZVwiLCBNbiwgVG5dXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogRm9udCBTbW9vdGhpbmdcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9mb250LXNtb290aGluZ1xuICAgICAgICovXG4gICAgICBcImZvbnQtc21vb3RoaW5nXCI6IFtcImFudGlhbGlhc2VkXCIsIFwic3VicGl4ZWwtYW50aWFsaWFzZWRcIl0sXG4gICAgICAvKipcbiAgICAgICAqIEZvbnQgU3R5bGVcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9mb250LXN0eWxlXG4gICAgICAgKi9cbiAgICAgIFwiZm9udC1zdHlsZVwiOiBbXCJpdGFsaWNcIiwgXCJub3QtaXRhbGljXCJdLFxuICAgICAgLyoqXG4gICAgICAgKiBGb250IFdlaWdodFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2ZvbnQtd2VpZ2h0XG4gICAgICAgKi9cbiAgICAgIFwiZm9udC13ZWlnaHRcIjogW3tcbiAgICAgICAgZm9udDogW1widGhpblwiLCBcImV4dHJhbGlnaHRcIiwgXCJsaWdodFwiLCBcIm5vcm1hbFwiLCBcIm1lZGl1bVwiLCBcInNlbWlib2xkXCIsIFwiYm9sZFwiLCBcImV4dHJhYm9sZFwiLCBcImJsYWNrXCIsIG5hXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIEZvbnQgRmFtaWx5XG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvZm9udC1mYW1pbHlcbiAgICAgICAqL1xuICAgICAgXCJmb250LWZhbWlseVwiOiBbe1xuICAgICAgICBmb250OiBbRWldXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogRm9udCBWYXJpYW50IE51bWVyaWNcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9mb250LXZhcmlhbnQtbnVtZXJpY1xuICAgICAgICovXG4gICAgICBcImZ2bi1ub3JtYWxcIjogW1wibm9ybWFsLW51bXNcIl0sXG4gICAgICAvKipcbiAgICAgICAqIEZvbnQgVmFyaWFudCBOdW1lcmljXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvZm9udC12YXJpYW50LW51bWVyaWNcbiAgICAgICAqL1xuICAgICAgXCJmdm4tb3JkaW5hbFwiOiBbXCJvcmRpbmFsXCJdLFxuICAgICAgLyoqXG4gICAgICAgKiBGb250IFZhcmlhbnQgTnVtZXJpY1xuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2ZvbnQtdmFyaWFudC1udW1lcmljXG4gICAgICAgKi9cbiAgICAgIFwiZnZuLXNsYXNoZWQtemVyb1wiOiBbXCJzbGFzaGVkLXplcm9cIl0sXG4gICAgICAvKipcbiAgICAgICAqIEZvbnQgVmFyaWFudCBOdW1lcmljXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvZm9udC12YXJpYW50LW51bWVyaWNcbiAgICAgICAqL1xuICAgICAgXCJmdm4tZmlndXJlXCI6IFtcImxpbmluZy1udW1zXCIsIFwib2xkc3R5bGUtbnVtc1wiXSxcbiAgICAgIC8qKlxuICAgICAgICogRm9udCBWYXJpYW50IE51bWVyaWNcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9mb250LXZhcmlhbnQtbnVtZXJpY1xuICAgICAgICovXG4gICAgICBcImZ2bi1zcGFjaW5nXCI6IFtcInByb3BvcnRpb25hbC1udW1zXCIsIFwidGFidWxhci1udW1zXCJdLFxuICAgICAgLyoqXG4gICAgICAgKiBGb250IFZhcmlhbnQgTnVtZXJpY1xuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2ZvbnQtdmFyaWFudC1udW1lcmljXG4gICAgICAgKi9cbiAgICAgIFwiZnZuLWZyYWN0aW9uXCI6IFtcImRpYWdvbmFsLWZyYWN0aW9uc1wiLCBcInN0YWNrZWQtZnJhY3RvbnNcIl0sXG4gICAgICAvKipcbiAgICAgICAqIExldHRlciBTcGFjaW5nXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvbGV0dGVyLXNwYWNpbmdcbiAgICAgICAqL1xuICAgICAgdHJhY2tpbmc6IFt7XG4gICAgICAgIHRyYWNraW5nOiBbXCJ0aWdodGVyXCIsIFwidGlnaHRcIiwgXCJub3JtYWxcIiwgXCJ3aWRlXCIsIFwid2lkZXJcIiwgXCJ3aWRlc3RcIiwgZmVdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogTGluZSBDbGFtcFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2xpbmUtY2xhbXBcbiAgICAgICAqL1xuICAgICAgXCJsaW5lLWNsYW1wXCI6IFt7XG4gICAgICAgIFwibGluZS1jbGFtcFwiOiBbXCJub25lXCIsIG5yLCBuYV1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBMaW5lIEhlaWdodFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2xpbmUtaGVpZ2h0XG4gICAgICAgKi9cbiAgICAgIGxlYWRpbmc6IFt7XG4gICAgICAgIGxlYWRpbmc6IFtcIm5vbmVcIiwgXCJ0aWdodFwiLCBcInNudWdcIiwgXCJub3JtYWxcIiwgXCJyZWxheGVkXCIsIFwibG9vc2VcIiwgcG4sIGZlXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIExpc3QgU3R5bGUgSW1hZ2VcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9saXN0LXN0eWxlLWltYWdlXG4gICAgICAgKi9cbiAgICAgIFwibGlzdC1pbWFnZVwiOiBbe1xuICAgICAgICBcImxpc3QtaW1hZ2VcIjogW1wibm9uZVwiLCBmZV1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBMaXN0IFN0eWxlIFR5cGVcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9saXN0LXN0eWxlLXR5cGVcbiAgICAgICAqL1xuICAgICAgXCJsaXN0LXN0eWxlLXR5cGVcIjogW3tcbiAgICAgICAgbGlzdDogW1wibm9uZVwiLCBcImRpc2NcIiwgXCJkZWNpbWFsXCIsIGZlXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIExpc3QgU3R5bGUgUG9zaXRpb25cbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9saXN0LXN0eWxlLXBvc2l0aW9uXG4gICAgICAgKi9cbiAgICAgIFwibGlzdC1zdHlsZS1wb3NpdGlvblwiOiBbe1xuICAgICAgICBsaXN0OiBbXCJpbnNpZGVcIiwgXCJvdXRzaWRlXCJdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogUGxhY2Vob2xkZXIgQ29sb3JcbiAgICAgICAqIEBkZXByZWNhdGVkIHNpbmNlIFRhaWx3aW5kIENTUyB2My4wLjBcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9wbGFjZWhvbGRlci1jb2xvclxuICAgICAgICovXG4gICAgICBcInBsYWNlaG9sZGVyLWNvbG9yXCI6IFt7XG4gICAgICAgIHBsYWNlaG9sZGVyOiBbZV1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBQbGFjZWhvbGRlciBPcGFjaXR5XG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvcGxhY2Vob2xkZXItb3BhY2l0eVxuICAgICAgICovXG4gICAgICBcInBsYWNlaG9sZGVyLW9wYWNpdHlcIjogW3tcbiAgICAgICAgXCJwbGFjZWhvbGRlci1vcGFjaXR5XCI6IFt3XVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIFRleHQgQWxpZ25tZW50XG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvdGV4dC1hbGlnblxuICAgICAgICovXG4gICAgICBcInRleHQtYWxpZ25tZW50XCI6IFt7XG4gICAgICAgIHRleHQ6IFtcImxlZnRcIiwgXCJjZW50ZXJcIiwgXCJyaWdodFwiLCBcImp1c3RpZnlcIiwgXCJzdGFydFwiLCBcImVuZFwiXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIFRleHQgQ29sb3JcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy90ZXh0LWNvbG9yXG4gICAgICAgKi9cbiAgICAgIFwidGV4dC1jb2xvclwiOiBbe1xuICAgICAgICB0ZXh0OiBbZV1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBUZXh0IE9wYWNpdHlcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy90ZXh0LW9wYWNpdHlcbiAgICAgICAqL1xuICAgICAgXCJ0ZXh0LW9wYWNpdHlcIjogW3tcbiAgICAgICAgXCJ0ZXh0LW9wYWNpdHlcIjogW3ddXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogVGV4dCBEZWNvcmF0aW9uXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvdGV4dC1kZWNvcmF0aW9uXG4gICAgICAgKi9cbiAgICAgIFwidGV4dC1kZWNvcmF0aW9uXCI6IFtcInVuZGVybGluZVwiLCBcIm92ZXJsaW5lXCIsIFwibGluZS10aHJvdWdoXCIsIFwibm8tdW5kZXJsaW5lXCJdLFxuICAgICAgLyoqXG4gICAgICAgKiBUZXh0IERlY29yYXRpb24gU3R5bGVcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy90ZXh0LWRlY29yYXRpb24tc3R5bGVcbiAgICAgICAqL1xuICAgICAgXCJ0ZXh0LWRlY29yYXRpb24tc3R5bGVcIjogW3tcbiAgICAgICAgZGVjb3JhdGlvbjogWy4uLmsoKSwgXCJ3YXZ5XCJdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogVGV4dCBEZWNvcmF0aW9uIFRoaWNrbmVzc1xuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3RleHQtZGVjb3JhdGlvbi10aGlja25lc3NcbiAgICAgICAqL1xuICAgICAgXCJ0ZXh0LWRlY29yYXRpb24tdGhpY2tuZXNzXCI6IFt7XG4gICAgICAgIGRlY29yYXRpb246IFtcImF1dG9cIiwgXCJmcm9tLWZvbnRcIiwgcG4sIFRuXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIFRleHQgVW5kZXJsaW5lIE9mZnNldFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3RleHQtdW5kZXJsaW5lLW9mZnNldFxuICAgICAgICovXG4gICAgICBcInVuZGVybGluZS1vZmZzZXRcIjogW3tcbiAgICAgICAgXCJ1bmRlcmxpbmUtb2Zmc2V0XCI6IFtcImF1dG9cIiwgcG4sIGZlXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIFRleHQgRGVjb3JhdGlvbiBDb2xvclxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3RleHQtZGVjb3JhdGlvbi1jb2xvclxuICAgICAgICovXG4gICAgICBcInRleHQtZGVjb3JhdGlvbi1jb2xvclwiOiBbe1xuICAgICAgICBkZWNvcmF0aW9uOiBbZV1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBUZXh0IFRyYW5zZm9ybVxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3RleHQtdHJhbnNmb3JtXG4gICAgICAgKi9cbiAgICAgIFwidGV4dC10cmFuc2Zvcm1cIjogW1widXBwZXJjYXNlXCIsIFwibG93ZXJjYXNlXCIsIFwiY2FwaXRhbGl6ZVwiLCBcIm5vcm1hbC1jYXNlXCJdLFxuICAgICAgLyoqXG4gICAgICAgKiBUZXh0IE92ZXJmbG93XG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvdGV4dC1vdmVyZmxvd1xuICAgICAgICovXG4gICAgICBcInRleHQtb3ZlcmZsb3dcIjogW1widHJ1bmNhdGVcIiwgXCJ0ZXh0LWVsbGlwc2lzXCIsIFwidGV4dC1jbGlwXCJdLFxuICAgICAgLyoqXG4gICAgICAgKiBUZXh0IFdyYXBcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy90ZXh0LXdyYXBcbiAgICAgICAqL1xuICAgICAgXCJ0ZXh0LXdyYXBcIjogW3tcbiAgICAgICAgdGV4dDogW1wid3JhcFwiLCBcIm5vd3JhcFwiLCBcImJhbGFuY2VcIiwgXCJwcmV0dHlcIl1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBUZXh0IEluZGVudFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3RleHQtaW5kZW50XG4gICAgICAgKi9cbiAgICAgIGluZGVudDogW3tcbiAgICAgICAgaW5kZW50OiBBKClcbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBWZXJ0aWNhbCBBbGlnbm1lbnRcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy92ZXJ0aWNhbC1hbGlnblxuICAgICAgICovXG4gICAgICBcInZlcnRpY2FsLWFsaWduXCI6IFt7XG4gICAgICAgIGFsaWduOiBbXCJiYXNlbGluZVwiLCBcInRvcFwiLCBcIm1pZGRsZVwiLCBcImJvdHRvbVwiLCBcInRleHQtdG9wXCIsIFwidGV4dC1ib3R0b21cIiwgXCJzdWJcIiwgXCJzdXBlclwiLCBmZV1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBXaGl0ZXNwYWNlXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3Mvd2hpdGVzcGFjZVxuICAgICAgICovXG4gICAgICB3aGl0ZXNwYWNlOiBbe1xuICAgICAgICB3aGl0ZXNwYWNlOiBbXCJub3JtYWxcIiwgXCJub3dyYXBcIiwgXCJwcmVcIiwgXCJwcmUtbGluZVwiLCBcInByZS13cmFwXCIsIFwiYnJlYWstc3BhY2VzXCJdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogV29yZCBCcmVha1xuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3dvcmQtYnJlYWtcbiAgICAgICAqL1xuICAgICAgYnJlYWs6IFt7XG4gICAgICAgIGJyZWFrOiBbXCJub3JtYWxcIiwgXCJ3b3Jkc1wiLCBcImFsbFwiLCBcImtlZXBcIl1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBIeXBoZW5zXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvaHlwaGVuc1xuICAgICAgICovXG4gICAgICBoeXBoZW5zOiBbe1xuICAgICAgICBoeXBoZW5zOiBbXCJub25lXCIsIFwibWFudWFsXCIsIFwiYXV0b1wiXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIENvbnRlbnRcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9jb250ZW50XG4gICAgICAgKi9cbiAgICAgIGNvbnRlbnQ6IFt7XG4gICAgICAgIGNvbnRlbnQ6IFtcIm5vbmVcIiwgZmVdXG4gICAgICB9XSxcbiAgICAgIC8vIEJhY2tncm91bmRzXG4gICAgICAvKipcbiAgICAgICAqIEJhY2tncm91bmQgQXR0YWNobWVudFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2JhY2tncm91bmQtYXR0YWNobWVudFxuICAgICAgICovXG4gICAgICBcImJnLWF0dGFjaG1lbnRcIjogW3tcbiAgICAgICAgYmc6IFtcImZpeGVkXCIsIFwibG9jYWxcIiwgXCJzY3JvbGxcIl1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBCYWNrZ3JvdW5kIENsaXBcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9iYWNrZ3JvdW5kLWNsaXBcbiAgICAgICAqL1xuICAgICAgXCJiZy1jbGlwXCI6IFt7XG4gICAgICAgIFwiYmctY2xpcFwiOiBbXCJib3JkZXJcIiwgXCJwYWRkaW5nXCIsIFwiY29udGVudFwiLCBcInRleHRcIl1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBCYWNrZ3JvdW5kIE9wYWNpdHlcbiAgICAgICAqIEBkZXByZWNhdGVkIHNpbmNlIFRhaWx3aW5kIENTUyB2My4wLjBcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9iYWNrZ3JvdW5kLW9wYWNpdHlcbiAgICAgICAqL1xuICAgICAgXCJiZy1vcGFjaXR5XCI6IFt7XG4gICAgICAgIFwiYmctb3BhY2l0eVwiOiBbd11cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBCYWNrZ3JvdW5kIE9yaWdpblxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2JhY2tncm91bmQtb3JpZ2luXG4gICAgICAgKi9cbiAgICAgIFwiYmctb3JpZ2luXCI6IFt7XG4gICAgICAgIFwiYmctb3JpZ2luXCI6IFtcImJvcmRlclwiLCBcInBhZGRpbmdcIiwgXCJjb250ZW50XCJdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogQmFja2dyb3VuZCBQb3NpdGlvblxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2JhY2tncm91bmQtcG9zaXRpb25cbiAgICAgICAqL1xuICAgICAgXCJiZy1wb3NpdGlvblwiOiBbe1xuICAgICAgICBiZzogWy4uLk4oKSwgZTFdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogQmFja2dyb3VuZCBSZXBlYXRcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9iYWNrZ3JvdW5kLXJlcGVhdFxuICAgICAgICovXG4gICAgICBcImJnLXJlcGVhdFwiOiBbe1xuICAgICAgICBiZzogW1wibm8tcmVwZWF0XCIsIHtcbiAgICAgICAgICByZXBlYXQ6IFtcIlwiLCBcInhcIiwgXCJ5XCIsIFwicm91bmRcIiwgXCJzcGFjZVwiXVxuICAgICAgICB9XVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIEJhY2tncm91bmQgU2l6ZVxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2JhY2tncm91bmQtc2l6ZVxuICAgICAgICovXG4gICAgICBcImJnLXNpemVcIjogW3tcbiAgICAgICAgYmc6IFtcImF1dG9cIiwgXCJjb3ZlclwiLCBcImNvbnRhaW5cIiwgUXhdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogQmFja2dyb3VuZCBJbWFnZVxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2JhY2tncm91bmQtaW1hZ2VcbiAgICAgICAqL1xuICAgICAgXCJiZy1pbWFnZVwiOiBbe1xuICAgICAgICBiZzogW1wibm9uZVwiLCB7XG4gICAgICAgICAgXCJncmFkaWVudC10b1wiOiBbXCJ0XCIsIFwidHJcIiwgXCJyXCIsIFwiYnJcIiwgXCJiXCIsIFwiYmxcIiwgXCJsXCIsIFwidGxcIl1cbiAgICAgICAgfSwgbjFdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogQmFja2dyb3VuZCBDb2xvclxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2JhY2tncm91bmQtY29sb3JcbiAgICAgICAqL1xuICAgICAgXCJiZy1jb2xvclwiOiBbe1xuICAgICAgICBiZzogW2VdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogR3JhZGllbnQgQ29sb3IgU3RvcHMgRnJvbSBQb3NpdGlvblxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2dyYWRpZW50LWNvbG9yLXN0b3BzXG4gICAgICAgKi9cbiAgICAgIFwiZ3JhZGllbnQtZnJvbS1wb3NcIjogW3tcbiAgICAgICAgZnJvbTogW2ddXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogR3JhZGllbnQgQ29sb3IgU3RvcHMgVmlhIFBvc2l0aW9uXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvZ3JhZGllbnQtY29sb3Itc3RvcHNcbiAgICAgICAqL1xuICAgICAgXCJncmFkaWVudC12aWEtcG9zXCI6IFt7XG4gICAgICAgIHZpYTogW2ddXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogR3JhZGllbnQgQ29sb3IgU3RvcHMgVG8gUG9zaXRpb25cbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9ncmFkaWVudC1jb2xvci1zdG9wc1xuICAgICAgICovXG4gICAgICBcImdyYWRpZW50LXRvLXBvc1wiOiBbe1xuICAgICAgICB0bzogW2ddXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogR3JhZGllbnQgQ29sb3IgU3RvcHMgRnJvbVxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2dyYWRpZW50LWNvbG9yLXN0b3BzXG4gICAgICAgKi9cbiAgICAgIFwiZ3JhZGllbnQtZnJvbVwiOiBbe1xuICAgICAgICBmcm9tOiBbcF1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBHcmFkaWVudCBDb2xvciBTdG9wcyBWaWFcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9ncmFkaWVudC1jb2xvci1zdG9wc1xuICAgICAgICovXG4gICAgICBcImdyYWRpZW50LXZpYVwiOiBbe1xuICAgICAgICB2aWE6IFtwXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIEdyYWRpZW50IENvbG9yIFN0b3BzIFRvXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvZ3JhZGllbnQtY29sb3Itc3RvcHNcbiAgICAgICAqL1xuICAgICAgXCJncmFkaWVudC10b1wiOiBbe1xuICAgICAgICB0bzogW3BdXG4gICAgICB9XSxcbiAgICAgIC8vIEJvcmRlcnNcbiAgICAgIC8qKlxuICAgICAgICogQm9yZGVyIFJhZGl1c1xuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2JvcmRlci1yYWRpdXNcbiAgICAgICAqL1xuICAgICAgcm91bmRlZDogW3tcbiAgICAgICAgcm91bmRlZDogW29dXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogQm9yZGVyIFJhZGl1cyBTdGFydFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2JvcmRlci1yYWRpdXNcbiAgICAgICAqL1xuICAgICAgXCJyb3VuZGVkLXNcIjogW3tcbiAgICAgICAgXCJyb3VuZGVkLXNcIjogW29dXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogQm9yZGVyIFJhZGl1cyBFbmRcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9ib3JkZXItcmFkaXVzXG4gICAgICAgKi9cbiAgICAgIFwicm91bmRlZC1lXCI6IFt7XG4gICAgICAgIFwicm91bmRlZC1lXCI6IFtvXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIEJvcmRlciBSYWRpdXMgVG9wXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvYm9yZGVyLXJhZGl1c1xuICAgICAgICovXG4gICAgICBcInJvdW5kZWQtdFwiOiBbe1xuICAgICAgICBcInJvdW5kZWQtdFwiOiBbb11cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBCb3JkZXIgUmFkaXVzIFJpZ2h0XG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvYm9yZGVyLXJhZGl1c1xuICAgICAgICovXG4gICAgICBcInJvdW5kZWQtclwiOiBbe1xuICAgICAgICBcInJvdW5kZWQtclwiOiBbb11cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBCb3JkZXIgUmFkaXVzIEJvdHRvbVxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2JvcmRlci1yYWRpdXNcbiAgICAgICAqL1xuICAgICAgXCJyb3VuZGVkLWJcIjogW3tcbiAgICAgICAgXCJyb3VuZGVkLWJcIjogW29dXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogQm9yZGVyIFJhZGl1cyBMZWZ0XG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvYm9yZGVyLXJhZGl1c1xuICAgICAgICovXG4gICAgICBcInJvdW5kZWQtbFwiOiBbe1xuICAgICAgICBcInJvdW5kZWQtbFwiOiBbb11cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBCb3JkZXIgUmFkaXVzIFN0YXJ0IFN0YXJ0XG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvYm9yZGVyLXJhZGl1c1xuICAgICAgICovXG4gICAgICBcInJvdW5kZWQtc3NcIjogW3tcbiAgICAgICAgXCJyb3VuZGVkLXNzXCI6IFtvXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIEJvcmRlciBSYWRpdXMgU3RhcnQgRW5kXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvYm9yZGVyLXJhZGl1c1xuICAgICAgICovXG4gICAgICBcInJvdW5kZWQtc2VcIjogW3tcbiAgICAgICAgXCJyb3VuZGVkLXNlXCI6IFtvXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIEJvcmRlciBSYWRpdXMgRW5kIEVuZFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2JvcmRlci1yYWRpdXNcbiAgICAgICAqL1xuICAgICAgXCJyb3VuZGVkLWVlXCI6IFt7XG4gICAgICAgIFwicm91bmRlZC1lZVwiOiBbb11cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBCb3JkZXIgUmFkaXVzIEVuZCBTdGFydFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2JvcmRlci1yYWRpdXNcbiAgICAgICAqL1xuICAgICAgXCJyb3VuZGVkLWVzXCI6IFt7XG4gICAgICAgIFwicm91bmRlZC1lc1wiOiBbb11cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBCb3JkZXIgUmFkaXVzIFRvcCBMZWZ0XG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvYm9yZGVyLXJhZGl1c1xuICAgICAgICovXG4gICAgICBcInJvdW5kZWQtdGxcIjogW3tcbiAgICAgICAgXCJyb3VuZGVkLXRsXCI6IFtvXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIEJvcmRlciBSYWRpdXMgVG9wIFJpZ2h0XG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvYm9yZGVyLXJhZGl1c1xuICAgICAgICovXG4gICAgICBcInJvdW5kZWQtdHJcIjogW3tcbiAgICAgICAgXCJyb3VuZGVkLXRyXCI6IFtvXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIEJvcmRlciBSYWRpdXMgQm90dG9tIFJpZ2h0XG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvYm9yZGVyLXJhZGl1c1xuICAgICAgICovXG4gICAgICBcInJvdW5kZWQtYnJcIjogW3tcbiAgICAgICAgXCJyb3VuZGVkLWJyXCI6IFtvXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIEJvcmRlciBSYWRpdXMgQm90dG9tIExlZnRcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9ib3JkZXItcmFkaXVzXG4gICAgICAgKi9cbiAgICAgIFwicm91bmRlZC1ibFwiOiBbe1xuICAgICAgICBcInJvdW5kZWQtYmxcIjogW29dXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogQm9yZGVyIFdpZHRoXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvYm9yZGVyLXdpZHRoXG4gICAgICAgKi9cbiAgICAgIFwiYm9yZGVyLXdcIjogW3tcbiAgICAgICAgYm9yZGVyOiBbc11cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBCb3JkZXIgV2lkdGggWFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2JvcmRlci13aWR0aFxuICAgICAgICovXG4gICAgICBcImJvcmRlci13LXhcIjogW3tcbiAgICAgICAgXCJib3JkZXIteFwiOiBbc11cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBCb3JkZXIgV2lkdGggWVxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2JvcmRlci13aWR0aFxuICAgICAgICovXG4gICAgICBcImJvcmRlci13LXlcIjogW3tcbiAgICAgICAgXCJib3JkZXIteVwiOiBbc11cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBCb3JkZXIgV2lkdGggU3RhcnRcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9ib3JkZXItd2lkdGhcbiAgICAgICAqL1xuICAgICAgXCJib3JkZXItdy1zXCI6IFt7XG4gICAgICAgIFwiYm9yZGVyLXNcIjogW3NdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogQm9yZGVyIFdpZHRoIEVuZFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2JvcmRlci13aWR0aFxuICAgICAgICovXG4gICAgICBcImJvcmRlci13LWVcIjogW3tcbiAgICAgICAgXCJib3JkZXItZVwiOiBbc11cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBCb3JkZXIgV2lkdGggVG9wXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvYm9yZGVyLXdpZHRoXG4gICAgICAgKi9cbiAgICAgIFwiYm9yZGVyLXctdFwiOiBbe1xuICAgICAgICBcImJvcmRlci10XCI6IFtzXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIEJvcmRlciBXaWR0aCBSaWdodFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2JvcmRlci13aWR0aFxuICAgICAgICovXG4gICAgICBcImJvcmRlci13LXJcIjogW3tcbiAgICAgICAgXCJib3JkZXItclwiOiBbc11cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBCb3JkZXIgV2lkdGggQm90dG9tXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvYm9yZGVyLXdpZHRoXG4gICAgICAgKi9cbiAgICAgIFwiYm9yZGVyLXctYlwiOiBbe1xuICAgICAgICBcImJvcmRlci1iXCI6IFtzXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIEJvcmRlciBXaWR0aCBMZWZ0XG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvYm9yZGVyLXdpZHRoXG4gICAgICAgKi9cbiAgICAgIFwiYm9yZGVyLXctbFwiOiBbe1xuICAgICAgICBcImJvcmRlci1sXCI6IFtzXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIEJvcmRlciBPcGFjaXR5XG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvYm9yZGVyLW9wYWNpdHlcbiAgICAgICAqL1xuICAgICAgXCJib3JkZXItb3BhY2l0eVwiOiBbe1xuICAgICAgICBcImJvcmRlci1vcGFjaXR5XCI6IFt3XVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIEJvcmRlciBTdHlsZVxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2JvcmRlci1zdHlsZVxuICAgICAgICovXG4gICAgICBcImJvcmRlci1zdHlsZVwiOiBbe1xuICAgICAgICBib3JkZXI6IFsuLi5rKCksIFwiaGlkZGVuXCJdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogRGl2aWRlIFdpZHRoIFhcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9kaXZpZGUtd2lkdGhcbiAgICAgICAqL1xuICAgICAgXCJkaXZpZGUteFwiOiBbe1xuICAgICAgICBcImRpdmlkZS14XCI6IFtzXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIERpdmlkZSBXaWR0aCBYIFJldmVyc2VcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9kaXZpZGUtd2lkdGhcbiAgICAgICAqL1xuICAgICAgXCJkaXZpZGUteC1yZXZlcnNlXCI6IFtcImRpdmlkZS14LXJldmVyc2VcIl0sXG4gICAgICAvKipcbiAgICAgICAqIERpdmlkZSBXaWR0aCBZXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvZGl2aWRlLXdpZHRoXG4gICAgICAgKi9cbiAgICAgIFwiZGl2aWRlLXlcIjogW3tcbiAgICAgICAgXCJkaXZpZGUteVwiOiBbc11cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBEaXZpZGUgV2lkdGggWSBSZXZlcnNlXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvZGl2aWRlLXdpZHRoXG4gICAgICAgKi9cbiAgICAgIFwiZGl2aWRlLXktcmV2ZXJzZVwiOiBbXCJkaXZpZGUteS1yZXZlcnNlXCJdLFxuICAgICAgLyoqXG4gICAgICAgKiBEaXZpZGUgT3BhY2l0eVxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2RpdmlkZS1vcGFjaXR5XG4gICAgICAgKi9cbiAgICAgIFwiZGl2aWRlLW9wYWNpdHlcIjogW3tcbiAgICAgICAgXCJkaXZpZGUtb3BhY2l0eVwiOiBbd11cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBEaXZpZGUgU3R5bGVcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9kaXZpZGUtc3R5bGVcbiAgICAgICAqL1xuICAgICAgXCJkaXZpZGUtc3R5bGVcIjogW3tcbiAgICAgICAgZGl2aWRlOiBrKClcbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBCb3JkZXIgQ29sb3JcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9ib3JkZXItY29sb3JcbiAgICAgICAqL1xuICAgICAgXCJib3JkZXItY29sb3JcIjogW3tcbiAgICAgICAgYm9yZGVyOiBbaV1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBCb3JkZXIgQ29sb3IgWFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2JvcmRlci1jb2xvclxuICAgICAgICovXG4gICAgICBcImJvcmRlci1jb2xvci14XCI6IFt7XG4gICAgICAgIFwiYm9yZGVyLXhcIjogW2ldXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogQm9yZGVyIENvbG9yIFlcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9ib3JkZXItY29sb3JcbiAgICAgICAqL1xuICAgICAgXCJib3JkZXItY29sb3IteVwiOiBbe1xuICAgICAgICBcImJvcmRlci15XCI6IFtpXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIEJvcmRlciBDb2xvciBUb3BcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9ib3JkZXItY29sb3JcbiAgICAgICAqL1xuICAgICAgXCJib3JkZXItY29sb3ItdFwiOiBbe1xuICAgICAgICBcImJvcmRlci10XCI6IFtpXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIEJvcmRlciBDb2xvciBSaWdodFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2JvcmRlci1jb2xvclxuICAgICAgICovXG4gICAgICBcImJvcmRlci1jb2xvci1yXCI6IFt7XG4gICAgICAgIFwiYm9yZGVyLXJcIjogW2ldXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogQm9yZGVyIENvbG9yIEJvdHRvbVxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2JvcmRlci1jb2xvclxuICAgICAgICovXG4gICAgICBcImJvcmRlci1jb2xvci1iXCI6IFt7XG4gICAgICAgIFwiYm9yZGVyLWJcIjogW2ldXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogQm9yZGVyIENvbG9yIExlZnRcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9ib3JkZXItY29sb3JcbiAgICAgICAqL1xuICAgICAgXCJib3JkZXItY29sb3ItbFwiOiBbe1xuICAgICAgICBcImJvcmRlci1sXCI6IFtpXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIERpdmlkZSBDb2xvclxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2RpdmlkZS1jb2xvclxuICAgICAgICovXG4gICAgICBcImRpdmlkZS1jb2xvclwiOiBbe1xuICAgICAgICBkaXZpZGU6IFtpXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIE91dGxpbmUgU3R5bGVcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9vdXRsaW5lLXN0eWxlXG4gICAgICAgKi9cbiAgICAgIFwib3V0bGluZS1zdHlsZVwiOiBbe1xuICAgICAgICBvdXRsaW5lOiBbXCJcIiwgLi4uaygpXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIE91dGxpbmUgT2Zmc2V0XG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3Mvb3V0bGluZS1vZmZzZXRcbiAgICAgICAqL1xuICAgICAgXCJvdXRsaW5lLW9mZnNldFwiOiBbe1xuICAgICAgICBcIm91dGxpbmUtb2Zmc2V0XCI6IFtwbiwgZmVdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogT3V0bGluZSBXaWR0aFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL291dGxpbmUtd2lkdGhcbiAgICAgICAqL1xuICAgICAgXCJvdXRsaW5lLXdcIjogW3tcbiAgICAgICAgb3V0bGluZTogW3BuLCBUbl1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBPdXRsaW5lIENvbG9yXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3Mvb3V0bGluZS1jb2xvclxuICAgICAgICovXG4gICAgICBcIm91dGxpbmUtY29sb3JcIjogW3tcbiAgICAgICAgb3V0bGluZTogW2VdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogUmluZyBXaWR0aFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3Jpbmctd2lkdGhcbiAgICAgICAqL1xuICAgICAgXCJyaW5nLXdcIjogW3tcbiAgICAgICAgcmluZzogaigpXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogUmluZyBXaWR0aCBJbnNldFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3Jpbmctd2lkdGhcbiAgICAgICAqL1xuICAgICAgXCJyaW5nLXctaW5zZXRcIjogW1wicmluZy1pbnNldFwiXSxcbiAgICAgIC8qKlxuICAgICAgICogUmluZyBDb2xvclxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3JpbmctY29sb3JcbiAgICAgICAqL1xuICAgICAgXCJyaW5nLWNvbG9yXCI6IFt7XG4gICAgICAgIHJpbmc6IFtlXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIFJpbmcgT3BhY2l0eVxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3Jpbmctb3BhY2l0eVxuICAgICAgICovXG4gICAgICBcInJpbmctb3BhY2l0eVwiOiBbe1xuICAgICAgICBcInJpbmctb3BhY2l0eVwiOiBbd11cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBSaW5nIE9mZnNldCBXaWR0aFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3Jpbmctb2Zmc2V0LXdpZHRoXG4gICAgICAgKi9cbiAgICAgIFwicmluZy1vZmZzZXQtd1wiOiBbe1xuICAgICAgICBcInJpbmctb2Zmc2V0XCI6IFtwbiwgVG5dXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogUmluZyBPZmZzZXQgQ29sb3JcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9yaW5nLW9mZnNldC1jb2xvclxuICAgICAgICovXG4gICAgICBcInJpbmctb2Zmc2V0LWNvbG9yXCI6IFt7XG4gICAgICAgIFwicmluZy1vZmZzZXRcIjogW2VdXG4gICAgICB9XSxcbiAgICAgIC8vIEVmZmVjdHNcbiAgICAgIC8qKlxuICAgICAgICogQm94IFNoYWRvd1xuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2JveC1zaGFkb3dcbiAgICAgICAqL1xuICAgICAgc2hhZG93OiBbe1xuICAgICAgICBzaGFkb3c6IFtcIlwiLCBcImlubmVyXCIsIFwibm9uZVwiLCBNbiwgcjFdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogQm94IFNoYWRvdyBDb2xvclxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2JveC1zaGFkb3ctY29sb3JcbiAgICAgICAqL1xuICAgICAgXCJzaGFkb3ctY29sb3JcIjogW3tcbiAgICAgICAgc2hhZG93OiBbRWldXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogT3BhY2l0eVxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL29wYWNpdHlcbiAgICAgICAqL1xuICAgICAgb3BhY2l0eTogW3tcbiAgICAgICAgb3BhY2l0eTogW3ddXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogTWl4IEJsZW5kIE1vZGVcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9taXgtYmxlbmQtbW9kZVxuICAgICAgICovXG4gICAgICBcIm1peC1ibGVuZFwiOiBbe1xuICAgICAgICBcIm1peC1ibGVuZFwiOiBbLi4uRigpLCBcInBsdXMtbGlnaHRlclwiLCBcInBsdXMtZGFya2VyXCJdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogQmFja2dyb3VuZCBCbGVuZCBNb2RlXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvYmFja2dyb3VuZC1ibGVuZC1tb2RlXG4gICAgICAgKi9cbiAgICAgIFwiYmctYmxlbmRcIjogW3tcbiAgICAgICAgXCJiZy1ibGVuZFwiOiBGKClcbiAgICAgIH1dLFxuICAgICAgLy8gRmlsdGVyc1xuICAgICAgLyoqXG4gICAgICAgKiBGaWx0ZXJcbiAgICAgICAqIEBkZXByZWNhdGVkIHNpbmNlIFRhaWx3aW5kIENTUyB2My4wLjBcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9maWx0ZXJcbiAgICAgICAqL1xuICAgICAgZmlsdGVyOiBbe1xuICAgICAgICBmaWx0ZXI6IFtcIlwiLCBcIm5vbmVcIl1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBCbHVyXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvYmx1clxuICAgICAgICovXG4gICAgICBibHVyOiBbe1xuICAgICAgICBibHVyOiBbbl1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBCcmlnaHRuZXNzXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvYnJpZ2h0bmVzc1xuICAgICAgICovXG4gICAgICBicmlnaHRuZXNzOiBbe1xuICAgICAgICBicmlnaHRuZXNzOiBbcl1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBDb250cmFzdFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2NvbnRyYXN0XG4gICAgICAgKi9cbiAgICAgIGNvbnRyYXN0OiBbe1xuICAgICAgICBjb250cmFzdDogW3VdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogRHJvcCBTaGFkb3dcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9kcm9wLXNoYWRvd1xuICAgICAgICovXG4gICAgICBcImRyb3Atc2hhZG93XCI6IFt7XG4gICAgICAgIFwiZHJvcC1zaGFkb3dcIjogW1wiXCIsIFwibm9uZVwiLCBNbiwgZmVdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogR3JheXNjYWxlXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvZ3JheXNjYWxlXG4gICAgICAgKi9cbiAgICAgIGdyYXlzY2FsZTogW3tcbiAgICAgICAgZ3JheXNjYWxlOiBbY11cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBIdWUgUm90YXRlXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvaHVlLXJvdGF0ZVxuICAgICAgICovXG4gICAgICBcImh1ZS1yb3RhdGVcIjogW3tcbiAgICAgICAgXCJodWUtcm90YXRlXCI6IFtmXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIEludmVydFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2ludmVydFxuICAgICAgICovXG4gICAgICBpbnZlcnQ6IFt7XG4gICAgICAgIGludmVydDogW2xdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogU2F0dXJhdGVcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9zYXR1cmF0ZVxuICAgICAgICovXG4gICAgICBzYXR1cmF0ZTogW3tcbiAgICAgICAgc2F0dXJhdGU6IFt4XVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIFNlcGlhXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3Mvc2VwaWFcbiAgICAgICAqL1xuICAgICAgc2VwaWE6IFt7XG4gICAgICAgIHNlcGlhOiBbeV1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBCYWNrZHJvcCBGaWx0ZXJcbiAgICAgICAqIEBkZXByZWNhdGVkIHNpbmNlIFRhaWx3aW5kIENTUyB2My4wLjBcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9iYWNrZHJvcC1maWx0ZXJcbiAgICAgICAqL1xuICAgICAgXCJiYWNrZHJvcC1maWx0ZXJcIjogW3tcbiAgICAgICAgXCJiYWNrZHJvcC1maWx0ZXJcIjogW1wiXCIsIFwibm9uZVwiXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIEJhY2tkcm9wIEJsdXJcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9iYWNrZHJvcC1ibHVyXG4gICAgICAgKi9cbiAgICAgIFwiYmFja2Ryb3AtYmx1clwiOiBbe1xuICAgICAgICBcImJhY2tkcm9wLWJsdXJcIjogW25dXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogQmFja2Ryb3AgQnJpZ2h0bmVzc1xuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2JhY2tkcm9wLWJyaWdodG5lc3NcbiAgICAgICAqL1xuICAgICAgXCJiYWNrZHJvcC1icmlnaHRuZXNzXCI6IFt7XG4gICAgICAgIFwiYmFja2Ryb3AtYnJpZ2h0bmVzc1wiOiBbcl1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBCYWNrZHJvcCBDb250cmFzdFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2JhY2tkcm9wLWNvbnRyYXN0XG4gICAgICAgKi9cbiAgICAgIFwiYmFja2Ryb3AtY29udHJhc3RcIjogW3tcbiAgICAgICAgXCJiYWNrZHJvcC1jb250cmFzdFwiOiBbdV1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBCYWNrZHJvcCBHcmF5c2NhbGVcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9iYWNrZHJvcC1ncmF5c2NhbGVcbiAgICAgICAqL1xuICAgICAgXCJiYWNrZHJvcC1ncmF5c2NhbGVcIjogW3tcbiAgICAgICAgXCJiYWNrZHJvcC1ncmF5c2NhbGVcIjogW2NdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogQmFja2Ryb3AgSHVlIFJvdGF0ZVxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2JhY2tkcm9wLWh1ZS1yb3RhdGVcbiAgICAgICAqL1xuICAgICAgXCJiYWNrZHJvcC1odWUtcm90YXRlXCI6IFt7XG4gICAgICAgIFwiYmFja2Ryb3AtaHVlLXJvdGF0ZVwiOiBbZl1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBCYWNrZHJvcCBJbnZlcnRcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9iYWNrZHJvcC1pbnZlcnRcbiAgICAgICAqL1xuICAgICAgXCJiYWNrZHJvcC1pbnZlcnRcIjogW3tcbiAgICAgICAgXCJiYWNrZHJvcC1pbnZlcnRcIjogW2xdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogQmFja2Ryb3AgT3BhY2l0eVxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2JhY2tkcm9wLW9wYWNpdHlcbiAgICAgICAqL1xuICAgICAgXCJiYWNrZHJvcC1vcGFjaXR5XCI6IFt7XG4gICAgICAgIFwiYmFja2Ryb3Atb3BhY2l0eVwiOiBbd11cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBCYWNrZHJvcCBTYXR1cmF0ZVxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2JhY2tkcm9wLXNhdHVyYXRlXG4gICAgICAgKi9cbiAgICAgIFwiYmFja2Ryb3Atc2F0dXJhdGVcIjogW3tcbiAgICAgICAgXCJiYWNrZHJvcC1zYXR1cmF0ZVwiOiBbeF1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBCYWNrZHJvcCBTZXBpYVxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2JhY2tkcm9wLXNlcGlhXG4gICAgICAgKi9cbiAgICAgIFwiYmFja2Ryb3Atc2VwaWFcIjogW3tcbiAgICAgICAgXCJiYWNrZHJvcC1zZXBpYVwiOiBbeV1cbiAgICAgIH1dLFxuICAgICAgLy8gVGFibGVzXG4gICAgICAvKipcbiAgICAgICAqIEJvcmRlciBDb2xsYXBzZVxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2JvcmRlci1jb2xsYXBzZVxuICAgICAgICovXG4gICAgICBcImJvcmRlci1jb2xsYXBzZVwiOiBbe1xuICAgICAgICBib3JkZXI6IFtcImNvbGxhcHNlXCIsIFwic2VwYXJhdGVcIl1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBCb3JkZXIgU3BhY2luZ1xuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2JvcmRlci1zcGFjaW5nXG4gICAgICAgKi9cbiAgICAgIFwiYm9yZGVyLXNwYWNpbmdcIjogW3tcbiAgICAgICAgXCJib3JkZXItc3BhY2luZ1wiOiBbYV1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBCb3JkZXIgU3BhY2luZyBYXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvYm9yZGVyLXNwYWNpbmdcbiAgICAgICAqL1xuICAgICAgXCJib3JkZXItc3BhY2luZy14XCI6IFt7XG4gICAgICAgIFwiYm9yZGVyLXNwYWNpbmcteFwiOiBbYV1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBCb3JkZXIgU3BhY2luZyBZXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvYm9yZGVyLXNwYWNpbmdcbiAgICAgICAqL1xuICAgICAgXCJib3JkZXItc3BhY2luZy15XCI6IFt7XG4gICAgICAgIFwiYm9yZGVyLXNwYWNpbmcteVwiOiBbYV1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBUYWJsZSBMYXlvdXRcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy90YWJsZS1sYXlvdXRcbiAgICAgICAqL1xuICAgICAgXCJ0YWJsZS1sYXlvdXRcIjogW3tcbiAgICAgICAgdGFibGU6IFtcImF1dG9cIiwgXCJmaXhlZFwiXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIENhcHRpb24gU2lkZVxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2NhcHRpb24tc2lkZVxuICAgICAgICovXG4gICAgICBjYXB0aW9uOiBbe1xuICAgICAgICBjYXB0aW9uOiBbXCJ0b3BcIiwgXCJib3R0b21cIl1cbiAgICAgIH1dLFxuICAgICAgLy8gVHJhbnNpdGlvbnMgYW5kIEFuaW1hdGlvblxuICAgICAgLyoqXG4gICAgICAgKiBUcmFuaXNpdGlvbiBQcm9wZXJ0eVxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3RyYW5zaXRpb24tcHJvcGVydHlcbiAgICAgICAqL1xuICAgICAgdHJhbnNpdGlvbjogW3tcbiAgICAgICAgdHJhbnNpdGlvbjogW1wibm9uZVwiLCBcImFsbFwiLCBcIlwiLCBcImNvbG9yc1wiLCBcIm9wYWNpdHlcIiwgXCJzaGFkb3dcIiwgXCJ0cmFuc2Zvcm1cIiwgZmVdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogVHJhbnNpdGlvbiBEdXJhdGlvblxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3RyYW5zaXRpb24tZHVyYXRpb25cbiAgICAgICAqL1xuICAgICAgZHVyYXRpb246IFt7XG4gICAgICAgIGR1cmF0aW9uOiBHKClcbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBUcmFuc2l0aW9uIFRpbWluZyBGdW5jdGlvblxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3RyYW5zaXRpb24tdGltaW5nLWZ1bmN0aW9uXG4gICAgICAgKi9cbiAgICAgIGVhc2U6IFt7XG4gICAgICAgIGVhc2U6IFtcImxpbmVhclwiLCBcImluXCIsIFwib3V0XCIsIFwiaW4tb3V0XCIsIGZlXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIFRyYW5zaXRpb24gRGVsYXlcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy90cmFuc2l0aW9uLWRlbGF5XG4gICAgICAgKi9cbiAgICAgIGRlbGF5OiBbe1xuICAgICAgICBkZWxheTogRygpXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogQW5pbWF0aW9uXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvYW5pbWF0aW9uXG4gICAgICAgKi9cbiAgICAgIGFuaW1hdGU6IFt7XG4gICAgICAgIGFuaW1hdGU6IFtcIm5vbmVcIiwgXCJzcGluXCIsIFwicGluZ1wiLCBcInB1bHNlXCIsIFwiYm91bmNlXCIsIGZlXVxuICAgICAgfV0sXG4gICAgICAvLyBUcmFuc2Zvcm1zXG4gICAgICAvKipcbiAgICAgICAqIFRyYW5zZm9ybVxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3RyYW5zZm9ybVxuICAgICAgICovXG4gICAgICB0cmFuc2Zvcm06IFt7XG4gICAgICAgIHRyYW5zZm9ybTogW1wiXCIsIFwiZ3B1XCIsIFwibm9uZVwiXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIFNjYWxlXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3Mvc2NhbGVcbiAgICAgICAqL1xuICAgICAgc2NhbGU6IFt7XG4gICAgICAgIHNjYWxlOiBbbV1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBTY2FsZSBYXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3Mvc2NhbGVcbiAgICAgICAqL1xuICAgICAgXCJzY2FsZS14XCI6IFt7XG4gICAgICAgIFwic2NhbGUteFwiOiBbbV1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBTY2FsZSBZXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3Mvc2NhbGVcbiAgICAgICAqL1xuICAgICAgXCJzY2FsZS15XCI6IFt7XG4gICAgICAgIFwic2NhbGUteVwiOiBbbV1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBSb3RhdGVcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9yb3RhdGVcbiAgICAgICAqL1xuICAgICAgcm90YXRlOiBbe1xuICAgICAgICByb3RhdGU6IFtDaSwgZmVdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogVHJhbnNsYXRlIFhcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy90cmFuc2xhdGVcbiAgICAgICAqL1xuICAgICAgXCJ0cmFuc2xhdGUteFwiOiBbe1xuICAgICAgICBcInRyYW5zbGF0ZS14XCI6IFtPXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIFRyYW5zbGF0ZSBZXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvdHJhbnNsYXRlXG4gICAgICAgKi9cbiAgICAgIFwidHJhbnNsYXRlLXlcIjogW3tcbiAgICAgICAgXCJ0cmFuc2xhdGUteVwiOiBbT11cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBTa2V3IFhcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9za2V3XG4gICAgICAgKi9cbiAgICAgIFwic2tldy14XCI6IFt7XG4gICAgICAgIFwic2tldy14XCI6IFtTXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIFNrZXcgWVxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3NrZXdcbiAgICAgICAqL1xuICAgICAgXCJza2V3LXlcIjogW3tcbiAgICAgICAgXCJza2V3LXlcIjogW1NdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogVHJhbnNmb3JtIE9yaWdpblxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3RyYW5zZm9ybS1vcmlnaW5cbiAgICAgICAqL1xuICAgICAgXCJ0cmFuc2Zvcm0tb3JpZ2luXCI6IFt7XG4gICAgICAgIG9yaWdpbjogW1wiY2VudGVyXCIsIFwidG9wXCIsIFwidG9wLXJpZ2h0XCIsIFwicmlnaHRcIiwgXCJib3R0b20tcmlnaHRcIiwgXCJib3R0b21cIiwgXCJib3R0b20tbGVmdFwiLCBcImxlZnRcIiwgXCJ0b3AtbGVmdFwiLCBmZV1cbiAgICAgIH1dLFxuICAgICAgLy8gSW50ZXJhY3Rpdml0eVxuICAgICAgLyoqXG4gICAgICAgKiBBY2NlbnQgQ29sb3JcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9hY2NlbnQtY29sb3JcbiAgICAgICAqL1xuICAgICAgYWNjZW50OiBbe1xuICAgICAgICBhY2NlbnQ6IFtcImF1dG9cIiwgZV1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBBcHBlYXJhbmNlXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvYXBwZWFyYW5jZVxuICAgICAgICovXG4gICAgICBhcHBlYXJhbmNlOiBbe1xuICAgICAgICBhcHBlYXJhbmNlOiBbXCJub25lXCIsIFwiYXV0b1wiXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIEN1cnNvclxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2N1cnNvclxuICAgICAgICovXG4gICAgICBjdXJzb3I6IFt7XG4gICAgICAgIGN1cnNvcjogW1wiYXV0b1wiLCBcImRlZmF1bHRcIiwgXCJwb2ludGVyXCIsIFwid2FpdFwiLCBcInRleHRcIiwgXCJtb3ZlXCIsIFwiaGVscFwiLCBcIm5vdC1hbGxvd2VkXCIsIFwibm9uZVwiLCBcImNvbnRleHQtbWVudVwiLCBcInByb2dyZXNzXCIsIFwiY2VsbFwiLCBcImNyb3NzaGFpclwiLCBcInZlcnRpY2FsLXRleHRcIiwgXCJhbGlhc1wiLCBcImNvcHlcIiwgXCJuby1kcm9wXCIsIFwiZ3JhYlwiLCBcImdyYWJiaW5nXCIsIFwiYWxsLXNjcm9sbFwiLCBcImNvbC1yZXNpemVcIiwgXCJyb3ctcmVzaXplXCIsIFwibi1yZXNpemVcIiwgXCJlLXJlc2l6ZVwiLCBcInMtcmVzaXplXCIsIFwidy1yZXNpemVcIiwgXCJuZS1yZXNpemVcIiwgXCJudy1yZXNpemVcIiwgXCJzZS1yZXNpemVcIiwgXCJzdy1yZXNpemVcIiwgXCJldy1yZXNpemVcIiwgXCJucy1yZXNpemVcIiwgXCJuZXN3LXJlc2l6ZVwiLCBcIm53c2UtcmVzaXplXCIsIFwiem9vbS1pblwiLCBcInpvb20tb3V0XCIsIGZlXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIENhcmV0IENvbG9yXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvanVzdC1pbi10aW1lLW1vZGUjY2FyZXQtY29sb3ItdXRpbGl0aWVzXG4gICAgICAgKi9cbiAgICAgIFwiY2FyZXQtY29sb3JcIjogW3tcbiAgICAgICAgY2FyZXQ6IFtlXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIFBvaW50ZXIgRXZlbnRzXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvcG9pbnRlci1ldmVudHNcbiAgICAgICAqL1xuICAgICAgXCJwb2ludGVyLWV2ZW50c1wiOiBbe1xuICAgICAgICBcInBvaW50ZXItZXZlbnRzXCI6IFtcIm5vbmVcIiwgXCJhdXRvXCJdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogUmVzaXplXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvcmVzaXplXG4gICAgICAgKi9cbiAgICAgIHJlc2l6ZTogW3tcbiAgICAgICAgcmVzaXplOiBbXCJub25lXCIsIFwieVwiLCBcInhcIiwgXCJcIl1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBTY3JvbGwgQmVoYXZpb3JcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9zY3JvbGwtYmVoYXZpb3JcbiAgICAgICAqL1xuICAgICAgXCJzY3JvbGwtYmVoYXZpb3JcIjogW3tcbiAgICAgICAgc2Nyb2xsOiBbXCJhdXRvXCIsIFwic21vb3RoXCJdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogU2Nyb2xsIE1hcmdpblxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3Njcm9sbC1tYXJnaW5cbiAgICAgICAqL1xuICAgICAgXCJzY3JvbGwtbVwiOiBbe1xuICAgICAgICBcInNjcm9sbC1tXCI6IEEoKVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIFNjcm9sbCBNYXJnaW4gWFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3Njcm9sbC1tYXJnaW5cbiAgICAgICAqL1xuICAgICAgXCJzY3JvbGwtbXhcIjogW3tcbiAgICAgICAgXCJzY3JvbGwtbXhcIjogQSgpXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogU2Nyb2xsIE1hcmdpbiBZXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3Mvc2Nyb2xsLW1hcmdpblxuICAgICAgICovXG4gICAgICBcInNjcm9sbC1teVwiOiBbe1xuICAgICAgICBcInNjcm9sbC1teVwiOiBBKClcbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBTY3JvbGwgTWFyZ2luIFN0YXJ0XG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3Mvc2Nyb2xsLW1hcmdpblxuICAgICAgICovXG4gICAgICBcInNjcm9sbC1tc1wiOiBbe1xuICAgICAgICBcInNjcm9sbC1tc1wiOiBBKClcbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBTY3JvbGwgTWFyZ2luIEVuZFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3Njcm9sbC1tYXJnaW5cbiAgICAgICAqL1xuICAgICAgXCJzY3JvbGwtbWVcIjogW3tcbiAgICAgICAgXCJzY3JvbGwtbWVcIjogQSgpXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogU2Nyb2xsIE1hcmdpbiBUb3BcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9zY3JvbGwtbWFyZ2luXG4gICAgICAgKi9cbiAgICAgIFwic2Nyb2xsLW10XCI6IFt7XG4gICAgICAgIFwic2Nyb2xsLW10XCI6IEEoKVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIFNjcm9sbCBNYXJnaW4gUmlnaHRcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9zY3JvbGwtbWFyZ2luXG4gICAgICAgKi9cbiAgICAgIFwic2Nyb2xsLW1yXCI6IFt7XG4gICAgICAgIFwic2Nyb2xsLW1yXCI6IEEoKVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIFNjcm9sbCBNYXJnaW4gQm90dG9tXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3Mvc2Nyb2xsLW1hcmdpblxuICAgICAgICovXG4gICAgICBcInNjcm9sbC1tYlwiOiBbe1xuICAgICAgICBcInNjcm9sbC1tYlwiOiBBKClcbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBTY3JvbGwgTWFyZ2luIExlZnRcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9zY3JvbGwtbWFyZ2luXG4gICAgICAgKi9cbiAgICAgIFwic2Nyb2xsLW1sXCI6IFt7XG4gICAgICAgIFwic2Nyb2xsLW1sXCI6IEEoKVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIFNjcm9sbCBQYWRkaW5nXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3Mvc2Nyb2xsLXBhZGRpbmdcbiAgICAgICAqL1xuICAgICAgXCJzY3JvbGwtcFwiOiBbe1xuICAgICAgICBcInNjcm9sbC1wXCI6IEEoKVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIFNjcm9sbCBQYWRkaW5nIFhcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9zY3JvbGwtcGFkZGluZ1xuICAgICAgICovXG4gICAgICBcInNjcm9sbC1weFwiOiBbe1xuICAgICAgICBcInNjcm9sbC1weFwiOiBBKClcbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBTY3JvbGwgUGFkZGluZyBZXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3Mvc2Nyb2xsLXBhZGRpbmdcbiAgICAgICAqL1xuICAgICAgXCJzY3JvbGwtcHlcIjogW3tcbiAgICAgICAgXCJzY3JvbGwtcHlcIjogQSgpXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogU2Nyb2xsIFBhZGRpbmcgU3RhcnRcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9zY3JvbGwtcGFkZGluZ1xuICAgICAgICovXG4gICAgICBcInNjcm9sbC1wc1wiOiBbe1xuICAgICAgICBcInNjcm9sbC1wc1wiOiBBKClcbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBTY3JvbGwgUGFkZGluZyBFbmRcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9zY3JvbGwtcGFkZGluZ1xuICAgICAgICovXG4gICAgICBcInNjcm9sbC1wZVwiOiBbe1xuICAgICAgICBcInNjcm9sbC1wZVwiOiBBKClcbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBTY3JvbGwgUGFkZGluZyBUb3BcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9zY3JvbGwtcGFkZGluZ1xuICAgICAgICovXG4gICAgICBcInNjcm9sbC1wdFwiOiBbe1xuICAgICAgICBcInNjcm9sbC1wdFwiOiBBKClcbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBTY3JvbGwgUGFkZGluZyBSaWdodFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3Njcm9sbC1wYWRkaW5nXG4gICAgICAgKi9cbiAgICAgIFwic2Nyb2xsLXByXCI6IFt7XG4gICAgICAgIFwic2Nyb2xsLXByXCI6IEEoKVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIFNjcm9sbCBQYWRkaW5nIEJvdHRvbVxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3Njcm9sbC1wYWRkaW5nXG4gICAgICAgKi9cbiAgICAgIFwic2Nyb2xsLXBiXCI6IFt7XG4gICAgICAgIFwic2Nyb2xsLXBiXCI6IEEoKVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIFNjcm9sbCBQYWRkaW5nIExlZnRcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9zY3JvbGwtcGFkZGluZ1xuICAgICAgICovXG4gICAgICBcInNjcm9sbC1wbFwiOiBbe1xuICAgICAgICBcInNjcm9sbC1wbFwiOiBBKClcbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBTY3JvbGwgU25hcCBBbGlnblxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3Njcm9sbC1zbmFwLWFsaWduXG4gICAgICAgKi9cbiAgICAgIFwic25hcC1hbGlnblwiOiBbe1xuICAgICAgICBzbmFwOiBbXCJzdGFydFwiLCBcImVuZFwiLCBcImNlbnRlclwiLCBcImFsaWduLW5vbmVcIl1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBTY3JvbGwgU25hcCBTdG9wXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3Mvc2Nyb2xsLXNuYXAtc3RvcFxuICAgICAgICovXG4gICAgICBcInNuYXAtc3RvcFwiOiBbe1xuICAgICAgICBzbmFwOiBbXCJub3JtYWxcIiwgXCJhbHdheXNcIl1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBTY3JvbGwgU25hcCBUeXBlXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3Mvc2Nyb2xsLXNuYXAtdHlwZVxuICAgICAgICovXG4gICAgICBcInNuYXAtdHlwZVwiOiBbe1xuICAgICAgICBzbmFwOiBbXCJub25lXCIsIFwieFwiLCBcInlcIiwgXCJib3RoXCJdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogU2Nyb2xsIFNuYXAgVHlwZSBTdHJpY3RuZXNzXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3Mvc2Nyb2xsLXNuYXAtdHlwZVxuICAgICAgICovXG4gICAgICBcInNuYXAtc3RyaWN0bmVzc1wiOiBbe1xuICAgICAgICBzbmFwOiBbXCJtYW5kYXRvcnlcIiwgXCJwcm94aW1pdHlcIl1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBUb3VjaCBBY3Rpb25cbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy90b3VjaC1hY3Rpb25cbiAgICAgICAqL1xuICAgICAgdG91Y2g6IFt7XG4gICAgICAgIHRvdWNoOiBbXCJhdXRvXCIsIFwibm9uZVwiLCBcIm1hbmlwdWxhdGlvblwiXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIFRvdWNoIEFjdGlvbiBYXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvdG91Y2gtYWN0aW9uXG4gICAgICAgKi9cbiAgICAgIFwidG91Y2gteFwiOiBbe1xuICAgICAgICBcInRvdWNoLXBhblwiOiBbXCJ4XCIsIFwibGVmdFwiLCBcInJpZ2h0XCJdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogVG91Y2ggQWN0aW9uIFlcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy90b3VjaC1hY3Rpb25cbiAgICAgICAqL1xuICAgICAgXCJ0b3VjaC15XCI6IFt7XG4gICAgICAgIFwidG91Y2gtcGFuXCI6IFtcInlcIiwgXCJ1cFwiLCBcImRvd25cIl1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBUb3VjaCBBY3Rpb24gUGluY2ggWm9vbVxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3RvdWNoLWFjdGlvblxuICAgICAgICovXG4gICAgICBcInRvdWNoLXB6XCI6IFtcInRvdWNoLXBpbmNoLXpvb21cIl0sXG4gICAgICAvKipcbiAgICAgICAqIFVzZXIgU2VsZWN0XG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvdXNlci1zZWxlY3RcbiAgICAgICAqL1xuICAgICAgc2VsZWN0OiBbe1xuICAgICAgICBzZWxlY3Q6IFtcIm5vbmVcIiwgXCJ0ZXh0XCIsIFwiYWxsXCIsIFwiYXV0b1wiXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIFdpbGwgQ2hhbmdlXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3Mvd2lsbC1jaGFuZ2VcbiAgICAgICAqL1xuICAgICAgXCJ3aWxsLWNoYW5nZVwiOiBbe1xuICAgICAgICBcIndpbGwtY2hhbmdlXCI6IFtcImF1dG9cIiwgXCJzY3JvbGxcIiwgXCJjb250ZW50c1wiLCBcInRyYW5zZm9ybVwiLCBmZV1cbiAgICAgIH1dLFxuICAgICAgLy8gU1ZHXG4gICAgICAvKipcbiAgICAgICAqIEZpbGxcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9maWxsXG4gICAgICAgKi9cbiAgICAgIGZpbGw6IFt7XG4gICAgICAgIGZpbGw6IFtlLCBcIm5vbmVcIl1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBTdHJva2UgV2lkdGhcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9zdHJva2Utd2lkdGhcbiAgICAgICAqL1xuICAgICAgXCJzdHJva2Utd1wiOiBbe1xuICAgICAgICBzdHJva2U6IFtwbiwgVG4sIG5hXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIFN0cm9rZVxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3N0cm9rZVxuICAgICAgICovXG4gICAgICBzdHJva2U6IFt7XG4gICAgICAgIHN0cm9rZTogW2UsIFwibm9uZVwiXVxuICAgICAgfV0sXG4gICAgICAvLyBBY2Nlc3NpYmlsaXR5XG4gICAgICAvKipcbiAgICAgICAqIFNjcmVlbiBSZWFkZXJzXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3Mvc2NyZWVuLXJlYWRlcnNcbiAgICAgICAqL1xuICAgICAgc3I6IFtcInNyLW9ubHlcIiwgXCJub3Qtc3Itb25seVwiXSxcbiAgICAgIC8qKlxuICAgICAgICogRm9yY2VkIENvbG9yIEFkanVzdFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2ZvcmNlZC1jb2xvci1hZGp1c3RcbiAgICAgICAqL1xuICAgICAgXCJmb3JjZWQtY29sb3ItYWRqdXN0XCI6IFt7XG4gICAgICAgIFwiZm9yY2VkLWNvbG9yLWFkanVzdFwiOiBbXCJhdXRvXCIsIFwibm9uZVwiXVxuICAgICAgfV1cbiAgICB9LFxuICAgIGNvbmZsaWN0aW5nQ2xhc3NHcm91cHM6IHtcbiAgICAgIG92ZXJmbG93OiBbXCJvdmVyZmxvdy14XCIsIFwib3ZlcmZsb3cteVwiXSxcbiAgICAgIG92ZXJzY3JvbGw6IFtcIm92ZXJzY3JvbGwteFwiLCBcIm92ZXJzY3JvbGwteVwiXSxcbiAgICAgIGluc2V0OiBbXCJpbnNldC14XCIsIFwiaW5zZXQteVwiLCBcInN0YXJ0XCIsIFwiZW5kXCIsIFwidG9wXCIsIFwicmlnaHRcIiwgXCJib3R0b21cIiwgXCJsZWZ0XCJdLFxuICAgICAgXCJpbnNldC14XCI6IFtcInJpZ2h0XCIsIFwibGVmdFwiXSxcbiAgICAgIFwiaW5zZXQteVwiOiBbXCJ0b3BcIiwgXCJib3R0b21cIl0sXG4gICAgICBmbGV4OiBbXCJiYXNpc1wiLCBcImdyb3dcIiwgXCJzaHJpbmtcIl0sXG4gICAgICBnYXA6IFtcImdhcC14XCIsIFwiZ2FwLXlcIl0sXG4gICAgICBwOiBbXCJweFwiLCBcInB5XCIsIFwicHNcIiwgXCJwZVwiLCBcInB0XCIsIFwicHJcIiwgXCJwYlwiLCBcInBsXCJdLFxuICAgICAgcHg6IFtcInByXCIsIFwicGxcIl0sXG4gICAgICBweTogW1wicHRcIiwgXCJwYlwiXSxcbiAgICAgIG06IFtcIm14XCIsIFwibXlcIiwgXCJtc1wiLCBcIm1lXCIsIFwibXRcIiwgXCJtclwiLCBcIm1iXCIsIFwibWxcIl0sXG4gICAgICBteDogW1wibXJcIiwgXCJtbFwiXSxcbiAgICAgIG15OiBbXCJtdFwiLCBcIm1iXCJdLFxuICAgICAgc2l6ZTogW1wid1wiLCBcImhcIl0sXG4gICAgICBcImZvbnQtc2l6ZVwiOiBbXCJsZWFkaW5nXCJdLFxuICAgICAgXCJmdm4tbm9ybWFsXCI6IFtcImZ2bi1vcmRpbmFsXCIsIFwiZnZuLXNsYXNoZWQtemVyb1wiLCBcImZ2bi1maWd1cmVcIiwgXCJmdm4tc3BhY2luZ1wiLCBcImZ2bi1mcmFjdGlvblwiXSxcbiAgICAgIFwiZnZuLW9yZGluYWxcIjogW1wiZnZuLW5vcm1hbFwiXSxcbiAgICAgIFwiZnZuLXNsYXNoZWQtemVyb1wiOiBbXCJmdm4tbm9ybWFsXCJdLFxuICAgICAgXCJmdm4tZmlndXJlXCI6IFtcImZ2bi1ub3JtYWxcIl0sXG4gICAgICBcImZ2bi1zcGFjaW5nXCI6IFtcImZ2bi1ub3JtYWxcIl0sXG4gICAgICBcImZ2bi1mcmFjdGlvblwiOiBbXCJmdm4tbm9ybWFsXCJdLFxuICAgICAgXCJsaW5lLWNsYW1wXCI6IFtcImRpc3BsYXlcIiwgXCJvdmVyZmxvd1wiXSxcbiAgICAgIHJvdW5kZWQ6IFtcInJvdW5kZWQtc1wiLCBcInJvdW5kZWQtZVwiLCBcInJvdW5kZWQtdFwiLCBcInJvdW5kZWQtclwiLCBcInJvdW5kZWQtYlwiLCBcInJvdW5kZWQtbFwiLCBcInJvdW5kZWQtc3NcIiwgXCJyb3VuZGVkLXNlXCIsIFwicm91bmRlZC1lZVwiLCBcInJvdW5kZWQtZXNcIiwgXCJyb3VuZGVkLXRsXCIsIFwicm91bmRlZC10clwiLCBcInJvdW5kZWQtYnJcIiwgXCJyb3VuZGVkLWJsXCJdLFxuICAgICAgXCJyb3VuZGVkLXNcIjogW1wicm91bmRlZC1zc1wiLCBcInJvdW5kZWQtZXNcIl0sXG4gICAgICBcInJvdW5kZWQtZVwiOiBbXCJyb3VuZGVkLXNlXCIsIFwicm91bmRlZC1lZVwiXSxcbiAgICAgIFwicm91bmRlZC10XCI6IFtcInJvdW5kZWQtdGxcIiwgXCJyb3VuZGVkLXRyXCJdLFxuICAgICAgXCJyb3VuZGVkLXJcIjogW1wicm91bmRlZC10clwiLCBcInJvdW5kZWQtYnJcIl0sXG4gICAgICBcInJvdW5kZWQtYlwiOiBbXCJyb3VuZGVkLWJyXCIsIFwicm91bmRlZC1ibFwiXSxcbiAgICAgIFwicm91bmRlZC1sXCI6IFtcInJvdW5kZWQtdGxcIiwgXCJyb3VuZGVkLWJsXCJdLFxuICAgICAgXCJib3JkZXItc3BhY2luZ1wiOiBbXCJib3JkZXItc3BhY2luZy14XCIsIFwiYm9yZGVyLXNwYWNpbmcteVwiXSxcbiAgICAgIFwiYm9yZGVyLXdcIjogW1wiYm9yZGVyLXctc1wiLCBcImJvcmRlci13LWVcIiwgXCJib3JkZXItdy10XCIsIFwiYm9yZGVyLXctclwiLCBcImJvcmRlci13LWJcIiwgXCJib3JkZXItdy1sXCJdLFxuICAgICAgXCJib3JkZXItdy14XCI6IFtcImJvcmRlci13LXJcIiwgXCJib3JkZXItdy1sXCJdLFxuICAgICAgXCJib3JkZXItdy15XCI6IFtcImJvcmRlci13LXRcIiwgXCJib3JkZXItdy1iXCJdLFxuICAgICAgXCJib3JkZXItY29sb3JcIjogW1wiYm9yZGVyLWNvbG9yLXRcIiwgXCJib3JkZXItY29sb3ItclwiLCBcImJvcmRlci1jb2xvci1iXCIsIFwiYm9yZGVyLWNvbG9yLWxcIl0sXG4gICAgICBcImJvcmRlci1jb2xvci14XCI6IFtcImJvcmRlci1jb2xvci1yXCIsIFwiYm9yZGVyLWNvbG9yLWxcIl0sXG4gICAgICBcImJvcmRlci1jb2xvci15XCI6IFtcImJvcmRlci1jb2xvci10XCIsIFwiYm9yZGVyLWNvbG9yLWJcIl0sXG4gICAgICBcInNjcm9sbC1tXCI6IFtcInNjcm9sbC1teFwiLCBcInNjcm9sbC1teVwiLCBcInNjcm9sbC1tc1wiLCBcInNjcm9sbC1tZVwiLCBcInNjcm9sbC1tdFwiLCBcInNjcm9sbC1tclwiLCBcInNjcm9sbC1tYlwiLCBcInNjcm9sbC1tbFwiXSxcbiAgICAgIFwic2Nyb2xsLW14XCI6IFtcInNjcm9sbC1tclwiLCBcInNjcm9sbC1tbFwiXSxcbiAgICAgIFwic2Nyb2xsLW15XCI6IFtcInNjcm9sbC1tdFwiLCBcInNjcm9sbC1tYlwiXSxcbiAgICAgIFwic2Nyb2xsLXBcIjogW1wic2Nyb2xsLXB4XCIsIFwic2Nyb2xsLXB5XCIsIFwic2Nyb2xsLXBzXCIsIFwic2Nyb2xsLXBlXCIsIFwic2Nyb2xsLXB0XCIsIFwic2Nyb2xsLXByXCIsIFwic2Nyb2xsLXBiXCIsIFwic2Nyb2xsLXBsXCJdLFxuICAgICAgXCJzY3JvbGwtcHhcIjogW1wic2Nyb2xsLXByXCIsIFwic2Nyb2xsLXBsXCJdLFxuICAgICAgXCJzY3JvbGwtcHlcIjogW1wic2Nyb2xsLXB0XCIsIFwic2Nyb2xsLXBiXCJdLFxuICAgICAgdG91Y2g6IFtcInRvdWNoLXhcIiwgXCJ0b3VjaC15XCIsIFwidG91Y2gtcHpcIl0sXG4gICAgICBcInRvdWNoLXhcIjogW1widG91Y2hcIl0sXG4gICAgICBcInRvdWNoLXlcIjogW1widG91Y2hcIl0sXG4gICAgICBcInRvdWNoLXB6XCI6IFtcInRvdWNoXCJdXG4gICAgfSxcbiAgICBjb25mbGljdGluZ0NsYXNzR3JvdXBNb2RpZmllcnM6IHtcbiAgICAgIFwiZm9udC1zaXplXCI6IFtcImxlYWRpbmdcIl1cbiAgICB9XG4gIH07XG59XG5jb25zdCB1MSA9IC8qIEBfX1BVUkVfXyAqLyBHeChzMSk7XG5mdW5jdGlvbiBMZSguLi5lKSB7XG4gIHJldHVybiB1MSgkZShlKSk7XG59XG5jb25zdCBjMSA9IFR4KFxuICBcImlubGluZS1mbGV4IGl0ZW1zLWNlbnRlciBqdXN0aWZ5LWNlbnRlciB3aGl0ZXNwYWNlLW5vd3JhcCByb3VuZGVkLW1kIHRleHQtc20gZm9udC1tZWRpdW0gcmluZy1vZmZzZXQtYmFja2dyb3VuZCB0cmFuc2l0aW9uLWNvbG9ycyBmb2N1cy12aXNpYmxlOm91dGxpbmUtbm9uZSBmb2N1cy12aXNpYmxlOnJpbmctMiBmb2N1cy12aXNpYmxlOnJpbmctcmluZyBmb2N1cy12aXNpYmxlOnJpbmctb2Zmc2V0LTIgZGlzYWJsZWQ6cG9pbnRlci1ldmVudHMtbm9uZSBkaXNhYmxlZDpvcGFjaXR5LTUwXCIsXG4gIHtcbiAgICB2YXJpYW50czoge1xuICAgICAgdmFyaWFudDoge1xuICAgICAgICBkZWZhdWx0OiBcImJnLXByaW1hcnkgdGV4dC1wcmltYXJ5LWZvcmVncm91bmQgaG92ZXI6YmctcHJpbWFyeS85MFwiLFxuICAgICAgICBkZXN0cnVjdGl2ZTogXCJiZy1kZXN0cnVjdGl2ZSB0ZXh0LWRlc3RydWN0aXZlLWZvcmVncm91bmQgaG92ZXI6YmctZGVzdHJ1Y3RpdmUvOTBcIixcbiAgICAgICAgb3V0bGluZTogXCJib3JkZXIgYm9yZGVyLWlucHV0IGJnLWJhY2tncm91bmQgaG92ZXI6YmctYWNjZW50IGhvdmVyOnRleHQtYWNjZW50LWZvcmVncm91bmRcIixcbiAgICAgICAgc2Vjb25kYXJ5OiBcImJnLXNlY29uZGFyeSB0ZXh0LXNlY29uZGFyeS1mb3JlZ3JvdW5kIGhvdmVyOmJnLXNlY29uZGFyeS84MFwiLFxuICAgICAgICBnaG9zdDogXCJob3ZlcjpiZy1hY2NlbnQgaG92ZXI6dGV4dC1hY2NlbnQtZm9yZWdyb3VuZFwiLFxuICAgICAgICBsaW5rOiBcInRleHQtcHJpbWFyeSB1bmRlcmxpbmUtb2Zmc2V0LTQgaG92ZXI6dW5kZXJsaW5lXCJcbiAgICAgIH0sXG4gICAgICBzaXplOiB7XG4gICAgICAgIGRlZmF1bHQ6IFwiaC0xMCBweC00IHB5LTJcIixcbiAgICAgICAgc206IFwiaC05IHJvdW5kZWQtbWQgcHgtM1wiLFxuICAgICAgICBsZzogXCJoLTExIHJvdW5kZWQtbWQgcHgtOFwiLFxuICAgICAgICBpY29uOiBcImgtMTAgdy0xMFwiXG4gICAgICB9XG4gICAgfSxcbiAgICBkZWZhdWx0VmFyaWFudHM6IHtcbiAgICAgIHZhcmlhbnQ6IFwiZGVmYXVsdFwiLFxuICAgICAgc2l6ZTogXCJkZWZhdWx0XCJcbiAgICB9XG4gIH1cbiksIGFyID0gSC5mb3J3YXJkUmVmKFxuICAoeyBjbGFzc05hbWU6IGUsIHZhcmlhbnQ6IHQsIHNpemU6IG4sIGFzQ2hpbGQ6IHIgPSAhMSwgLi4uaSB9LCBvKSA9PiAvKiBAX19QVVJFX18gKi8gWChcbiAgICByID8ga3IgOiBcImJ1dHRvblwiLFxuICAgIHtcbiAgICAgIGNsYXNzTmFtZTogTGUoYzEoeyB2YXJpYW50OiB0LCBzaXplOiBuLCBjbGFzc05hbWU6IGUgfSkpLFxuICAgICAgcmVmOiBvLFxuICAgICAgLi4uaVxuICAgIH1cbiAgKVxuKTtcbmFyLmRpc3BsYXlOYW1lID0gXCJCdXR0b25cIjtcbmNvbnN0IEtVID0gKHsgdGl0bGU6IGUgfSkgPT4gLyogQF9fUFVSRV9fICovIFgoYXIsIHsgY2hpbGRyZW46IGUgfSk7XG4vKipcbiAqIEBsaWNlbnNlIGx1Y2lkZS1yZWFjdCB2MC4zOTAuMCAtIElTQ1xuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIElTQyBsaWNlbnNlLlxuICogU2VlIHRoZSBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cbmNvbnN0IGwxID0gKGUpID0+IGUucmVwbGFjZSgvKFthLXowLTldKShbQS1aXSkvZywgXCIkMS0kMlwiKS50b0xvd2VyQ2FzZSgpLCB3bSA9ICguLi5lKSA9PiBlLmZpbHRlcigodCwgbiwgcikgPT4gISF0ICYmIHIuaW5kZXhPZih0KSA9PT0gbikuam9pbihcIiBcIik7XG4vKipcbiAqIEBsaWNlbnNlIGx1Y2lkZS1yZWFjdCB2MC4zOTAuMCAtIElTQ1xuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIElTQyBsaWNlbnNlLlxuICogU2VlIHRoZSBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cbnZhciBmMSA9IHtcbiAgeG1sbnM6IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIixcbiAgd2lkdGg6IDI0LFxuICBoZWlnaHQ6IDI0LFxuICB2aWV3Qm94OiBcIjAgMCAyNCAyNFwiLFxuICBmaWxsOiBcIm5vbmVcIixcbiAgc3Ryb2tlOiBcImN1cnJlbnRDb2xvclwiLFxuICBzdHJva2VXaWR0aDogMixcbiAgc3Ryb2tlTGluZWNhcDogXCJyb3VuZFwiLFxuICBzdHJva2VMaW5lam9pbjogXCJyb3VuZFwiXG59O1xuLyoqXG4gKiBAbGljZW5zZSBsdWNpZGUtcmVhY3QgdjAuMzkwLjAgLSBJU0NcbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBJU0MgbGljZW5zZS5cbiAqIFNlZSB0aGUgTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5jb25zdCBkMSA9IGhlKFxuICAoe1xuICAgIGNvbG9yOiBlID0gXCJjdXJyZW50Q29sb3JcIixcbiAgICBzaXplOiB0ID0gMjQsXG4gICAgc3Ryb2tlV2lkdGg6IG4gPSAyLFxuICAgIGFic29sdXRlU3Ryb2tlV2lkdGg6IHIsXG4gICAgY2xhc3NOYW1lOiBpID0gXCJcIixcbiAgICBjaGlsZHJlbjogbyxcbiAgICBpY29uTm9kZTogYSxcbiAgICAuLi5zXG4gIH0sIHUpID0+IFkoXG4gICAgXCJzdmdcIixcbiAgICB7XG4gICAgICByZWY6IHUsXG4gICAgICAuLi5mMSxcbiAgICAgIHdpZHRoOiB0LFxuICAgICAgaGVpZ2h0OiB0LFxuICAgICAgc3Ryb2tlOiBlLFxuICAgICAgc3Ryb2tlV2lkdGg6IHIgPyBOdW1iZXIobikgKiAyNCAvIE51bWJlcih0KSA6IG4sXG4gICAgICBjbGFzc05hbWU6IHdtKFwibHVjaWRlXCIsIGkpLFxuICAgICAgLi4uc1xuICAgIH0sXG4gICAgW1xuICAgICAgLi4uYS5tYXAoKFtjLCBmXSkgPT4gWShjLCBmKSksXG4gICAgICAuLi5BcnJheS5pc0FycmF5KG8pID8gbyA6IFtvXVxuICAgIF1cbiAgKVxuKTtcbi8qKlxuICogQGxpY2Vuc2UgbHVjaWRlLXJlYWN0IHYwLjM5MC4wIC0gSVNDXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgSVNDIGxpY2Vuc2UuXG4gKiBTZWUgdGhlIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuY29uc3QgcHIgPSAoZSwgdCkgPT4ge1xuICBjb25zdCBuID0gaGUoXG4gICAgKHsgY2xhc3NOYW1lOiByLCAuLi5pIH0sIG8pID0+IFkoZDEsIHtcbiAgICAgIHJlZjogbyxcbiAgICAgIGljb25Ob2RlOiB0LFxuICAgICAgY2xhc3NOYW1lOiB3bShgbHVjaWRlLSR7bDEoZSl9YCwgciksXG4gICAgICAuLi5pXG4gICAgfSlcbiAgKTtcbiAgcmV0dXJuIG4uZGlzcGxheU5hbWUgPSBgJHtlfWAsIG47XG59O1xuLyoqXG4gKiBAbGljZW5zZSBsdWNpZGUtcmVhY3QgdjAuMzkwLjAgLSBJU0NcbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBJU0MgbGljZW5zZS5cbiAqIFNlZSB0aGUgTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5jb25zdCBwMSA9IHByKFwiQmVsbFJpbmdcIiwgW1xuICBbXCJwYXRoXCIsIHsgZDogXCJNNiA4YTYgNiAwIDAgMSAxMiAwYzAgNyAzIDkgMyA5SDNzMy0yIDMtOVwiLCBrZXk6IFwiMXFvMnMyXCIgfV0sXG4gIFtcInBhdGhcIiwgeyBkOiBcIk0xMC4zIDIxYTEuOTQgMS45NCAwIDAgMCAzLjQgMFwiLCBrZXk6IFwicWdvMzVzXCIgfV0sXG4gIFtcInBhdGhcIiwgeyBkOiBcIk00IDJDMi44IDMuNyAyIDUuNyAyIDhcIiwga2V5OiBcInRhcDllMFwiIH1dLFxuICBbXCJwYXRoXCIsIHsgZDogXCJNMjIgOGMwLTIuMy0uOC00LjMtMi02XCIsIGtleTogXCI1YmIzYWRcIiB9XVxuXSk7XG4vKipcbiAqIEBsaWNlbnNlIGx1Y2lkZS1yZWFjdCB2MC4zOTAuMCAtIElTQ1xuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIElTQyBsaWNlbnNlLlxuICogU2VlIHRoZSBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cbmNvbnN0IHhtID0gcHIoXCJDaGVja1wiLCBbW1wicGF0aFwiLCB7IGQ6IFwiTTIwIDYgOSAxN2wtNS01XCIsIGtleTogXCIxZ21mMmNcIiB9XV0pO1xuLyoqXG4gKiBAbGljZW5zZSBsdWNpZGUtcmVhY3QgdjAuMzkwLjAgLSBJU0NcbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBJU0MgbGljZW5zZS5cbiAqIFNlZSB0aGUgTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5jb25zdCBoMSA9IHByKFwiQ2hldnJvbkRvd25cIiwgW1xuICBbXCJwYXRoXCIsIHsgZDogXCJtNiA5IDYgNiA2LTZcIiwga2V5OiBcInFydW5zbFwiIH1dXG5dKTtcbi8qKlxuICogQGxpY2Vuc2UgbHVjaWRlLXJlYWN0IHYwLjM5MC4wIC0gSVNDXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgSVNDIGxpY2Vuc2UuXG4gKiBTZWUgdGhlIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuY29uc3QgZzEgPSBwcihcIkNoZXZyb25SaWdodFwiLCBbXG4gIFtcInBhdGhcIiwgeyBkOiBcIm05IDE4IDYtNi02LTZcIiwga2V5OiBcIm10aGh3cVwiIH1dXG5dKTtcbi8qKlxuICogQGxpY2Vuc2UgbHVjaWRlLXJlYWN0IHYwLjM5MC4wIC0gSVNDXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgSVNDIGxpY2Vuc2UuXG4gKiBTZWUgdGhlIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuY29uc3QgdjEgPSBwcihcIkNpcmNsZVwiLCBbXG4gIFtcImNpcmNsZVwiLCB7IGN4OiBcIjEyXCIsIGN5OiBcIjEyXCIsIHI6IFwiMTBcIiwga2V5OiBcIjFtZ2xheVwiIH1dXG5dKTtcbi8qKlxuICogQGxpY2Vuc2UgbHVjaWRlLXJlYWN0IHYwLjM5MC4wIC0gSVNDXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgSVNDIGxpY2Vuc2UuXG4gKiBTZWUgdGhlIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuY29uc3QgbTEgPSBwcihcIk1vb25cIiwgW1xuICBbXCJwYXRoXCIsIHsgZDogXCJNMTIgM2E2IDYgMCAwIDAgOSA5IDkgOSAwIDEgMS05LTlaXCIsIGtleTogXCJhN3RuMThcIiB9XVxuXSk7XG4vKipcbiAqIEBsaWNlbnNlIGx1Y2lkZS1yZWFjdCB2MC4zOTAuMCAtIElTQ1xuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIElTQyBsaWNlbnNlLlxuICogU2VlIHRoZSBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cbmNvbnN0IHkxID0gcHIoXCJTdW5cIiwgW1xuICBbXCJjaXJjbGVcIiwgeyBjeDogXCIxMlwiLCBjeTogXCIxMlwiLCByOiBcIjRcIiwga2V5OiBcIjRleGlwMlwiIH1dLFxuICBbXCJwYXRoXCIsIHsgZDogXCJNMTIgMnYyXCIsIGtleTogXCJ0dXMwM21cIiB9XSxcbiAgW1wicGF0aFwiLCB7IGQ6IFwiTTEyIDIwdjJcIiwga2V5OiBcIjFsaDFrZ1wiIH1dLFxuICBbXCJwYXRoXCIsIHsgZDogXCJtNC45MyA0LjkzIDEuNDEgMS40MVwiLCBrZXk6IFwiMTQ5dDZqXCIgfV0sXG4gIFtcInBhdGhcIiwgeyBkOiBcIm0xNy42NiAxNy42NiAxLjQxIDEuNDFcIiwga2V5OiBcInB0Ymd1dlwiIH1dLFxuICBbXCJwYXRoXCIsIHsgZDogXCJNMiAxMmgyXCIsIGtleTogXCIxdDhmOG5cIiB9XSxcbiAgW1wicGF0aFwiLCB7IGQ6IFwiTTIwIDEyaDJcIiwga2V5OiBcIjFxOG1qd1wiIH1dLFxuICBbXCJwYXRoXCIsIHsgZDogXCJtNi4zNCAxNy42Ni0xLjQxIDEuNDFcIiwga2V5OiBcIjFtOHp6NVwiIH1dLFxuICBbXCJwYXRoXCIsIHsgZDogXCJtMTkuMDcgNC45My0xLjQxIDEuNDFcIiwga2V5OiBcIjFzaGxjc1wiIH1dXG5dKSwgU20gPSBILmZvcndhcmRSZWYoKHsgY2xhc3NOYW1lOiBlLCAuLi50IH0sIG4pID0+IC8qIEBfX1BVUkVfXyAqLyBYKFxuICBcImRpdlwiLFxuICB7XG4gICAgcmVmOiBuLFxuICAgIGNsYXNzTmFtZTogTGUoXG4gICAgICBcInJvdW5kZWQtbGcgYm9yZGVyIGJnLWNhcmQgdGV4dC1jYXJkLWZvcmVncm91bmQgc2hhZG93LXNtXCIsXG4gICAgICBlXG4gICAgKSxcbiAgICAuLi50XG4gIH1cbikpO1xuU20uZGlzcGxheU5hbWUgPSBcIkNhcmRcIjtcbmNvbnN0ICRtID0gSC5mb3J3YXJkUmVmKCh7IGNsYXNzTmFtZTogZSwgLi4udCB9LCBuKSA9PiAvKiBAX19QVVJFX18gKi8gWChcbiAgXCJkaXZcIixcbiAge1xuICAgIHJlZjogbixcbiAgICBjbGFzc05hbWU6IExlKFwiZmxleCBmbGV4LWNvbCBzcGFjZS15LTEuNSBwLTZcIiwgZSksXG4gICAgLi4udFxuICB9XG4pKTtcbiRtLmRpc3BsYXlOYW1lID0gXCJDYXJkSGVhZGVyXCI7XG5jb25zdCBPbSA9IEguZm9yd2FyZFJlZigoeyBjbGFzc05hbWU6IGUsIC4uLnQgfSwgbikgPT4gLyogQF9fUFVSRV9fICovIFgoXG4gIFwiaDNcIixcbiAge1xuICAgIHJlZjogbixcbiAgICBjbGFzc05hbWU6IExlKFxuICAgICAgXCJ0ZXh0LTJ4bCBmb250LXNlbWlib2xkIGxlYWRpbmctbm9uZSB0cmFja2luZy10aWdodFwiLFxuICAgICAgZVxuICAgICksXG4gICAgLi4udFxuICB9XG4pKTtcbk9tLmRpc3BsYXlOYW1lID0gXCJDYXJkVGl0bGVcIjtcbmNvbnN0IF9tID0gSC5mb3J3YXJkUmVmKCh7IGNsYXNzTmFtZTogZSwgLi4udCB9LCBuKSA9PiAvKiBAX19QVVJFX18gKi8gWChcbiAgXCJwXCIsXG4gIHtcbiAgICByZWY6IG4sXG4gICAgY2xhc3NOYW1lOiBMZShcInRleHQtc20gdGV4dC1tdXRlZC1mb3JlZ3JvdW5kXCIsIGUpLFxuICAgIC4uLnRcbiAgfVxuKSk7XG5fbS5kaXNwbGF5TmFtZSA9IFwiQ2FyZERlc2NyaXB0aW9uXCI7XG5jb25zdCBBbSA9IEguZm9yd2FyZFJlZigoeyBjbGFzc05hbWU6IGUsIC4uLnQgfSwgbikgPT4gLyogQF9fUFVSRV9fICovIFgoXCJkaXZcIiwgeyByZWY6IG4sIGNsYXNzTmFtZTogTGUoXCJwLTYgcHQtMFwiLCBlKSwgLi4udCB9KSk7XG5BbS5kaXNwbGF5TmFtZSA9IFwiQ2FyZENvbnRlbnRcIjtcbmNvbnN0IFBtID0gSC5mb3J3YXJkUmVmKCh7IGNsYXNzTmFtZTogZSwgLi4udCB9LCBuKSA9PiAvKiBAX19QVVJFX18gKi8gWChcbiAgXCJkaXZcIixcbiAge1xuICAgIHJlZjogbixcbiAgICBjbGFzc05hbWU6IExlKFwiZmxleCBpdGVtcy1jZW50ZXIgcC02IHB0LTBcIiwgZSksXG4gICAgLi4udFxuICB9XG4pKTtcblBtLmRpc3BsYXlOYW1lID0gXCJDYXJkRm9vdGVyXCI7XG5jb25zdCBiMSA9IFtcbiAge1xuICAgIHRpdGxlOiBcIllvdXIgY2FsbCBoYXMgYmVlbiBjb25maXJtZWQuXCIsXG4gICAgZGVzY3JpcHRpb246IFwiMSBob3VyIGFnb1wiXG4gIH0sXG4gIHtcbiAgICB0aXRsZTogXCJZb3UgaGF2ZSBhIG5ldyBtZXNzYWdlIVwiLFxuICAgIGRlc2NyaXB0aW9uOiBcIjEgaG91ciBhZ29cIlxuICB9LFxuICB7XG4gICAgdGl0bGU6IFwiWW91ciBzdWJzY3JpcHRpb24gaXMgZXhwaXJpbmcgc29vbiFcIixcbiAgICBkZXNjcmlwdGlvbjogXCIyIGhvdXJzIGFnb1wiXG4gIH1cbl07XG5mdW5jdGlvbiBZVSh7IGNsYXNzTmFtZTogZSwgLi4udCB9KSB7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gemUoU20sIHsgY2xhc3NOYW1lOiBMZShcInctWzM4MHB4XVwiLCBlKSwgLi4udCwgY2hpbGRyZW46IFtcbiAgICAvKiBAX19QVVJFX18gKi8gemUoJG0sIHsgY2hpbGRyZW46IFtcbiAgICAgIC8qIEBfX1BVUkVfXyAqLyBYKE9tLCB7IGNoaWxkcmVuOiBcIk5vdGlmaWNhdGlvbnNcIiB9KSxcbiAgICAgIC8qIEBfX1BVUkVfXyAqLyBYKF9tLCB7IGNoaWxkcmVuOiBcIllvdSBoYXZlIDMgdW5yZWFkIG1lc3NhZ2VzLlwiIH0pXG4gICAgXSB9KSxcbiAgICAvKiBAX19QVVJFX18gKi8gemUoQW0sIHsgY2xhc3NOYW1lOiBcImdyaWQgZ2FwLTRcIiwgY2hpbGRyZW46IFtcbiAgICAgIC8qIEBfX1BVUkVfXyAqLyB6ZShcImRpdlwiLCB7IGNsYXNzTmFtZTogXCIgZmxleCBpdGVtcy1jZW50ZXIgc3BhY2UteC00IHJvdW5kZWQtbWQgYm9yZGVyIHAtNFwiLCBjaGlsZHJlbjogW1xuICAgICAgICAvKiBAX19QVVJFX18gKi8gWChwMSwge30pLFxuICAgICAgICAvKiBAX19QVVJFX18gKi8gemUoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwiZmxleC0xIHNwYWNlLXktMVwiLCBjaGlsZHJlbjogW1xuICAgICAgICAgIC8qIEBfX1BVUkVfXyAqLyBYKFwicFwiLCB7IGNsYXNzTmFtZTogXCJ0ZXh0LXNtIGZvbnQtbWVkaXVtIGxlYWRpbmctbm9uZVwiLCBjaGlsZHJlbjogXCJQdXNoIE5vdGlmaWNhdGlvbnNcIiB9KSxcbiAgICAgICAgICAvKiBAX19QVVJFX18gKi8gWChcInBcIiwgeyBjbGFzc05hbWU6IFwidGV4dC1zbSB0ZXh0LW11dGVkLWZvcmVncm91bmRcIiwgY2hpbGRyZW46IFwiU2VuZCBub3RpZmljYXRpb25zIHRvIGRldmljZS5cIiB9KVxuICAgICAgICBdIH0pXG4gICAgICBdIH0pLFxuICAgICAgLyogQF9fUFVSRV9fICovIFgoXCJkaXZcIiwgeyBjaGlsZHJlbjogYjEubWFwKChuLCByKSA9PiAvKiBAX19QVVJFX18gKi8gemUoXG4gICAgICAgIFwiZGl2XCIsXG4gICAgICAgIHtcbiAgICAgICAgICBjbGFzc05hbWU6IFwibWItNCBncmlkIGdyaWQtY29scy1bMjVweF8xZnJdIGl0ZW1zLXN0YXJ0IHBiLTQgbGFzdDptYi0wIGxhc3Q6cGItMFwiLFxuICAgICAgICAgIGNoaWxkcmVuOiBbXG4gICAgICAgICAgICAvKiBAX19QVVJFX18gKi8gWChcInNwYW5cIiwgeyBjbGFzc05hbWU6IFwiZmxleCBoLTIgdy0yIHRyYW5zbGF0ZS15LTEgcm91bmRlZC1mdWxsIGJnLXNreS01MDBcIiB9KSxcbiAgICAgICAgICAgIC8qIEBfX1BVUkVfXyAqLyB6ZShcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJzcGFjZS15LTFcIiwgY2hpbGRyZW46IFtcbiAgICAgICAgICAgICAgLyogQF9fUFVSRV9fICovIFgoXCJwXCIsIHsgY2xhc3NOYW1lOiBcInRleHQtc20gZm9udC1tZWRpdW0gbGVhZGluZy1ub25lXCIsIGNoaWxkcmVuOiBuLnRpdGxlIH0pLFxuICAgICAgICAgICAgICAvKiBAX19QVVJFX18gKi8gWChcInBcIiwgeyBjbGFzc05hbWU6IFwidGV4dC1zbSB0ZXh0LW11dGVkLWZvcmVncm91bmRcIiwgY2hpbGRyZW46IG4uZGVzY3JpcHRpb24gfSlcbiAgICAgICAgICAgIF0gfSlcbiAgICAgICAgICBdXG4gICAgICAgIH0sXG4gICAgICAgIHJcbiAgICAgICkpIH0pXG4gICAgXSB9KSxcbiAgICAvKiBAX19QVVJFX18gKi8gWChQbSwgeyBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIHplKGFyLCB7IGNsYXNzTmFtZTogXCJ3LWZ1bGxcIiwgY2hpbGRyZW46IFtcbiAgICAgIC8qIEBfX1BVUkVfXyAqLyBYKHhtLCB7IGNsYXNzTmFtZTogXCJtci0yIGgtNCB3LTRcIiB9KSxcbiAgICAgIFwiIE1hcmsgYWxsIGFzIHJlYWRcIlxuICAgIF0gfSkgfSlcbiAgXSB9KTtcbn1cbmZ1bmN0aW9uIHdlKGUsIHQsIHsgY2hlY2tGb3JEZWZhdWx0UHJldmVudGVkOiBuID0gITAgfSA9IHt9KSB7XG4gIHJldHVybiBmdW5jdGlvbihpKSB7XG4gICAgaWYgKGUgPT0gbnVsbCB8fCBlKGkpLCBuID09PSAhMSB8fCAhaS5kZWZhdWx0UHJldmVudGVkKVxuICAgICAgcmV0dXJuIHQgPT0gbnVsbCA/IHZvaWQgMCA6IHQoaSk7XG4gIH07XG59XG5mdW5jdGlvbiBGbyhlLCB0ID0gW10pIHtcbiAgbGV0IG4gPSBbXTtcbiAgZnVuY3Rpb24gcihvLCBhKSB7XG4gICAgY29uc3QgcyA9IC8qIEBfX1BVUkVfXyAqLyBadChhKSwgdSA9IG4ubGVuZ3RoO1xuICAgIG4gPSBbXG4gICAgICAuLi5uLFxuICAgICAgYVxuICAgIF07XG4gICAgZnVuY3Rpb24gYyhsKSB7XG4gICAgICBjb25zdCB7IHNjb3BlOiBkLCBjaGlsZHJlbjogcCwgLi4uZyB9ID0gbCwgaCA9IChkID09IG51bGwgPyB2b2lkIDAgOiBkW2VdW3VdKSB8fCBzLCB2ID0gWGkoXG4gICAgICAgICgpID0+IGcsXG4gICAgICAgIE9iamVjdC52YWx1ZXMoZylcbiAgICAgICk7XG4gICAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIFkoaC5Qcm92aWRlciwge1xuICAgICAgICB2YWx1ZTogdlxuICAgICAgfSwgcCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGYobCwgZCkge1xuICAgICAgY29uc3QgcCA9IChkID09IG51bGwgPyB2b2lkIDAgOiBkW2VdW3VdKSB8fCBzLCBnID0gTnQocCk7XG4gICAgICBpZiAoZylcbiAgICAgICAgcmV0dXJuIGc7XG4gICAgICBpZiAoYSAhPT0gdm9pZCAwKVxuICAgICAgICByZXR1cm4gYTtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgXFxgJHtsfVxcYCBtdXN0IGJlIHVzZWQgd2l0aGluIFxcYCR7b31cXGBgKTtcbiAgICB9XG4gICAgcmV0dXJuIGMuZGlzcGxheU5hbWUgPSBvICsgXCJQcm92aWRlclwiLCBbXG4gICAgICBjLFxuICAgICAgZlxuICAgIF07XG4gIH1cbiAgY29uc3QgaSA9ICgpID0+IHtcbiAgICBjb25zdCBvID0gbi5tYXAoKGEpID0+IC8qIEBfX1BVUkVfXyAqLyBadChhKSk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHMpIHtcbiAgICAgIGNvbnN0IHUgPSAocyA9PSBudWxsID8gdm9pZCAwIDogc1tlXSkgfHwgbztcbiAgICAgIHJldHVybiBYaShcbiAgICAgICAgKCkgPT4gKHtcbiAgICAgICAgICBbYF9fc2NvcGUke2V9YF06IHtcbiAgICAgICAgICAgIC4uLnMsXG4gICAgICAgICAgICBbZV06IHVcbiAgICAgICAgICB9XG4gICAgICAgIH0pLFxuICAgICAgICBbXG4gICAgICAgICAgcyxcbiAgICAgICAgICB1XG4gICAgICAgIF1cbiAgICAgICk7XG4gICAgfTtcbiAgfTtcbiAgcmV0dXJuIGkuc2NvcGVOYW1lID0gZSwgW1xuICAgIHIsXG4gICAgdzEoaSwgLi4udClcbiAgXTtcbn1cbmZ1bmN0aW9uIHcxKC4uLmUpIHtcbiAgY29uc3QgdCA9IGVbMF07XG4gIGlmIChlLmxlbmd0aCA9PT0gMSlcbiAgICByZXR1cm4gdDtcbiAgY29uc3QgbiA9ICgpID0+IHtcbiAgICBjb25zdCByID0gZS5tYXAoXG4gICAgICAoaSkgPT4gKHtcbiAgICAgICAgdXNlU2NvcGU6IGkoKSxcbiAgICAgICAgc2NvcGVOYW1lOiBpLnNjb3BlTmFtZVxuICAgICAgfSlcbiAgICApO1xuICAgIHJldHVybiBmdW5jdGlvbihvKSB7XG4gICAgICBjb25zdCBhID0gci5yZWR1Y2UoKHMsIHsgdXNlU2NvcGU6IHUsIHNjb3BlTmFtZTogYyB9KSA9PiB7XG4gICAgICAgIGNvbnN0IGwgPSB1KG8pW2BfX3Njb3BlJHtjfWBdO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIC4uLnMsXG4gICAgICAgICAgLi4ubFxuICAgICAgICB9O1xuICAgICAgfSwge30pO1xuICAgICAgcmV0dXJuIFhpKFxuICAgICAgICAoKSA9PiAoe1xuICAgICAgICAgIFtgX19zY29wZSR7dC5zY29wZU5hbWV9YF06IGFcbiAgICAgICAgfSksXG4gICAgICAgIFtcbiAgICAgICAgICBhXG4gICAgICAgIF1cbiAgICAgICk7XG4gICAgfTtcbiAgfTtcbiAgcmV0dXJuIG4uc2NvcGVOYW1lID0gdC5zY29wZU5hbWUsIG47XG59XG5mdW5jdGlvbiB1bihlKSB7XG4gIGNvbnN0IHQgPSBfZShlKTtcbiAgcmV0dXJuIEZlKCgpID0+IHtcbiAgICB0LmN1cnJlbnQgPSBlO1xuICB9KSwgWGkoXG4gICAgKCkgPT4gKC4uLm4pID0+IHtcbiAgICAgIHZhciByO1xuICAgICAgcmV0dXJuIChyID0gdC5jdXJyZW50KSA9PT0gbnVsbCB8fCByID09PSB2b2lkIDAgPyB2b2lkIDAgOiByLmNhbGwodCwgLi4ubik7XG4gICAgfSxcbiAgICBbXVxuICApO1xufVxuZnVuY3Rpb24gQ20oeyBwcm9wOiBlLCBkZWZhdWx0UHJvcDogdCwgb25DaGFuZ2U6IG4gPSAoKSA9PiB7XG59IH0pIHtcbiAgY29uc3QgW3IsIGldID0geDEoe1xuICAgIGRlZmF1bHRQcm9wOiB0LFxuICAgIG9uQ2hhbmdlOiBuXG4gIH0pLCBvID0gZSAhPT0gdm9pZCAwLCBhID0gbyA/IGUgOiByLCBzID0gdW4obiksIHUgPSB1dCgoYykgPT4ge1xuICAgIGlmIChvKSB7XG4gICAgICBjb25zdCBsID0gdHlwZW9mIGMgPT0gXCJmdW5jdGlvblwiID8gYyhlKSA6IGM7XG4gICAgICBsICE9PSBlICYmIHMobCk7XG4gICAgfSBlbHNlXG4gICAgICBpKGMpO1xuICB9LCBbXG4gICAgbyxcbiAgICBlLFxuICAgIGksXG4gICAgc1xuICBdKTtcbiAgcmV0dXJuIFtcbiAgICBhLFxuICAgIHVcbiAgXTtcbn1cbmZ1bmN0aW9uIHgxKHsgZGVmYXVsdFByb3A6IGUsIG9uQ2hhbmdlOiB0IH0pIHtcbiAgY29uc3QgbiA9IFllKGUpLCBbcl0gPSBuLCBpID0gX2UociksIG8gPSB1bih0KTtcbiAgcmV0dXJuIEZlKCgpID0+IHtcbiAgICBpLmN1cnJlbnQgIT09IHIgJiYgKG8ociksIGkuY3VycmVudCA9IHIpO1xuICB9LCBbXG4gICAgcixcbiAgICBpLFxuICAgIG9cbiAgXSksIG47XG59XG5jb25zdCBTMSA9IFtcbiAgXCJhXCIsXG4gIFwiYnV0dG9uXCIsXG4gIFwiZGl2XCIsXG4gIFwiZm9ybVwiLFxuICBcImgyXCIsXG4gIFwiaDNcIixcbiAgXCJpbWdcIixcbiAgXCJpbnB1dFwiLFxuICBcImxhYmVsXCIsXG4gIFwibGlcIixcbiAgXCJuYXZcIixcbiAgXCJvbFwiLFxuICBcInBcIixcbiAgXCJzcGFuXCIsXG4gIFwic3ZnXCIsXG4gIFwidWxcIlxuXSwgRnQgPSBTMS5yZWR1Y2UoKGUsIHQpID0+IHtcbiAgY29uc3QgbiA9IC8qIEBfX1BVUkVfXyAqLyBoZSgociwgaSkgPT4ge1xuICAgIGNvbnN0IHsgYXNDaGlsZDogbywgLi4uYSB9ID0gciwgcyA9IG8gPyBrciA6IHQ7XG4gICAgcmV0dXJuIEZlKCgpID0+IHtcbiAgICAgIHdpbmRvd1tTeW1ib2wuZm9yKFwicmFkaXgtdWlcIildID0gITA7XG4gICAgfSwgW10pLCAvKiBAX19QVVJFX18gKi8gWShzLCBjZSh7fSwgYSwge1xuICAgICAgcmVmOiBpXG4gICAgfSkpO1xuICB9KTtcbiAgcmV0dXJuIG4uZGlzcGxheU5hbWUgPSBgUHJpbWl0aXZlLiR7dH1gLCB7XG4gICAgLi4uZSxcbiAgICBbdF06IG5cbiAgfTtcbn0sIHt9KTtcbmZ1bmN0aW9uIEVtKGUsIHQpIHtcbiAgZSAmJiBmbShcbiAgICAoKSA9PiBlLmRpc3BhdGNoRXZlbnQodClcbiAgKTtcbn1cbmZ1bmN0aW9uIFRtKGUpIHtcbiAgY29uc3QgdCA9IGUgKyBcIkNvbGxlY3Rpb25Qcm92aWRlclwiLCBbbiwgcl0gPSBGbyh0KSwgW2ksIG9dID0gbih0LCB7XG4gICAgY29sbGVjdGlvblJlZjoge1xuICAgICAgY3VycmVudDogbnVsbFxuICAgIH0sXG4gICAgaXRlbU1hcDogLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKVxuICB9KSwgYSA9IChwKSA9PiB7XG4gICAgY29uc3QgeyBzY29wZTogZywgY2hpbGRyZW46IGggfSA9IHAsIHYgPSBQLnVzZVJlZihudWxsKSwgdyA9IFAudXNlUmVmKC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCkpLmN1cnJlbnQ7XG4gICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBQLmNyZWF0ZUVsZW1lbnQoaSwge1xuICAgICAgc2NvcGU6IGcsXG4gICAgICBpdGVtTWFwOiB3LFxuICAgICAgY29sbGVjdGlvblJlZjogdlxuICAgIH0sIGgpO1xuICB9LCBzID0gZSArIFwiQ29sbGVjdGlvblNsb3RcIiwgdSA9IC8qIEBfX1BVUkVfXyAqLyBQLmZvcndhcmRSZWYoKHAsIGcpID0+IHtcbiAgICBjb25zdCB7IHNjb3BlOiBoLCBjaGlsZHJlbjogdiB9ID0gcCwgdyA9IG8ocywgaCksIGIgPSBfdChnLCB3LmNvbGxlY3Rpb25SZWYpO1xuICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8gUC5jcmVhdGVFbGVtZW50KGtyLCB7XG4gICAgICByZWY6IGJcbiAgICB9LCB2KTtcbiAgfSksIGMgPSBlICsgXCJDb2xsZWN0aW9uSXRlbVNsb3RcIiwgZiA9IFwiZGF0YS1yYWRpeC1jb2xsZWN0aW9uLWl0ZW1cIiwgbCA9IC8qIEBfX1BVUkVfXyAqLyBQLmZvcndhcmRSZWYoKHAsIGcpID0+IHtcbiAgICBjb25zdCB7IHNjb3BlOiBoLCBjaGlsZHJlbjogdiwgLi4udyB9ID0gcCwgYiA9IFAudXNlUmVmKG51bGwpLCB4ID0gX3QoZywgYiksIG0gPSBvKGMsIGgpO1xuICAgIHJldHVybiBQLnVzZUVmZmVjdCgoKSA9PiAobS5pdGVtTWFwLnNldChiLCB7XG4gICAgICByZWY6IGIsXG4gICAgICAuLi53XG4gICAgfSksICgpID0+IHZvaWQgbS5pdGVtTWFwLmRlbGV0ZShiKSkpLCAvKiBAX19QVVJFX18gKi8gUC5jcmVhdGVFbGVtZW50KGtyLCB7XG4gICAgICBbZl06IFwiXCIsXG4gICAgICByZWY6IHhcbiAgICB9LCB2KTtcbiAgfSk7XG4gIGZ1bmN0aW9uIGQocCkge1xuICAgIGNvbnN0IGcgPSBvKGUgKyBcIkNvbGxlY3Rpb25Db25zdW1lclwiLCBwKTtcbiAgICByZXR1cm4gUC51c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgICBjb25zdCB2ID0gZy5jb2xsZWN0aW9uUmVmLmN1cnJlbnQ7XG4gICAgICBpZiAoIXYpXG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIGNvbnN0IHcgPSBBcnJheS5mcm9tKHYucXVlcnlTZWxlY3RvckFsbChgWyR7Zn1dYCkpO1xuICAgICAgcmV0dXJuIEFycmF5LmZyb20oZy5pdGVtTWFwLnZhbHVlcygpKS5zb3J0KFxuICAgICAgICAobSwgeSkgPT4gdy5pbmRleE9mKG0ucmVmLmN1cnJlbnQpIC0gdy5pbmRleE9mKHkucmVmLmN1cnJlbnQpXG4gICAgICApO1xuICAgIH0sIFtcbiAgICAgIGcuY29sbGVjdGlvblJlZixcbiAgICAgIGcuaXRlbU1hcFxuICAgIF0pO1xuICB9XG4gIHJldHVybiBbXG4gICAge1xuICAgICAgUHJvdmlkZXI6IGEsXG4gICAgICBTbG90OiB1LFxuICAgICAgSXRlbVNsb3Q6IGxcbiAgICB9LFxuICAgIGQsXG4gICAgclxuICBdO1xufVxuY29uc3QgJDEgPSAvKiBAX19QVVJFX18gKi8gWnQodm9pZCAwKTtcbmZ1bmN0aW9uIE1tKGUpIHtcbiAgY29uc3QgdCA9IE50KCQxKTtcbiAgcmV0dXJuIGUgfHwgdCB8fCBcImx0clwiO1xufVxuZnVuY3Rpb24gTzEoZSwgdCA9IGdsb2JhbFRoaXMgPT0gbnVsbCA/IHZvaWQgMCA6IGdsb2JhbFRoaXMuZG9jdW1lbnQpIHtcbiAgY29uc3QgbiA9IHVuKGUpO1xuICBGZSgoKSA9PiB7XG4gICAgY29uc3QgciA9IChpKSA9PiB7XG4gICAgICBpLmtleSA9PT0gXCJFc2NhcGVcIiAmJiBuKGkpO1xuICAgIH07XG4gICAgcmV0dXJuIHQuYWRkRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgciksICgpID0+IHQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgcik7XG4gIH0sIFtcbiAgICBuLFxuICAgIHRcbiAgXSk7XG59XG5jb25zdCBtYyA9IFwiZGlzbWlzc2FibGVMYXllci51cGRhdGVcIiwgXzEgPSBcImRpc21pc3NhYmxlTGF5ZXIucG9pbnRlckRvd25PdXRzaWRlXCIsIEExID0gXCJkaXNtaXNzYWJsZUxheWVyLmZvY3VzT3V0c2lkZVwiO1xubGV0IHpkO1xuY29uc3QgUDEgPSAvKiBAX19QVVJFX18gKi8gWnQoe1xuICBsYXllcnM6IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCksXG4gIGxheWVyc1dpdGhPdXRzaWRlUG9pbnRlckV2ZW50c0Rpc2FibGVkOiAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpLFxuICBicmFuY2hlczogLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKVxufSksIEMxID0gLyogQF9fUFVSRV9fICovIGhlKChlLCB0KSA9PiB7XG4gIHZhciBuO1xuICBjb25zdCB7IGRpc2FibGVPdXRzaWRlUG9pbnRlckV2ZW50czogciA9ICExLCBvbkVzY2FwZUtleURvd246IGksIG9uUG9pbnRlckRvd25PdXRzaWRlOiBvLCBvbkZvY3VzT3V0c2lkZTogYSwgb25JbnRlcmFjdE91dHNpZGU6IHMsIG9uRGlzbWlzczogdSwgLi4uYyB9ID0gZSwgZiA9IE50KFAxKSwgW2wsIGRdID0gWWUobnVsbCksIHAgPSAobiA9IGwgPT0gbnVsbCA/IHZvaWQgMCA6IGwub3duZXJEb2N1bWVudCkgIT09IG51bGwgJiYgbiAhPT0gdm9pZCAwID8gbiA6IGdsb2JhbFRoaXMgPT0gbnVsbCA/IHZvaWQgMCA6IGdsb2JhbFRoaXMuZG9jdW1lbnQsIFssIGddID0gWWUoe30pLCBoID0gX3QoXG4gICAgdCxcbiAgICAoTykgPT4gZChPKVxuICApLCB2ID0gQXJyYXkuZnJvbShmLmxheWVycyksIFt3XSA9IFtcbiAgICAuLi5mLmxheWVyc1dpdGhPdXRzaWRlUG9pbnRlckV2ZW50c0Rpc2FibGVkXG4gIF0uc2xpY2UoLTEpLCBiID0gdi5pbmRleE9mKHcpLCB4ID0gbCA/IHYuaW5kZXhPZihsKSA6IC0xLCBtID0gZi5sYXllcnNXaXRoT3V0c2lkZVBvaW50ZXJFdmVudHNEaXNhYmxlZC5zaXplID4gMCwgeSA9IHggPj0gYiwgUyA9IEUxKChPKSA9PiB7XG4gICAgY29uc3QgVCA9IE8udGFyZ2V0LCBNID0gW1xuICAgICAgLi4uZi5icmFuY2hlc1xuICAgIF0uc29tZShcbiAgICAgIChFKSA9PiBFLmNvbnRhaW5zKFQpXG4gICAgKTtcbiAgICAheSB8fCBNIHx8IChvID09IG51bGwgfHwgbyhPKSwgcyA9PSBudWxsIHx8IHMoTyksIE8uZGVmYXVsdFByZXZlbnRlZCB8fCB1ID09IG51bGwgfHwgdSgpKTtcbiAgfSwgcCksICQgPSBUMSgoTykgPT4ge1xuICAgIGNvbnN0IFQgPSBPLnRhcmdldDtcbiAgICBbXG4gICAgICAuLi5mLmJyYW5jaGVzXG4gICAgXS5zb21lKFxuICAgICAgKEUpID0+IEUuY29udGFpbnMoVClcbiAgICApIHx8IChhID09IG51bGwgfHwgYShPKSwgcyA9PSBudWxsIHx8IHMoTyksIE8uZGVmYXVsdFByZXZlbnRlZCB8fCB1ID09IG51bGwgfHwgdSgpKTtcbiAgfSwgcCk7XG4gIHJldHVybiBPMSgoTykgPT4ge1xuICAgIHggPT09IGYubGF5ZXJzLnNpemUgLSAxICYmIChpID09IG51bGwgfHwgaShPKSwgIU8uZGVmYXVsdFByZXZlbnRlZCAmJiB1ICYmIChPLnByZXZlbnREZWZhdWx0KCksIHUoKSkpO1xuICB9LCBwKSwgRmUoKCkgPT4ge1xuICAgIGlmIChsKVxuICAgICAgcmV0dXJuIHIgJiYgKGYubGF5ZXJzV2l0aE91dHNpZGVQb2ludGVyRXZlbnRzRGlzYWJsZWQuc2l6ZSA9PT0gMCAmJiAoemQgPSBwLmJvZHkuc3R5bGUucG9pbnRlckV2ZW50cywgcC5ib2R5LnN0eWxlLnBvaW50ZXJFdmVudHMgPSBcIm5vbmVcIiksIGYubGF5ZXJzV2l0aE91dHNpZGVQb2ludGVyRXZlbnRzRGlzYWJsZWQuYWRkKGwpKSwgZi5sYXllcnMuYWRkKGwpLCBWZCgpLCAoKSA9PiB7XG4gICAgICAgIHIgJiYgZi5sYXllcnNXaXRoT3V0c2lkZVBvaW50ZXJFdmVudHNEaXNhYmxlZC5zaXplID09PSAxICYmIChwLmJvZHkuc3R5bGUucG9pbnRlckV2ZW50cyA9IHpkKTtcbiAgICAgIH07XG4gIH0sIFtcbiAgICBsLFxuICAgIHAsXG4gICAgcixcbiAgICBmXG4gIF0pLCBGZSgoKSA9PiAoKSA9PiB7XG4gICAgbCAmJiAoZi5sYXllcnMuZGVsZXRlKGwpLCBmLmxheWVyc1dpdGhPdXRzaWRlUG9pbnRlckV2ZW50c0Rpc2FibGVkLmRlbGV0ZShsKSwgVmQoKSk7XG4gIH0sIFtcbiAgICBsLFxuICAgIGZcbiAgXSksIEZlKCgpID0+IHtcbiAgICBjb25zdCBPID0gKCkgPT4gZyh7fSk7XG4gICAgcmV0dXJuIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIobWMsIE8pLCAoKSA9PiBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKG1jLCBPKTtcbiAgfSwgW10pLCAvKiBAX19QVVJFX18gKi8gWShGdC5kaXYsIGNlKHt9LCBjLCB7XG4gICAgcmVmOiBoLFxuICAgIHN0eWxlOiB7XG4gICAgICBwb2ludGVyRXZlbnRzOiBtID8geSA/IFwiYXV0b1wiIDogXCJub25lXCIgOiB2b2lkIDAsXG4gICAgICAuLi5lLnN0eWxlXG4gICAgfSxcbiAgICBvbkZvY3VzQ2FwdHVyZTogd2UoZS5vbkZvY3VzQ2FwdHVyZSwgJC5vbkZvY3VzQ2FwdHVyZSksXG4gICAgb25CbHVyQ2FwdHVyZTogd2UoZS5vbkJsdXJDYXB0dXJlLCAkLm9uQmx1ckNhcHR1cmUpLFxuICAgIG9uUG9pbnRlckRvd25DYXB0dXJlOiB3ZShlLm9uUG9pbnRlckRvd25DYXB0dXJlLCBTLm9uUG9pbnRlckRvd25DYXB0dXJlKVxuICB9KSk7XG59KTtcbmZ1bmN0aW9uIEUxKGUsIHQgPSBnbG9iYWxUaGlzID09IG51bGwgPyB2b2lkIDAgOiBnbG9iYWxUaGlzLmRvY3VtZW50KSB7XG4gIGNvbnN0IG4gPSB1bihlKSwgciA9IF9lKCExKSwgaSA9IF9lKCgpID0+IHtcbiAgfSk7XG4gIHJldHVybiBGZSgoKSA9PiB7XG4gICAgY29uc3QgbyA9IChzKSA9PiB7XG4gICAgICBpZiAocy50YXJnZXQgJiYgIXIuY3VycmVudCkge1xuICAgICAgICBsZXQgYyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIFJtKF8xLCBuLCB1LCB7XG4gICAgICAgICAgICBkaXNjcmV0ZTogITBcbiAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgdSA9IHtcbiAgICAgICAgICBvcmlnaW5hbEV2ZW50OiBzXG4gICAgICAgIH07XG4gICAgICAgIHMucG9pbnRlclR5cGUgPT09IFwidG91Y2hcIiA/ICh0LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBpLmN1cnJlbnQpLCBpLmN1cnJlbnQgPSBjLCB0LmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBpLmN1cnJlbnQsIHtcbiAgICAgICAgICBvbmNlOiAhMFxuICAgICAgICB9KSkgOiBjKCk7XG4gICAgICB9IGVsc2VcbiAgICAgICAgdC5yZW1vdmVFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgaS5jdXJyZW50KTtcbiAgICAgIHIuY3VycmVudCA9ICExO1xuICAgIH0sIGEgPSB3aW5kb3cuc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0LmFkZEV2ZW50TGlzdGVuZXIoXCJwb2ludGVyZG93blwiLCBvKTtcbiAgICB9LCAwKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgd2luZG93LmNsZWFyVGltZW91dChhKSwgdC5yZW1vdmVFdmVudExpc3RlbmVyKFwicG9pbnRlcmRvd25cIiwgbyksIHQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIGkuY3VycmVudCk7XG4gICAgfTtcbiAgfSwgW1xuICAgIHQsXG4gICAgblxuICBdKSwge1xuICAgIC8vIGVuc3VyZXMgd2UgY2hlY2sgUmVhY3QgY29tcG9uZW50IHRyZWUgKG5vdCBqdXN0IERPTSB0cmVlKVxuICAgIG9uUG9pbnRlckRvd25DYXB0dXJlOiAoKSA9PiByLmN1cnJlbnQgPSAhMFxuICB9O1xufVxuZnVuY3Rpb24gVDEoZSwgdCA9IGdsb2JhbFRoaXMgPT0gbnVsbCA/IHZvaWQgMCA6IGdsb2JhbFRoaXMuZG9jdW1lbnQpIHtcbiAgY29uc3QgbiA9IHVuKGUpLCByID0gX2UoITEpO1xuICByZXR1cm4gRmUoKCkgPT4ge1xuICAgIGNvbnN0IGkgPSAobykgPT4ge1xuICAgICAgby50YXJnZXQgJiYgIXIuY3VycmVudCAmJiBSbShBMSwgbiwge1xuICAgICAgICBvcmlnaW5hbEV2ZW50OiBvXG4gICAgICB9LCB7XG4gICAgICAgIGRpc2NyZXRlOiAhMVxuICAgICAgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gdC5hZGRFdmVudExpc3RlbmVyKFwiZm9jdXNpblwiLCBpKSwgKCkgPT4gdC5yZW1vdmVFdmVudExpc3RlbmVyKFwiZm9jdXNpblwiLCBpKTtcbiAgfSwgW1xuICAgIHQsXG4gICAgblxuICBdKSwge1xuICAgIG9uRm9jdXNDYXB0dXJlOiAoKSA9PiByLmN1cnJlbnQgPSAhMCxcbiAgICBvbkJsdXJDYXB0dXJlOiAoKSA9PiByLmN1cnJlbnQgPSAhMVxuICB9O1xufVxuZnVuY3Rpb24gVmQoKSB7XG4gIGNvbnN0IGUgPSBuZXcgQ3VzdG9tRXZlbnQobWMpO1xuICBkb2N1bWVudC5kaXNwYXRjaEV2ZW50KGUpO1xufVxuZnVuY3Rpb24gUm0oZSwgdCwgbiwgeyBkaXNjcmV0ZTogciB9KSB7XG4gIGNvbnN0IGkgPSBuLm9yaWdpbmFsRXZlbnQudGFyZ2V0LCBvID0gbmV3IEN1c3RvbUV2ZW50KGUsIHtcbiAgICBidWJibGVzOiAhMSxcbiAgICBjYW5jZWxhYmxlOiAhMCxcbiAgICBkZXRhaWw6IG5cbiAgfSk7XG4gIHQgJiYgaS5hZGRFdmVudExpc3RlbmVyKGUsIHQsIHtcbiAgICBvbmNlOiAhMFxuICB9KSwgciA/IEVtKGksIG8pIDogaS5kaXNwYXRjaEV2ZW50KG8pO1xufVxubGV0IHZ1ID0gMDtcbmZ1bmN0aW9uIE0xKCkge1xuICBGZSgoKSA9PiB7XG4gICAgdmFyIGUsIHQ7XG4gICAgY29uc3QgbiA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCJbZGF0YS1yYWRpeC1mb2N1cy1ndWFyZF1cIik7XG4gICAgcmV0dXJuIGRvY3VtZW50LmJvZHkuaW5zZXJ0QWRqYWNlbnRFbGVtZW50KFwiYWZ0ZXJiZWdpblwiLCAoZSA9IG5bMF0pICE9PSBudWxsICYmIGUgIT09IHZvaWQgMCA/IGUgOiBHZCgpKSwgZG9jdW1lbnQuYm9keS5pbnNlcnRBZGphY2VudEVsZW1lbnQoXCJiZWZvcmVlbmRcIiwgKHQgPSBuWzFdKSAhPT0gbnVsbCAmJiB0ICE9PSB2b2lkIDAgPyB0IDogR2QoKSksIHZ1KyssICgpID0+IHtcbiAgICAgIHZ1ID09PSAxICYmIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCJbZGF0YS1yYWRpeC1mb2N1cy1ndWFyZF1cIikuZm9yRWFjaChcbiAgICAgICAgKHIpID0+IHIucmVtb3ZlKClcbiAgICAgICksIHZ1LS07XG4gICAgfTtcbiAgfSwgW10pO1xufVxuZnVuY3Rpb24gR2QoKSB7XG4gIGNvbnN0IGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3BhblwiKTtcbiAgcmV0dXJuIGUuc2V0QXR0cmlidXRlKFwiZGF0YS1yYWRpeC1mb2N1cy1ndWFyZFwiLCBcIlwiKSwgZS50YWJJbmRleCA9IDAsIGUuc3R5bGUuY3NzVGV4dCA9IFwib3V0bGluZTogbm9uZTsgb3BhY2l0eTogMDsgcG9zaXRpb246IGZpeGVkOyBwb2ludGVyLWV2ZW50czogbm9uZVwiLCBlO1xufVxuY29uc3QgbXUgPSBcImZvY3VzU2NvcGUuYXV0b0ZvY3VzT25Nb3VudFwiLCB5dSA9IFwiZm9jdXNTY29wZS5hdXRvRm9jdXNPblVubW91bnRcIiwgV2QgPSB7XG4gIGJ1YmJsZXM6ICExLFxuICBjYW5jZWxhYmxlOiAhMFxufSwgUjEgPSAvKiBAX19QVVJFX18gKi8gaGUoKGUsIHQpID0+IHtcbiAgY29uc3QgeyBsb29wOiBuID0gITEsIHRyYXBwZWQ6IHIgPSAhMSwgb25Nb3VudEF1dG9Gb2N1czogaSwgb25Vbm1vdW50QXV0b0ZvY3VzOiBvLCAuLi5hIH0gPSBlLCBbcywgdV0gPSBZZShudWxsKSwgYyA9IHVuKGkpLCBmID0gdW4obyksIGwgPSBfZShudWxsKSwgZCA9IF90KFxuICAgIHQsXG4gICAgKGgpID0+IHUoaClcbiAgKSwgcCA9IF9lKHtcbiAgICBwYXVzZWQ6ICExLFxuICAgIHBhdXNlKCkge1xuICAgICAgdGhpcy5wYXVzZWQgPSAhMDtcbiAgICB9LFxuICAgIHJlc3VtZSgpIHtcbiAgICAgIHRoaXMucGF1c2VkID0gITE7XG4gICAgfVxuICB9KS5jdXJyZW50O1xuICBGZSgoKSA9PiB7XG4gICAgaWYgKHIpIHtcbiAgICAgIGxldCBoID0gZnVuY3Rpb24oeCkge1xuICAgICAgICBpZiAocC5wYXVzZWQgfHwgIXMpXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCBtID0geC50YXJnZXQ7XG4gICAgICAgIHMuY29udGFpbnMobSkgPyBsLmN1cnJlbnQgPSBtIDogUm4obC5jdXJyZW50LCB7XG4gICAgICAgICAgc2VsZWN0OiAhMFxuICAgICAgICB9KTtcbiAgICAgIH0sIHYgPSBmdW5jdGlvbih4KSB7XG4gICAgICAgIGlmIChwLnBhdXNlZCB8fCAhcylcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IG0gPSB4LnJlbGF0ZWRUYXJnZXQ7XG4gICAgICAgIG0gIT09IG51bGwgJiYgKHMuY29udGFpbnMobSkgfHwgUm4obC5jdXJyZW50LCB7XG4gICAgICAgICAgc2VsZWN0OiAhMFxuICAgICAgICB9KSk7XG4gICAgICB9LCB3ID0gZnVuY3Rpb24oeCkge1xuICAgICAgICBpZiAoZG9jdW1lbnQuYWN0aXZlRWxlbWVudCA9PT0gZG9jdW1lbnQuYm9keSlcbiAgICAgICAgICBmb3IgKGNvbnN0IHkgb2YgeClcbiAgICAgICAgICAgIHkucmVtb3ZlZE5vZGVzLmxlbmd0aCA+IDAgJiYgUm4ocyk7XG4gICAgICB9O1xuICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImZvY3VzaW5cIiwgaCksIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJmb2N1c291dFwiLCB2KTtcbiAgICAgIGNvbnN0IGIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcih3KTtcbiAgICAgIHJldHVybiBzICYmIGIub2JzZXJ2ZShzLCB7XG4gICAgICAgIGNoaWxkTGlzdDogITAsXG4gICAgICAgIHN1YnRyZWU6ICEwXG4gICAgICB9KSwgKCkgPT4ge1xuICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwiZm9jdXNpblwiLCBoKSwgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImZvY3Vzb3V0XCIsIHYpLCBiLmRpc2Nvbm5lY3QoKTtcbiAgICAgIH07XG4gICAgfVxuICB9LCBbXG4gICAgcixcbiAgICBzLFxuICAgIHAucGF1c2VkXG4gIF0pLCBGZSgoKSA9PiB7XG4gICAgaWYgKHMpIHtcbiAgICAgIEhkLmFkZChwKTtcbiAgICAgIGNvbnN0IGggPSBkb2N1bWVudC5hY3RpdmVFbGVtZW50O1xuICAgICAgaWYgKCFzLmNvbnRhaW5zKGgpKSB7XG4gICAgICAgIGNvbnN0IHcgPSBuZXcgQ3VzdG9tRXZlbnQobXUsIFdkKTtcbiAgICAgICAgcy5hZGRFdmVudExpc3RlbmVyKG11LCBjKSwgcy5kaXNwYXRjaEV2ZW50KHcpLCB3LmRlZmF1bHRQcmV2ZW50ZWQgfHwgKEkxKEYxKEltKHMpKSwge1xuICAgICAgICAgIHNlbGVjdDogITBcbiAgICAgICAgfSksIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgPT09IGggJiYgUm4ocykpO1xuICAgICAgfVxuICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgcy5yZW1vdmVFdmVudExpc3RlbmVyKG11LCBjKSwgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgY29uc3QgdyA9IG5ldyBDdXN0b21FdmVudCh5dSwgV2QpO1xuICAgICAgICAgIHMuYWRkRXZlbnRMaXN0ZW5lcih5dSwgZiksIHMuZGlzcGF0Y2hFdmVudCh3KSwgdy5kZWZhdWx0UHJldmVudGVkIHx8IFJuKGggPz8gZG9jdW1lbnQuYm9keSwge1xuICAgICAgICAgICAgc2VsZWN0OiAhMFxuICAgICAgICAgIH0pLCBzLnJlbW92ZUV2ZW50TGlzdGVuZXIoeXUsIGYpLCBIZC5yZW1vdmUocCk7XG4gICAgICAgIH0sIDApO1xuICAgICAgfTtcbiAgICB9XG4gIH0sIFtcbiAgICBzLFxuICAgIGMsXG4gICAgZixcbiAgICBwXG4gIF0pO1xuICBjb25zdCBnID0gdXQoKGgpID0+IHtcbiAgICBpZiAoIW4gJiYgIXIgfHwgcC5wYXVzZWQpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgdiA9IGgua2V5ID09PSBcIlRhYlwiICYmICFoLmFsdEtleSAmJiAhaC5jdHJsS2V5ICYmICFoLm1ldGFLZXksIHcgPSBkb2N1bWVudC5hY3RpdmVFbGVtZW50O1xuICAgIGlmICh2ICYmIHcpIHtcbiAgICAgIGNvbnN0IGIgPSBoLmN1cnJlbnRUYXJnZXQsIFt4LCBtXSA9IGoxKGIpO1xuICAgICAgeCAmJiBtID8gIWguc2hpZnRLZXkgJiYgdyA9PT0gbSA/IChoLnByZXZlbnREZWZhdWx0KCksIG4gJiYgUm4oeCwge1xuICAgICAgICBzZWxlY3Q6ICEwXG4gICAgICB9KSkgOiBoLnNoaWZ0S2V5ICYmIHcgPT09IHggJiYgKGgucHJldmVudERlZmF1bHQoKSwgbiAmJiBSbihtLCB7XG4gICAgICAgIHNlbGVjdDogITBcbiAgICAgIH0pKSA6IHcgPT09IGIgJiYgaC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cbiAgfSwgW1xuICAgIG4sXG4gICAgcixcbiAgICBwLnBhdXNlZFxuICBdKTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBZKEZ0LmRpdiwgY2Uoe1xuICAgIHRhYkluZGV4OiAtMVxuICB9LCBhLCB7XG4gICAgcmVmOiBkLFxuICAgIG9uS2V5RG93bjogZ1xuICB9KSk7XG59KTtcbmZ1bmN0aW9uIEkxKGUsIHsgc2VsZWN0OiB0ID0gITEgfSA9IHt9KSB7XG4gIGNvbnN0IG4gPSBkb2N1bWVudC5hY3RpdmVFbGVtZW50O1xuICBmb3IgKGNvbnN0IHIgb2YgZSlcbiAgICBpZiAoUm4ociwge1xuICAgICAgc2VsZWN0OiB0XG4gICAgfSksIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgIT09IG4pXG4gICAgICByZXR1cm47XG59XG5mdW5jdGlvbiBqMShlKSB7XG4gIGNvbnN0IHQgPSBJbShlKSwgbiA9IFVkKHQsIGUpLCByID0gVWQodC5yZXZlcnNlKCksIGUpO1xuICByZXR1cm4gW1xuICAgIG4sXG4gICAgclxuICBdO1xufVxuZnVuY3Rpb24gSW0oZSkge1xuICBjb25zdCB0ID0gW10sIG4gPSBkb2N1bWVudC5jcmVhdGVUcmVlV2Fsa2VyKGUsIE5vZGVGaWx0ZXIuU0hPV19FTEVNRU5ULCB7XG4gICAgYWNjZXB0Tm9kZTogKHIpID0+IHtcbiAgICAgIGNvbnN0IGkgPSByLnRhZ05hbWUgPT09IFwiSU5QVVRcIiAmJiByLnR5cGUgPT09IFwiaGlkZGVuXCI7XG4gICAgICByZXR1cm4gci5kaXNhYmxlZCB8fCByLmhpZGRlbiB8fCBpID8gTm9kZUZpbHRlci5GSUxURVJfU0tJUCA6IHIudGFiSW5kZXggPj0gMCA/IE5vZGVGaWx0ZXIuRklMVEVSX0FDQ0VQVCA6IE5vZGVGaWx0ZXIuRklMVEVSX1NLSVA7XG4gICAgfVxuICB9KTtcbiAgZm9yICg7IG4ubmV4dE5vZGUoKTsgKVxuICAgIHQucHVzaChuLmN1cnJlbnROb2RlKTtcbiAgcmV0dXJuIHQ7XG59XG5mdW5jdGlvbiBVZChlLCB0KSB7XG4gIGZvciAoY29uc3QgbiBvZiBlKVxuICAgIGlmICghazEobiwge1xuICAgICAgdXBUbzogdFxuICAgIH0pKVxuICAgICAgcmV0dXJuIG47XG59XG5mdW5jdGlvbiBrMShlLCB7IHVwVG86IHQgfSkge1xuICBpZiAoZ2V0Q29tcHV0ZWRTdHlsZShlKS52aXNpYmlsaXR5ID09PSBcImhpZGRlblwiKVxuICAgIHJldHVybiAhMDtcbiAgZm9yICg7IGU7ICkge1xuICAgIGlmICh0ICE9PSB2b2lkIDAgJiYgZSA9PT0gdClcbiAgICAgIHJldHVybiAhMTtcbiAgICBpZiAoZ2V0Q29tcHV0ZWRTdHlsZShlKS5kaXNwbGF5ID09PSBcIm5vbmVcIilcbiAgICAgIHJldHVybiAhMDtcbiAgICBlID0gZS5wYXJlbnRFbGVtZW50O1xuICB9XG4gIHJldHVybiAhMTtcbn1cbmZ1bmN0aW9uIEQxKGUpIHtcbiAgcmV0dXJuIGUgaW5zdGFuY2VvZiBIVE1MSW5wdXRFbGVtZW50ICYmIFwic2VsZWN0XCIgaW4gZTtcbn1cbmZ1bmN0aW9uIFJuKGUsIHsgc2VsZWN0OiB0ID0gITEgfSA9IHt9KSB7XG4gIGlmIChlICYmIGUuZm9jdXMpIHtcbiAgICBjb25zdCBuID0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudDtcbiAgICBlLmZvY3VzKHtcbiAgICAgIHByZXZlbnRTY3JvbGw6ICEwXG4gICAgfSksIGUgIT09IG4gJiYgRDEoZSkgJiYgdCAmJiBlLnNlbGVjdCgpO1xuICB9XG59XG5jb25zdCBIZCA9IE4xKCk7XG5mdW5jdGlvbiBOMSgpIHtcbiAgbGV0IGUgPSBbXTtcbiAgcmV0dXJuIHtcbiAgICBhZGQodCkge1xuICAgICAgY29uc3QgbiA9IGVbMF07XG4gICAgICB0ICE9PSBuICYmIChuID09IG51bGwgfHwgbi5wYXVzZSgpKSwgZSA9IHFkKGUsIHQpLCBlLnVuc2hpZnQodCk7XG4gICAgfSxcbiAgICByZW1vdmUodCkge1xuICAgICAgdmFyIG47XG4gICAgICBlID0gcWQoZSwgdCksIChuID0gZVswXSkgPT09IG51bGwgfHwgbiA9PT0gdm9pZCAwIHx8IG4ucmVzdW1lKCk7XG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gcWQoZSwgdCkge1xuICBjb25zdCBuID0gW1xuICAgIC4uLmVcbiAgXSwgciA9IG4uaW5kZXhPZih0KTtcbiAgcmV0dXJuIHIgIT09IC0xICYmIG4uc3BsaWNlKHIsIDEpLCBuO1xufVxuZnVuY3Rpb24gRjEoZSkge1xuICByZXR1cm4gZS5maWx0ZXIoXG4gICAgKHQpID0+IHQudGFnTmFtZSAhPT0gXCJBXCJcbiAgKTtcbn1cbmNvbnN0IERyID0gZ2xvYmFsVGhpcyAhPSBudWxsICYmIGdsb2JhbFRoaXMuZG9jdW1lbnQgPyBjbSA6ICgpID0+IHtcbn0sIEwxID0gSC51c2VJZCB8fCAoKCkgPT4ge1xufSk7XG5sZXQgQjEgPSAwO1xuZnVuY3Rpb24geWMoZSkge1xuICBjb25zdCBbdCwgbl0gPSBILnVzZVN0YXRlKEwxKCkpO1xuICByZXR1cm4gRHIoKCkgPT4ge1xuICAgIGUgfHwgbihcbiAgICAgIChyKSA9PiByID8/IFN0cmluZyhCMSsrKVxuICAgICk7XG4gIH0sIFtcbiAgICBlXG4gIF0pLCBlIHx8ICh0ID8gYHJhZGl4LSR7dH1gIDogXCJcIik7XG59XG5jb25zdCB6MSA9IFtcInRvcFwiLCBcInJpZ2h0XCIsIFwiYm90dG9tXCIsIFwibGVmdFwiXSwgcm4gPSBNYXRoLm1pbiwgeHQgPSBNYXRoLm1heCwgTWEgPSBNYXRoLnJvdW5kLCByYSA9IE1hdGguZmxvb3IsIHpuID0gKGUpID0+ICh7XG4gIHg6IGUsXG4gIHk6IGVcbn0pLCBWMSA9IHtcbiAgbGVmdDogXCJyaWdodFwiLFxuICByaWdodDogXCJsZWZ0XCIsXG4gIGJvdHRvbTogXCJ0b3BcIixcbiAgdG9wOiBcImJvdHRvbVwiXG59LCBHMSA9IHtcbiAgc3RhcnQ6IFwiZW5kXCIsXG4gIGVuZDogXCJzdGFydFwiXG59O1xuZnVuY3Rpb24gYmMoZSwgdCwgbikge1xuICByZXR1cm4geHQoZSwgcm4odCwgbikpO1xufVxuZnVuY3Rpb24gd24oZSwgdCkge1xuICByZXR1cm4gdHlwZW9mIGUgPT0gXCJmdW5jdGlvblwiID8gZSh0KSA6IGU7XG59XG5mdW5jdGlvbiB4bihlKSB7XG4gIHJldHVybiBlLnNwbGl0KFwiLVwiKVswXTtcbn1cbmZ1bmN0aW9uIG9pKGUpIHtcbiAgcmV0dXJuIGUuc3BsaXQoXCItXCIpWzFdO1xufVxuZnVuY3Rpb24gdGYoZSkge1xuICByZXR1cm4gZSA9PT0gXCJ4XCIgPyBcInlcIiA6IFwieFwiO1xufVxuZnVuY3Rpb24gbmYoZSkge1xuICByZXR1cm4gZSA9PT0gXCJ5XCIgPyBcImhlaWdodFwiIDogXCJ3aWR0aFwiO1xufVxuZnVuY3Rpb24gYWkoZSkge1xuICByZXR1cm4gW1widG9wXCIsIFwiYm90dG9tXCJdLmluY2x1ZGVzKHhuKGUpKSA/IFwieVwiIDogXCJ4XCI7XG59XG5mdW5jdGlvbiByZihlKSB7XG4gIHJldHVybiB0ZihhaShlKSk7XG59XG5mdW5jdGlvbiBXMShlLCB0LCBuKSB7XG4gIG4gPT09IHZvaWQgMCAmJiAobiA9ICExKTtcbiAgY29uc3QgciA9IG9pKGUpLCBpID0gcmYoZSksIG8gPSBuZihpKTtcbiAgbGV0IGEgPSBpID09PSBcInhcIiA/IHIgPT09IChuID8gXCJlbmRcIiA6IFwic3RhcnRcIikgPyBcInJpZ2h0XCIgOiBcImxlZnRcIiA6IHIgPT09IFwic3RhcnRcIiA/IFwiYm90dG9tXCIgOiBcInRvcFwiO1xuICByZXR1cm4gdC5yZWZlcmVuY2Vbb10gPiB0LmZsb2F0aW5nW29dICYmIChhID0gUmEoYSkpLCBbYSwgUmEoYSldO1xufVxuZnVuY3Rpb24gVTEoZSkge1xuICBjb25zdCB0ID0gUmEoZSk7XG4gIHJldHVybiBbd2MoZSksIHQsIHdjKHQpXTtcbn1cbmZ1bmN0aW9uIHdjKGUpIHtcbiAgcmV0dXJuIGUucmVwbGFjZSgvc3RhcnR8ZW5kL2csICh0KSA9PiBHMVt0XSk7XG59XG5mdW5jdGlvbiBIMShlLCB0LCBuKSB7XG4gIGNvbnN0IHIgPSBbXCJsZWZ0XCIsIFwicmlnaHRcIl0sIGkgPSBbXCJyaWdodFwiLCBcImxlZnRcIl0sIG8gPSBbXCJ0b3BcIiwgXCJib3R0b21cIl0sIGEgPSBbXCJib3R0b21cIiwgXCJ0b3BcIl07XG4gIHN3aXRjaCAoZSkge1xuICAgIGNhc2UgXCJ0b3BcIjpcbiAgICBjYXNlIFwiYm90dG9tXCI6XG4gICAgICByZXR1cm4gbiA/IHQgPyBpIDogciA6IHQgPyByIDogaTtcbiAgICBjYXNlIFwibGVmdFwiOlxuICAgIGNhc2UgXCJyaWdodFwiOlxuICAgICAgcmV0dXJuIHQgPyBvIDogYTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIFtdO1xuICB9XG59XG5mdW5jdGlvbiBxMShlLCB0LCBuLCByKSB7XG4gIGNvbnN0IGkgPSBvaShlKTtcbiAgbGV0IG8gPSBIMSh4bihlKSwgbiA9PT0gXCJzdGFydFwiLCByKTtcbiAgcmV0dXJuIGkgJiYgKG8gPSBvLm1hcCgoYSkgPT4gYSArIFwiLVwiICsgaSksIHQgJiYgKG8gPSBvLmNvbmNhdChvLm1hcCh3YykpKSksIG87XG59XG5mdW5jdGlvbiBSYShlKSB7XG4gIHJldHVybiBlLnJlcGxhY2UoL2xlZnR8cmlnaHR8Ym90dG9tfHRvcC9nLCAodCkgPT4gVjFbdF0pO1xufVxuZnVuY3Rpb24gSzEoZSkge1xuICByZXR1cm4ge1xuICAgIHRvcDogMCxcbiAgICByaWdodDogMCxcbiAgICBib3R0b206IDAsXG4gICAgbGVmdDogMCxcbiAgICAuLi5lXG4gIH07XG59XG5mdW5jdGlvbiBqbShlKSB7XG4gIHJldHVybiB0eXBlb2YgZSAhPSBcIm51bWJlclwiID8gSzEoZSkgOiB7XG4gICAgdG9wOiBlLFxuICAgIHJpZ2h0OiBlLFxuICAgIGJvdHRvbTogZSxcbiAgICBsZWZ0OiBlXG4gIH07XG59XG5mdW5jdGlvbiBJYShlKSB7XG4gIGNvbnN0IHtcbiAgICB4OiB0LFxuICAgIHk6IG4sXG4gICAgd2lkdGg6IHIsXG4gICAgaGVpZ2h0OiBpXG4gIH0gPSBlO1xuICByZXR1cm4ge1xuICAgIHdpZHRoOiByLFxuICAgIGhlaWdodDogaSxcbiAgICB0b3A6IG4sXG4gICAgbGVmdDogdCxcbiAgICByaWdodDogdCArIHIsXG4gICAgYm90dG9tOiBuICsgaSxcbiAgICB4OiB0LFxuICAgIHk6IG5cbiAgfTtcbn1cbmZ1bmN0aW9uIEtkKGUsIHQsIG4pIHtcbiAgbGV0IHtcbiAgICByZWZlcmVuY2U6IHIsXG4gICAgZmxvYXRpbmc6IGlcbiAgfSA9IGU7XG4gIGNvbnN0IG8gPSBhaSh0KSwgYSA9IHJmKHQpLCBzID0gbmYoYSksIHUgPSB4bih0KSwgYyA9IG8gPT09IFwieVwiLCBmID0gci54ICsgci53aWR0aCAvIDIgLSBpLndpZHRoIC8gMiwgbCA9IHIueSArIHIuaGVpZ2h0IC8gMiAtIGkuaGVpZ2h0IC8gMiwgZCA9IHJbc10gLyAyIC0gaVtzXSAvIDI7XG4gIGxldCBwO1xuICBzd2l0Y2ggKHUpIHtcbiAgICBjYXNlIFwidG9wXCI6XG4gICAgICBwID0ge1xuICAgICAgICB4OiBmLFxuICAgICAgICB5OiByLnkgLSBpLmhlaWdodFxuICAgICAgfTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJib3R0b21cIjpcbiAgICAgIHAgPSB7XG4gICAgICAgIHg6IGYsXG4gICAgICAgIHk6IHIueSArIHIuaGVpZ2h0XG4gICAgICB9O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcInJpZ2h0XCI6XG4gICAgICBwID0ge1xuICAgICAgICB4OiByLnggKyByLndpZHRoLFxuICAgICAgICB5OiBsXG4gICAgICB9O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcImxlZnRcIjpcbiAgICAgIHAgPSB7XG4gICAgICAgIHg6IHIueCAtIGkud2lkdGgsXG4gICAgICAgIHk6IGxcbiAgICAgIH07XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgcCA9IHtcbiAgICAgICAgeDogci54LFxuICAgICAgICB5OiByLnlcbiAgICAgIH07XG4gIH1cbiAgc3dpdGNoIChvaSh0KSkge1xuICAgIGNhc2UgXCJzdGFydFwiOlxuICAgICAgcFthXSAtPSBkICogKG4gJiYgYyA/IC0xIDogMSk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwiZW5kXCI6XG4gICAgICBwW2FdICs9IGQgKiAobiAmJiBjID8gLTEgOiAxKTtcbiAgICAgIGJyZWFrO1xuICB9XG4gIHJldHVybiBwO1xufVxuY29uc3QgWTEgPSBhc3luYyAoZSwgdCwgbikgPT4ge1xuICBjb25zdCB7XG4gICAgcGxhY2VtZW50OiByID0gXCJib3R0b21cIixcbiAgICBzdHJhdGVneTogaSA9IFwiYWJzb2x1dGVcIixcbiAgICBtaWRkbGV3YXJlOiBvID0gW10sXG4gICAgcGxhdGZvcm06IGFcbiAgfSA9IG4sIHMgPSBvLmZpbHRlcihCb29sZWFuKSwgdSA9IGF3YWl0IChhLmlzUlRMID09IG51bGwgPyB2b2lkIDAgOiBhLmlzUlRMKHQpKTtcbiAgbGV0IGMgPSBhd2FpdCBhLmdldEVsZW1lbnRSZWN0cyh7XG4gICAgcmVmZXJlbmNlOiBlLFxuICAgIGZsb2F0aW5nOiB0LFxuICAgIHN0cmF0ZWd5OiBpXG4gIH0pLCB7XG4gICAgeDogZixcbiAgICB5OiBsXG4gIH0gPSBLZChjLCByLCB1KSwgZCA9IHIsIHAgPSB7fSwgZyA9IDA7XG4gIGZvciAobGV0IGggPSAwOyBoIDwgcy5sZW5ndGg7IGgrKykge1xuICAgIGNvbnN0IHtcbiAgICAgIG5hbWU6IHYsXG4gICAgICBmbjogd1xuICAgIH0gPSBzW2hdLCB7XG4gICAgICB4OiBiLFxuICAgICAgeTogeCxcbiAgICAgIGRhdGE6IG0sXG4gICAgICByZXNldDogeVxuICAgIH0gPSBhd2FpdCB3KHtcbiAgICAgIHg6IGYsXG4gICAgICB5OiBsLFxuICAgICAgaW5pdGlhbFBsYWNlbWVudDogcixcbiAgICAgIHBsYWNlbWVudDogZCxcbiAgICAgIHN0cmF0ZWd5OiBpLFxuICAgICAgbWlkZGxld2FyZURhdGE6IHAsXG4gICAgICByZWN0czogYyxcbiAgICAgIHBsYXRmb3JtOiBhLFxuICAgICAgZWxlbWVudHM6IHtcbiAgICAgICAgcmVmZXJlbmNlOiBlLFxuICAgICAgICBmbG9hdGluZzogdFxuICAgICAgfVxuICAgIH0pO1xuICAgIGYgPSBiID8/IGYsIGwgPSB4ID8/IGwsIHAgPSB7XG4gICAgICAuLi5wLFxuICAgICAgW3ZdOiB7XG4gICAgICAgIC4uLnBbdl0sXG4gICAgICAgIC4uLm1cbiAgICAgIH1cbiAgICB9LCB5ICYmIGcgPD0gNTAgJiYgKGcrKywgdHlwZW9mIHkgPT0gXCJvYmplY3RcIiAmJiAoeS5wbGFjZW1lbnQgJiYgKGQgPSB5LnBsYWNlbWVudCksIHkucmVjdHMgJiYgKGMgPSB5LnJlY3RzID09PSAhMCA/IGF3YWl0IGEuZ2V0RWxlbWVudFJlY3RzKHtcbiAgICAgIHJlZmVyZW5jZTogZSxcbiAgICAgIGZsb2F0aW5nOiB0LFxuICAgICAgc3RyYXRlZ3k6IGlcbiAgICB9KSA6IHkucmVjdHMpLCB7XG4gICAgICB4OiBmLFxuICAgICAgeTogbFxuICAgIH0gPSBLZChjLCBkLCB1KSksIGggPSAtMSk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB4OiBmLFxuICAgIHk6IGwsXG4gICAgcGxhY2VtZW50OiBkLFxuICAgIHN0cmF0ZWd5OiBpLFxuICAgIG1pZGRsZXdhcmVEYXRhOiBwXG4gIH07XG59O1xuYXN5bmMgZnVuY3Rpb24gWmkoZSwgdCkge1xuICB2YXIgbjtcbiAgdCA9PT0gdm9pZCAwICYmICh0ID0ge30pO1xuICBjb25zdCB7XG4gICAgeDogcixcbiAgICB5OiBpLFxuICAgIHBsYXRmb3JtOiBvLFxuICAgIHJlY3RzOiBhLFxuICAgIGVsZW1lbnRzOiBzLFxuICAgIHN0cmF0ZWd5OiB1XG4gIH0gPSBlLCB7XG4gICAgYm91bmRhcnk6IGMgPSBcImNsaXBwaW5nQW5jZXN0b3JzXCIsXG4gICAgcm9vdEJvdW5kYXJ5OiBmID0gXCJ2aWV3cG9ydFwiLFxuICAgIGVsZW1lbnRDb250ZXh0OiBsID0gXCJmbG9hdGluZ1wiLFxuICAgIGFsdEJvdW5kYXJ5OiBkID0gITEsXG4gICAgcGFkZGluZzogcCA9IDBcbiAgfSA9IHduKHQsIGUpLCBnID0gam0ocCksIHYgPSBzW2QgPyBsID09PSBcImZsb2F0aW5nXCIgPyBcInJlZmVyZW5jZVwiIDogXCJmbG9hdGluZ1wiIDogbF0sIHcgPSBJYShhd2FpdCBvLmdldENsaXBwaW5nUmVjdCh7XG4gICAgZWxlbWVudDogKG4gPSBhd2FpdCAoby5pc0VsZW1lbnQgPT0gbnVsbCA/IHZvaWQgMCA6IG8uaXNFbGVtZW50KHYpKSkgPT0gbnVsbCB8fCBuID8gdiA6IHYuY29udGV4dEVsZW1lbnQgfHwgYXdhaXQgKG8uZ2V0RG9jdW1lbnRFbGVtZW50ID09IG51bGwgPyB2b2lkIDAgOiBvLmdldERvY3VtZW50RWxlbWVudChzLmZsb2F0aW5nKSksXG4gICAgYm91bmRhcnk6IGMsXG4gICAgcm9vdEJvdW5kYXJ5OiBmLFxuICAgIHN0cmF0ZWd5OiB1XG4gIH0pKSwgYiA9IGwgPT09IFwiZmxvYXRpbmdcIiA/IHtcbiAgICB4OiByLFxuICAgIHk6IGksXG4gICAgd2lkdGg6IGEuZmxvYXRpbmcud2lkdGgsXG4gICAgaGVpZ2h0OiBhLmZsb2F0aW5nLmhlaWdodFxuICB9IDogYS5yZWZlcmVuY2UsIHggPSBhd2FpdCAoby5nZXRPZmZzZXRQYXJlbnQgPT0gbnVsbCA/IHZvaWQgMCA6IG8uZ2V0T2Zmc2V0UGFyZW50KHMuZmxvYXRpbmcpKSwgbSA9IGF3YWl0IChvLmlzRWxlbWVudCA9PSBudWxsID8gdm9pZCAwIDogby5pc0VsZW1lbnQoeCkpID8gYXdhaXQgKG8uZ2V0U2NhbGUgPT0gbnVsbCA/IHZvaWQgMCA6IG8uZ2V0U2NhbGUoeCkpIHx8IHtcbiAgICB4OiAxLFxuICAgIHk6IDFcbiAgfSA6IHtcbiAgICB4OiAxLFxuICAgIHk6IDFcbiAgfSwgeSA9IElhKG8uY29udmVydE9mZnNldFBhcmVudFJlbGF0aXZlUmVjdFRvVmlld3BvcnRSZWxhdGl2ZVJlY3QgPyBhd2FpdCBvLmNvbnZlcnRPZmZzZXRQYXJlbnRSZWxhdGl2ZVJlY3RUb1ZpZXdwb3J0UmVsYXRpdmVSZWN0KHtcbiAgICBlbGVtZW50czogcyxcbiAgICByZWN0OiBiLFxuICAgIG9mZnNldFBhcmVudDogeCxcbiAgICBzdHJhdGVneTogdVxuICB9KSA6IGIpO1xuICByZXR1cm4ge1xuICAgIHRvcDogKHcudG9wIC0geS50b3AgKyBnLnRvcCkgLyBtLnksXG4gICAgYm90dG9tOiAoeS5ib3R0b20gLSB3LmJvdHRvbSArIGcuYm90dG9tKSAvIG0ueSxcbiAgICBsZWZ0OiAody5sZWZ0IC0geS5sZWZ0ICsgZy5sZWZ0KSAvIG0ueCxcbiAgICByaWdodDogKHkucmlnaHQgLSB3LnJpZ2h0ICsgZy5yaWdodCkgLyBtLnhcbiAgfTtcbn1cbmNvbnN0IFgxID0gKGUpID0+ICh7XG4gIG5hbWU6IFwiYXJyb3dcIixcbiAgb3B0aW9uczogZSxcbiAgYXN5bmMgZm4odCkge1xuICAgIGNvbnN0IHtcbiAgICAgIHg6IG4sXG4gICAgICB5OiByLFxuICAgICAgcGxhY2VtZW50OiBpLFxuICAgICAgcmVjdHM6IG8sXG4gICAgICBwbGF0Zm9ybTogYSxcbiAgICAgIGVsZW1lbnRzOiBzLFxuICAgICAgbWlkZGxld2FyZURhdGE6IHVcbiAgICB9ID0gdCwge1xuICAgICAgZWxlbWVudDogYyxcbiAgICAgIHBhZGRpbmc6IGYgPSAwXG4gICAgfSA9IHduKGUsIHQpIHx8IHt9O1xuICAgIGlmIChjID09IG51bGwpXG4gICAgICByZXR1cm4ge307XG4gICAgY29uc3QgbCA9IGptKGYpLCBkID0ge1xuICAgICAgeDogbixcbiAgICAgIHk6IHJcbiAgICB9LCBwID0gcmYoaSksIGcgPSBuZihwKSwgaCA9IGF3YWl0IGEuZ2V0RGltZW5zaW9ucyhjKSwgdiA9IHAgPT09IFwieVwiLCB3ID0gdiA/IFwidG9wXCIgOiBcImxlZnRcIiwgYiA9IHYgPyBcImJvdHRvbVwiIDogXCJyaWdodFwiLCB4ID0gdiA/IFwiY2xpZW50SGVpZ2h0XCIgOiBcImNsaWVudFdpZHRoXCIsIG0gPSBvLnJlZmVyZW5jZVtnXSArIG8ucmVmZXJlbmNlW3BdIC0gZFtwXSAtIG8uZmxvYXRpbmdbZ10sIHkgPSBkW3BdIC0gby5yZWZlcmVuY2VbcF0sIFMgPSBhd2FpdCAoYS5nZXRPZmZzZXRQYXJlbnQgPT0gbnVsbCA/IHZvaWQgMCA6IGEuZ2V0T2Zmc2V0UGFyZW50KGMpKTtcbiAgICBsZXQgJCA9IFMgPyBTW3hdIDogMDtcbiAgICAoISQgfHwgIWF3YWl0IChhLmlzRWxlbWVudCA9PSBudWxsID8gdm9pZCAwIDogYS5pc0VsZW1lbnQoUykpKSAmJiAoJCA9IHMuZmxvYXRpbmdbeF0gfHwgby5mbG9hdGluZ1tnXSk7XG4gICAgY29uc3QgTyA9IG0gLyAyIC0geSAvIDIsIFQgPSAkIC8gMiAtIGhbZ10gLyAyIC0gMSwgTSA9IHJuKGxbd10sIFQpLCBFID0gcm4obFtiXSwgVCksIEEgPSBNLCBqID0gJCAtIGhbZ10gLSBFLCBSID0gJCAvIDIgLSBoW2ddIC8gMiArIE8sIE4gPSBiYyhBLCBSLCBqKSwgayA9ICF1LmFycm93ICYmIG9pKGkpICE9IG51bGwgJiYgUiAhPT0gTiAmJiBvLnJlZmVyZW5jZVtnXSAvIDIgLSAoUiA8IEEgPyBNIDogRSkgLSBoW2ddIC8gMiA8IDAsIEYgPSBrID8gUiA8IEEgPyBSIC0gQSA6IFIgLSBqIDogMDtcbiAgICByZXR1cm4ge1xuICAgICAgW3BdOiBkW3BdICsgRixcbiAgICAgIGRhdGE6IHtcbiAgICAgICAgW3BdOiBOLFxuICAgICAgICBjZW50ZXJPZmZzZXQ6IFIgLSBOIC0gRixcbiAgICAgICAgLi4uayAmJiB7XG4gICAgICAgICAgYWxpZ25tZW50T2Zmc2V0OiBGXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICByZXNldDoga1xuICAgIH07XG4gIH1cbn0pLCBaMSA9IGZ1bmN0aW9uKGUpIHtcbiAgcmV0dXJuIGUgPT09IHZvaWQgMCAmJiAoZSA9IHt9KSwge1xuICAgIG5hbWU6IFwiZmxpcFwiLFxuICAgIG9wdGlvbnM6IGUsXG4gICAgYXN5bmMgZm4odCkge1xuICAgICAgdmFyIG4sIHI7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHBsYWNlbWVudDogaSxcbiAgICAgICAgbWlkZGxld2FyZURhdGE6IG8sXG4gICAgICAgIHJlY3RzOiBhLFxuICAgICAgICBpbml0aWFsUGxhY2VtZW50OiBzLFxuICAgICAgICBwbGF0Zm9ybTogdSxcbiAgICAgICAgZWxlbWVudHM6IGNcbiAgICAgIH0gPSB0LCB7XG4gICAgICAgIG1haW5BeGlzOiBmID0gITAsXG4gICAgICAgIGNyb3NzQXhpczogbCA9ICEwLFxuICAgICAgICBmYWxsYmFja1BsYWNlbWVudHM6IGQsXG4gICAgICAgIGZhbGxiYWNrU3RyYXRlZ3k6IHAgPSBcImJlc3RGaXRcIixcbiAgICAgICAgZmFsbGJhY2tBeGlzU2lkZURpcmVjdGlvbjogZyA9IFwibm9uZVwiLFxuICAgICAgICBmbGlwQWxpZ25tZW50OiBoID0gITAsXG4gICAgICAgIC4uLnZcbiAgICAgIH0gPSB3bihlLCB0KTtcbiAgICAgIGlmICgobiA9IG8uYXJyb3cpICE9IG51bGwgJiYgbi5hbGlnbm1lbnRPZmZzZXQpXG4gICAgICAgIHJldHVybiB7fTtcbiAgICAgIGNvbnN0IHcgPSB4bihpKSwgYiA9IHhuKHMpID09PSBzLCB4ID0gYXdhaXQgKHUuaXNSVEwgPT0gbnVsbCA/IHZvaWQgMCA6IHUuaXNSVEwoYy5mbG9hdGluZykpLCBtID0gZCB8fCAoYiB8fCAhaCA/IFtSYShzKV0gOiBVMShzKSk7XG4gICAgICAhZCAmJiBnICE9PSBcIm5vbmVcIiAmJiBtLnB1c2goLi4ucTEocywgaCwgZywgeCkpO1xuICAgICAgY29uc3QgeSA9IFtzLCAuLi5tXSwgUyA9IGF3YWl0IFppKHQsIHYpLCAkID0gW107XG4gICAgICBsZXQgTyA9ICgociA9IG8uZmxpcCkgPT0gbnVsbCA/IHZvaWQgMCA6IHIub3ZlcmZsb3dzKSB8fCBbXTtcbiAgICAgIGlmIChmICYmICQucHVzaChTW3ddKSwgbCkge1xuICAgICAgICBjb25zdCBBID0gVzEoaSwgYSwgeCk7XG4gICAgICAgICQucHVzaChTW0FbMF1dLCBTW0FbMV1dKTtcbiAgICAgIH1cbiAgICAgIGlmIChPID0gWy4uLk8sIHtcbiAgICAgICAgcGxhY2VtZW50OiBpLFxuICAgICAgICBvdmVyZmxvd3M6ICRcbiAgICAgIH1dLCAhJC5ldmVyeSgoQSkgPT4gQSA8PSAwKSkge1xuICAgICAgICB2YXIgVCwgTTtcbiAgICAgICAgY29uc3QgQSA9ICgoKFQgPSBvLmZsaXApID09IG51bGwgPyB2b2lkIDAgOiBULmluZGV4KSB8fCAwKSArIDEsIGogPSB5W0FdO1xuICAgICAgICBpZiAoailcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICBpbmRleDogQSxcbiAgICAgICAgICAgICAgb3ZlcmZsb3dzOiBPXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcmVzZXQ6IHtcbiAgICAgICAgICAgICAgcGxhY2VtZW50OiBqXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgbGV0IFIgPSAoTSA9IE8uZmlsdGVyKChOKSA9PiBOLm92ZXJmbG93c1swXSA8PSAwKS5zb3J0KChOLCBrKSA9PiBOLm92ZXJmbG93c1sxXSAtIGsub3ZlcmZsb3dzWzFdKVswXSkgPT0gbnVsbCA/IHZvaWQgMCA6IE0ucGxhY2VtZW50O1xuICAgICAgICBpZiAoIVIpXG4gICAgICAgICAgc3dpdGNoIChwKSB7XG4gICAgICAgICAgICBjYXNlIFwiYmVzdEZpdFwiOiB7XG4gICAgICAgICAgICAgIHZhciBFO1xuICAgICAgICAgICAgICBjb25zdCBOID0gKEUgPSBPLm1hcCgoaykgPT4gW2sucGxhY2VtZW50LCBrLm92ZXJmbG93cy5maWx0ZXIoKEYpID0+IEYgPiAwKS5yZWR1Y2UoKEYsIFYpID0+IEYgKyBWLCAwKV0pLnNvcnQoKGssIEYpID0+IGtbMV0gLSBGWzFdKVswXSkgPT0gbnVsbCA/IHZvaWQgMCA6IEVbMF07XG4gICAgICAgICAgICAgIE4gJiYgKFIgPSBOKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFwiaW5pdGlhbFBsYWNlbWVudFwiOlxuICAgICAgICAgICAgICBSID0gcztcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICBpZiAoaSAhPT0gUilcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcmVzZXQ6IHtcbiAgICAgICAgICAgICAgcGxhY2VtZW50OiBSXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7fTtcbiAgICB9XG4gIH07XG59O1xuZnVuY3Rpb24gWWQoZSwgdCkge1xuICByZXR1cm4ge1xuICAgIHRvcDogZS50b3AgLSB0LmhlaWdodCxcbiAgICByaWdodDogZS5yaWdodCAtIHQud2lkdGgsXG4gICAgYm90dG9tOiBlLmJvdHRvbSAtIHQuaGVpZ2h0LFxuICAgIGxlZnQ6IGUubGVmdCAtIHQud2lkdGhcbiAgfTtcbn1cbmZ1bmN0aW9uIFhkKGUpIHtcbiAgcmV0dXJuIHoxLnNvbWUoKHQpID0+IGVbdF0gPj0gMCk7XG59XG5jb25zdCBKMSA9IGZ1bmN0aW9uKGUpIHtcbiAgcmV0dXJuIGUgPT09IHZvaWQgMCAmJiAoZSA9IHt9KSwge1xuICAgIG5hbWU6IFwiaGlkZVwiLFxuICAgIG9wdGlvbnM6IGUsXG4gICAgYXN5bmMgZm4odCkge1xuICAgICAgY29uc3Qge1xuICAgICAgICByZWN0czogblxuICAgICAgfSA9IHQsIHtcbiAgICAgICAgc3RyYXRlZ3k6IHIgPSBcInJlZmVyZW5jZUhpZGRlblwiLFxuICAgICAgICAuLi5pXG4gICAgICB9ID0gd24oZSwgdCk7XG4gICAgICBzd2l0Y2ggKHIpIHtcbiAgICAgICAgY2FzZSBcInJlZmVyZW5jZUhpZGRlblwiOiB7XG4gICAgICAgICAgY29uc3QgbyA9IGF3YWl0IFppKHQsIHtcbiAgICAgICAgICAgIC4uLmksXG4gICAgICAgICAgICBlbGVtZW50Q29udGV4dDogXCJyZWZlcmVuY2VcIlxuICAgICAgICAgIH0pLCBhID0gWWQobywgbi5yZWZlcmVuY2UpO1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgIHJlZmVyZW5jZUhpZGRlbk9mZnNldHM6IGEsXG4gICAgICAgICAgICAgIHJlZmVyZW5jZUhpZGRlbjogWGQoYSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJlc2NhcGVkXCI6IHtcbiAgICAgICAgICBjb25zdCBvID0gYXdhaXQgWmkodCwge1xuICAgICAgICAgICAgLi4uaSxcbiAgICAgICAgICAgIGFsdEJvdW5kYXJ5OiAhMFxuICAgICAgICAgIH0pLCBhID0gWWQobywgbi5mbG9hdGluZyk7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgZXNjYXBlZE9mZnNldHM6IGEsXG4gICAgICAgICAgICAgIGVzY2FwZWQ6IFhkKGEpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiB7fTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG59O1xuYXN5bmMgZnVuY3Rpb24gUTEoZSwgdCkge1xuICBjb25zdCB7XG4gICAgcGxhY2VtZW50OiBuLFxuICAgIHBsYXRmb3JtOiByLFxuICAgIGVsZW1lbnRzOiBpXG4gIH0gPSBlLCBvID0gYXdhaXQgKHIuaXNSVEwgPT0gbnVsbCA/IHZvaWQgMCA6IHIuaXNSVEwoaS5mbG9hdGluZykpLCBhID0geG4obiksIHMgPSBvaShuKSwgdSA9IGFpKG4pID09PSBcInlcIiwgYyA9IFtcImxlZnRcIiwgXCJ0b3BcIl0uaW5jbHVkZXMoYSkgPyAtMSA6IDEsIGYgPSBvICYmIHUgPyAtMSA6IDEsIGwgPSB3bih0LCBlKTtcbiAgbGV0IHtcbiAgICBtYWluQXhpczogZCxcbiAgICBjcm9zc0F4aXM6IHAsXG4gICAgYWxpZ25tZW50QXhpczogZ1xuICB9ID0gdHlwZW9mIGwgPT0gXCJudW1iZXJcIiA/IHtcbiAgICBtYWluQXhpczogbCxcbiAgICBjcm9zc0F4aXM6IDAsXG4gICAgYWxpZ25tZW50QXhpczogbnVsbFxuICB9IDoge1xuICAgIG1haW5BeGlzOiAwLFxuICAgIGNyb3NzQXhpczogMCxcbiAgICBhbGlnbm1lbnRBeGlzOiBudWxsLFxuICAgIC4uLmxcbiAgfTtcbiAgcmV0dXJuIHMgJiYgdHlwZW9mIGcgPT0gXCJudW1iZXJcIiAmJiAocCA9IHMgPT09IFwiZW5kXCIgPyBnICogLTEgOiBnKSwgdSA/IHtcbiAgICB4OiBwICogZixcbiAgICB5OiBkICogY1xuICB9IDoge1xuICAgIHg6IGQgKiBjLFxuICAgIHk6IHAgKiBmXG4gIH07XG59XG5jb25zdCBlUyA9IGZ1bmN0aW9uKGUpIHtcbiAgcmV0dXJuIGUgPT09IHZvaWQgMCAmJiAoZSA9IDApLCB7XG4gICAgbmFtZTogXCJvZmZzZXRcIixcbiAgICBvcHRpb25zOiBlLFxuICAgIGFzeW5jIGZuKHQpIHtcbiAgICAgIHZhciBuLCByO1xuICAgICAgY29uc3Qge1xuICAgICAgICB4OiBpLFxuICAgICAgICB5OiBvLFxuICAgICAgICBwbGFjZW1lbnQ6IGEsXG4gICAgICAgIG1pZGRsZXdhcmVEYXRhOiBzXG4gICAgICB9ID0gdCwgdSA9IGF3YWl0IFExKHQsIGUpO1xuICAgICAgcmV0dXJuIGEgPT09ICgobiA9IHMub2Zmc2V0KSA9PSBudWxsID8gdm9pZCAwIDogbi5wbGFjZW1lbnQpICYmIChyID0gcy5hcnJvdykgIT0gbnVsbCAmJiByLmFsaWdubWVudE9mZnNldCA/IHt9IDoge1xuICAgICAgICB4OiBpICsgdS54LFxuICAgICAgICB5OiBvICsgdS55LFxuICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgLi4udSxcbiAgICAgICAgICBwbGFjZW1lbnQ6IGFcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gIH07XG59LCB0UyA9IGZ1bmN0aW9uKGUpIHtcbiAgcmV0dXJuIGUgPT09IHZvaWQgMCAmJiAoZSA9IHt9KSwge1xuICAgIG5hbWU6IFwic2hpZnRcIixcbiAgICBvcHRpb25zOiBlLFxuICAgIGFzeW5jIGZuKHQpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgeDogbixcbiAgICAgICAgeTogcixcbiAgICAgICAgcGxhY2VtZW50OiBpXG4gICAgICB9ID0gdCwge1xuICAgICAgICBtYWluQXhpczogbyA9ICEwLFxuICAgICAgICBjcm9zc0F4aXM6IGEgPSAhMSxcbiAgICAgICAgbGltaXRlcjogcyA9IHtcbiAgICAgICAgICBmbjogKHYpID0+IHtcbiAgICAgICAgICAgIGxldCB7XG4gICAgICAgICAgICAgIHg6IHcsXG4gICAgICAgICAgICAgIHk6IGJcbiAgICAgICAgICAgIH0gPSB2O1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgeDogdyxcbiAgICAgICAgICAgICAgeTogYlxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIC4uLnVcbiAgICAgIH0gPSB3bihlLCB0KSwgYyA9IHtcbiAgICAgICAgeDogbixcbiAgICAgICAgeTogclxuICAgICAgfSwgZiA9IGF3YWl0IFppKHQsIHUpLCBsID0gYWkoeG4oaSkpLCBkID0gdGYobCk7XG4gICAgICBsZXQgcCA9IGNbZF0sIGcgPSBjW2xdO1xuICAgICAgaWYgKG8pIHtcbiAgICAgICAgY29uc3QgdiA9IGQgPT09IFwieVwiID8gXCJ0b3BcIiA6IFwibGVmdFwiLCB3ID0gZCA9PT0gXCJ5XCIgPyBcImJvdHRvbVwiIDogXCJyaWdodFwiLCBiID0gcCArIGZbdl0sIHggPSBwIC0gZlt3XTtcbiAgICAgICAgcCA9IGJjKGIsIHAsIHgpO1xuICAgICAgfVxuICAgICAgaWYgKGEpIHtcbiAgICAgICAgY29uc3QgdiA9IGwgPT09IFwieVwiID8gXCJ0b3BcIiA6IFwibGVmdFwiLCB3ID0gbCA9PT0gXCJ5XCIgPyBcImJvdHRvbVwiIDogXCJyaWdodFwiLCBiID0gZyArIGZbdl0sIHggPSBnIC0gZlt3XTtcbiAgICAgICAgZyA9IGJjKGIsIGcsIHgpO1xuICAgICAgfVxuICAgICAgY29uc3QgaCA9IHMuZm4oe1xuICAgICAgICAuLi50LFxuICAgICAgICBbZF06IHAsXG4gICAgICAgIFtsXTogZ1xuICAgICAgfSk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5oLFxuICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgeDogaC54IC0gbixcbiAgICAgICAgICB5OiBoLnkgLSByXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICB9O1xufSwgblMgPSBmdW5jdGlvbihlKSB7XG4gIHJldHVybiBlID09PSB2b2lkIDAgJiYgKGUgPSB7fSksIHtcbiAgICBvcHRpb25zOiBlLFxuICAgIGZuKHQpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgeDogbixcbiAgICAgICAgeTogcixcbiAgICAgICAgcGxhY2VtZW50OiBpLFxuICAgICAgICByZWN0czogbyxcbiAgICAgICAgbWlkZGxld2FyZURhdGE6IGFcbiAgICAgIH0gPSB0LCB7XG4gICAgICAgIG9mZnNldDogcyA9IDAsXG4gICAgICAgIG1haW5BeGlzOiB1ID0gITAsXG4gICAgICAgIGNyb3NzQXhpczogYyA9ICEwXG4gICAgICB9ID0gd24oZSwgdCksIGYgPSB7XG4gICAgICAgIHg6IG4sXG4gICAgICAgIHk6IHJcbiAgICAgIH0sIGwgPSBhaShpKSwgZCA9IHRmKGwpO1xuICAgICAgbGV0IHAgPSBmW2RdLCBnID0gZltsXTtcbiAgICAgIGNvbnN0IGggPSB3bihzLCB0KSwgdiA9IHR5cGVvZiBoID09IFwibnVtYmVyXCIgPyB7XG4gICAgICAgIG1haW5BeGlzOiBoLFxuICAgICAgICBjcm9zc0F4aXM6IDBcbiAgICAgIH0gOiB7XG4gICAgICAgIG1haW5BeGlzOiAwLFxuICAgICAgICBjcm9zc0F4aXM6IDAsXG4gICAgICAgIC4uLmhcbiAgICAgIH07XG4gICAgICBpZiAodSkge1xuICAgICAgICBjb25zdCB4ID0gZCA9PT0gXCJ5XCIgPyBcImhlaWdodFwiIDogXCJ3aWR0aFwiLCBtID0gby5yZWZlcmVuY2VbZF0gLSBvLmZsb2F0aW5nW3hdICsgdi5tYWluQXhpcywgeSA9IG8ucmVmZXJlbmNlW2RdICsgby5yZWZlcmVuY2VbeF0gLSB2Lm1haW5BeGlzO1xuICAgICAgICBwIDwgbSA/IHAgPSBtIDogcCA+IHkgJiYgKHAgPSB5KTtcbiAgICAgIH1cbiAgICAgIGlmIChjKSB7XG4gICAgICAgIHZhciB3LCBiO1xuICAgICAgICBjb25zdCB4ID0gZCA9PT0gXCJ5XCIgPyBcIndpZHRoXCIgOiBcImhlaWdodFwiLCBtID0gW1widG9wXCIsIFwibGVmdFwiXS5pbmNsdWRlcyh4bihpKSksIHkgPSBvLnJlZmVyZW5jZVtsXSAtIG8uZmxvYXRpbmdbeF0gKyAobSAmJiAoKHcgPSBhLm9mZnNldCkgPT0gbnVsbCA/IHZvaWQgMCA6IHdbbF0pIHx8IDApICsgKG0gPyAwIDogdi5jcm9zc0F4aXMpLCBTID0gby5yZWZlcmVuY2VbbF0gKyBvLnJlZmVyZW5jZVt4XSArIChtID8gMCA6ICgoYiA9IGEub2Zmc2V0KSA9PSBudWxsID8gdm9pZCAwIDogYltsXSkgfHwgMCkgLSAobSA/IHYuY3Jvc3NBeGlzIDogMCk7XG4gICAgICAgIGcgPCB5ID8gZyA9IHkgOiBnID4gUyAmJiAoZyA9IFMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgW2RdOiBwLFxuICAgICAgICBbbF06IGdcbiAgICAgIH07XG4gICAgfVxuICB9O1xufSwgclMgPSBmdW5jdGlvbihlKSB7XG4gIHJldHVybiBlID09PSB2b2lkIDAgJiYgKGUgPSB7fSksIHtcbiAgICBuYW1lOiBcInNpemVcIixcbiAgICBvcHRpb25zOiBlLFxuICAgIGFzeW5jIGZuKHQpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgcGxhY2VtZW50OiBuLFxuICAgICAgICByZWN0czogcixcbiAgICAgICAgcGxhdGZvcm06IGksXG4gICAgICAgIGVsZW1lbnRzOiBvXG4gICAgICB9ID0gdCwge1xuICAgICAgICBhcHBseTogYSA9ICgpID0+IHtcbiAgICAgICAgfSxcbiAgICAgICAgLi4uc1xuICAgICAgfSA9IHduKGUsIHQpLCB1ID0gYXdhaXQgWmkodCwgcyksIGMgPSB4bihuKSwgZiA9IG9pKG4pLCBsID0gYWkobikgPT09IFwieVwiLCB7XG4gICAgICAgIHdpZHRoOiBkLFxuICAgICAgICBoZWlnaHQ6IHBcbiAgICAgIH0gPSByLmZsb2F0aW5nO1xuICAgICAgbGV0IGcsIGg7XG4gICAgICBjID09PSBcInRvcFwiIHx8IGMgPT09IFwiYm90dG9tXCIgPyAoZyA9IGMsIGggPSBmID09PSAoYXdhaXQgKGkuaXNSVEwgPT0gbnVsbCA/IHZvaWQgMCA6IGkuaXNSVEwoby5mbG9hdGluZykpID8gXCJzdGFydFwiIDogXCJlbmRcIikgPyBcImxlZnRcIiA6IFwicmlnaHRcIikgOiAoaCA9IGMsIGcgPSBmID09PSBcImVuZFwiID8gXCJ0b3BcIiA6IFwiYm90dG9tXCIpO1xuICAgICAgY29uc3QgdiA9IHAgLSB1LnRvcCAtIHUuYm90dG9tLCB3ID0gZCAtIHUubGVmdCAtIHUucmlnaHQsIGIgPSBybihwIC0gdVtnXSwgdiksIHggPSBybihkIC0gdVtoXSwgdyksIG0gPSAhdC5taWRkbGV3YXJlRGF0YS5zaGlmdDtcbiAgICAgIGxldCB5ID0gYiwgUyA9IHg7XG4gICAgICBpZiAobCA/IFMgPSBmIHx8IG0gPyBybih4LCB3KSA6IHcgOiB5ID0gZiB8fCBtID8gcm4oYiwgdikgOiB2LCBtICYmICFmKSB7XG4gICAgICAgIGNvbnN0IE8gPSB4dCh1LmxlZnQsIDApLCBUID0geHQodS5yaWdodCwgMCksIE0gPSB4dCh1LnRvcCwgMCksIEUgPSB4dCh1LmJvdHRvbSwgMCk7XG4gICAgICAgIGwgPyBTID0gZCAtIDIgKiAoTyAhPT0gMCB8fCBUICE9PSAwID8gTyArIFQgOiB4dCh1LmxlZnQsIHUucmlnaHQpKSA6IHkgPSBwIC0gMiAqIChNICE9PSAwIHx8IEUgIT09IDAgPyBNICsgRSA6IHh0KHUudG9wLCB1LmJvdHRvbSkpO1xuICAgICAgfVxuICAgICAgYXdhaXQgYSh7XG4gICAgICAgIC4uLnQsXG4gICAgICAgIGF2YWlsYWJsZVdpZHRoOiBTLFxuICAgICAgICBhdmFpbGFibGVIZWlnaHQ6IHlcbiAgICAgIH0pO1xuICAgICAgY29uc3QgJCA9IGF3YWl0IGkuZ2V0RGltZW5zaW9ucyhvLmZsb2F0aW5nKTtcbiAgICAgIHJldHVybiBkICE9PSAkLndpZHRoIHx8IHAgIT09ICQuaGVpZ2h0ID8ge1xuICAgICAgICByZXNldDoge1xuICAgICAgICAgIHJlY3RzOiAhMFxuICAgICAgICB9XG4gICAgICB9IDoge307XG4gICAgfVxuICB9O1xufTtcbmZ1bmN0aW9uIHNpKGUpIHtcbiAgcmV0dXJuIGttKGUpID8gKGUubm9kZU5hbWUgfHwgXCJcIikudG9Mb3dlckNhc2UoKSA6IFwiI2RvY3VtZW50XCI7XG59XG5mdW5jdGlvbiBPdChlKSB7XG4gIHZhciB0O1xuICByZXR1cm4gKGUgPT0gbnVsbCB8fCAodCA9IGUub3duZXJEb2N1bWVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IHQuZGVmYXVsdFZpZXcpIHx8IHdpbmRvdztcbn1cbmZ1bmN0aW9uIEFuKGUpIHtcbiAgdmFyIHQ7XG4gIHJldHVybiAodCA9IChrbShlKSA/IGUub3duZXJEb2N1bWVudCA6IGUuZG9jdW1lbnQpIHx8IHdpbmRvdy5kb2N1bWVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IHQuZG9jdW1lbnRFbGVtZW50O1xufVxuZnVuY3Rpb24ga20oZSkge1xuICByZXR1cm4gZSBpbnN0YW5jZW9mIE5vZGUgfHwgZSBpbnN0YW5jZW9mIE90KGUpLk5vZGU7XG59XG5mdW5jdGlvbiBjbihlKSB7XG4gIHJldHVybiBlIGluc3RhbmNlb2YgRWxlbWVudCB8fCBlIGluc3RhbmNlb2YgT3QoZSkuRWxlbWVudDtcbn1cbmZ1bmN0aW9uIGxuKGUpIHtcbiAgcmV0dXJuIGUgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCB8fCBlIGluc3RhbmNlb2YgT3QoZSkuSFRNTEVsZW1lbnQ7XG59XG5mdW5jdGlvbiBaZChlKSB7XG4gIHJldHVybiB0eXBlb2YgU2hhZG93Um9vdCA+IFwidVwiID8gITEgOiBlIGluc3RhbmNlb2YgU2hhZG93Um9vdCB8fCBlIGluc3RhbmNlb2YgT3QoZSkuU2hhZG93Um9vdDtcbn1cbmZ1bmN0aW9uIExvKGUpIHtcbiAgY29uc3Qge1xuICAgIG92ZXJmbG93OiB0LFxuICAgIG92ZXJmbG93WDogbixcbiAgICBvdmVyZmxvd1k6IHIsXG4gICAgZGlzcGxheTogaVxuICB9ID0gSnQoZSk7XG4gIHJldHVybiAvYXV0b3xzY3JvbGx8b3ZlcmxheXxoaWRkZW58Y2xpcC8udGVzdCh0ICsgciArIG4pICYmICFbXCJpbmxpbmVcIiwgXCJjb250ZW50c1wiXS5pbmNsdWRlcyhpKTtcbn1cbmZ1bmN0aW9uIGlTKGUpIHtcbiAgcmV0dXJuIFtcInRhYmxlXCIsIFwidGRcIiwgXCJ0aFwiXS5pbmNsdWRlcyhzaShlKSk7XG59XG5mdW5jdGlvbiBvZihlKSB7XG4gIGNvbnN0IHQgPSBhZigpLCBuID0gSnQoZSk7XG4gIHJldHVybiBuLnRyYW5zZm9ybSAhPT0gXCJub25lXCIgfHwgbi5wZXJzcGVjdGl2ZSAhPT0gXCJub25lXCIgfHwgKG4uY29udGFpbmVyVHlwZSA/IG4uY29udGFpbmVyVHlwZSAhPT0gXCJub3JtYWxcIiA6ICExKSB8fCAhdCAmJiAobi5iYWNrZHJvcEZpbHRlciA/IG4uYmFja2Ryb3BGaWx0ZXIgIT09IFwibm9uZVwiIDogITEpIHx8ICF0ICYmIChuLmZpbHRlciA/IG4uZmlsdGVyICE9PSBcIm5vbmVcIiA6ICExKSB8fCBbXCJ0cmFuc2Zvcm1cIiwgXCJwZXJzcGVjdGl2ZVwiLCBcImZpbHRlclwiXS5zb21lKChyKSA9PiAobi53aWxsQ2hhbmdlIHx8IFwiXCIpLmluY2x1ZGVzKHIpKSB8fCBbXCJwYWludFwiLCBcImxheW91dFwiLCBcInN0cmljdFwiLCBcImNvbnRlbnRcIl0uc29tZSgocikgPT4gKG4uY29udGFpbiB8fCBcIlwiKS5pbmNsdWRlcyhyKSk7XG59XG5mdW5jdGlvbiBvUyhlKSB7XG4gIGxldCB0ID0gVm4oZSk7XG4gIGZvciAoOyBsbih0KSAmJiAhTnIodCk7ICkge1xuICAgIGlmIChvZih0KSlcbiAgICAgIHJldHVybiB0O1xuICAgIHQgPSBWbih0KTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGFmKCkge1xuICByZXR1cm4gdHlwZW9mIENTUyA+IFwidVwiIHx8ICFDU1Muc3VwcG9ydHMgPyAhMSA6IENTUy5zdXBwb3J0cyhcIi13ZWJraXQtYmFja2Ryb3AtZmlsdGVyXCIsIFwibm9uZVwiKTtcbn1cbmZ1bmN0aW9uIE5yKGUpIHtcbiAgcmV0dXJuIFtcImh0bWxcIiwgXCJib2R5XCIsIFwiI2RvY3VtZW50XCJdLmluY2x1ZGVzKHNpKGUpKTtcbn1cbmZ1bmN0aW9uIEp0KGUpIHtcbiAgcmV0dXJuIE90KGUpLmdldENvbXB1dGVkU3R5bGUoZSk7XG59XG5mdW5jdGlvbiBScyhlKSB7XG4gIHJldHVybiBjbihlKSA/IHtcbiAgICBzY3JvbGxMZWZ0OiBlLnNjcm9sbExlZnQsXG4gICAgc2Nyb2xsVG9wOiBlLnNjcm9sbFRvcFxuICB9IDoge1xuICAgIHNjcm9sbExlZnQ6IGUucGFnZVhPZmZzZXQsXG4gICAgc2Nyb2xsVG9wOiBlLnBhZ2VZT2Zmc2V0XG4gIH07XG59XG5mdW5jdGlvbiBWbihlKSB7XG4gIGlmIChzaShlKSA9PT0gXCJodG1sXCIpXG4gICAgcmV0dXJuIGU7XG4gIGNvbnN0IHQgPSAoXG4gICAgLy8gU3RlcCBpbnRvIHRoZSBzaGFkb3cgRE9NIG9mIHRoZSBwYXJlbnQgb2YgYSBzbG90dGVkIG5vZGUuXG4gICAgZS5hc3NpZ25lZFNsb3QgfHwgLy8gRE9NIEVsZW1lbnQgZGV0ZWN0ZWQuXG4gICAgZS5wYXJlbnROb2RlIHx8IC8vIFNoYWRvd1Jvb3QgZGV0ZWN0ZWQuXG4gICAgWmQoZSkgJiYgZS5ob3N0IHx8IC8vIEZhbGxiYWNrLlxuICAgIEFuKGUpXG4gICk7XG4gIHJldHVybiBaZCh0KSA/IHQuaG9zdCA6IHQ7XG59XG5mdW5jdGlvbiBEbShlKSB7XG4gIGNvbnN0IHQgPSBWbihlKTtcbiAgcmV0dXJuIE5yKHQpID8gZS5vd25lckRvY3VtZW50ID8gZS5vd25lckRvY3VtZW50LmJvZHkgOiBlLmJvZHkgOiBsbih0KSAmJiBMbyh0KSA/IHQgOiBEbSh0KTtcbn1cbmZ1bmN0aW9uIEppKGUsIHQsIG4pIHtcbiAgdmFyIHI7XG4gIHQgPT09IHZvaWQgMCAmJiAodCA9IFtdKSwgbiA9PT0gdm9pZCAwICYmIChuID0gITApO1xuICBjb25zdCBpID0gRG0oZSksIG8gPSBpID09PSAoKHIgPSBlLm93bmVyRG9jdW1lbnQpID09IG51bGwgPyB2b2lkIDAgOiByLmJvZHkpLCBhID0gT3QoaSk7XG4gIHJldHVybiBvID8gdC5jb25jYXQoYSwgYS52aXN1YWxWaWV3cG9ydCB8fCBbXSwgTG8oaSkgPyBpIDogW10sIGEuZnJhbWVFbGVtZW50ICYmIG4gPyBKaShhLmZyYW1lRWxlbWVudCkgOiBbXSkgOiB0LmNvbmNhdChpLCBKaShpLCBbXSwgbikpO1xufVxuZnVuY3Rpb24gTm0oZSkge1xuICBjb25zdCB0ID0gSnQoZSk7XG4gIGxldCBuID0gcGFyc2VGbG9hdCh0LndpZHRoKSB8fCAwLCByID0gcGFyc2VGbG9hdCh0LmhlaWdodCkgfHwgMDtcbiAgY29uc3QgaSA9IGxuKGUpLCBvID0gaSA/IGUub2Zmc2V0V2lkdGggOiBuLCBhID0gaSA/IGUub2Zmc2V0SGVpZ2h0IDogciwgcyA9IE1hKG4pICE9PSBvIHx8IE1hKHIpICE9PSBhO1xuICByZXR1cm4gcyAmJiAobiA9IG8sIHIgPSBhKSwge1xuICAgIHdpZHRoOiBuLFxuICAgIGhlaWdodDogcixcbiAgICAkOiBzXG4gIH07XG59XG5mdW5jdGlvbiBzZihlKSB7XG4gIHJldHVybiBjbihlKSA/IGUgOiBlLmNvbnRleHRFbGVtZW50O1xufVxuZnVuY3Rpb24gVHIoZSkge1xuICBjb25zdCB0ID0gc2YoZSk7XG4gIGlmICghbG4odCkpXG4gICAgcmV0dXJuIHpuKDEpO1xuICBjb25zdCBuID0gdC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSwge1xuICAgIHdpZHRoOiByLFxuICAgIGhlaWdodDogaSxcbiAgICAkOiBvXG4gIH0gPSBObSh0KTtcbiAgbGV0IGEgPSAobyA/IE1hKG4ud2lkdGgpIDogbi53aWR0aCkgLyByLCBzID0gKG8gPyBNYShuLmhlaWdodCkgOiBuLmhlaWdodCkgLyBpO1xuICByZXR1cm4gKCFhIHx8ICFOdW1iZXIuaXNGaW5pdGUoYSkpICYmIChhID0gMSksICghcyB8fCAhTnVtYmVyLmlzRmluaXRlKHMpKSAmJiAocyA9IDEpLCB7XG4gICAgeDogYSxcbiAgICB5OiBzXG4gIH07XG59XG5jb25zdCBhUyA9IC8qIEBfX1BVUkVfXyAqLyB6bigwKTtcbmZ1bmN0aW9uIEZtKGUpIHtcbiAgY29uc3QgdCA9IE90KGUpO1xuICByZXR1cm4gIWFmKCkgfHwgIXQudmlzdWFsVmlld3BvcnQgPyBhUyA6IHtcbiAgICB4OiB0LnZpc3VhbFZpZXdwb3J0Lm9mZnNldExlZnQsXG4gICAgeTogdC52aXN1YWxWaWV3cG9ydC5vZmZzZXRUb3BcbiAgfTtcbn1cbmZ1bmN0aW9uIHNTKGUsIHQsIG4pIHtcbiAgcmV0dXJuIHQgPT09IHZvaWQgMCAmJiAodCA9ICExKSwgIW4gfHwgdCAmJiBuICE9PSBPdChlKSA/ICExIDogdDtcbn1cbmZ1bmN0aW9uIGNyKGUsIHQsIG4sIHIpIHtcbiAgdCA9PT0gdm9pZCAwICYmICh0ID0gITEpLCBuID09PSB2b2lkIDAgJiYgKG4gPSAhMSk7XG4gIGNvbnN0IGkgPSBlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLCBvID0gc2YoZSk7XG4gIGxldCBhID0gem4oMSk7XG4gIHQgJiYgKHIgPyBjbihyKSAmJiAoYSA9IFRyKHIpKSA6IGEgPSBUcihlKSk7XG4gIGNvbnN0IHMgPSBzUyhvLCBuLCByKSA/IEZtKG8pIDogem4oMCk7XG4gIGxldCB1ID0gKGkubGVmdCArIHMueCkgLyBhLngsIGMgPSAoaS50b3AgKyBzLnkpIC8gYS55LCBmID0gaS53aWR0aCAvIGEueCwgbCA9IGkuaGVpZ2h0IC8gYS55O1xuICBpZiAobykge1xuICAgIGNvbnN0IGQgPSBPdChvKSwgcCA9IHIgJiYgY24ocikgPyBPdChyKSA6IHI7XG4gICAgbGV0IGcgPSBkLCBoID0gZy5mcmFtZUVsZW1lbnQ7XG4gICAgZm9yICg7IGggJiYgciAmJiBwICE9PSBnOyApIHtcbiAgICAgIGNvbnN0IHYgPSBUcihoKSwgdyA9IGguZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksIGIgPSBKdChoKSwgeCA9IHcubGVmdCArIChoLmNsaWVudExlZnQgKyBwYXJzZUZsb2F0KGIucGFkZGluZ0xlZnQpKSAqIHYueCwgbSA9IHcudG9wICsgKGguY2xpZW50VG9wICsgcGFyc2VGbG9hdChiLnBhZGRpbmdUb3ApKSAqIHYueTtcbiAgICAgIHUgKj0gdi54LCBjICo9IHYueSwgZiAqPSB2LngsIGwgKj0gdi55LCB1ICs9IHgsIGMgKz0gbSwgZyA9IE90KGgpLCBoID0gZy5mcmFtZUVsZW1lbnQ7XG4gICAgfVxuICB9XG4gIHJldHVybiBJYSh7XG4gICAgd2lkdGg6IGYsXG4gICAgaGVpZ2h0OiBsLFxuICAgIHg6IHUsXG4gICAgeTogY1xuICB9KTtcbn1cbmNvbnN0IHVTID0gW1wiOnBvcG92ZXItb3BlblwiLCBcIjptb2RhbFwiXTtcbmZ1bmN0aW9uIHVmKGUpIHtcbiAgcmV0dXJuIHVTLnNvbWUoKHQpID0+IHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGUubWF0Y2hlcyh0KTtcbiAgICB9IGNhdGNoIHtcbiAgICAgIHJldHVybiAhMTtcbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gY1MoZSkge1xuICBsZXQge1xuICAgIGVsZW1lbnRzOiB0LFxuICAgIHJlY3Q6IG4sXG4gICAgb2Zmc2V0UGFyZW50OiByLFxuICAgIHN0cmF0ZWd5OiBpXG4gIH0gPSBlO1xuICBjb25zdCBvID0gaSA9PT0gXCJmaXhlZFwiLCBhID0gQW4ociksIHMgPSB0ID8gdWYodC5mbG9hdGluZykgOiAhMTtcbiAgaWYgKHIgPT09IGEgfHwgcyAmJiBvKVxuICAgIHJldHVybiBuO1xuICBsZXQgdSA9IHtcbiAgICBzY3JvbGxMZWZ0OiAwLFxuICAgIHNjcm9sbFRvcDogMFxuICB9LCBjID0gem4oMSk7XG4gIGNvbnN0IGYgPSB6bigwKSwgbCA9IGxuKHIpO1xuICBpZiAoKGwgfHwgIWwgJiYgIW8pICYmICgoc2kocikgIT09IFwiYm9keVwiIHx8IExvKGEpKSAmJiAodSA9IFJzKHIpKSwgbG4ocikpKSB7XG4gICAgY29uc3QgZCA9IGNyKHIpO1xuICAgIGMgPSBUcihyKSwgZi54ID0gZC54ICsgci5jbGllbnRMZWZ0LCBmLnkgPSBkLnkgKyByLmNsaWVudFRvcDtcbiAgfVxuICByZXR1cm4ge1xuICAgIHdpZHRoOiBuLndpZHRoICogYy54LFxuICAgIGhlaWdodDogbi5oZWlnaHQgKiBjLnksXG4gICAgeDogbi54ICogYy54IC0gdS5zY3JvbGxMZWZ0ICogYy54ICsgZi54LFxuICAgIHk6IG4ueSAqIGMueSAtIHUuc2Nyb2xsVG9wICogYy55ICsgZi55XG4gIH07XG59XG5mdW5jdGlvbiBsUyhlKSB7XG4gIHJldHVybiBBcnJheS5mcm9tKGUuZ2V0Q2xpZW50UmVjdHMoKSk7XG59XG5mdW5jdGlvbiBMbShlKSB7XG4gIHJldHVybiBjcihBbihlKSkubGVmdCArIFJzKGUpLnNjcm9sbExlZnQ7XG59XG5mdW5jdGlvbiBmUyhlKSB7XG4gIGNvbnN0IHQgPSBBbihlKSwgbiA9IFJzKGUpLCByID0gZS5vd25lckRvY3VtZW50LmJvZHksIGkgPSB4dCh0LnNjcm9sbFdpZHRoLCB0LmNsaWVudFdpZHRoLCByLnNjcm9sbFdpZHRoLCByLmNsaWVudFdpZHRoKSwgbyA9IHh0KHQuc2Nyb2xsSGVpZ2h0LCB0LmNsaWVudEhlaWdodCwgci5zY3JvbGxIZWlnaHQsIHIuY2xpZW50SGVpZ2h0KTtcbiAgbGV0IGEgPSAtbi5zY3JvbGxMZWZ0ICsgTG0oZSk7XG4gIGNvbnN0IHMgPSAtbi5zY3JvbGxUb3A7XG4gIHJldHVybiBKdChyKS5kaXJlY3Rpb24gPT09IFwicnRsXCIgJiYgKGEgKz0geHQodC5jbGllbnRXaWR0aCwgci5jbGllbnRXaWR0aCkgLSBpKSwge1xuICAgIHdpZHRoOiBpLFxuICAgIGhlaWdodDogbyxcbiAgICB4OiBhLFxuICAgIHk6IHNcbiAgfTtcbn1cbmZ1bmN0aW9uIGRTKGUsIHQpIHtcbiAgY29uc3QgbiA9IE90KGUpLCByID0gQW4oZSksIGkgPSBuLnZpc3VhbFZpZXdwb3J0O1xuICBsZXQgbyA9IHIuY2xpZW50V2lkdGgsIGEgPSByLmNsaWVudEhlaWdodCwgcyA9IDAsIHUgPSAwO1xuICBpZiAoaSkge1xuICAgIG8gPSBpLndpZHRoLCBhID0gaS5oZWlnaHQ7XG4gICAgY29uc3QgYyA9IGFmKCk7XG4gICAgKCFjIHx8IGMgJiYgdCA9PT0gXCJmaXhlZFwiKSAmJiAocyA9IGkub2Zmc2V0TGVmdCwgdSA9IGkub2Zmc2V0VG9wKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHdpZHRoOiBvLFxuICAgIGhlaWdodDogYSxcbiAgICB4OiBzLFxuICAgIHk6IHVcbiAgfTtcbn1cbmZ1bmN0aW9uIHBTKGUsIHQpIHtcbiAgY29uc3QgbiA9IGNyKGUsICEwLCB0ID09PSBcImZpeGVkXCIpLCByID0gbi50b3AgKyBlLmNsaWVudFRvcCwgaSA9IG4ubGVmdCArIGUuY2xpZW50TGVmdCwgbyA9IGxuKGUpID8gVHIoZSkgOiB6bigxKSwgYSA9IGUuY2xpZW50V2lkdGggKiBvLngsIHMgPSBlLmNsaWVudEhlaWdodCAqIG8ueSwgdSA9IGkgKiBvLngsIGMgPSByICogby55O1xuICByZXR1cm4ge1xuICAgIHdpZHRoOiBhLFxuICAgIGhlaWdodDogcyxcbiAgICB4OiB1LFxuICAgIHk6IGNcbiAgfTtcbn1cbmZ1bmN0aW9uIEpkKGUsIHQsIG4pIHtcbiAgbGV0IHI7XG4gIGlmICh0ID09PSBcInZpZXdwb3J0XCIpXG4gICAgciA9IGRTKGUsIG4pO1xuICBlbHNlIGlmICh0ID09PSBcImRvY3VtZW50XCIpXG4gICAgciA9IGZTKEFuKGUpKTtcbiAgZWxzZSBpZiAoY24odCkpXG4gICAgciA9IHBTKHQsIG4pO1xuICBlbHNlIHtcbiAgICBjb25zdCBpID0gRm0oZSk7XG4gICAgciA9IHtcbiAgICAgIC4uLnQsXG4gICAgICB4OiB0LnggLSBpLngsXG4gICAgICB5OiB0LnkgLSBpLnlcbiAgICB9O1xuICB9XG4gIHJldHVybiBJYShyKTtcbn1cbmZ1bmN0aW9uIEJtKGUsIHQpIHtcbiAgY29uc3QgbiA9IFZuKGUpO1xuICByZXR1cm4gbiA9PT0gdCB8fCAhY24obikgfHwgTnIobikgPyAhMSA6IEp0KG4pLnBvc2l0aW9uID09PSBcImZpeGVkXCIgfHwgQm0obiwgdCk7XG59XG5mdW5jdGlvbiBoUyhlLCB0KSB7XG4gIGNvbnN0IG4gPSB0LmdldChlKTtcbiAgaWYgKG4pXG4gICAgcmV0dXJuIG47XG4gIGxldCByID0gSmkoZSwgW10sICExKS5maWx0ZXIoKHMpID0+IGNuKHMpICYmIHNpKHMpICE9PSBcImJvZHlcIiksIGkgPSBudWxsO1xuICBjb25zdCBvID0gSnQoZSkucG9zaXRpb24gPT09IFwiZml4ZWRcIjtcbiAgbGV0IGEgPSBvID8gVm4oZSkgOiBlO1xuICBmb3IgKDsgY24oYSkgJiYgIU5yKGEpOyApIHtcbiAgICBjb25zdCBzID0gSnQoYSksIHUgPSBvZihhKTtcbiAgICAhdSAmJiBzLnBvc2l0aW9uID09PSBcImZpeGVkXCIgJiYgKGkgPSBudWxsKSwgKG8gPyAhdSAmJiAhaSA6ICF1ICYmIHMucG9zaXRpb24gPT09IFwic3RhdGljXCIgJiYgISFpICYmIFtcImFic29sdXRlXCIsIFwiZml4ZWRcIl0uaW5jbHVkZXMoaS5wb3NpdGlvbikgfHwgTG8oYSkgJiYgIXUgJiYgQm0oZSwgYSkpID8gciA9IHIuZmlsdGVyKChmKSA9PiBmICE9PSBhKSA6IGkgPSBzLCBhID0gVm4oYSk7XG4gIH1cbiAgcmV0dXJuIHQuc2V0KGUsIHIpLCByO1xufVxuZnVuY3Rpb24gZ1MoZSkge1xuICBsZXQge1xuICAgIGVsZW1lbnQ6IHQsXG4gICAgYm91bmRhcnk6IG4sXG4gICAgcm9vdEJvdW5kYXJ5OiByLFxuICAgIHN0cmF0ZWd5OiBpXG4gIH0gPSBlO1xuICBjb25zdCBhID0gWy4uLm4gPT09IFwiY2xpcHBpbmdBbmNlc3RvcnNcIiA/IHVmKHQpID8gW10gOiBoUyh0LCB0aGlzLl9jKSA6IFtdLmNvbmNhdChuKSwgcl0sIHMgPSBhWzBdLCB1ID0gYS5yZWR1Y2UoKGMsIGYpID0+IHtcbiAgICBjb25zdCBsID0gSmQodCwgZiwgaSk7XG4gICAgcmV0dXJuIGMudG9wID0geHQobC50b3AsIGMudG9wKSwgYy5yaWdodCA9IHJuKGwucmlnaHQsIGMucmlnaHQpLCBjLmJvdHRvbSA9IHJuKGwuYm90dG9tLCBjLmJvdHRvbSksIGMubGVmdCA9IHh0KGwubGVmdCwgYy5sZWZ0KSwgYztcbiAgfSwgSmQodCwgcywgaSkpO1xuICByZXR1cm4ge1xuICAgIHdpZHRoOiB1LnJpZ2h0IC0gdS5sZWZ0LFxuICAgIGhlaWdodDogdS5ib3R0b20gLSB1LnRvcCxcbiAgICB4OiB1LmxlZnQsXG4gICAgeTogdS50b3BcbiAgfTtcbn1cbmZ1bmN0aW9uIHZTKGUpIHtcbiAgY29uc3Qge1xuICAgIHdpZHRoOiB0LFxuICAgIGhlaWdodDogblxuICB9ID0gTm0oZSk7XG4gIHJldHVybiB7XG4gICAgd2lkdGg6IHQsXG4gICAgaGVpZ2h0OiBuXG4gIH07XG59XG5mdW5jdGlvbiBtUyhlLCB0LCBuKSB7XG4gIGNvbnN0IHIgPSBsbih0KSwgaSA9IEFuKHQpLCBvID0gbiA9PT0gXCJmaXhlZFwiLCBhID0gY3IoZSwgITAsIG8sIHQpO1xuICBsZXQgcyA9IHtcbiAgICBzY3JvbGxMZWZ0OiAwLFxuICAgIHNjcm9sbFRvcDogMFxuICB9O1xuICBjb25zdCB1ID0gem4oMCk7XG4gIGlmIChyIHx8ICFyICYmICFvKVxuICAgIGlmICgoc2kodCkgIT09IFwiYm9keVwiIHx8IExvKGkpKSAmJiAocyA9IFJzKHQpKSwgcikge1xuICAgICAgY29uc3QgbCA9IGNyKHQsICEwLCBvLCB0KTtcbiAgICAgIHUueCA9IGwueCArIHQuY2xpZW50TGVmdCwgdS55ID0gbC55ICsgdC5jbGllbnRUb3A7XG4gICAgfSBlbHNlXG4gICAgICBpICYmICh1LnggPSBMbShpKSk7XG4gIGNvbnN0IGMgPSBhLmxlZnQgKyBzLnNjcm9sbExlZnQgLSB1LngsIGYgPSBhLnRvcCArIHMuc2Nyb2xsVG9wIC0gdS55O1xuICByZXR1cm4ge1xuICAgIHg6IGMsXG4gICAgeTogZixcbiAgICB3aWR0aDogYS53aWR0aCxcbiAgICBoZWlnaHQ6IGEuaGVpZ2h0XG4gIH07XG59XG5mdW5jdGlvbiBidShlKSB7XG4gIHJldHVybiBKdChlKS5wb3NpdGlvbiA9PT0gXCJzdGF0aWNcIjtcbn1cbmZ1bmN0aW9uIFFkKGUsIHQpIHtcbiAgcmV0dXJuICFsbihlKSB8fCBKdChlKS5wb3NpdGlvbiA9PT0gXCJmaXhlZFwiID8gbnVsbCA6IHQgPyB0KGUpIDogZS5vZmZzZXRQYXJlbnQ7XG59XG5mdW5jdGlvbiB6bShlLCB0KSB7XG4gIGNvbnN0IG4gPSBPdChlKTtcbiAgaWYgKHVmKGUpKVxuICAgIHJldHVybiBuO1xuICBpZiAoIWxuKGUpKSB7XG4gICAgbGV0IGkgPSBWbihlKTtcbiAgICBmb3IgKDsgaSAmJiAhTnIoaSk7ICkge1xuICAgICAgaWYgKGNuKGkpICYmICFidShpKSlcbiAgICAgICAgcmV0dXJuIGk7XG4gICAgICBpID0gVm4oaSk7XG4gICAgfVxuICAgIHJldHVybiBuO1xuICB9XG4gIGxldCByID0gUWQoZSwgdCk7XG4gIGZvciAoOyByICYmIGlTKHIpICYmIGJ1KHIpOyApXG4gICAgciA9IFFkKHIsIHQpO1xuICByZXR1cm4gciAmJiBOcihyKSAmJiBidShyKSAmJiAhb2YocikgPyBuIDogciB8fCBvUyhlKSB8fCBuO1xufVxuY29uc3QgeVMgPSBhc3luYyBmdW5jdGlvbihlKSB7XG4gIGNvbnN0IHQgPSB0aGlzLmdldE9mZnNldFBhcmVudCB8fCB6bSwgbiA9IHRoaXMuZ2V0RGltZW5zaW9ucywgciA9IGF3YWl0IG4oZS5mbG9hdGluZyk7XG4gIHJldHVybiB7XG4gICAgcmVmZXJlbmNlOiBtUyhlLnJlZmVyZW5jZSwgYXdhaXQgdChlLmZsb2F0aW5nKSwgZS5zdHJhdGVneSksXG4gICAgZmxvYXRpbmc6IHtcbiAgICAgIHg6IDAsXG4gICAgICB5OiAwLFxuICAgICAgd2lkdGg6IHIud2lkdGgsXG4gICAgICBoZWlnaHQ6IHIuaGVpZ2h0XG4gICAgfVxuICB9O1xufTtcbmZ1bmN0aW9uIGJTKGUpIHtcbiAgcmV0dXJuIEp0KGUpLmRpcmVjdGlvbiA9PT0gXCJydGxcIjtcbn1cbmNvbnN0IHdTID0ge1xuICBjb252ZXJ0T2Zmc2V0UGFyZW50UmVsYXRpdmVSZWN0VG9WaWV3cG9ydFJlbGF0aXZlUmVjdDogY1MsXG4gIGdldERvY3VtZW50RWxlbWVudDogQW4sXG4gIGdldENsaXBwaW5nUmVjdDogZ1MsXG4gIGdldE9mZnNldFBhcmVudDogem0sXG4gIGdldEVsZW1lbnRSZWN0czogeVMsXG4gIGdldENsaWVudFJlY3RzOiBsUyxcbiAgZ2V0RGltZW5zaW9uczogdlMsXG4gIGdldFNjYWxlOiBUcixcbiAgaXNFbGVtZW50OiBjbixcbiAgaXNSVEw6IGJTXG59O1xuZnVuY3Rpb24geFMoZSwgdCkge1xuICBsZXQgbiA9IG51bGwsIHI7XG4gIGNvbnN0IGkgPSBBbihlKTtcbiAgZnVuY3Rpb24gbygpIHtcbiAgICB2YXIgcztcbiAgICBjbGVhclRpbWVvdXQociksIChzID0gbikgPT0gbnVsbCB8fCBzLmRpc2Nvbm5lY3QoKSwgbiA9IG51bGw7XG4gIH1cbiAgZnVuY3Rpb24gYShzLCB1KSB7XG4gICAgcyA9PT0gdm9pZCAwICYmIChzID0gITEpLCB1ID09PSB2b2lkIDAgJiYgKHUgPSAxKSwgbygpO1xuICAgIGNvbnN0IHtcbiAgICAgIGxlZnQ6IGMsXG4gICAgICB0b3A6IGYsXG4gICAgICB3aWR0aDogbCxcbiAgICAgIGhlaWdodDogZFxuICAgIH0gPSBlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIGlmIChzIHx8IHQoKSwgIWwgfHwgIWQpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgcCA9IHJhKGYpLCBnID0gcmEoaS5jbGllbnRXaWR0aCAtIChjICsgbCkpLCBoID0gcmEoaS5jbGllbnRIZWlnaHQgLSAoZiArIGQpKSwgdiA9IHJhKGMpLCBiID0ge1xuICAgICAgcm9vdE1hcmdpbjogLXAgKyBcInB4IFwiICsgLWcgKyBcInB4IFwiICsgLWggKyBcInB4IFwiICsgLXYgKyBcInB4XCIsXG4gICAgICB0aHJlc2hvbGQ6IHh0KDAsIHJuKDEsIHUpKSB8fCAxXG4gICAgfTtcbiAgICBsZXQgeCA9ICEwO1xuICAgIGZ1bmN0aW9uIG0oeSkge1xuICAgICAgY29uc3QgUyA9IHlbMF0uaW50ZXJzZWN0aW9uUmF0aW87XG4gICAgICBpZiAoUyAhPT0gdSkge1xuICAgICAgICBpZiAoIXgpXG4gICAgICAgICAgcmV0dXJuIGEoKTtcbiAgICAgICAgUyA/IGEoITEsIFMpIDogciA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIGEoITEsIDFlLTcpO1xuICAgICAgICB9LCAxZTMpO1xuICAgICAgfVxuICAgICAgeCA9ICExO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgbiA9IG5ldyBJbnRlcnNlY3Rpb25PYnNlcnZlcihtLCB7XG4gICAgICAgIC4uLmIsXG4gICAgICAgIC8vIEhhbmRsZSA8aWZyYW1lPnNcbiAgICAgICAgcm9vdDogaS5vd25lckRvY3VtZW50XG4gICAgICB9KTtcbiAgICB9IGNhdGNoIHtcbiAgICAgIG4gPSBuZXcgSW50ZXJzZWN0aW9uT2JzZXJ2ZXIobSwgYik7XG4gICAgfVxuICAgIG4ub2JzZXJ2ZShlKTtcbiAgfVxuICByZXR1cm4gYSghMCksIG87XG59XG5mdW5jdGlvbiBTUyhlLCB0LCBuLCByKSB7XG4gIHIgPT09IHZvaWQgMCAmJiAociA9IHt9KTtcbiAgY29uc3Qge1xuICAgIGFuY2VzdG9yU2Nyb2xsOiBpID0gITAsXG4gICAgYW5jZXN0b3JSZXNpemU6IG8gPSAhMCxcbiAgICBlbGVtZW50UmVzaXplOiBhID0gdHlwZW9mIFJlc2l6ZU9ic2VydmVyID09IFwiZnVuY3Rpb25cIixcbiAgICBsYXlvdXRTaGlmdDogcyA9IHR5cGVvZiBJbnRlcnNlY3Rpb25PYnNlcnZlciA9PSBcImZ1bmN0aW9uXCIsXG4gICAgYW5pbWF0aW9uRnJhbWU6IHUgPSAhMVxuICB9ID0gciwgYyA9IHNmKGUpLCBmID0gaSB8fCBvID8gWy4uLmMgPyBKaShjKSA6IFtdLCAuLi5KaSh0KV0gOiBbXTtcbiAgZi5mb3JFYWNoKCh3KSA9PiB7XG4gICAgaSAmJiB3LmFkZEV2ZW50TGlzdGVuZXIoXCJzY3JvbGxcIiwgbiwge1xuICAgICAgcGFzc2l2ZTogITBcbiAgICB9KSwgbyAmJiB3LmFkZEV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIiwgbik7XG4gIH0pO1xuICBjb25zdCBsID0gYyAmJiBzID8geFMoYywgbikgOiBudWxsO1xuICBsZXQgZCA9IC0xLCBwID0gbnVsbDtcbiAgYSAmJiAocCA9IG5ldyBSZXNpemVPYnNlcnZlcigodykgPT4ge1xuICAgIGxldCBbYl0gPSB3O1xuICAgIGIgJiYgYi50YXJnZXQgPT09IGMgJiYgcCAmJiAocC51bm9ic2VydmUodCksIGNhbmNlbEFuaW1hdGlvbkZyYW1lKGQpLCBkID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgIHZhciB4O1xuICAgICAgKHggPSBwKSA9PSBudWxsIHx8IHgub2JzZXJ2ZSh0KTtcbiAgICB9KSksIG4oKTtcbiAgfSksIGMgJiYgIXUgJiYgcC5vYnNlcnZlKGMpLCBwLm9ic2VydmUodCkpO1xuICBsZXQgZywgaCA9IHUgPyBjcihlKSA6IG51bGw7XG4gIHUgJiYgdigpO1xuICBmdW5jdGlvbiB2KCkge1xuICAgIGNvbnN0IHcgPSBjcihlKTtcbiAgICBoICYmICh3LnggIT09IGgueCB8fCB3LnkgIT09IGgueSB8fCB3LndpZHRoICE9PSBoLndpZHRoIHx8IHcuaGVpZ2h0ICE9PSBoLmhlaWdodCkgJiYgbigpLCBoID0gdywgZyA9IHJlcXVlc3RBbmltYXRpb25GcmFtZSh2KTtcbiAgfVxuICByZXR1cm4gbigpLCAoKSA9PiB7XG4gICAgdmFyIHc7XG4gICAgZi5mb3JFYWNoKChiKSA9PiB7XG4gICAgICBpICYmIGIucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInNjcm9sbFwiLCBuKSwgbyAmJiBiLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIiwgbik7XG4gICAgfSksIGwgPT0gbnVsbCB8fCBsKCksICh3ID0gcCkgPT0gbnVsbCB8fCB3LmRpc2Nvbm5lY3QoKSwgcCA9IG51bGwsIHUgJiYgY2FuY2VsQW5pbWF0aW9uRnJhbWUoZyk7XG4gIH07XG59XG5jb25zdCAkUyA9IGVTLCBPUyA9IHRTLCBfUyA9IFoxLCBBUyA9IHJTLCBQUyA9IEoxLCBlcCA9IFgxLCBDUyA9IG5TLCBFUyA9IChlLCB0LCBuKSA9PiB7XG4gIGNvbnN0IHIgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpLCBpID0ge1xuICAgIHBsYXRmb3JtOiB3UyxcbiAgICAuLi5uXG4gIH0sIG8gPSB7XG4gICAgLi4uaS5wbGF0Zm9ybSxcbiAgICBfYzogclxuICB9O1xuICByZXR1cm4gWTEoZSwgdCwge1xuICAgIC4uLmksXG4gICAgcGxhdGZvcm06IG9cbiAgfSk7XG59O1xudmFyIEFhID0gdHlwZW9mIGRvY3VtZW50IDwgXCJ1XCIgPyBjbSA6IEZlO1xuZnVuY3Rpb24gamEoZSwgdCkge1xuICBpZiAoZSA9PT0gdClcbiAgICByZXR1cm4gITA7XG4gIGlmICh0eXBlb2YgZSAhPSB0eXBlb2YgdClcbiAgICByZXR1cm4gITE7XG4gIGlmICh0eXBlb2YgZSA9PSBcImZ1bmN0aW9uXCIgJiYgZS50b1N0cmluZygpID09PSB0LnRvU3RyaW5nKCkpXG4gICAgcmV0dXJuICEwO1xuICBsZXQgbiwgciwgaTtcbiAgaWYgKGUgJiYgdCAmJiB0eXBlb2YgZSA9PSBcIm9iamVjdFwiKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZSkpIHtcbiAgICAgIGlmIChuID0gZS5sZW5ndGgsIG4gIT09IHQubGVuZ3RoKVxuICAgICAgICByZXR1cm4gITE7XG4gICAgICBmb3IgKHIgPSBuOyByLS0gIT09IDA7IClcbiAgICAgICAgaWYgKCFqYShlW3JdLCB0W3JdKSlcbiAgICAgICAgICByZXR1cm4gITE7XG4gICAgICByZXR1cm4gITA7XG4gICAgfVxuICAgIGlmIChpID0gT2JqZWN0LmtleXMoZSksIG4gPSBpLmxlbmd0aCwgbiAhPT0gT2JqZWN0LmtleXModCkubGVuZ3RoKVxuICAgICAgcmV0dXJuICExO1xuICAgIGZvciAociA9IG47IHItLSAhPT0gMDsgKVxuICAgICAgaWYgKCF7fS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHQsIGlbcl0pKVxuICAgICAgICByZXR1cm4gITE7XG4gICAgZm9yIChyID0gbjsgci0tICE9PSAwOyApIHtcbiAgICAgIGNvbnN0IG8gPSBpW3JdO1xuICAgICAgaWYgKCEobyA9PT0gXCJfb3duZXJcIiAmJiBlLiQkdHlwZW9mKSAmJiAhamEoZVtvXSwgdFtvXSkpXG4gICAgICAgIHJldHVybiAhMTtcbiAgICB9XG4gICAgcmV0dXJuICEwO1xuICB9XG4gIHJldHVybiBlICE9PSBlICYmIHQgIT09IHQ7XG59XG5mdW5jdGlvbiBWbShlKSB7XG4gIHJldHVybiB0eXBlb2Ygd2luZG93ID4gXCJ1XCIgPyAxIDogKGUub3duZXJEb2N1bWVudC5kZWZhdWx0VmlldyB8fCB3aW5kb3cpLmRldmljZVBpeGVsUmF0aW8gfHwgMTtcbn1cbmZ1bmN0aW9uIHRwKGUsIHQpIHtcbiAgY29uc3QgbiA9IFZtKGUpO1xuICByZXR1cm4gTWF0aC5yb3VuZCh0ICogbikgLyBuO1xufVxuZnVuY3Rpb24gbnAoZSkge1xuICBjb25zdCB0ID0gSC51c2VSZWYoZSk7XG4gIHJldHVybiBBYSgoKSA9PiB7XG4gICAgdC5jdXJyZW50ID0gZTtcbiAgfSksIHQ7XG59XG5mdW5jdGlvbiBUUyhlKSB7XG4gIGUgPT09IHZvaWQgMCAmJiAoZSA9IHt9KTtcbiAgY29uc3Qge1xuICAgIHBsYWNlbWVudDogdCA9IFwiYm90dG9tXCIsXG4gICAgc3RyYXRlZ3k6IG4gPSBcImFic29sdXRlXCIsXG4gICAgbWlkZGxld2FyZTogciA9IFtdLFxuICAgIHBsYXRmb3JtOiBpLFxuICAgIGVsZW1lbnRzOiB7XG4gICAgICByZWZlcmVuY2U6IG8sXG4gICAgICBmbG9hdGluZzogYVxuICAgIH0gPSB7fSxcbiAgICB0cmFuc2Zvcm06IHMgPSAhMCxcbiAgICB3aGlsZUVsZW1lbnRzTW91bnRlZDogdSxcbiAgICBvcGVuOiBjXG4gIH0gPSBlLCBbZiwgbF0gPSBILnVzZVN0YXRlKHtcbiAgICB4OiAwLFxuICAgIHk6IDAsXG4gICAgc3RyYXRlZ3k6IG4sXG4gICAgcGxhY2VtZW50OiB0LFxuICAgIG1pZGRsZXdhcmVEYXRhOiB7fSxcbiAgICBpc1Bvc2l0aW9uZWQ6ICExXG4gIH0pLCBbZCwgcF0gPSBILnVzZVN0YXRlKHIpO1xuICBqYShkLCByKSB8fCBwKHIpO1xuICBjb25zdCBbZywgaF0gPSBILnVzZVN0YXRlKG51bGwpLCBbdiwgd10gPSBILnVzZVN0YXRlKG51bGwpLCBiID0gSC51c2VDYWxsYmFjaygoRikgPT4ge1xuICAgIEYgIT09IFMuY3VycmVudCAmJiAoUy5jdXJyZW50ID0gRiwgaChGKSk7XG4gIH0sIFtdKSwgeCA9IEgudXNlQ2FsbGJhY2soKEYpID0+IHtcbiAgICBGICE9PSAkLmN1cnJlbnQgJiYgKCQuY3VycmVudCA9IEYsIHcoRikpO1xuICB9LCBbXSksIG0gPSBvIHx8IGcsIHkgPSBhIHx8IHYsIFMgPSBILnVzZVJlZihudWxsKSwgJCA9IEgudXNlUmVmKG51bGwpLCBPID0gSC51c2VSZWYoZiksIFQgPSB1ICE9IG51bGwsIE0gPSBucCh1KSwgRSA9IG5wKGkpLCBBID0gSC51c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgaWYgKCFTLmN1cnJlbnQgfHwgISQuY3VycmVudClcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBGID0ge1xuICAgICAgcGxhY2VtZW50OiB0LFxuICAgICAgc3RyYXRlZ3k6IG4sXG4gICAgICBtaWRkbGV3YXJlOiBkXG4gICAgfTtcbiAgICBFLmN1cnJlbnQgJiYgKEYucGxhdGZvcm0gPSBFLmN1cnJlbnQpLCBFUyhTLmN1cnJlbnQsICQuY3VycmVudCwgRikudGhlbigoVikgPT4ge1xuICAgICAgY29uc3QgTCA9IHtcbiAgICAgICAgLi4uVixcbiAgICAgICAgaXNQb3NpdGlvbmVkOiAhMFxuICAgICAgfTtcbiAgICAgIGouY3VycmVudCAmJiAhamEoTy5jdXJyZW50LCBMKSAmJiAoTy5jdXJyZW50ID0gTCwgeHguZmx1c2hTeW5jKCgpID0+IHtcbiAgICAgICAgbChMKTtcbiAgICAgIH0pKTtcbiAgICB9KTtcbiAgfSwgW2QsIHQsIG4sIEVdKTtcbiAgQWEoKCkgPT4ge1xuICAgIGMgPT09ICExICYmIE8uY3VycmVudC5pc1Bvc2l0aW9uZWQgJiYgKE8uY3VycmVudC5pc1Bvc2l0aW9uZWQgPSAhMSwgbCgoRikgPT4gKHtcbiAgICAgIC4uLkYsXG4gICAgICBpc1Bvc2l0aW9uZWQ6ICExXG4gICAgfSkpKTtcbiAgfSwgW2NdKTtcbiAgY29uc3QgaiA9IEgudXNlUmVmKCExKTtcbiAgQWEoKCkgPT4gKGouY3VycmVudCA9ICEwLCAoKSA9PiB7XG4gICAgai5jdXJyZW50ID0gITE7XG4gIH0pLCBbXSksIEFhKCgpID0+IHtcbiAgICBpZiAobSAmJiAoUy5jdXJyZW50ID0gbSksIHkgJiYgKCQuY3VycmVudCA9IHkpLCBtICYmIHkpIHtcbiAgICAgIGlmIChNLmN1cnJlbnQpXG4gICAgICAgIHJldHVybiBNLmN1cnJlbnQobSwgeSwgQSk7XG4gICAgICBBKCk7XG4gICAgfVxuICB9LCBbbSwgeSwgQSwgTSwgVF0pO1xuICBjb25zdCBSID0gSC51c2VNZW1vKCgpID0+ICh7XG4gICAgcmVmZXJlbmNlOiBTLFxuICAgIGZsb2F0aW5nOiAkLFxuICAgIHNldFJlZmVyZW5jZTogYixcbiAgICBzZXRGbG9hdGluZzogeFxuICB9KSwgW2IsIHhdKSwgTiA9IEgudXNlTWVtbygoKSA9PiAoe1xuICAgIHJlZmVyZW5jZTogbSxcbiAgICBmbG9hdGluZzogeVxuICB9KSwgW20sIHldKSwgayA9IEgudXNlTWVtbygoKSA9PiB7XG4gICAgY29uc3QgRiA9IHtcbiAgICAgIHBvc2l0aW9uOiBuLFxuICAgICAgbGVmdDogMCxcbiAgICAgIHRvcDogMFxuICAgIH07XG4gICAgaWYgKCFOLmZsb2F0aW5nKVxuICAgICAgcmV0dXJuIEY7XG4gICAgY29uc3QgViA9IHRwKE4uZmxvYXRpbmcsIGYueCksIEwgPSB0cChOLmZsb2F0aW5nLCBmLnkpO1xuICAgIHJldHVybiBzID8ge1xuICAgICAgLi4uRixcbiAgICAgIHRyYW5zZm9ybTogXCJ0cmFuc2xhdGUoXCIgKyBWICsgXCJweCwgXCIgKyBMICsgXCJweClcIixcbiAgICAgIC4uLlZtKE4uZmxvYXRpbmcpID49IDEuNSAmJiB7XG4gICAgICAgIHdpbGxDaGFuZ2U6IFwidHJhbnNmb3JtXCJcbiAgICAgIH1cbiAgICB9IDoge1xuICAgICAgcG9zaXRpb246IG4sXG4gICAgICBsZWZ0OiBWLFxuICAgICAgdG9wOiBMXG4gICAgfTtcbiAgfSwgW24sIHMsIE4uZmxvYXRpbmcsIGYueCwgZi55XSk7XG4gIHJldHVybiBILnVzZU1lbW8oKCkgPT4gKHtcbiAgICAuLi5mLFxuICAgIHVwZGF0ZTogQSxcbiAgICByZWZzOiBSLFxuICAgIGVsZW1lbnRzOiBOLFxuICAgIGZsb2F0aW5nU3R5bGVzOiBrXG4gIH0pLCBbZiwgQSwgUiwgTiwga10pO1xufVxuY29uc3QgTVMgPSAoZSkgPT4ge1xuICBmdW5jdGlvbiB0KG4pIHtcbiAgICByZXR1cm4ge30uaGFzT3duUHJvcGVydHkuY2FsbChuLCBcImN1cnJlbnRcIik7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBuYW1lOiBcImFycm93XCIsXG4gICAgb3B0aW9uczogZSxcbiAgICBmbihuKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGVsZW1lbnQ6IHIsXG4gICAgICAgIHBhZGRpbmc6IGlcbiAgICAgIH0gPSB0eXBlb2YgZSA9PSBcImZ1bmN0aW9uXCIgPyBlKG4pIDogZTtcbiAgICAgIHJldHVybiByICYmIHQocikgPyByLmN1cnJlbnQgIT0gbnVsbCA/IGVwKHtcbiAgICAgICAgZWxlbWVudDogci5jdXJyZW50LFxuICAgICAgICBwYWRkaW5nOiBpXG4gICAgICB9KS5mbihuKSA6IHt9IDogciA/IGVwKHtcbiAgICAgICAgZWxlbWVudDogcixcbiAgICAgICAgcGFkZGluZzogaVxuICAgICAgfSkuZm4obikgOiB7fTtcbiAgICB9XG4gIH07XG59LCBSUyA9IChlLCB0KSA9PiAoe1xuICAuLi4kUyhlKSxcbiAgb3B0aW9uczogW2UsIHRdXG59KSwgSVMgPSAoZSwgdCkgPT4gKHtcbiAgLi4uT1MoZSksXG4gIG9wdGlvbnM6IFtlLCB0XVxufSksIGpTID0gKGUsIHQpID0+ICh7XG4gIC4uLkNTKGUpLFxuICBvcHRpb25zOiBbZSwgdF1cbn0pLCBrUyA9IChlLCB0KSA9PiAoe1xuICAuLi5fUyhlKSxcbiAgb3B0aW9uczogW2UsIHRdXG59KSwgRFMgPSAoZSwgdCkgPT4gKHtcbiAgLi4uQVMoZSksXG4gIG9wdGlvbnM6IFtlLCB0XVxufSksIE5TID0gKGUsIHQpID0+ICh7XG4gIC4uLlBTKGUpLFxuICBvcHRpb25zOiBbZSwgdF1cbn0pLCBGUyA9IChlLCB0KSA9PiAoe1xuICAuLi5NUyhlKSxcbiAgb3B0aW9uczogW2UsIHRdXG59KTtcbmZ1bmN0aW9uIExTKGUpIHtcbiAgY29uc3QgW3QsIG5dID0gWWUodm9pZCAwKTtcbiAgcmV0dXJuIERyKCgpID0+IHtcbiAgICBpZiAoZSkge1xuICAgICAgbih7XG4gICAgICAgIHdpZHRoOiBlLm9mZnNldFdpZHRoLFxuICAgICAgICBoZWlnaHQ6IGUub2Zmc2V0SGVpZ2h0XG4gICAgICB9KTtcbiAgICAgIGNvbnN0IHIgPSBuZXcgUmVzaXplT2JzZXJ2ZXIoKGkpID0+IHtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGkpIHx8ICFpLmxlbmd0aClcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IG8gPSBpWzBdO1xuICAgICAgICBsZXQgYSwgcztcbiAgICAgICAgaWYgKFwiYm9yZGVyQm94U2l6ZVwiIGluIG8pIHtcbiAgICAgICAgICBjb25zdCB1ID0gby5ib3JkZXJCb3hTaXplLCBjID0gQXJyYXkuaXNBcnJheSh1KSA/IHVbMF0gOiB1O1xuICAgICAgICAgIGEgPSBjLmlubGluZVNpemUsIHMgPSBjLmJsb2NrU2l6ZTtcbiAgICAgICAgfSBlbHNlXG4gICAgICAgICAgYSA9IGUub2Zmc2V0V2lkdGgsIHMgPSBlLm9mZnNldEhlaWdodDtcbiAgICAgICAgbih7XG4gICAgICAgICAgd2lkdGg6IGEsXG4gICAgICAgICAgaGVpZ2h0OiBzXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gci5vYnNlcnZlKGUsIHtcbiAgICAgICAgYm94OiBcImJvcmRlci1ib3hcIlxuICAgICAgfSksICgpID0+IHIudW5vYnNlcnZlKGUpO1xuICAgIH0gZWxzZVxuICAgICAgbih2b2lkIDApO1xuICB9LCBbXG4gICAgZVxuICBdKSwgdDtcbn1cbmNvbnN0IEdtID0gXCJQb3BwZXJcIiwgW1dtLCBVbV0gPSBGbyhHbSksIFtCUywgSG1dID0gV20oR20pLCB6UyA9IChlKSA9PiB7XG4gIGNvbnN0IHsgX19zY29wZVBvcHBlcjogdCwgY2hpbGRyZW46IG4gfSA9IGUsIFtyLCBpXSA9IFllKG51bGwpO1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIFkoQlMsIHtcbiAgICBzY29wZTogdCxcbiAgICBhbmNob3I6IHIsXG4gICAgb25BbmNob3JDaGFuZ2U6IGlcbiAgfSwgbik7XG59LCBWUyA9IFwiUG9wcGVyQW5jaG9yXCIsIEdTID0gLyogQF9fUFVSRV9fICovIGhlKChlLCB0KSA9PiB7XG4gIGNvbnN0IHsgX19zY29wZVBvcHBlcjogbiwgdmlydHVhbFJlZjogciwgLi4uaSB9ID0gZSwgbyA9IEhtKFZTLCBuKSwgYSA9IF9lKG51bGwpLCBzID0gX3QodCwgYSk7XG4gIHJldHVybiBGZSgoKSA9PiB7XG4gICAgby5vbkFuY2hvckNoYW5nZSgociA9PSBudWxsID8gdm9pZCAwIDogci5jdXJyZW50KSB8fCBhLmN1cnJlbnQpO1xuICB9KSwgciA/IG51bGwgOiAvKiBAX19QVVJFX18gKi8gWShGdC5kaXYsIGNlKHt9LCBpLCB7XG4gICAgcmVmOiBzXG4gIH0pKTtcbn0pLCBxbSA9IFwiUG9wcGVyQ29udGVudFwiLCBbV1MsIFhVXSA9IFdtKHFtKSwgVVMgPSAvKiBAX19QVVJFX18gKi8gaGUoKGUsIHQpID0+IHtcbiAgdmFyIG4sIHIsIGksIG8sIGEsIHMsIHUsIGM7XG4gIGNvbnN0IHsgX19zY29wZVBvcHBlcjogZiwgc2lkZTogbCA9IFwiYm90dG9tXCIsIHNpZGVPZmZzZXQ6IGQgPSAwLCBhbGlnbjogcCA9IFwiY2VudGVyXCIsIGFsaWduT2Zmc2V0OiBnID0gMCwgYXJyb3dQYWRkaW5nOiBoID0gMCwgYXZvaWRDb2xsaXNpb25zOiB2ID0gITAsIGNvbGxpc2lvbkJvdW5kYXJ5OiB3ID0gW10sIGNvbGxpc2lvblBhZGRpbmc6IGIgPSAwLCBzdGlja3k6IHggPSBcInBhcnRpYWxcIiwgaGlkZVdoZW5EZXRhY2hlZDogbSA9ICExLCB1cGRhdGVQb3NpdGlvblN0cmF0ZWd5OiB5ID0gXCJvcHRpbWl6ZWRcIiwgb25QbGFjZWQ6IFMsIC4uLiQgfSA9IGUsIE8gPSBIbShxbSwgZiksIFtULCBNXSA9IFllKG51bGwpLCBFID0gX3QoXG4gICAgdCxcbiAgICAoeGUpID0+IE0oeGUpXG4gICksIFtBLCBqXSA9IFllKG51bGwpLCBSID0gTFMoQSksIE4gPSAobiA9IFIgPT0gbnVsbCA/IHZvaWQgMCA6IFIud2lkdGgpICE9PSBudWxsICYmIG4gIT09IHZvaWQgMCA/IG4gOiAwLCBrID0gKHIgPSBSID09IG51bGwgPyB2b2lkIDAgOiBSLmhlaWdodCkgIT09IG51bGwgJiYgciAhPT0gdm9pZCAwID8gciA6IDAsIEYgPSBsICsgKHAgIT09IFwiY2VudGVyXCIgPyBcIi1cIiArIHAgOiBcIlwiKSwgViA9IHR5cGVvZiBiID09IFwibnVtYmVyXCIgPyBiIDoge1xuICAgIHRvcDogMCxcbiAgICByaWdodDogMCxcbiAgICBib3R0b206IDAsXG4gICAgbGVmdDogMCxcbiAgICAuLi5iXG4gIH0sIEwgPSBBcnJheS5pc0FycmF5KHcpID8gdyA6IFtcbiAgICB3XG4gIF0sIEkgPSBMLmxlbmd0aCA+IDAsIEQgPSB7XG4gICAgcGFkZGluZzogVixcbiAgICBib3VuZGFyeTogTC5maWx0ZXIoSFMpLFxuICAgIC8vIHdpdGggYHN0cmF0ZWd5OiAnZml4ZWQnYCwgdGhpcyBpcyB0aGUgb25seSB3YXkgdG8gZ2V0IGl0IHRvIHJlc3BlY3QgYm91bmRhcmllc1xuICAgIGFsdEJvdW5kYXJ5OiBJXG4gIH0sIHsgcmVmczogRywgZmxvYXRpbmdTdHlsZXM6IHEsIHBsYWNlbWVudDogSiwgaXNQb3NpdGlvbmVkOiBuZSwgbWlkZGxld2FyZURhdGE6IHRlIH0gPSBUUyh7XG4gICAgLy8gZGVmYXVsdCB0byBgZml4ZWRgIHN0cmF0ZWd5IHNvIHVzZXJzIGRvbid0IGhhdmUgdG8gcGljayBhbmQgd2UgYWxzbyBhdm9pZCBmb2N1cyBzY3JvbGwgaXNzdWVzXG4gICAgc3RyYXRlZ3k6IFwiZml4ZWRcIixcbiAgICBwbGFjZW1lbnQ6IEYsXG4gICAgd2hpbGVFbGVtZW50c01vdW50ZWQ6ICguLi54ZSkgPT4gU1MoLi4ueGUsIHtcbiAgICAgIGFuaW1hdGlvbkZyYW1lOiB5ID09PSBcImFsd2F5c1wiXG4gICAgfSksXG4gICAgZWxlbWVudHM6IHtcbiAgICAgIHJlZmVyZW5jZTogTy5hbmNob3JcbiAgICB9LFxuICAgIG1pZGRsZXdhcmU6IFtcbiAgICAgIFJTKHtcbiAgICAgICAgbWFpbkF4aXM6IGQgKyBrLFxuICAgICAgICBhbGlnbm1lbnRBeGlzOiBnXG4gICAgICB9KSxcbiAgICAgIHYgJiYgSVMoe1xuICAgICAgICBtYWluQXhpczogITAsXG4gICAgICAgIGNyb3NzQXhpczogITEsXG4gICAgICAgIGxpbWl0ZXI6IHggPT09IFwicGFydGlhbFwiID8galMoKSA6IHZvaWQgMCxcbiAgICAgICAgLi4uRFxuICAgICAgfSksXG4gICAgICB2ICYmIGtTKHtcbiAgICAgICAgLi4uRFxuICAgICAgfSksXG4gICAgICBEUyh7XG4gICAgICAgIC4uLkQsXG4gICAgICAgIGFwcGx5OiAoeyBlbGVtZW50czogeGUsIHJlY3RzOiBFZSwgYXZhaWxhYmxlV2lkdGg6IFplLCBhdmFpbGFibGVIZWlnaHQ6IGR0IH0pID0+IHtcbiAgICAgICAgICBjb25zdCB7IHdpZHRoOiB6dCwgaGVpZ2h0OiBWdCB9ID0gRWUucmVmZXJlbmNlLCBydCA9IHhlLmZsb2F0aW5nLnN0eWxlO1xuICAgICAgICAgIHJ0LnNldFByb3BlcnR5KFwiLS1yYWRpeC1wb3BwZXItYXZhaWxhYmxlLXdpZHRoXCIsIGAke1plfXB4YCksIHJ0LnNldFByb3BlcnR5KFwiLS1yYWRpeC1wb3BwZXItYXZhaWxhYmxlLWhlaWdodFwiLCBgJHtkdH1weGApLCBydC5zZXRQcm9wZXJ0eShcIi0tcmFkaXgtcG9wcGVyLWFuY2hvci13aWR0aFwiLCBgJHt6dH1weGApLCBydC5zZXRQcm9wZXJ0eShcIi0tcmFkaXgtcG9wcGVyLWFuY2hvci1oZWlnaHRcIiwgYCR7VnR9cHhgKTtcbiAgICAgICAgfVxuICAgICAgfSksXG4gICAgICBBICYmIEZTKHtcbiAgICAgICAgZWxlbWVudDogQSxcbiAgICAgICAgcGFkZGluZzogaFxuICAgICAgfSksXG4gICAgICBxUyh7XG4gICAgICAgIGFycm93V2lkdGg6IE4sXG4gICAgICAgIGFycm93SGVpZ2h0OiBrXG4gICAgICB9KSxcbiAgICAgIG0gJiYgTlMoe1xuICAgICAgICBzdHJhdGVneTogXCJyZWZlcmVuY2VIaWRkZW5cIixcbiAgICAgICAgLi4uRFxuICAgICAgfSlcbiAgICBdXG4gIH0pLCBbZWUsIGllXSA9IEttKEopLCBCID0gdW4oUyk7XG4gIERyKCgpID0+IHtcbiAgICBuZSAmJiAoQiA9PSBudWxsIHx8IEIoKSk7XG4gIH0sIFtcbiAgICBuZSxcbiAgICBCXG4gIF0pO1xuICBjb25zdCBVID0gKGkgPSB0ZS5hcnJvdykgPT09IG51bGwgfHwgaSA9PT0gdm9pZCAwID8gdm9pZCAwIDogaS54LCByZSA9IChvID0gdGUuYXJyb3cpID09PSBudWxsIHx8IG8gPT09IHZvaWQgMCA/IHZvaWQgMCA6IG8ueSwgQyA9ICgoYSA9IHRlLmFycm93KSA9PT0gbnVsbCB8fCBhID09PSB2b2lkIDAgPyB2b2lkIDAgOiBhLmNlbnRlck9mZnNldCkgIT09IDAsIFtnZSwgbGVdID0gWWUoKTtcbiAgcmV0dXJuIERyKCgpID0+IHtcbiAgICBUICYmIGxlKHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKFQpLnpJbmRleCk7XG4gIH0sIFtcbiAgICBUXG4gIF0pLCAvKiBAX19QVVJFX18gKi8gWShcImRpdlwiLCB7XG4gICAgcmVmOiBHLnNldEZsb2F0aW5nLFxuICAgIFwiZGF0YS1yYWRpeC1wb3BwZXItY29udGVudC13cmFwcGVyXCI6IFwiXCIsXG4gICAgc3R5bGU6IHtcbiAgICAgIC4uLnEsXG4gICAgICB0cmFuc2Zvcm06IG5lID8gcS50cmFuc2Zvcm0gOiBcInRyYW5zbGF0ZSgwLCAtMjAwJSlcIixcbiAgICAgIC8vIGtlZXAgb2ZmIHRoZSBwYWdlIHdoZW4gbWVhc3VyaW5nXG4gICAgICBtaW5XaWR0aDogXCJtYXgtY29udGVudFwiLFxuICAgICAgekluZGV4OiBnZSxcbiAgICAgIFwiLS1yYWRpeC1wb3BwZXItdHJhbnNmb3JtLW9yaWdpblwiOiBbXG4gICAgICAgIChzID0gdGUudHJhbnNmb3JtT3JpZ2luKSA9PT0gbnVsbCB8fCBzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzLngsXG4gICAgICAgICh1ID0gdGUudHJhbnNmb3JtT3JpZ2luKSA9PT0gbnVsbCB8fCB1ID09PSB2b2lkIDAgPyB2b2lkIDAgOiB1LnlcbiAgICAgIF0uam9pbihcIiBcIilcbiAgICB9LFxuICAgIGRpcjogZS5kaXJcbiAgfSwgLyogQF9fUFVSRV9fICovIFkoV1MsIHtcbiAgICBzY29wZTogZixcbiAgICBwbGFjZWRTaWRlOiBlZSxcbiAgICBvbkFycm93Q2hhbmdlOiBqLFxuICAgIGFycm93WDogVSxcbiAgICBhcnJvd1k6IHJlLFxuICAgIHNob3VsZEhpZGVBcnJvdzogQ1xuICB9LCAvKiBAX19QVVJFX18gKi8gWShGdC5kaXYsIGNlKHtcbiAgICBcImRhdGEtc2lkZVwiOiBlZSxcbiAgICBcImRhdGEtYWxpZ25cIjogaWVcbiAgfSwgJCwge1xuICAgIHJlZjogRSxcbiAgICBzdHlsZToge1xuICAgICAgLi4uJC5zdHlsZSxcbiAgICAgIC8vIGlmIHRoZSBQb3BwZXJDb250ZW50IGhhc24ndCBiZWVuIHBsYWNlZCB5ZXQgKG5vdCBhbGwgbWVhc3VyZW1lbnRzIGRvbmUpXG4gICAgICAvLyB3ZSBwcmV2ZW50IGFuaW1hdGlvbnMgc28gdGhhdCB1c2VycydzIGFuaW1hdGlvbiBkb24ndCBraWNrIGluIHRvbyBlYXJseSByZWZlcnJpbmcgd3Jvbmcgc2lkZXNcbiAgICAgIGFuaW1hdGlvbjogbmUgPyB2b2lkIDAgOiBcIm5vbmVcIixcbiAgICAgIC8vIGhpZGUgdGhlIGNvbnRlbnQgaWYgdXNpbmcgdGhlIGhpZGUgbWlkZGxld2FyZSBhbmQgc2hvdWxkIGJlIGhpZGRlblxuICAgICAgb3BhY2l0eTogKGMgPSB0ZS5oaWRlKSAhPT0gbnVsbCAmJiBjICE9PSB2b2lkIDAgJiYgYy5yZWZlcmVuY2VIaWRkZW4gPyAwIDogdm9pZCAwXG4gICAgfVxuICB9KSkpKTtcbn0pO1xuZnVuY3Rpb24gSFMoZSkge1xuICByZXR1cm4gZSAhPT0gbnVsbDtcbn1cbmNvbnN0IHFTID0gKGUpID0+ICh7XG4gIG5hbWU6IFwidHJhbnNmb3JtT3JpZ2luXCIsXG4gIG9wdGlvbnM6IGUsXG4gIGZuKHQpIHtcbiAgICB2YXIgbiwgciwgaSwgbywgYTtcbiAgICBjb25zdCB7IHBsYWNlbWVudDogcywgcmVjdHM6IHUsIG1pZGRsZXdhcmVEYXRhOiBjIH0gPSB0LCBsID0gKChuID0gYy5hcnJvdykgPT09IG51bGwgfHwgbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogbi5jZW50ZXJPZmZzZXQpICE9PSAwLCBkID0gbCA/IDAgOiBlLmFycm93V2lkdGgsIHAgPSBsID8gMCA6IGUuYXJyb3dIZWlnaHQsIFtnLCBoXSA9IEttKHMpLCB2ID0ge1xuICAgICAgc3RhcnQ6IFwiMCVcIixcbiAgICAgIGNlbnRlcjogXCI1MCVcIixcbiAgICAgIGVuZDogXCIxMDAlXCJcbiAgICB9W2hdLCB3ID0gKChyID0gKGkgPSBjLmFycm93KSA9PT0gbnVsbCB8fCBpID09PSB2b2lkIDAgPyB2b2lkIDAgOiBpLngpICE9PSBudWxsICYmIHIgIT09IHZvaWQgMCA/IHIgOiAwKSArIGQgLyAyLCBiID0gKChvID0gKGEgPSBjLmFycm93KSA9PT0gbnVsbCB8fCBhID09PSB2b2lkIDAgPyB2b2lkIDAgOiBhLnkpICE9PSBudWxsICYmIG8gIT09IHZvaWQgMCA/IG8gOiAwKSArIHAgLyAyO1xuICAgIGxldCB4ID0gXCJcIiwgbSA9IFwiXCI7XG4gICAgcmV0dXJuIGcgPT09IFwiYm90dG9tXCIgPyAoeCA9IGwgPyB2IDogYCR7d31weGAsIG0gPSBgJHstcH1weGApIDogZyA9PT0gXCJ0b3BcIiA/ICh4ID0gbCA/IHYgOiBgJHt3fXB4YCwgbSA9IGAke3UuZmxvYXRpbmcuaGVpZ2h0ICsgcH1weGApIDogZyA9PT0gXCJyaWdodFwiID8gKHggPSBgJHstcH1weGAsIG0gPSBsID8gdiA6IGAke2J9cHhgKSA6IGcgPT09IFwibGVmdFwiICYmICh4ID0gYCR7dS5mbG9hdGluZy53aWR0aCArIHB9cHhgLCBtID0gbCA/IHYgOiBgJHtifXB4YCksIHtcbiAgICAgIGRhdGE6IHtcbiAgICAgICAgeCxcbiAgICAgICAgeTogbVxuICAgICAgfVxuICAgIH07XG4gIH1cbn0pO1xuZnVuY3Rpb24gS20oZSkge1xuICBjb25zdCBbdCwgbiA9IFwiY2VudGVyXCJdID0gZS5zcGxpdChcIi1cIik7XG4gIHJldHVybiBbXG4gICAgdCxcbiAgICBuXG4gIF07XG59XG5jb25zdCBLUyA9IHpTLCBZUyA9IEdTLCBYUyA9IFVTLCBaUyA9IC8qIEBfX1BVUkVfXyAqLyBoZSgoZSwgdCkgPT4ge1xuICB2YXIgbjtcbiAgY29uc3QgeyBjb250YWluZXI6IHIgPSBnbG9iYWxUaGlzID09IG51bGwgfHwgKG4gPSBnbG9iYWxUaGlzLmRvY3VtZW50KSA9PT0gbnVsbCB8fCBuID09PSB2b2lkIDAgPyB2b2lkIDAgOiBuLmJvZHksIC4uLmkgfSA9IGU7XG4gIHJldHVybiByID8gLyogQF9fUFVSRV9fICovIFN4LmNyZWF0ZVBvcnRhbCgvKiBAX19QVVJFX18gKi8gWShGdC5kaXYsIGNlKHt9LCBpLCB7XG4gICAgcmVmOiB0XG4gIH0pKSwgcikgOiBudWxsO1xufSk7XG5mdW5jdGlvbiBKUyhlLCB0KSB7XG4gIHJldHVybiB3eCgobiwgcikgPT4ge1xuICAgIGNvbnN0IGkgPSB0W25dW3JdO1xuICAgIHJldHVybiBpID8/IG47XG4gIH0sIGUpO1xufVxuY29uc3QgQm8gPSAoZSkgPT4ge1xuICBjb25zdCB7IHByZXNlbnQ6IHQsIGNoaWxkcmVuOiBuIH0gPSBlLCByID0gUVModCksIGkgPSB0eXBlb2YgbiA9PSBcImZ1bmN0aW9uXCIgPyBuKHtcbiAgICBwcmVzZW50OiByLmlzUHJlc2VudFxuICB9KSA6ICR0Lm9ubHkobiksIG8gPSBfdChyLnJlZiwgaS5yZWYpO1xuICByZXR1cm4gdHlwZW9mIG4gPT0gXCJmdW5jdGlvblwiIHx8IHIuaXNQcmVzZW50ID8gLyogQF9fUFVSRV9fICovIEdlKGksIHtcbiAgICByZWY6IG9cbiAgfSkgOiBudWxsO1xufTtcbkJvLmRpc3BsYXlOYW1lID0gXCJQcmVzZW5jZVwiO1xuZnVuY3Rpb24gUVMoZSkge1xuICBjb25zdCBbdCwgbl0gPSBZZSgpLCByID0gX2Uoe30pLCBpID0gX2UoZSksIG8gPSBfZShcIm5vbmVcIiksIGEgPSBlID8gXCJtb3VudGVkXCIgOiBcInVubW91bnRlZFwiLCBbcywgdV0gPSBKUyhhLCB7XG4gICAgbW91bnRlZDoge1xuICAgICAgVU5NT1VOVDogXCJ1bm1vdW50ZWRcIixcbiAgICAgIEFOSU1BVElPTl9PVVQ6IFwidW5tb3VudFN1c3BlbmRlZFwiXG4gICAgfSxcbiAgICB1bm1vdW50U3VzcGVuZGVkOiB7XG4gICAgICBNT1VOVDogXCJtb3VudGVkXCIsXG4gICAgICBBTklNQVRJT05fRU5EOiBcInVubW91bnRlZFwiXG4gICAgfSxcbiAgICB1bm1vdW50ZWQ6IHtcbiAgICAgIE1PVU5UOiBcIm1vdW50ZWRcIlxuICAgIH1cbiAgfSk7XG4gIHJldHVybiBGZSgoKSA9PiB7XG4gICAgY29uc3QgYyA9IGlhKHIuY3VycmVudCk7XG4gICAgby5jdXJyZW50ID0gcyA9PT0gXCJtb3VudGVkXCIgPyBjIDogXCJub25lXCI7XG4gIH0sIFtcbiAgICBzXG4gIF0pLCBEcigoKSA9PiB7XG4gICAgY29uc3QgYyA9IHIuY3VycmVudCwgZiA9IGkuY3VycmVudDtcbiAgICBpZiAoZiAhPT0gZSkge1xuICAgICAgY29uc3QgZCA9IG8uY3VycmVudCwgcCA9IGlhKGMpO1xuICAgICAgZSA/IHUoXCJNT1VOVFwiKSA6IHAgPT09IFwibm9uZVwiIHx8IChjID09IG51bGwgPyB2b2lkIDAgOiBjLmRpc3BsYXkpID09PSBcIm5vbmVcIiA/IHUoXCJVTk1PVU5UXCIpIDogdShmICYmIGQgIT09IHAgPyBcIkFOSU1BVElPTl9PVVRcIiA6IFwiVU5NT1VOVFwiKSwgaS5jdXJyZW50ID0gZTtcbiAgICB9XG4gIH0sIFtcbiAgICBlLFxuICAgIHVcbiAgXSksIERyKCgpID0+IHtcbiAgICBpZiAodCkge1xuICAgICAgY29uc3QgYyA9IChsKSA9PiB7XG4gICAgICAgIGNvbnN0IHAgPSBpYShyLmN1cnJlbnQpLmluY2x1ZGVzKGwuYW5pbWF0aW9uTmFtZSk7XG4gICAgICAgIGwudGFyZ2V0ID09PSB0ICYmIHAgJiYgZm0oXG4gICAgICAgICAgKCkgPT4gdShcIkFOSU1BVElPTl9FTkRcIilcbiAgICAgICAgKTtcbiAgICAgIH0sIGYgPSAobCkgPT4ge1xuICAgICAgICBsLnRhcmdldCA9PT0gdCAmJiAoby5jdXJyZW50ID0gaWEoci5jdXJyZW50KSk7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIHQuYWRkRXZlbnRMaXN0ZW5lcihcImFuaW1hdGlvbnN0YXJ0XCIsIGYpLCB0LmFkZEV2ZW50TGlzdGVuZXIoXCJhbmltYXRpb25jYW5jZWxcIiwgYyksIHQuYWRkRXZlbnRMaXN0ZW5lcihcImFuaW1hdGlvbmVuZFwiLCBjKSwgKCkgPT4ge1xuICAgICAgICB0LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJhbmltYXRpb25zdGFydFwiLCBmKSwgdC5yZW1vdmVFdmVudExpc3RlbmVyKFwiYW5pbWF0aW9uY2FuY2VsXCIsIGMpLCB0LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJhbmltYXRpb25lbmRcIiwgYyk7XG4gICAgICB9O1xuICAgIH0gZWxzZVxuICAgICAgdShcIkFOSU1BVElPTl9FTkRcIik7XG4gIH0sIFtcbiAgICB0LFxuICAgIHVcbiAgXSksIHtcbiAgICBpc1ByZXNlbnQ6IFtcbiAgICAgIFwibW91bnRlZFwiLFxuICAgICAgXCJ1bm1vdW50U3VzcGVuZGVkXCJcbiAgICBdLmluY2x1ZGVzKHMpLFxuICAgIHJlZjogdXQoKGMpID0+IHtcbiAgICAgIGMgJiYgKHIuY3VycmVudCA9IGdldENvbXB1dGVkU3R5bGUoYykpLCBuKGMpO1xuICAgIH0sIFtdKVxuICB9O1xufVxuZnVuY3Rpb24gaWEoZSkge1xuICByZXR1cm4gKGUgPT0gbnVsbCA/IHZvaWQgMCA6IGUuYW5pbWF0aW9uTmFtZSkgfHwgXCJub25lXCI7XG59XG5jb25zdCB3dSA9IFwicm92aW5nRm9jdXNHcm91cC5vbkVudHJ5Rm9jdXNcIiwgZSQgPSB7XG4gIGJ1YmJsZXM6ICExLFxuICBjYW5jZWxhYmxlOiAhMFxufSwgY2YgPSBcIlJvdmluZ0ZvY3VzR3JvdXBcIiwgW3hjLCBZbSwgdCRdID0gVG0oY2YpLCBbbiQsIFhtXSA9IEZvKGNmLCBbXG4gIHQkXG5dKSwgW3IkLCBpJF0gPSBuJChjZiksIG8kID0gLyogQF9fUFVSRV9fICovIGhlKChlLCB0KSA9PiAvKiBAX19QVVJFX18gKi8gWSh4Yy5Qcm92aWRlciwge1xuICBzY29wZTogZS5fX3Njb3BlUm92aW5nRm9jdXNHcm91cFxufSwgLyogQF9fUFVSRV9fICovIFkoeGMuU2xvdCwge1xuICBzY29wZTogZS5fX3Njb3BlUm92aW5nRm9jdXNHcm91cFxufSwgLyogQF9fUFVSRV9fICovIFkoYSQsIGNlKHt9LCBlLCB7XG4gIHJlZjogdFxufSkpKSkpLCBhJCA9IC8qIEBfX1BVUkVfXyAqLyBoZSgoZSwgdCkgPT4ge1xuICBjb25zdCB7IF9fc2NvcGVSb3ZpbmdGb2N1c0dyb3VwOiBuLCBvcmllbnRhdGlvbjogciwgbG9vcDogaSA9ICExLCBkaXI6IG8sIGN1cnJlbnRUYWJTdG9wSWQ6IGEsIGRlZmF1bHRDdXJyZW50VGFiU3RvcElkOiBzLCBvbkN1cnJlbnRUYWJTdG9wSWRDaGFuZ2U6IHUsIG9uRW50cnlGb2N1czogYywgLi4uZiB9ID0gZSwgbCA9IF9lKG51bGwpLCBkID0gX3QodCwgbCksIHAgPSBNbShvKSwgW2cgPSBudWxsLCBoXSA9IENtKHtcbiAgICBwcm9wOiBhLFxuICAgIGRlZmF1bHRQcm9wOiBzLFxuICAgIG9uQ2hhbmdlOiB1XG4gIH0pLCBbdiwgd10gPSBZZSghMSksIGIgPSB1bihjKSwgeCA9IFltKG4pLCBtID0gX2UoITEpLCBbeSwgU10gPSBZZSgwKTtcbiAgcmV0dXJuIEZlKCgpID0+IHtcbiAgICBjb25zdCAkID0gbC5jdXJyZW50O1xuICAgIGlmICgkKVxuICAgICAgcmV0dXJuICQuYWRkRXZlbnRMaXN0ZW5lcih3dSwgYiksICgpID0+ICQucmVtb3ZlRXZlbnRMaXN0ZW5lcih3dSwgYik7XG4gIH0sIFtcbiAgICBiXG4gIF0pLCAvKiBAX19QVVJFX18gKi8gWShyJCwge1xuICAgIHNjb3BlOiBuLFxuICAgIG9yaWVudGF0aW9uOiByLFxuICAgIGRpcjogcCxcbiAgICBsb29wOiBpLFxuICAgIGN1cnJlbnRUYWJTdG9wSWQ6IGcsXG4gICAgb25JdGVtRm9jdXM6IHV0KFxuICAgICAgKCQpID0+IGgoJCksXG4gICAgICBbXG4gICAgICAgIGhcbiAgICAgIF1cbiAgICApLFxuICAgIG9uSXRlbVNoaWZ0VGFiOiB1dChcbiAgICAgICgpID0+IHcoITApLFxuICAgICAgW11cbiAgICApLFxuICAgIG9uRm9jdXNhYmxlSXRlbUFkZDogdXQoXG4gICAgICAoKSA9PiBTKFxuICAgICAgICAoJCkgPT4gJCArIDFcbiAgICAgICksXG4gICAgICBbXVxuICAgICksXG4gICAgb25Gb2N1c2FibGVJdGVtUmVtb3ZlOiB1dChcbiAgICAgICgpID0+IFMoXG4gICAgICAgICgkKSA9PiAkIC0gMVxuICAgICAgKSxcbiAgICAgIFtdXG4gICAgKVxuICB9LCAvKiBAX19QVVJFX18gKi8gWShGdC5kaXYsIGNlKHtcbiAgICB0YWJJbmRleDogdiB8fCB5ID09PSAwID8gLTEgOiAwLFxuICAgIFwiZGF0YS1vcmllbnRhdGlvblwiOiByXG4gIH0sIGYsIHtcbiAgICByZWY6IGQsXG4gICAgc3R5bGU6IHtcbiAgICAgIG91dGxpbmU6IFwibm9uZVwiLFxuICAgICAgLi4uZS5zdHlsZVxuICAgIH0sXG4gICAgb25Nb3VzZURvd246IHdlKGUub25Nb3VzZURvd24sICgpID0+IHtcbiAgICAgIG0uY3VycmVudCA9ICEwO1xuICAgIH0pLFxuICAgIG9uRm9jdXM6IHdlKGUub25Gb2N1cywgKCQpID0+IHtcbiAgICAgIGNvbnN0IE8gPSAhbS5jdXJyZW50O1xuICAgICAgaWYgKCQudGFyZ2V0ID09PSAkLmN1cnJlbnRUYXJnZXQgJiYgTyAmJiAhdikge1xuICAgICAgICBjb25zdCBUID0gbmV3IEN1c3RvbUV2ZW50KHd1LCBlJCk7XG4gICAgICAgIGlmICgkLmN1cnJlbnRUYXJnZXQuZGlzcGF0Y2hFdmVudChUKSwgIVQuZGVmYXVsdFByZXZlbnRlZCkge1xuICAgICAgICAgIGNvbnN0IE0gPSB4KCkuZmlsdGVyKFxuICAgICAgICAgICAgKE4pID0+IE4uZm9jdXNhYmxlXG4gICAgICAgICAgKSwgRSA9IE0uZmluZChcbiAgICAgICAgICAgIChOKSA9PiBOLmFjdGl2ZVxuICAgICAgICAgICksIEEgPSBNLmZpbmQoXG4gICAgICAgICAgICAoTikgPT4gTi5pZCA9PT0gZ1xuICAgICAgICAgICksIFIgPSBbXG4gICAgICAgICAgICBFLFxuICAgICAgICAgICAgQSxcbiAgICAgICAgICAgIC4uLk1cbiAgICAgICAgICBdLmZpbHRlcihCb29sZWFuKS5tYXAoXG4gICAgICAgICAgICAoTikgPT4gTi5yZWYuY3VycmVudFxuICAgICAgICAgICk7XG4gICAgICAgICAgWm0oUik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIG0uY3VycmVudCA9ICExO1xuICAgIH0pLFxuICAgIG9uQmx1cjogd2UoXG4gICAgICBlLm9uQmx1cixcbiAgICAgICgpID0+IHcoITEpXG4gICAgKVxuICB9KSkpO1xufSksIHMkID0gXCJSb3ZpbmdGb2N1c0dyb3VwSXRlbVwiLCB1JCA9IC8qIEBfX1BVUkVfXyAqLyBoZSgoZSwgdCkgPT4ge1xuICBjb25zdCB7IF9fc2NvcGVSb3ZpbmdGb2N1c0dyb3VwOiBuLCBmb2N1c2FibGU6IHIgPSAhMCwgYWN0aXZlOiBpID0gITEsIHRhYlN0b3BJZDogbywgLi4uYSB9ID0gZSwgcyA9IHljKCksIHUgPSBvIHx8IHMsIGMgPSBpJChzJCwgbiksIGYgPSBjLmN1cnJlbnRUYWJTdG9wSWQgPT09IHUsIGwgPSBZbShuKSwgeyBvbkZvY3VzYWJsZUl0ZW1BZGQ6IGQsIG9uRm9jdXNhYmxlSXRlbVJlbW92ZTogcCB9ID0gYztcbiAgcmV0dXJuIEZlKCgpID0+IHtcbiAgICBpZiAocilcbiAgICAgIHJldHVybiBkKCksICgpID0+IHAoKTtcbiAgfSwgW1xuICAgIHIsXG4gICAgZCxcbiAgICBwXG4gIF0pLCAvKiBAX19QVVJFX18gKi8gWSh4Yy5JdGVtU2xvdCwge1xuICAgIHNjb3BlOiBuLFxuICAgIGlkOiB1LFxuICAgIGZvY3VzYWJsZTogcixcbiAgICBhY3RpdmU6IGlcbiAgfSwgLyogQF9fUFVSRV9fICovIFkoRnQuc3BhbiwgY2Uoe1xuICAgIHRhYkluZGV4OiBmID8gMCA6IC0xLFxuICAgIFwiZGF0YS1vcmllbnRhdGlvblwiOiBjLm9yaWVudGF0aW9uXG4gIH0sIGEsIHtcbiAgICByZWY6IHQsXG4gICAgb25Nb3VzZURvd246IHdlKGUub25Nb3VzZURvd24sIChnKSA9PiB7XG4gICAgICByID8gYy5vbkl0ZW1Gb2N1cyh1KSA6IGcucHJldmVudERlZmF1bHQoKTtcbiAgICB9KSxcbiAgICBvbkZvY3VzOiB3ZShcbiAgICAgIGUub25Gb2N1cyxcbiAgICAgICgpID0+IGMub25JdGVtRm9jdXModSlcbiAgICApLFxuICAgIG9uS2V5RG93bjogd2UoZS5vbktleURvd24sIChnKSA9PiB7XG4gICAgICBpZiAoZy5rZXkgPT09IFwiVGFiXCIgJiYgZy5zaGlmdEtleSkge1xuICAgICAgICBjLm9uSXRlbVNoaWZ0VGFiKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChnLnRhcmdldCAhPT0gZy5jdXJyZW50VGFyZ2V0KVxuICAgICAgICByZXR1cm47XG4gICAgICBjb25zdCBoID0gZiQoZywgYy5vcmllbnRhdGlvbiwgYy5kaXIpO1xuICAgICAgaWYgKGggIT09IHZvaWQgMCkge1xuICAgICAgICBnLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGxldCB3ID0gbCgpLmZpbHRlcihcbiAgICAgICAgICAoYikgPT4gYi5mb2N1c2FibGVcbiAgICAgICAgKS5tYXAoXG4gICAgICAgICAgKGIpID0+IGIucmVmLmN1cnJlbnRcbiAgICAgICAgKTtcbiAgICAgICAgaWYgKGggPT09IFwibGFzdFwiKVxuICAgICAgICAgIHcucmV2ZXJzZSgpO1xuICAgICAgICBlbHNlIGlmIChoID09PSBcInByZXZcIiB8fCBoID09PSBcIm5leHRcIikge1xuICAgICAgICAgIGggPT09IFwicHJldlwiICYmIHcucmV2ZXJzZSgpO1xuICAgICAgICAgIGNvbnN0IGIgPSB3LmluZGV4T2YoZy5jdXJyZW50VGFyZ2V0KTtcbiAgICAgICAgICB3ID0gYy5sb29wID8gZCQodywgYiArIDEpIDogdy5zbGljZShiICsgMSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VGltZW91dChcbiAgICAgICAgICAoKSA9PiBabSh3KVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH0pXG4gIH0pKSk7XG59KSwgYyQgPSB7XG4gIEFycm93TGVmdDogXCJwcmV2XCIsXG4gIEFycm93VXA6IFwicHJldlwiLFxuICBBcnJvd1JpZ2h0OiBcIm5leHRcIixcbiAgQXJyb3dEb3duOiBcIm5leHRcIixcbiAgUGFnZVVwOiBcImZpcnN0XCIsXG4gIEhvbWU6IFwiZmlyc3RcIixcbiAgUGFnZURvd246IFwibGFzdFwiLFxuICBFbmQ6IFwibGFzdFwiXG59O1xuZnVuY3Rpb24gbCQoZSwgdCkge1xuICByZXR1cm4gdCAhPT0gXCJydGxcIiA/IGUgOiBlID09PSBcIkFycm93TGVmdFwiID8gXCJBcnJvd1JpZ2h0XCIgOiBlID09PSBcIkFycm93UmlnaHRcIiA/IFwiQXJyb3dMZWZ0XCIgOiBlO1xufVxuZnVuY3Rpb24gZiQoZSwgdCwgbikge1xuICBjb25zdCByID0gbCQoZS5rZXksIG4pO1xuICBpZiAoISh0ID09PSBcInZlcnRpY2FsXCIgJiYgW1xuICAgIFwiQXJyb3dMZWZ0XCIsXG4gICAgXCJBcnJvd1JpZ2h0XCJcbiAgXS5pbmNsdWRlcyhyKSkgJiYgISh0ID09PSBcImhvcml6b250YWxcIiAmJiBbXG4gICAgXCJBcnJvd1VwXCIsXG4gICAgXCJBcnJvd0Rvd25cIlxuICBdLmluY2x1ZGVzKHIpKSlcbiAgICByZXR1cm4gYyRbcl07XG59XG5mdW5jdGlvbiBabShlKSB7XG4gIGNvbnN0IHQgPSBkb2N1bWVudC5hY3RpdmVFbGVtZW50O1xuICBmb3IgKGNvbnN0IG4gb2YgZSlcbiAgICBpZiAobiA9PT0gdCB8fCAobi5mb2N1cygpLCBkb2N1bWVudC5hY3RpdmVFbGVtZW50ICE9PSB0KSlcbiAgICAgIHJldHVybjtcbn1cbmZ1bmN0aW9uIGQkKGUsIHQpIHtcbiAgcmV0dXJuIGUubWFwKFxuICAgIChuLCByKSA9PiBlWyh0ICsgcikgJSBlLmxlbmd0aF1cbiAgKTtcbn1cbmNvbnN0IHAkID0gbyQsIGgkID0gdSQ7XG52YXIgZyQgPSBmdW5jdGlvbihlKSB7XG4gIGlmICh0eXBlb2YgZG9jdW1lbnQgPiBcInVcIilcbiAgICByZXR1cm4gbnVsbDtcbiAgdmFyIHQgPSBBcnJheS5pc0FycmF5KGUpID8gZVswXSA6IGU7XG4gIHJldHVybiB0Lm93bmVyRG9jdW1lbnQuYm9keTtcbn0sIHhyID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCksIG9hID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCksIGFhID0ge30sIHh1ID0gMCwgSm0gPSBmdW5jdGlvbihlKSB7XG4gIHJldHVybiBlICYmIChlLmhvc3QgfHwgSm0oZS5wYXJlbnROb2RlKSk7XG59LCB2JCA9IGZ1bmN0aW9uKGUsIHQpIHtcbiAgcmV0dXJuIHQubWFwKGZ1bmN0aW9uKG4pIHtcbiAgICBpZiAoZS5jb250YWlucyhuKSlcbiAgICAgIHJldHVybiBuO1xuICAgIHZhciByID0gSm0obik7XG4gICAgcmV0dXJuIHIgJiYgZS5jb250YWlucyhyKSA/IHIgOiAoY29uc29sZS5lcnJvcihcImFyaWEtaGlkZGVuXCIsIG4sIFwiaW4gbm90IGNvbnRhaW5lZCBpbnNpZGVcIiwgZSwgXCIuIERvaW5nIG5vdGhpbmdcIiksIG51bGwpO1xuICB9KS5maWx0ZXIoZnVuY3Rpb24obikge1xuICAgIHJldHVybiAhIW47XG4gIH0pO1xufSwgbSQgPSBmdW5jdGlvbihlLCB0LCBuLCByKSB7XG4gIHZhciBpID0gdiQodCwgQXJyYXkuaXNBcnJheShlKSA/IGUgOiBbZV0pO1xuICBhYVtuXSB8fCAoYWFbbl0gPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKSk7XG4gIHZhciBvID0gYWFbbl0sIGEgPSBbXSwgcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCksIHUgPSBuZXcgU2V0KGkpLCBjID0gZnVuY3Rpb24obCkge1xuICAgICFsIHx8IHMuaGFzKGwpIHx8IChzLmFkZChsKSwgYyhsLnBhcmVudE5vZGUpKTtcbiAgfTtcbiAgaS5mb3JFYWNoKGMpO1xuICB2YXIgZiA9IGZ1bmN0aW9uKGwpIHtcbiAgICAhbCB8fCB1LmhhcyhsKSB8fCBBcnJheS5wcm90b3R5cGUuZm9yRWFjaC5jYWxsKGwuY2hpbGRyZW4sIGZ1bmN0aW9uKGQpIHtcbiAgICAgIGlmIChzLmhhcyhkKSlcbiAgICAgICAgZihkKTtcbiAgICAgIGVsc2VcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB2YXIgcCA9IGQuZ2V0QXR0cmlidXRlKHIpLCBnID0gcCAhPT0gbnVsbCAmJiBwICE9PSBcImZhbHNlXCIsIGggPSAoeHIuZ2V0KGQpIHx8IDApICsgMSwgdiA9IChvLmdldChkKSB8fCAwKSArIDE7XG4gICAgICAgICAgeHIuc2V0KGQsIGgpLCBvLnNldChkLCB2KSwgYS5wdXNoKGQpLCBoID09PSAxICYmIGcgJiYgb2Euc2V0KGQsICEwKSwgdiA9PT0gMSAmJiBkLnNldEF0dHJpYnV0ZShuLCBcInRydWVcIiksIGcgfHwgZC5zZXRBdHRyaWJ1dGUociwgXCJ0cnVlXCIpO1xuICAgICAgICB9IGNhdGNoICh3KSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihcImFyaWEtaGlkZGVuOiBjYW5ub3Qgb3BlcmF0ZSBvbiBcIiwgZCwgdyk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgfTtcbiAgcmV0dXJuIGYodCksIHMuY2xlYXIoKSwgeHUrKywgZnVuY3Rpb24oKSB7XG4gICAgYS5mb3JFYWNoKGZ1bmN0aW9uKGwpIHtcbiAgICAgIHZhciBkID0geHIuZ2V0KGwpIC0gMSwgcCA9IG8uZ2V0KGwpIC0gMTtcbiAgICAgIHhyLnNldChsLCBkKSwgby5zZXQobCwgcCksIGQgfHwgKG9hLmhhcyhsKSB8fCBsLnJlbW92ZUF0dHJpYnV0ZShyKSwgb2EuZGVsZXRlKGwpKSwgcCB8fCBsLnJlbW92ZUF0dHJpYnV0ZShuKTtcbiAgICB9KSwgeHUtLSwgeHUgfHwgKHhyID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCksIHhyID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCksIG9hID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCksIGFhID0ge30pO1xuICB9O1xufSwgeSQgPSBmdW5jdGlvbihlLCB0LCBuKSB7XG4gIG4gPT09IHZvaWQgMCAmJiAobiA9IFwiZGF0YS1hcmlhLWhpZGRlblwiKTtcbiAgdmFyIHIgPSBBcnJheS5mcm9tKEFycmF5LmlzQXJyYXkoZSkgPyBlIDogW2VdKSwgaSA9IGckKGUpO1xuICByZXR1cm4gaSA/IChyLnB1c2guYXBwbHkociwgQXJyYXkuZnJvbShpLnF1ZXJ5U2VsZWN0b3JBbGwoXCJbYXJpYS1saXZlXVwiKSkpLCBtJChyLCBpLCBuLCBcImFyaWEtaGlkZGVuXCIpKSA6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBudWxsO1xuICB9O1xufSwgbm4gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIG5uID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbih0KSB7XG4gICAgZm9yICh2YXIgbiwgciA9IDEsIGkgPSBhcmd1bWVudHMubGVuZ3RoOyByIDwgaTsgcisrKSB7XG4gICAgICBuID0gYXJndW1lbnRzW3JdO1xuICAgICAgZm9yICh2YXIgbyBpbiBuKVxuICAgICAgICBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobiwgbykgJiYgKHRbb10gPSBuW29dKTtcbiAgICB9XG4gICAgcmV0dXJuIHQ7XG4gIH0sIG5uLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59O1xuZnVuY3Rpb24gUW0oZSwgdCkge1xuICB2YXIgbiA9IHt9O1xuICBmb3IgKHZhciByIGluIGUpXG4gICAgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGUsIHIpICYmIHQuaW5kZXhPZihyKSA8IDAgJiYgKG5bcl0gPSBlW3JdKTtcbiAgaWYgKGUgIT0gbnVsbCAmJiB0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyA9PSBcImZ1bmN0aW9uXCIpXG4gICAgZm9yICh2YXIgaSA9IDAsIHIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGUpOyBpIDwgci5sZW5ndGg7IGkrKylcbiAgICAgIHQuaW5kZXhPZihyW2ldKSA8IDAgJiYgT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKGUsIHJbaV0pICYmIChuW3JbaV1dID0gZVtyW2ldXSk7XG4gIHJldHVybiBuO1xufVxuZnVuY3Rpb24gYiQoZSwgdCwgbikge1xuICBpZiAobiB8fCBhcmd1bWVudHMubGVuZ3RoID09PSAyKVxuICAgIGZvciAodmFyIHIgPSAwLCBpID0gdC5sZW5ndGgsIG87IHIgPCBpOyByKyspXG4gICAgICAobyB8fCAhKHIgaW4gdCkpICYmIChvIHx8IChvID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwodCwgMCwgcikpLCBvW3JdID0gdFtyXSk7XG4gIHJldHVybiBlLmNvbmNhdChvIHx8IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHQpKTtcbn1cbnZhciBQYSA9IFwicmlnaHQtc2Nyb2xsLWJhci1wb3NpdGlvblwiLCBDYSA9IFwid2lkdGgtYmVmb3JlLXNjcm9sbC1iYXJcIiwgdyQgPSBcIndpdGgtc2Nyb2xsLWJhcnMtaGlkZGVuXCIsIHgkID0gXCItLXJlbW92ZWQtYm9keS1zY3JvbGwtYmFyLXNpemVcIjtcbmZ1bmN0aW9uIFN1KGUsIHQpIHtcbiAgcmV0dXJuIHR5cGVvZiBlID09IFwiZnVuY3Rpb25cIiA/IGUodCkgOiBlICYmIChlLmN1cnJlbnQgPSB0KSwgZTtcbn1cbmZ1bmN0aW9uIFMkKGUsIHQpIHtcbiAgdmFyIG4gPSBZZShmdW5jdGlvbigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgLy8gdmFsdWVcbiAgICAgIHZhbHVlOiBlLFxuICAgICAgLy8gbGFzdCBjYWxsYmFja1xuICAgICAgY2FsbGJhY2s6IHQsXG4gICAgICAvLyBcIm1lbW9pemVkXCIgcHVibGljIGludGVyZmFjZVxuICAgICAgZmFjYWRlOiB7XG4gICAgICAgIGdldCBjdXJyZW50KCkge1xuICAgICAgICAgIHJldHVybiBuLnZhbHVlO1xuICAgICAgICB9LFxuICAgICAgICBzZXQgY3VycmVudChyKSB7XG4gICAgICAgICAgdmFyIGkgPSBuLnZhbHVlO1xuICAgICAgICAgIGkgIT09IHIgJiYgKG4udmFsdWUgPSByLCBuLmNhbGxiYWNrKHIsIGkpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gIH0pWzBdO1xuICByZXR1cm4gbi5jYWxsYmFjayA9IHQsIG4uZmFjYWRlO1xufVxudmFyICQkID0gdHlwZW9mIHdpbmRvdyA8IFwidVwiID8gSC51c2VMYXlvdXRFZmZlY3QgOiBILnVzZUVmZmVjdCwgcnAgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKTtcbmZ1bmN0aW9uIE8kKGUsIHQpIHtcbiAgdmFyIG4gPSBTJChudWxsLCBmdW5jdGlvbihyKSB7XG4gICAgcmV0dXJuIGUuZm9yRWFjaChmdW5jdGlvbihpKSB7XG4gICAgICByZXR1cm4gU3UoaSwgcik7XG4gICAgfSk7XG4gIH0pO1xuICByZXR1cm4gJCQoZnVuY3Rpb24oKSB7XG4gICAgdmFyIHIgPSBycC5nZXQobik7XG4gICAgaWYgKHIpIHtcbiAgICAgIHZhciBpID0gbmV3IFNldChyKSwgbyA9IG5ldyBTZXQoZSksIGEgPSBuLmN1cnJlbnQ7XG4gICAgICBpLmZvckVhY2goZnVuY3Rpb24ocykge1xuICAgICAgICBvLmhhcyhzKSB8fCBTdShzLCBudWxsKTtcbiAgICAgIH0pLCBvLmZvckVhY2goZnVuY3Rpb24ocykge1xuICAgICAgICBpLmhhcyhzKSB8fCBTdShzLCBhKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBycC5zZXQobiwgZSk7XG4gIH0sIFtlXSksIG47XG59XG5mdW5jdGlvbiBfJChlKSB7XG4gIHJldHVybiBlO1xufVxuZnVuY3Rpb24gQSQoZSwgdCkge1xuICB0ID09PSB2b2lkIDAgJiYgKHQgPSBfJCk7XG4gIHZhciBuID0gW10sIHIgPSAhMSwgaSA9IHtcbiAgICByZWFkOiBmdW5jdGlvbigpIHtcbiAgICAgIGlmIChyKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTaWRlY2FyOiBjb3VsZCBub3QgYHJlYWRgIGZyb20gYW4gYGFzc2lnbmVkYCBtZWRpdW0uIGByZWFkYCBjb3VsZCBiZSB1c2VkIG9ubHkgd2l0aCBgdXNlTWVkaXVtYC5cIik7XG4gICAgICByZXR1cm4gbi5sZW5ndGggPyBuW24ubGVuZ3RoIC0gMV0gOiBlO1xuICAgIH0sXG4gICAgdXNlTWVkaXVtOiBmdW5jdGlvbihvKSB7XG4gICAgICB2YXIgYSA9IHQobywgcik7XG4gICAgICByZXR1cm4gbi5wdXNoKGEpLCBmdW5jdGlvbigpIHtcbiAgICAgICAgbiA9IG4uZmlsdGVyKGZ1bmN0aW9uKHMpIHtcbiAgICAgICAgICByZXR1cm4gcyAhPT0gYTtcbiAgICAgICAgfSk7XG4gICAgICB9O1xuICAgIH0sXG4gICAgYXNzaWduU3luY01lZGl1bTogZnVuY3Rpb24obykge1xuICAgICAgZm9yIChyID0gITA7IG4ubGVuZ3RoOyApIHtcbiAgICAgICAgdmFyIGEgPSBuO1xuICAgICAgICBuID0gW10sIGEuZm9yRWFjaChvKTtcbiAgICAgIH1cbiAgICAgIG4gPSB7XG4gICAgICAgIHB1c2g6IGZ1bmN0aW9uKHMpIHtcbiAgICAgICAgICByZXR1cm4gbyhzKTtcbiAgICAgICAgfSxcbiAgICAgICAgZmlsdGVyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gbjtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9LFxuICAgIGFzc2lnbk1lZGl1bTogZnVuY3Rpb24obykge1xuICAgICAgciA9ICEwO1xuICAgICAgdmFyIGEgPSBbXTtcbiAgICAgIGlmIChuLmxlbmd0aCkge1xuICAgICAgICB2YXIgcyA9IG47XG4gICAgICAgIG4gPSBbXSwgcy5mb3JFYWNoKG8pLCBhID0gbjtcbiAgICAgIH1cbiAgICAgIHZhciB1ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBmID0gYTtcbiAgICAgICAgYSA9IFtdLCBmLmZvckVhY2gobyk7XG4gICAgICB9LCBjID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKS50aGVuKHUpO1xuICAgICAgfTtcbiAgICAgIGMoKSwgbiA9IHtcbiAgICAgICAgcHVzaDogZnVuY3Rpb24oZikge1xuICAgICAgICAgIGEucHVzaChmKSwgYygpO1xuICAgICAgICB9LFxuICAgICAgICBmaWx0ZXI6IGZ1bmN0aW9uKGYpIHtcbiAgICAgICAgICByZXR1cm4gYSA9IGEuZmlsdGVyKGYpLCBuO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgfTtcbiAgcmV0dXJuIGk7XG59XG5mdW5jdGlvbiBQJChlKSB7XG4gIGUgPT09IHZvaWQgMCAmJiAoZSA9IHt9KTtcbiAgdmFyIHQgPSBBJChudWxsKTtcbiAgcmV0dXJuIHQub3B0aW9ucyA9IG5uKHsgYXN5bmM6ICEwLCBzc3I6ICExIH0sIGUpLCB0O1xufVxudmFyIGV5ID0gZnVuY3Rpb24oZSkge1xuICB2YXIgdCA9IGUuc2lkZUNhciwgbiA9IFFtKGUsIFtcInNpZGVDYXJcIl0pO1xuICBpZiAoIXQpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiU2lkZWNhcjogcGxlYXNlIHByb3ZpZGUgYHNpZGVDYXJgIHByb3BlcnR5IHRvIGltcG9ydCB0aGUgcmlnaHQgY2FyXCIpO1xuICB2YXIgciA9IHQucmVhZCgpO1xuICBpZiAoIXIpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiU2lkZWNhciBtZWRpdW0gbm90IGZvdW5kXCIpO1xuICByZXR1cm4gSC5jcmVhdGVFbGVtZW50KHIsIG5uKHt9LCBuKSk7XG59O1xuZXkuaXNTaWRlQ2FyRXhwb3J0ID0gITA7XG5mdW5jdGlvbiBDJChlLCB0KSB7XG4gIHJldHVybiBlLnVzZU1lZGl1bSh0KSwgZXk7XG59XG52YXIgdHkgPSBQJCgpLCAkdSA9IGZ1bmN0aW9uKCkge1xufSwgSXMgPSBILmZvcndhcmRSZWYoZnVuY3Rpb24oZSwgdCkge1xuICB2YXIgbiA9IEgudXNlUmVmKG51bGwpLCByID0gSC51c2VTdGF0ZSh7XG4gICAgb25TY3JvbGxDYXB0dXJlOiAkdSxcbiAgICBvbldoZWVsQ2FwdHVyZTogJHUsXG4gICAgb25Ub3VjaE1vdmVDYXB0dXJlOiAkdVxuICB9KSwgaSA9IHJbMF0sIG8gPSByWzFdLCBhID0gZS5mb3J3YXJkUHJvcHMsIHMgPSBlLmNoaWxkcmVuLCB1ID0gZS5jbGFzc05hbWUsIGMgPSBlLnJlbW92ZVNjcm9sbEJhciwgZiA9IGUuZW5hYmxlZCwgbCA9IGUuc2hhcmRzLCBkID0gZS5zaWRlQ2FyLCBwID0gZS5ub0lzb2xhdGlvbiwgZyA9IGUuaW5lcnQsIGggPSBlLmFsbG93UGluY2hab29tLCB2ID0gZS5hcywgdyA9IHYgPT09IHZvaWQgMCA/IFwiZGl2XCIgOiB2LCBiID0gUW0oZSwgW1wiZm9yd2FyZFByb3BzXCIsIFwiY2hpbGRyZW5cIiwgXCJjbGFzc05hbWVcIiwgXCJyZW1vdmVTY3JvbGxCYXJcIiwgXCJlbmFibGVkXCIsIFwic2hhcmRzXCIsIFwic2lkZUNhclwiLCBcIm5vSXNvbGF0aW9uXCIsIFwiaW5lcnRcIiwgXCJhbGxvd1BpbmNoWm9vbVwiLCBcImFzXCJdKSwgeCA9IGQsIG0gPSBPJChbbiwgdF0pLCB5ID0gbm4obm4oe30sIGIpLCBpKTtcbiAgcmV0dXJuIEguY3JlYXRlRWxlbWVudChcbiAgICBILkZyYWdtZW50LFxuICAgIG51bGwsXG4gICAgZiAmJiBILmNyZWF0ZUVsZW1lbnQoeCwgeyBzaWRlQ2FyOiB0eSwgcmVtb3ZlU2Nyb2xsQmFyOiBjLCBzaGFyZHM6IGwsIG5vSXNvbGF0aW9uOiBwLCBpbmVydDogZywgc2V0Q2FsbGJhY2tzOiBvLCBhbGxvd1BpbmNoWm9vbTogISFoLCBsb2NrUmVmOiBuIH0pLFxuICAgIGEgPyBILmNsb25lRWxlbWVudChILkNoaWxkcmVuLm9ubHkocyksIG5uKG5uKHt9LCB5KSwgeyByZWY6IG0gfSkpIDogSC5jcmVhdGVFbGVtZW50KHcsIG5uKHt9LCB5LCB7IGNsYXNzTmFtZTogdSwgcmVmOiBtIH0pLCBzKVxuICApO1xufSk7XG5Jcy5kZWZhdWx0UHJvcHMgPSB7XG4gIGVuYWJsZWQ6ICEwLFxuICByZW1vdmVTY3JvbGxCYXI6ICEwLFxuICBpbmVydDogITFcbn07XG5Jcy5jbGFzc05hbWVzID0ge1xuICBmdWxsV2lkdGg6IENhLFxuICB6ZXJvUmlnaHQ6IFBhXG59O1xudmFyIEUkID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0eXBlb2YgX193ZWJwYWNrX25vbmNlX18gPCBcInVcIilcbiAgICByZXR1cm4gX193ZWJwYWNrX25vbmNlX187XG59O1xuZnVuY3Rpb24gVCQoKSB7XG4gIGlmICghZG9jdW1lbnQpXG4gICAgcmV0dXJuIG51bGw7XG4gIHZhciBlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInN0eWxlXCIpO1xuICBlLnR5cGUgPSBcInRleHQvY3NzXCI7XG4gIHZhciB0ID0gRSQoKTtcbiAgcmV0dXJuIHQgJiYgZS5zZXRBdHRyaWJ1dGUoXCJub25jZVwiLCB0KSwgZTtcbn1cbmZ1bmN0aW9uIE0kKGUsIHQpIHtcbiAgZS5zdHlsZVNoZWV0ID8gZS5zdHlsZVNoZWV0LmNzc1RleHQgPSB0IDogZS5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSh0KSk7XG59XG5mdW5jdGlvbiBSJChlKSB7XG4gIHZhciB0ID0gZG9jdW1lbnQuaGVhZCB8fCBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZShcImhlYWRcIilbMF07XG4gIHQuYXBwZW5kQ2hpbGQoZSk7XG59XG52YXIgSSQgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGUgPSAwLCB0ID0gbnVsbDtcbiAgcmV0dXJuIHtcbiAgICBhZGQ6IGZ1bmN0aW9uKG4pIHtcbiAgICAgIGUgPT0gMCAmJiAodCA9IFQkKCkpICYmIChNJCh0LCBuKSwgUiQodCkpLCBlKys7XG4gICAgfSxcbiAgICByZW1vdmU6IGZ1bmN0aW9uKCkge1xuICAgICAgZS0tLCAhZSAmJiB0ICYmICh0LnBhcmVudE5vZGUgJiYgdC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHQpLCB0ID0gbnVsbCk7XG4gICAgfVxuICB9O1xufSwgaiQgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGUgPSBJJCgpO1xuICByZXR1cm4gZnVuY3Rpb24odCwgbikge1xuICAgIEgudXNlRWZmZWN0KGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGUuYWRkKHQpLCBmdW5jdGlvbigpIHtcbiAgICAgICAgZS5yZW1vdmUoKTtcbiAgICAgIH07XG4gICAgfSwgW3QgJiYgbl0pO1xuICB9O1xufSwgbnkgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGUgPSBqJCgpLCB0ID0gZnVuY3Rpb24obikge1xuICAgIHZhciByID0gbi5zdHlsZXMsIGkgPSBuLmR5bmFtaWM7XG4gICAgcmV0dXJuIGUociwgaSksIG51bGw7XG4gIH07XG4gIHJldHVybiB0O1xufSwgayQgPSB7XG4gIGxlZnQ6IDAsXG4gIHRvcDogMCxcbiAgcmlnaHQ6IDAsXG4gIGdhcDogMFxufSwgT3UgPSBmdW5jdGlvbihlKSB7XG4gIHJldHVybiBwYXJzZUludChlIHx8IFwiXCIsIDEwKSB8fCAwO1xufSwgRCQgPSBmdW5jdGlvbihlKSB7XG4gIHZhciB0ID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZG9jdW1lbnQuYm9keSksIG4gPSB0W2UgPT09IFwicGFkZGluZ1wiID8gXCJwYWRkaW5nTGVmdFwiIDogXCJtYXJnaW5MZWZ0XCJdLCByID0gdFtlID09PSBcInBhZGRpbmdcIiA/IFwicGFkZGluZ1RvcFwiIDogXCJtYXJnaW5Ub3BcIl0sIGkgPSB0W2UgPT09IFwicGFkZGluZ1wiID8gXCJwYWRkaW5nUmlnaHRcIiA6IFwibWFyZ2luUmlnaHRcIl07XG4gIHJldHVybiBbT3UobiksIE91KHIpLCBPdShpKV07XG59LCBOJCA9IGZ1bmN0aW9uKGUpIHtcbiAgaWYgKGUgPT09IHZvaWQgMCAmJiAoZSA9IFwibWFyZ2luXCIpLCB0eXBlb2Ygd2luZG93ID4gXCJ1XCIpXG4gICAgcmV0dXJuIGskO1xuICB2YXIgdCA9IEQkKGUpLCBuID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudFdpZHRoLCByID0gd2luZG93LmlubmVyV2lkdGg7XG4gIHJldHVybiB7XG4gICAgbGVmdDogdFswXSxcbiAgICB0b3A6IHRbMV0sXG4gICAgcmlnaHQ6IHRbMl0sXG4gICAgZ2FwOiBNYXRoLm1heCgwLCByIC0gbiArIHRbMl0gLSB0WzBdKVxuICB9O1xufSwgRiQgPSBueSgpLCBNciA9IFwiZGF0YS1zY3JvbGwtbG9ja2VkXCIsIEwkID0gZnVuY3Rpb24oZSwgdCwgbiwgcikge1xuICB2YXIgaSA9IGUubGVmdCwgbyA9IGUudG9wLCBhID0gZS5yaWdodCwgcyA9IGUuZ2FwO1xuICByZXR1cm4gbiA9PT0gdm9pZCAwICYmIChuID0gXCJtYXJnaW5cIiksIGBcbiAgLmAuY29uY2F0KHckLCBgIHtcbiAgIG92ZXJmbG93OiBoaWRkZW4gYCkuY29uY2F0KHIsIGA7XG4gICBwYWRkaW5nLXJpZ2h0OiBgKS5jb25jYXQocywgXCJweCBcIikuY29uY2F0KHIsIGA7XG4gIH1cbiAgYm9keVtgKS5jb25jYXQoTXIsIGBdIHtcbiAgICBvdmVyZmxvdzogaGlkZGVuIGApLmNvbmNhdChyLCBgO1xuICAgIG92ZXJzY3JvbGwtYmVoYXZpb3I6IGNvbnRhaW47XG4gICAgYCkuY29uY2F0KFtcbiAgICB0ICYmIFwicG9zaXRpb246IHJlbGF0aXZlIFwiLmNvbmNhdChyLCBcIjtcIiksXG4gICAgbiA9PT0gXCJtYXJnaW5cIiAmJiBgXG4gICAgcGFkZGluZy1sZWZ0OiBgLmNvbmNhdChpLCBgcHg7XG4gICAgcGFkZGluZy10b3A6IGApLmNvbmNhdChvLCBgcHg7XG4gICAgcGFkZGluZy1yaWdodDogYCkuY29uY2F0KGEsIGBweDtcbiAgICBtYXJnaW4tbGVmdDowO1xuICAgIG1hcmdpbi10b3A6MDtcbiAgICBtYXJnaW4tcmlnaHQ6IGApLmNvbmNhdChzLCBcInB4IFwiKS5jb25jYXQociwgYDtcbiAgICBgKSxcbiAgICBuID09PSBcInBhZGRpbmdcIiAmJiBcInBhZGRpbmctcmlnaHQ6IFwiLmNvbmNhdChzLCBcInB4IFwiKS5jb25jYXQociwgXCI7XCIpXG4gIF0uZmlsdGVyKEJvb2xlYW4pLmpvaW4oXCJcIiksIGBcbiAgfVxuICBcbiAgLmApLmNvbmNhdChQYSwgYCB7XG4gICAgcmlnaHQ6IGApLmNvbmNhdChzLCBcInB4IFwiKS5jb25jYXQociwgYDtcbiAgfVxuICBcbiAgLmApLmNvbmNhdChDYSwgYCB7XG4gICAgbWFyZ2luLXJpZ2h0OiBgKS5jb25jYXQocywgXCJweCBcIikuY29uY2F0KHIsIGA7XG4gIH1cbiAgXG4gIC5gKS5jb25jYXQoUGEsIFwiIC5cIikuY29uY2F0KFBhLCBgIHtcbiAgICByaWdodDogMCBgKS5jb25jYXQociwgYDtcbiAgfVxuICBcbiAgLmApLmNvbmNhdChDYSwgXCIgLlwiKS5jb25jYXQoQ2EsIGAge1xuICAgIG1hcmdpbi1yaWdodDogMCBgKS5jb25jYXQociwgYDtcbiAgfVxuICBcbiAgYm9keVtgKS5jb25jYXQoTXIsIGBdIHtcbiAgICBgKS5jb25jYXQoeCQsIFwiOiBcIikuY29uY2F0KHMsIGBweDtcbiAgfVxuYCk7XG59LCBpcCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgZSA9IHBhcnNlSW50KGRvY3VtZW50LmJvZHkuZ2V0QXR0cmlidXRlKE1yKSB8fCBcIjBcIiwgMTApO1xuICByZXR1cm4gaXNGaW5pdGUoZSkgPyBlIDogMDtcbn0sIEIkID0gZnVuY3Rpb24oKSB7XG4gIEgudXNlRWZmZWN0KGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBkb2N1bWVudC5ib2R5LnNldEF0dHJpYnV0ZShNciwgKGlwKCkgKyAxKS50b1N0cmluZygpKSwgZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgZSA9IGlwKCkgLSAxO1xuICAgICAgZSA8PSAwID8gZG9jdW1lbnQuYm9keS5yZW1vdmVBdHRyaWJ1dGUoTXIpIDogZG9jdW1lbnQuYm9keS5zZXRBdHRyaWJ1dGUoTXIsIGUudG9TdHJpbmcoKSk7XG4gICAgfTtcbiAgfSwgW10pO1xufSwgeiQgPSBmdW5jdGlvbihlKSB7XG4gIHZhciB0ID0gZS5ub1JlbGF0aXZlLCBuID0gZS5ub0ltcG9ydGFudCwgciA9IGUuZ2FwTW9kZSwgaSA9IHIgPT09IHZvaWQgMCA/IFwibWFyZ2luXCIgOiByO1xuICBCJCgpO1xuICB2YXIgbyA9IEgudXNlTWVtbyhmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gTiQoaSk7XG4gIH0sIFtpXSk7XG4gIHJldHVybiBILmNyZWF0ZUVsZW1lbnQoRiQsIHsgc3R5bGVzOiBMJChvLCAhdCwgaSwgbiA/IFwiXCIgOiBcIiFpbXBvcnRhbnRcIikgfSk7XG59LCBTYyA9ICExO1xuaWYgKHR5cGVvZiB3aW5kb3cgPCBcInVcIilcbiAgdHJ5IHtcbiAgICB2YXIgc2EgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkoe30sIFwicGFzc2l2ZVwiLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gU2MgPSAhMCwgITA7XG4gICAgICB9XG4gICAgfSk7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJ0ZXN0XCIsIHNhLCBzYSksIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwidGVzdFwiLCBzYSwgc2EpO1xuICB9IGNhdGNoIHtcbiAgICBTYyA9ICExO1xuICB9XG52YXIgU3IgPSBTYyA/IHsgcGFzc2l2ZTogITEgfSA6ICExLCBWJCA9IGZ1bmN0aW9uKGUpIHtcbiAgcmV0dXJuIGUudGFnTmFtZSA9PT0gXCJURVhUQVJFQVwiO1xufSwgcnkgPSBmdW5jdGlvbihlLCB0KSB7XG4gIHZhciBuID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZSk7XG4gIHJldHVybiAoXG4gICAgLy8gbm90LW5vdC1zY3JvbGxhYmxlXG4gICAgblt0XSAhPT0gXCJoaWRkZW5cIiAmJiAvLyBjb250YWlucyBzY3JvbGwgaW5zaWRlIHNlbGZcbiAgICAhKG4ub3ZlcmZsb3dZID09PSBuLm92ZXJmbG93WCAmJiAhViQoZSkgJiYgblt0XSA9PT0gXCJ2aXNpYmxlXCIpXG4gICk7XG59LCBHJCA9IGZ1bmN0aW9uKGUpIHtcbiAgcmV0dXJuIHJ5KGUsIFwib3ZlcmZsb3dZXCIpO1xufSwgVyQgPSBmdW5jdGlvbihlKSB7XG4gIHJldHVybiByeShlLCBcIm92ZXJmbG93WFwiKTtcbn0sIG9wID0gZnVuY3Rpb24oZSwgdCkge1xuICB2YXIgbiA9IHQ7XG4gIGRvIHtcbiAgICB0eXBlb2YgU2hhZG93Um9vdCA8IFwidVwiICYmIG4gaW5zdGFuY2VvZiBTaGFkb3dSb290ICYmIChuID0gbi5ob3N0KTtcbiAgICB2YXIgciA9IGl5KGUsIG4pO1xuICAgIGlmIChyKSB7XG4gICAgICB2YXIgaSA9IG95KGUsIG4pLCBvID0gaVsxXSwgYSA9IGlbMl07XG4gICAgICBpZiAobyA+IGEpXG4gICAgICAgIHJldHVybiAhMDtcbiAgICB9XG4gICAgbiA9IG4ucGFyZW50Tm9kZTtcbiAgfSB3aGlsZSAobiAmJiBuICE9PSBkb2N1bWVudC5ib2R5KTtcbiAgcmV0dXJuICExO1xufSwgVSQgPSBmdW5jdGlvbihlKSB7XG4gIHZhciB0ID0gZS5zY3JvbGxUb3AsIG4gPSBlLnNjcm9sbEhlaWdodCwgciA9IGUuY2xpZW50SGVpZ2h0O1xuICByZXR1cm4gW1xuICAgIHQsXG4gICAgbixcbiAgICByXG4gIF07XG59LCBIJCA9IGZ1bmN0aW9uKGUpIHtcbiAgdmFyIHQgPSBlLnNjcm9sbExlZnQsIG4gPSBlLnNjcm9sbFdpZHRoLCByID0gZS5jbGllbnRXaWR0aDtcbiAgcmV0dXJuIFtcbiAgICB0LFxuICAgIG4sXG4gICAgclxuICBdO1xufSwgaXkgPSBmdW5jdGlvbihlLCB0KSB7XG4gIHJldHVybiBlID09PSBcInZcIiA/IEckKHQpIDogVyQodCk7XG59LCBveSA9IGZ1bmN0aW9uKGUsIHQpIHtcbiAgcmV0dXJuIGUgPT09IFwidlwiID8gVSQodCkgOiBIJCh0KTtcbn0sIHEkID0gZnVuY3Rpb24oZSwgdCkge1xuICByZXR1cm4gZSA9PT0gXCJoXCIgJiYgdCA9PT0gXCJydGxcIiA/IC0xIDogMTtcbn0sIEskID0gZnVuY3Rpb24oZSwgdCwgbiwgciwgaSkge1xuICB2YXIgbyA9IHEkKGUsIHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHQpLmRpcmVjdGlvbiksIGEgPSBvICogciwgcyA9IG4udGFyZ2V0LCB1ID0gdC5jb250YWlucyhzKSwgYyA9ICExLCBmID0gYSA+IDAsIGwgPSAwLCBkID0gMDtcbiAgZG8ge1xuICAgIHZhciBwID0gb3koZSwgcyksIGcgPSBwWzBdLCBoID0gcFsxXSwgdiA9IHBbMl0sIHcgPSBoIC0gdiAtIG8gKiBnO1xuICAgIChnIHx8IHcpICYmIGl5KGUsIHMpICYmIChsICs9IHcsIGQgKz0gZyksIHMgPSBzLnBhcmVudE5vZGU7XG4gIH0gd2hpbGUgKFxuICAgIC8vIHBvcnRhbGVkIGNvbnRlbnRcbiAgICAhdSAmJiBzICE9PSBkb2N1bWVudC5ib2R5IHx8IC8vIHNlbGYgY29udGVudFxuICAgIHUgJiYgKHQuY29udGFpbnMocykgfHwgdCA9PT0gcylcbiAgKTtcbiAgcmV0dXJuIChmICYmIChsID09PSAwIHx8ICFpKSB8fCAhZiAmJiAoZCA9PT0gMCB8fCAhaSkpICYmIChjID0gITApLCBjO1xufSwgdWEgPSBmdW5jdGlvbihlKSB7XG4gIHJldHVybiBcImNoYW5nZWRUb3VjaGVzXCIgaW4gZSA/IFtlLmNoYW5nZWRUb3VjaGVzWzBdLmNsaWVudFgsIGUuY2hhbmdlZFRvdWNoZXNbMF0uY2xpZW50WV0gOiBbMCwgMF07XG59LCBhcCA9IGZ1bmN0aW9uKGUpIHtcbiAgcmV0dXJuIFtlLmRlbHRhWCwgZS5kZWx0YVldO1xufSwgc3AgPSBmdW5jdGlvbihlKSB7XG4gIHJldHVybiBlICYmIFwiY3VycmVudFwiIGluIGUgPyBlLmN1cnJlbnQgOiBlO1xufSwgWSQgPSBmdW5jdGlvbihlLCB0KSB7XG4gIHJldHVybiBlWzBdID09PSB0WzBdICYmIGVbMV0gPT09IHRbMV07XG59LCBYJCA9IGZ1bmN0aW9uKGUpIHtcbiAgcmV0dXJuIGBcbiAgLmJsb2NrLWludGVyYWN0aXZpdHktYC5jb25jYXQoZSwgYCB7cG9pbnRlci1ldmVudHM6IG5vbmU7fVxuICAuYWxsb3ctaW50ZXJhY3Rpdml0eS1gKS5jb25jYXQoZSwgYCB7cG9pbnRlci1ldmVudHM6IGFsbDt9XG5gKTtcbn0sIFokID0gMCwgJHIgPSBbXTtcbmZ1bmN0aW9uIEokKGUpIHtcbiAgdmFyIHQgPSBILnVzZVJlZihbXSksIG4gPSBILnVzZVJlZihbMCwgMF0pLCByID0gSC51c2VSZWYoKSwgaSA9IEgudXNlU3RhdGUoWiQrKylbMF0sIG8gPSBILnVzZVN0YXRlKGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBueSgpO1xuICB9KVswXSwgYSA9IEgudXNlUmVmKGUpO1xuICBILnVzZUVmZmVjdChmdW5jdGlvbigpIHtcbiAgICBhLmN1cnJlbnQgPSBlO1xuICB9LCBbZV0pLCBILnVzZUVmZmVjdChmdW5jdGlvbigpIHtcbiAgICBpZiAoZS5pbmVydCkge1xuICAgICAgZG9jdW1lbnQuYm9keS5jbGFzc0xpc3QuYWRkKFwiYmxvY2staW50ZXJhY3Rpdml0eS1cIi5jb25jYXQoaSkpO1xuICAgICAgdmFyIGggPSBiJChbZS5sb2NrUmVmLmN1cnJlbnRdLCAoZS5zaGFyZHMgfHwgW10pLm1hcChzcCksICEwKS5maWx0ZXIoQm9vbGVhbik7XG4gICAgICByZXR1cm4gaC5mb3JFYWNoKGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgcmV0dXJuIHYuY2xhc3NMaXN0LmFkZChcImFsbG93LWludGVyYWN0aXZpdHktXCIuY29uY2F0KGkpKTtcbiAgICAgIH0pLCBmdW5jdGlvbigpIHtcbiAgICAgICAgZG9jdW1lbnQuYm9keS5jbGFzc0xpc3QucmVtb3ZlKFwiYmxvY2staW50ZXJhY3Rpdml0eS1cIi5jb25jYXQoaSkpLCBoLmZvckVhY2goZnVuY3Rpb24odikge1xuICAgICAgICAgIHJldHVybiB2LmNsYXNzTGlzdC5yZW1vdmUoXCJhbGxvdy1pbnRlcmFjdGl2aXR5LVwiLmNvbmNhdChpKSk7XG4gICAgICAgIH0pO1xuICAgICAgfTtcbiAgICB9XG4gIH0sIFtlLmluZXJ0LCBlLmxvY2tSZWYuY3VycmVudCwgZS5zaGFyZHNdKTtcbiAgdmFyIHMgPSBILnVzZUNhbGxiYWNrKGZ1bmN0aW9uKGgsIHYpIHtcbiAgICBpZiAoXCJ0b3VjaGVzXCIgaW4gaCAmJiBoLnRvdWNoZXMubGVuZ3RoID09PSAyKVxuICAgICAgcmV0dXJuICFhLmN1cnJlbnQuYWxsb3dQaW5jaFpvb207XG4gICAgdmFyIHcgPSB1YShoKSwgYiA9IG4uY3VycmVudCwgeCA9IFwiZGVsdGFYXCIgaW4gaCA/IGguZGVsdGFYIDogYlswXSAtIHdbMF0sIG0gPSBcImRlbHRhWVwiIGluIGggPyBoLmRlbHRhWSA6IGJbMV0gLSB3WzFdLCB5LCBTID0gaC50YXJnZXQsICQgPSBNYXRoLmFicyh4KSA+IE1hdGguYWJzKG0pID8gXCJoXCIgOiBcInZcIjtcbiAgICBpZiAoXCJ0b3VjaGVzXCIgaW4gaCAmJiAkID09PSBcImhcIiAmJiBTLnR5cGUgPT09IFwicmFuZ2VcIilcbiAgICAgIHJldHVybiAhMTtcbiAgICB2YXIgTyA9IG9wKCQsIFMpO1xuICAgIGlmICghTylcbiAgICAgIHJldHVybiAhMDtcbiAgICBpZiAoTyA/IHkgPSAkIDogKHkgPSAkID09PSBcInZcIiA/IFwiaFwiIDogXCJ2XCIsIE8gPSBvcCgkLCBTKSksICFPKVxuICAgICAgcmV0dXJuICExO1xuICAgIGlmICghci5jdXJyZW50ICYmIFwiY2hhbmdlZFRvdWNoZXNcIiBpbiBoICYmICh4IHx8IG0pICYmIChyLmN1cnJlbnQgPSB5KSwgIXkpXG4gICAgICByZXR1cm4gITA7XG4gICAgdmFyIFQgPSByLmN1cnJlbnQgfHwgeTtcbiAgICByZXR1cm4gSyQoVCwgdiwgaCwgVCA9PT0gXCJoXCIgPyB4IDogbSwgITApO1xuICB9LCBbXSksIHUgPSBILnVzZUNhbGxiYWNrKGZ1bmN0aW9uKGgpIHtcbiAgICB2YXIgdiA9IGg7XG4gICAgaWYgKCEoISRyLmxlbmd0aCB8fCAkclskci5sZW5ndGggLSAxXSAhPT0gbykpIHtcbiAgICAgIHZhciB3ID0gXCJkZWx0YVlcIiBpbiB2ID8gYXAodikgOiB1YSh2KSwgYiA9IHQuY3VycmVudC5maWx0ZXIoZnVuY3Rpb24oeSkge1xuICAgICAgICByZXR1cm4geS5uYW1lID09PSB2LnR5cGUgJiYgeS50YXJnZXQgPT09IHYudGFyZ2V0ICYmIFkkKHkuZGVsdGEsIHcpO1xuICAgICAgfSlbMF07XG4gICAgICBpZiAoYiAmJiBiLnNob3VsZCkge1xuICAgICAgICB2LmNhbmNlbGFibGUgJiYgdi5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoIWIpIHtcbiAgICAgICAgdmFyIHggPSAoYS5jdXJyZW50LnNoYXJkcyB8fCBbXSkubWFwKHNwKS5maWx0ZXIoQm9vbGVhbikuZmlsdGVyKGZ1bmN0aW9uKHkpIHtcbiAgICAgICAgICByZXR1cm4geS5jb250YWlucyh2LnRhcmdldCk7XG4gICAgICAgIH0pLCBtID0geC5sZW5ndGggPiAwID8gcyh2LCB4WzBdKSA6ICFhLmN1cnJlbnQubm9Jc29sYXRpb247XG4gICAgICAgIG0gJiYgdi5jYW5jZWxhYmxlICYmIHYucHJldmVudERlZmF1bHQoKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIFtdKSwgYyA9IEgudXNlQ2FsbGJhY2soZnVuY3Rpb24oaCwgdiwgdywgYikge1xuICAgIHZhciB4ID0geyBuYW1lOiBoLCBkZWx0YTogdiwgdGFyZ2V0OiB3LCBzaG91bGQ6IGIgfTtcbiAgICB0LmN1cnJlbnQucHVzaCh4KSwgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgIHQuY3VycmVudCA9IHQuY3VycmVudC5maWx0ZXIoZnVuY3Rpb24obSkge1xuICAgICAgICByZXR1cm4gbSAhPT0geDtcbiAgICAgIH0pO1xuICAgIH0sIDEpO1xuICB9LCBbXSksIGYgPSBILnVzZUNhbGxiYWNrKGZ1bmN0aW9uKGgpIHtcbiAgICBuLmN1cnJlbnQgPSB1YShoKSwgci5jdXJyZW50ID0gdm9pZCAwO1xuICB9LCBbXSksIGwgPSBILnVzZUNhbGxiYWNrKGZ1bmN0aW9uKGgpIHtcbiAgICBjKGgudHlwZSwgYXAoaCksIGgudGFyZ2V0LCBzKGgsIGUubG9ja1JlZi5jdXJyZW50KSk7XG4gIH0sIFtdKSwgZCA9IEgudXNlQ2FsbGJhY2soZnVuY3Rpb24oaCkge1xuICAgIGMoaC50eXBlLCB1YShoKSwgaC50YXJnZXQsIHMoaCwgZS5sb2NrUmVmLmN1cnJlbnQpKTtcbiAgfSwgW10pO1xuICBILnVzZUVmZmVjdChmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gJHIucHVzaChvKSwgZS5zZXRDYWxsYmFja3Moe1xuICAgICAgb25TY3JvbGxDYXB0dXJlOiBsLFxuICAgICAgb25XaGVlbENhcHR1cmU6IGwsXG4gICAgICBvblRvdWNoTW92ZUNhcHR1cmU6IGRcbiAgICB9KSwgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcIndoZWVsXCIsIHUsIFNyKSwgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInRvdWNobW92ZVwiLCB1LCBTciksIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJ0b3VjaHN0YXJ0XCIsIGYsIFNyKSwgZnVuY3Rpb24oKSB7XG4gICAgICAkciA9ICRyLmZpbHRlcihmdW5jdGlvbihoKSB7XG4gICAgICAgIHJldHVybiBoICE9PSBvO1xuICAgICAgfSksIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ3aGVlbFwiLCB1LCBTciksIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ0b3VjaG1vdmVcIiwgdSwgU3IpLCBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwidG91Y2hzdGFydFwiLCBmLCBTcik7XG4gICAgfTtcbiAgfSwgW10pO1xuICB2YXIgcCA9IGUucmVtb3ZlU2Nyb2xsQmFyLCBnID0gZS5pbmVydDtcbiAgcmV0dXJuIEguY3JlYXRlRWxlbWVudChcbiAgICBILkZyYWdtZW50LFxuICAgIG51bGwsXG4gICAgZyA/IEguY3JlYXRlRWxlbWVudChvLCB7IHN0eWxlczogWCQoaSkgfSkgOiBudWxsLFxuICAgIHAgPyBILmNyZWF0ZUVsZW1lbnQoeiQsIHsgZ2FwTW9kZTogXCJtYXJnaW5cIiB9KSA6IG51bGxcbiAgKTtcbn1cbmNvbnN0IFEkID0gQyQodHksIEokKTtcbnZhciBheSA9IEguZm9yd2FyZFJlZihmdW5jdGlvbihlLCB0KSB7XG4gIHJldHVybiBILmNyZWF0ZUVsZW1lbnQoSXMsIG5uKHt9LCBlLCB7IHJlZjogdCwgc2lkZUNhcjogUSQgfSkpO1xufSk7XG5heS5jbGFzc05hbWVzID0gSXMuY2xhc3NOYW1lcztcbmNvbnN0ICRjID0gW1xuICBcIkVudGVyXCIsXG4gIFwiIFwiXG5dLCBlTyA9IFtcbiAgXCJBcnJvd0Rvd25cIixcbiAgXCJQYWdlVXBcIixcbiAgXCJIb21lXCJcbl0sIHN5ID0gW1xuICBcIkFycm93VXBcIixcbiAgXCJQYWdlRG93blwiLFxuICBcIkVuZFwiXG5dLCB0TyA9IFtcbiAgLi4uZU8sXG4gIC4uLnN5XG5dLCBuTyA9IHtcbiAgbHRyOiBbXG4gICAgLi4uJGMsXG4gICAgXCJBcnJvd1JpZ2h0XCJcbiAgXSxcbiAgcnRsOiBbXG4gICAgLi4uJGMsXG4gICAgXCJBcnJvd0xlZnRcIlxuICBdXG59LCByTyA9IHtcbiAgbHRyOiBbXG4gICAgXCJBcnJvd0xlZnRcIlxuICBdLFxuICBydGw6IFtcbiAgICBcIkFycm93UmlnaHRcIlxuICBdXG59LCBqcyA9IFwiTWVudVwiLCBbUWksIGlPLCBvT10gPSBUbShqcyksIFtociwgdXldID0gRm8oanMsIFtcbiAgb08sXG4gIFVtLFxuICBYbVxuXSksIGxmID0gVW0oKSwgY3kgPSBYbSgpLCBbYU8sIGdyXSA9IGhyKGpzKSwgW3NPLCB6b10gPSBocihqcyksIHVPID0gKGUpID0+IHtcbiAgY29uc3QgeyBfX3Njb3BlTWVudTogdCwgb3BlbjogbiA9ICExLCBjaGlsZHJlbjogciwgZGlyOiBpLCBvbk9wZW5DaGFuZ2U6IG8sIG1vZGFsOiBhID0gITAgfSA9IGUsIHMgPSBsZih0KSwgW3UsIGNdID0gWWUobnVsbCksIGYgPSBfZSghMSksIGwgPSB1bihvKSwgZCA9IE1tKGkpO1xuICByZXR1cm4gRmUoKCkgPT4ge1xuICAgIGNvbnN0IHAgPSAoKSA9PiB7XG4gICAgICBmLmN1cnJlbnQgPSAhMCwgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJkb3duXCIsIGcsIHtcbiAgICAgICAgY2FwdHVyZTogITAsXG4gICAgICAgIG9uY2U6ICEwXG4gICAgICB9KSwgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJtb3ZlXCIsIGcsIHtcbiAgICAgICAgY2FwdHVyZTogITAsXG4gICAgICAgIG9uY2U6ICEwXG4gICAgICB9KTtcbiAgICB9LCBnID0gKCkgPT4gZi5jdXJyZW50ID0gITE7XG4gICAgcmV0dXJuIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIHAsIHtcbiAgICAgIGNhcHR1cmU6ICEwXG4gICAgfSksICgpID0+IHtcbiAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIHAsIHtcbiAgICAgICAgY2FwdHVyZTogITBcbiAgICAgIH0pLCBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwicG9pbnRlcmRvd25cIiwgZywge1xuICAgICAgICBjYXB0dXJlOiAhMFxuICAgICAgfSksIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJwb2ludGVybW92ZVwiLCBnLCB7XG4gICAgICAgIGNhcHR1cmU6ICEwXG4gICAgICB9KTtcbiAgICB9O1xuICB9LCBbXSksIC8qIEBfX1BVUkVfXyAqLyBZKEtTLCBzLCAvKiBAX19QVVJFX18gKi8gWShhTywge1xuICAgIHNjb3BlOiB0LFxuICAgIG9wZW46IG4sXG4gICAgb25PcGVuQ2hhbmdlOiBsLFxuICAgIGNvbnRlbnQ6IHUsXG4gICAgb25Db250ZW50Q2hhbmdlOiBjXG4gIH0sIC8qIEBfX1BVUkVfXyAqLyBZKHNPLCB7XG4gICAgc2NvcGU6IHQsXG4gICAgb25DbG9zZTogdXQoXG4gICAgICAoKSA9PiBsKCExKSxcbiAgICAgIFtcbiAgICAgICAgbFxuICAgICAgXVxuICAgICksXG4gICAgaXNVc2luZ0tleWJvYXJkUmVmOiBmLFxuICAgIGRpcjogZCxcbiAgICBtb2RhbDogYVxuICB9LCByKSkpO1xufSwgbHkgPSAvKiBAX19QVVJFX18gKi8gaGUoKGUsIHQpID0+IHtcbiAgY29uc3QgeyBfX3Njb3BlTWVudTogbiwgLi4uciB9ID0gZSwgaSA9IGxmKG4pO1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIFkoWVMsIGNlKHt9LCBpLCByLCB7XG4gICAgcmVmOiB0XG4gIH0pKTtcbn0pLCBmeSA9IFwiTWVudVBvcnRhbFwiLCBbY08sIGR5XSA9IGhyKGZ5LCB7XG4gIGZvcmNlTW91bnQ6IHZvaWQgMFxufSksIGxPID0gKGUpID0+IHtcbiAgY29uc3QgeyBfX3Njb3BlTWVudTogdCwgZm9yY2VNb3VudDogbiwgY2hpbGRyZW46IHIsIGNvbnRhaW5lcjogaSB9ID0gZSwgbyA9IGdyKGZ5LCB0KTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBZKGNPLCB7XG4gICAgc2NvcGU6IHQsXG4gICAgZm9yY2VNb3VudDogblxuICB9LCAvKiBAX19QVVJFX18gKi8gWShCbywge1xuICAgIHByZXNlbnQ6IG4gfHwgby5vcGVuXG4gIH0sIC8qIEBfX1BVUkVfXyAqLyBZKFpTLCB7XG4gICAgYXNDaGlsZDogITAsXG4gICAgY29udGFpbmVyOiBpXG4gIH0sIHIpKSk7XG59LCBZdCA9IFwiTWVudUNvbnRlbnRcIiwgW2ZPLCBmZl0gPSBocihZdCksIGRPID0gLyogQF9fUFVSRV9fICovIGhlKChlLCB0KSA9PiB7XG4gIGNvbnN0IG4gPSBkeShZdCwgZS5fX3Njb3BlTWVudSksIHsgZm9yY2VNb3VudDogciA9IG4uZm9yY2VNb3VudCwgLi4uaSB9ID0gZSwgbyA9IGdyKFl0LCBlLl9fc2NvcGVNZW51KSwgYSA9IHpvKFl0LCBlLl9fc2NvcGVNZW51KTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBZKFFpLlByb3ZpZGVyLCB7XG4gICAgc2NvcGU6IGUuX19zY29wZU1lbnVcbiAgfSwgLyogQF9fUFVSRV9fICovIFkoQm8sIHtcbiAgICBwcmVzZW50OiByIHx8IG8ub3BlblxuICB9LCAvKiBAX19QVVJFX18gKi8gWShRaS5TbG90LCB7XG4gICAgc2NvcGU6IGUuX19zY29wZU1lbnVcbiAgfSwgYS5tb2RhbCA/IC8qIEBfX1BVUkVfXyAqLyBZKHBPLCBjZSh7fSwgaSwge1xuICAgIHJlZjogdFxuICB9KSkgOiAvKiBAX19QVVJFX18gKi8gWShoTywgY2Uoe30sIGksIHtcbiAgICByZWY6IHRcbiAgfSkpKSkpO1xufSksIHBPID0gLyogQF9fUFVSRV9fICovIGhlKChlLCB0KSA9PiB7XG4gIGNvbnN0IG4gPSBncihZdCwgZS5fX3Njb3BlTWVudSksIHIgPSBfZShudWxsKSwgaSA9IF90KHQsIHIpO1xuICByZXR1cm4gRmUoKCkgPT4ge1xuICAgIGNvbnN0IG8gPSByLmN1cnJlbnQ7XG4gICAgaWYgKG8pXG4gICAgICByZXR1cm4geSQobyk7XG4gIH0sIFtdKSwgLyogQF9fUFVSRV9fICovIFkoZGYsIGNlKHt9LCBlLCB7XG4gICAgcmVmOiBpLFxuICAgIHRyYXBGb2N1czogbi5vcGVuLFxuICAgIGRpc2FibGVPdXRzaWRlUG9pbnRlckV2ZW50czogbi5vcGVuLFxuICAgIGRpc2FibGVPdXRzaWRlU2Nyb2xsOiAhMCxcbiAgICBvbkZvY3VzT3V0c2lkZTogd2UoXG4gICAgICBlLm9uRm9jdXNPdXRzaWRlLFxuICAgICAgKG8pID0+IG8ucHJldmVudERlZmF1bHQoKSxcbiAgICAgIHtcbiAgICAgICAgY2hlY2tGb3JEZWZhdWx0UHJldmVudGVkOiAhMVxuICAgICAgfVxuICAgICksXG4gICAgb25EaXNtaXNzOiAoKSA9PiBuLm9uT3BlbkNoYW5nZSghMSlcbiAgfSkpO1xufSksIGhPID0gLyogQF9fUFVSRV9fICovIGhlKChlLCB0KSA9PiB7XG4gIGNvbnN0IG4gPSBncihZdCwgZS5fX3Njb3BlTWVudSk7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gWShkZiwgY2Uoe30sIGUsIHtcbiAgICByZWY6IHQsXG4gICAgdHJhcEZvY3VzOiAhMSxcbiAgICBkaXNhYmxlT3V0c2lkZVBvaW50ZXJFdmVudHM6ICExLFxuICAgIGRpc2FibGVPdXRzaWRlU2Nyb2xsOiAhMSxcbiAgICBvbkRpc21pc3M6ICgpID0+IG4ub25PcGVuQ2hhbmdlKCExKVxuICB9KSk7XG59KSwgZGYgPSAvKiBAX19QVVJFX18gKi8gaGUoKGUsIHQpID0+IHtcbiAgY29uc3QgeyBfX3Njb3BlTWVudTogbiwgbG9vcDogciA9ICExLCB0cmFwRm9jdXM6IGksIG9uT3BlbkF1dG9Gb2N1czogbywgb25DbG9zZUF1dG9Gb2N1czogYSwgZGlzYWJsZU91dHNpZGVQb2ludGVyRXZlbnRzOiBzLCBvbkVudHJ5Rm9jdXM6IHUsIG9uRXNjYXBlS2V5RG93bjogYywgb25Qb2ludGVyRG93bk91dHNpZGU6IGYsIG9uRm9jdXNPdXRzaWRlOiBsLCBvbkludGVyYWN0T3V0c2lkZTogZCwgb25EaXNtaXNzOiBwLCBkaXNhYmxlT3V0c2lkZVNjcm9sbDogZywgLi4uaCB9ID0gZSwgdiA9IGdyKFl0LCBuKSwgdyA9IHpvKFl0LCBuKSwgYiA9IGxmKG4pLCB4ID0gY3kobiksIG0gPSBpTyhuKSwgW3ksIFNdID0gWWUobnVsbCksICQgPSBfZShudWxsKSwgTyA9IF90KHQsICQsIHYub25Db250ZW50Q2hhbmdlKSwgVCA9IF9lKDApLCBNID0gX2UoXCJcIiksIEUgPSBfZSgwKSwgQSA9IF9lKG51bGwpLCBqID0gX2UoXCJyaWdodFwiKSwgUiA9IF9lKDApLCBOID0gZyA/IGF5IDogdW0sIGsgPSBnID8ge1xuICAgIGFzOiBrcixcbiAgICBhbGxvd1BpbmNoWm9vbTogITBcbiAgfSA6IHZvaWQgMCwgRiA9IChMKSA9PiB7XG4gICAgdmFyIEksIEQ7XG4gICAgY29uc3QgRyA9IE0uY3VycmVudCArIEwsIHEgPSBtKCkuZmlsdGVyKFxuICAgICAgKEIpID0+ICFCLmRpc2FibGVkXG4gICAgKSwgSiA9IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQsIG5lID0gKEkgPSBxLmZpbmQoXG4gICAgICAoQikgPT4gQi5yZWYuY3VycmVudCA9PT0gSlxuICAgICkpID09PSBudWxsIHx8IEkgPT09IHZvaWQgMCA/IHZvaWQgMCA6IEkudGV4dFZhbHVlLCB0ZSA9IHEubWFwKFxuICAgICAgKEIpID0+IEIudGV4dFZhbHVlXG4gICAgKSwgZWUgPSBUTyh0ZSwgRywgbmUpLCBpZSA9IChEID0gcS5maW5kKFxuICAgICAgKEIpID0+IEIudGV4dFZhbHVlID09PSBlZVxuICAgICkpID09PSBudWxsIHx8IEQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IEQucmVmLmN1cnJlbnQ7XG4gICAgKGZ1bmN0aW9uIEIoVSkge1xuICAgICAgTS5jdXJyZW50ID0gVSwgd2luZG93LmNsZWFyVGltZW91dChULmN1cnJlbnQpLCBVICE9PSBcIlwiICYmIChULmN1cnJlbnQgPSB3aW5kb3cuc2V0VGltZW91dChcbiAgICAgICAgKCkgPT4gQihcIlwiKSxcbiAgICAgICAgMWUzXG4gICAgICApKTtcbiAgICB9KShHKSwgaWUgJiYgc2V0VGltZW91dChcbiAgICAgICgpID0+IGllLmZvY3VzKClcbiAgICApO1xuICB9O1xuICBGZSgoKSA9PiAoKSA9PiB3aW5kb3cuY2xlYXJUaW1lb3V0KFQuY3VycmVudCksIFtdKSwgTTEoKTtcbiAgY29uc3QgViA9IHV0KChMKSA9PiB7XG4gICAgdmFyIEksIEQ7XG4gICAgcmV0dXJuIGouY3VycmVudCA9PT0gKChJID0gQS5jdXJyZW50KSA9PT0gbnVsbCB8fCBJID09PSB2b2lkIDAgPyB2b2lkIDAgOiBJLnNpZGUpICYmIFJPKEwsIChEID0gQS5jdXJyZW50KSA9PT0gbnVsbCB8fCBEID09PSB2b2lkIDAgPyB2b2lkIDAgOiBELmFyZWEpO1xuICB9LCBbXSk7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gWShmTywge1xuICAgIHNjb3BlOiBuLFxuICAgIHNlYXJjaFJlZjogTSxcbiAgICBvbkl0ZW1FbnRlcjogdXQoKEwpID0+IHtcbiAgICAgIFYoTCkgJiYgTC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH0sIFtcbiAgICAgIFZcbiAgICBdKSxcbiAgICBvbkl0ZW1MZWF2ZTogdXQoKEwpID0+IHtcbiAgICAgIHZhciBJO1xuICAgICAgVihMKSB8fCAoKEkgPSAkLmN1cnJlbnQpID09PSBudWxsIHx8IEkgPT09IHZvaWQgMCB8fCBJLmZvY3VzKCksIFMobnVsbCkpO1xuICAgIH0sIFtcbiAgICAgIFZcbiAgICBdKSxcbiAgICBvblRyaWdnZXJMZWF2ZTogdXQoKEwpID0+IHtcbiAgICAgIFYoTCkgJiYgTC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH0sIFtcbiAgICAgIFZcbiAgICBdKSxcbiAgICBwb2ludGVyR3JhY2VUaW1lclJlZjogRSxcbiAgICBvblBvaW50ZXJHcmFjZUludGVudENoYW5nZTogdXQoKEwpID0+IHtcbiAgICAgIEEuY3VycmVudCA9IEw7XG4gICAgfSwgW10pXG4gIH0sIC8qIEBfX1BVUkVfXyAqLyBZKE4sIGssIC8qIEBfX1BVUkVfXyAqLyBZKFIxLCB7XG4gICAgYXNDaGlsZDogITAsXG4gICAgdHJhcHBlZDogaSxcbiAgICBvbk1vdW50QXV0b0ZvY3VzOiB3ZShvLCAoTCkgPT4ge1xuICAgICAgdmFyIEk7XG4gICAgICBMLnByZXZlbnREZWZhdWx0KCksIChJID0gJC5jdXJyZW50KSA9PT0gbnVsbCB8fCBJID09PSB2b2lkIDAgfHwgSS5mb2N1cygpO1xuICAgIH0pLFxuICAgIG9uVW5tb3VudEF1dG9Gb2N1czogYVxuICB9LCAvKiBAX19QVVJFX18gKi8gWShDMSwge1xuICAgIGFzQ2hpbGQ6ICEwLFxuICAgIGRpc2FibGVPdXRzaWRlUG9pbnRlckV2ZW50czogcyxcbiAgICBvbkVzY2FwZUtleURvd246IGMsXG4gICAgb25Qb2ludGVyRG93bk91dHNpZGU6IGYsXG4gICAgb25Gb2N1c091dHNpZGU6IGwsXG4gICAgb25JbnRlcmFjdE91dHNpZGU6IGQsXG4gICAgb25EaXNtaXNzOiBwXG4gIH0sIC8qIEBfX1BVUkVfXyAqLyBZKHAkLCBjZSh7XG4gICAgYXNDaGlsZDogITBcbiAgfSwgeCwge1xuICAgIGRpcjogdy5kaXIsXG4gICAgb3JpZW50YXRpb246IFwidmVydGljYWxcIixcbiAgICBsb29wOiByLFxuICAgIGN1cnJlbnRUYWJTdG9wSWQ6IHksXG4gICAgb25DdXJyZW50VGFiU3RvcElkQ2hhbmdlOiBTLFxuICAgIG9uRW50cnlGb2N1czogd2UodSwgKEwpID0+IHtcbiAgICAgIHcuaXNVc2luZ0tleWJvYXJkUmVmLmN1cnJlbnQgfHwgTC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH0pXG4gIH0pLCAvKiBAX19QVVJFX18gKi8gWShYUywgY2Uoe1xuICAgIHJvbGU6IFwibWVudVwiLFxuICAgIFwiYXJpYS1vcmllbnRhdGlvblwiOiBcInZlcnRpY2FsXCIsXG4gICAgXCJkYXRhLXN0YXRlXCI6IG15KHYub3BlbiksXG4gICAgXCJkYXRhLXJhZGl4LW1lbnUtY29udGVudFwiOiBcIlwiLFxuICAgIGRpcjogdy5kaXJcbiAgfSwgYiwgaCwge1xuICAgIHJlZjogTyxcbiAgICBzdHlsZToge1xuICAgICAgb3V0bGluZTogXCJub25lXCIsXG4gICAgICAuLi5oLnN0eWxlXG4gICAgfSxcbiAgICBvbktleURvd246IHdlKGgub25LZXlEb3duLCAoTCkgPT4ge1xuICAgICAgY29uc3QgRCA9IEwudGFyZ2V0LmNsb3Nlc3QoXCJbZGF0YS1yYWRpeC1tZW51LWNvbnRlbnRdXCIpID09PSBMLmN1cnJlbnRUYXJnZXQsIEcgPSBMLmN0cmxLZXkgfHwgTC5hbHRLZXkgfHwgTC5tZXRhS2V5LCBxID0gTC5rZXkubGVuZ3RoID09PSAxO1xuICAgICAgRCAmJiAoTC5rZXkgPT09IFwiVGFiXCIgJiYgTC5wcmV2ZW50RGVmYXVsdCgpLCAhRyAmJiBxICYmIEYoTC5rZXkpKTtcbiAgICAgIGNvbnN0IEogPSAkLmN1cnJlbnQ7XG4gICAgICBpZiAoTC50YXJnZXQgIT09IEogfHwgIXRPLmluY2x1ZGVzKEwua2V5KSlcbiAgICAgICAgcmV0dXJuO1xuICAgICAgTC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgY29uc3QgdGUgPSBtKCkuZmlsdGVyKFxuICAgICAgICAoZWUpID0+ICFlZS5kaXNhYmxlZFxuICAgICAgKS5tYXAoXG4gICAgICAgIChlZSkgPT4gZWUucmVmLmN1cnJlbnRcbiAgICAgICk7XG4gICAgICBzeS5pbmNsdWRlcyhMLmtleSkgJiYgdGUucmV2ZXJzZSgpLCBDTyh0ZSk7XG4gICAgfSksXG4gICAgb25CbHVyOiB3ZShlLm9uQmx1ciwgKEwpID0+IHtcbiAgICAgIEwuY3VycmVudFRhcmdldC5jb250YWlucyhMLnRhcmdldCkgfHwgKHdpbmRvdy5jbGVhclRpbWVvdXQoVC5jdXJyZW50KSwgTS5jdXJyZW50ID0gXCJcIik7XG4gICAgfSksXG4gICAgb25Qb2ludGVyTW92ZTogd2UoZS5vblBvaW50ZXJNb3ZlLCBlbygoTCkgPT4ge1xuICAgICAgY29uc3QgSSA9IEwudGFyZ2V0LCBEID0gUi5jdXJyZW50ICE9PSBMLmNsaWVudFg7XG4gICAgICBpZiAoTC5jdXJyZW50VGFyZ2V0LmNvbnRhaW5zKEkpICYmIEQpIHtcbiAgICAgICAgY29uc3QgRyA9IEwuY2xpZW50WCA+IFIuY3VycmVudCA/IFwicmlnaHRcIiA6IFwibGVmdFwiO1xuICAgICAgICBqLmN1cnJlbnQgPSBHLCBSLmN1cnJlbnQgPSBMLmNsaWVudFg7XG4gICAgICB9XG4gICAgfSkpXG4gIH0pKSkpKSkpO1xufSksIGdPID0gLyogQF9fUFVSRV9fICovIGhlKChlLCB0KSA9PiB7XG4gIGNvbnN0IHsgX19zY29wZU1lbnU6IG4sIC4uLnIgfSA9IGU7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gWShGdC5kaXYsIGNlKHt9LCByLCB7XG4gICAgcmVmOiB0XG4gIH0pKTtcbn0pLCBPYyA9IFwiTWVudUl0ZW1cIiwgdXAgPSBcIm1lbnUuaXRlbVNlbGVjdFwiLCBwZiA9IC8qIEBfX1BVUkVfXyAqLyBoZSgoZSwgdCkgPT4ge1xuICBjb25zdCB7IGRpc2FibGVkOiBuID0gITEsIG9uU2VsZWN0OiByLCAuLi5pIH0gPSBlLCBvID0gX2UobnVsbCksIGEgPSB6byhPYywgZS5fX3Njb3BlTWVudSksIHMgPSBmZihPYywgZS5fX3Njb3BlTWVudSksIHUgPSBfdCh0LCBvKSwgYyA9IF9lKCExKSwgZiA9ICgpID0+IHtcbiAgICBjb25zdCBsID0gby5jdXJyZW50O1xuICAgIGlmICghbiAmJiBsKSB7XG4gICAgICBjb25zdCBkID0gbmV3IEN1c3RvbUV2ZW50KHVwLCB7XG4gICAgICAgIGJ1YmJsZXM6ICEwLFxuICAgICAgICBjYW5jZWxhYmxlOiAhMFxuICAgICAgfSk7XG4gICAgICBsLmFkZEV2ZW50TGlzdGVuZXIoXG4gICAgICAgIHVwLFxuICAgICAgICAocCkgPT4gciA9PSBudWxsID8gdm9pZCAwIDogcihwKSxcbiAgICAgICAge1xuICAgICAgICAgIG9uY2U6ICEwXG4gICAgICAgIH1cbiAgICAgICksIEVtKGwsIGQpLCBkLmRlZmF1bHRQcmV2ZW50ZWQgPyBjLmN1cnJlbnQgPSAhMSA6IGEub25DbG9zZSgpO1xuICAgIH1cbiAgfTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBZKHB5LCBjZSh7fSwgaSwge1xuICAgIHJlZjogdSxcbiAgICBkaXNhYmxlZDogbixcbiAgICBvbkNsaWNrOiB3ZShlLm9uQ2xpY2ssIGYpLFxuICAgIG9uUG9pbnRlckRvd246IChsKSA9PiB7XG4gICAgICB2YXIgZDtcbiAgICAgIChkID0gZS5vblBvaW50ZXJEb3duKSA9PT0gbnVsbCB8fCBkID09PSB2b2lkIDAgfHwgZC5jYWxsKGUsIGwpLCBjLmN1cnJlbnQgPSAhMDtcbiAgICB9LFxuICAgIG9uUG9pbnRlclVwOiB3ZShlLm9uUG9pbnRlclVwLCAobCkgPT4ge1xuICAgICAgdmFyIGQ7XG4gICAgICBjLmN1cnJlbnQgfHwgKGQgPSBsLmN1cnJlbnRUYXJnZXQpID09PSBudWxsIHx8IGQgPT09IHZvaWQgMCB8fCBkLmNsaWNrKCk7XG4gICAgfSksXG4gICAgb25LZXlEb3duOiB3ZShlLm9uS2V5RG93biwgKGwpID0+IHtcbiAgICAgIGNvbnN0IGQgPSBzLnNlYXJjaFJlZi5jdXJyZW50ICE9PSBcIlwiO1xuICAgICAgbiB8fCBkICYmIGwua2V5ID09PSBcIiBcIiB8fCAkYy5pbmNsdWRlcyhsLmtleSkgJiYgKGwuY3VycmVudFRhcmdldC5jbGljaygpLCBsLnByZXZlbnREZWZhdWx0KCkpO1xuICAgIH0pXG4gIH0pKTtcbn0pLCBweSA9IC8qIEBfX1BVUkVfXyAqLyBoZSgoZSwgdCkgPT4ge1xuICBjb25zdCB7IF9fc2NvcGVNZW51OiBuLCBkaXNhYmxlZDogciA9ICExLCB0ZXh0VmFsdWU6IGksIC4uLm8gfSA9IGUsIGEgPSBmZihPYywgbiksIHMgPSBjeShuKSwgdSA9IF9lKG51bGwpLCBjID0gX3QodCwgdSksIFtmLCBsXSA9IFllKCExKSwgW2QsIHBdID0gWWUoXCJcIik7XG4gIHJldHVybiBGZSgoKSA9PiB7XG4gICAgY29uc3QgZyA9IHUuY3VycmVudDtcbiAgICBpZiAoZykge1xuICAgICAgdmFyIGg7XG4gICAgICBwKCgoaCA9IGcudGV4dENvbnRlbnQpICE9PSBudWxsICYmIGggIT09IHZvaWQgMCA/IGggOiBcIlwiKS50cmltKCkpO1xuICAgIH1cbiAgfSwgW1xuICAgIG8uY2hpbGRyZW5cbiAgXSksIC8qIEBfX1BVUkVfXyAqLyBZKFFpLkl0ZW1TbG90LCB7XG4gICAgc2NvcGU6IG4sXG4gICAgZGlzYWJsZWQ6IHIsXG4gICAgdGV4dFZhbHVlOiBpID8/IGRcbiAgfSwgLyogQF9fUFVSRV9fICovIFkoaCQsIGNlKHtcbiAgICBhc0NoaWxkOiAhMFxuICB9LCBzLCB7XG4gICAgZm9jdXNhYmxlOiAhclxuICB9KSwgLyogQF9fUFVSRV9fICovIFkoRnQuZGl2LCBjZSh7XG4gICAgcm9sZTogXCJtZW51aXRlbVwiLFxuICAgIFwiZGF0YS1oaWdobGlnaHRlZFwiOiBmID8gXCJcIiA6IHZvaWQgMCxcbiAgICBcImFyaWEtZGlzYWJsZWRcIjogciB8fCB2b2lkIDAsXG4gICAgXCJkYXRhLWRpc2FibGVkXCI6IHIgPyBcIlwiIDogdm9pZCAwXG4gIH0sIG8sIHtcbiAgICByZWY6IGMsXG4gICAgb25Qb2ludGVyTW92ZTogd2UoZS5vblBvaW50ZXJNb3ZlLCBlbygoZykgPT4ge1xuICAgICAgciA/IGEub25JdGVtTGVhdmUoZykgOiAoYS5vbkl0ZW1FbnRlcihnKSwgZy5kZWZhdWx0UHJldmVudGVkIHx8IGcuY3VycmVudFRhcmdldC5mb2N1cygpKTtcbiAgICB9KSksXG4gICAgb25Qb2ludGVyTGVhdmU6IHdlKGUub25Qb2ludGVyTGVhdmUsIGVvKFxuICAgICAgKGcpID0+IGEub25JdGVtTGVhdmUoZylcbiAgICApKSxcbiAgICBvbkZvY3VzOiB3ZShcbiAgICAgIGUub25Gb2N1cyxcbiAgICAgICgpID0+IGwoITApXG4gICAgKSxcbiAgICBvbkJsdXI6IHdlKFxuICAgICAgZS5vbkJsdXIsXG4gICAgICAoKSA9PiBsKCExKVxuICAgIClcbiAgfSkpKSk7XG59KSwgdk8gPSAvKiBAX19QVVJFX18gKi8gaGUoKGUsIHQpID0+IHtcbiAgY29uc3QgeyBjaGVja2VkOiBuID0gITEsIG9uQ2hlY2tlZENoYW5nZTogciwgLi4uaSB9ID0gZTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBZKGd5LCB7XG4gICAgc2NvcGU6IGUuX19zY29wZU1lbnUsXG4gICAgY2hlY2tlZDogblxuICB9LCAvKiBAX19QVVJFX18gKi8gWShwZiwgY2Uoe1xuICAgIHJvbGU6IFwibWVudWl0ZW1jaGVja2JveFwiLFxuICAgIFwiYXJpYS1jaGVja2VkXCI6IGthKG4pID8gXCJtaXhlZFwiIDogblxuICB9LCBpLCB7XG4gICAgcmVmOiB0LFxuICAgIFwiZGF0YS1zdGF0ZVwiOiBoZihuKSxcbiAgICBvblNlbGVjdDogd2UoXG4gICAgICBpLm9uU2VsZWN0LFxuICAgICAgKCkgPT4gciA9PSBudWxsID8gdm9pZCAwIDogcihrYShuKSA/ICEwIDogIW4pLFxuICAgICAge1xuICAgICAgICBjaGVja0ZvckRlZmF1bHRQcmV2ZW50ZWQ6ICExXG4gICAgICB9XG4gICAgKVxuICB9KSkpO1xufSksIG1PID0gXCJNZW51UmFkaW9Hcm91cFwiLCBbWlUsIHlPXSA9IGhyKG1PLCB7XG4gIHZhbHVlOiB2b2lkIDAsXG4gIG9uVmFsdWVDaGFuZ2U6ICgpID0+IHtcbiAgfVxufSksIGJPID0gXCJNZW51UmFkaW9JdGVtXCIsIHdPID0gLyogQF9fUFVSRV9fICovIGhlKChlLCB0KSA9PiB7XG4gIGNvbnN0IHsgdmFsdWU6IG4sIC4uLnIgfSA9IGUsIGkgPSB5TyhiTywgZS5fX3Njb3BlTWVudSksIG8gPSBuID09PSBpLnZhbHVlO1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIFkoZ3ksIHtcbiAgICBzY29wZTogZS5fX3Njb3BlTWVudSxcbiAgICBjaGVja2VkOiBvXG4gIH0sIC8qIEBfX1BVUkVfXyAqLyBZKHBmLCBjZSh7XG4gICAgcm9sZTogXCJtZW51aXRlbXJhZGlvXCIsXG4gICAgXCJhcmlhLWNoZWNrZWRcIjogb1xuICB9LCByLCB7XG4gICAgcmVmOiB0LFxuICAgIFwiZGF0YS1zdGF0ZVwiOiBoZihvKSxcbiAgICBvblNlbGVjdDogd2Uoci5vblNlbGVjdCwgKCkgPT4ge1xuICAgICAgdmFyIGE7XG4gICAgICByZXR1cm4gKGEgPSBpLm9uVmFsdWVDaGFuZ2UpID09PSBudWxsIHx8IGEgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGEuY2FsbChpLCBuKTtcbiAgICB9LCB7XG4gICAgICBjaGVja0ZvckRlZmF1bHRQcmV2ZW50ZWQ6ICExXG4gICAgfSlcbiAgfSkpKTtcbn0pLCBoeSA9IFwiTWVudUl0ZW1JbmRpY2F0b3JcIiwgW2d5LCB4T10gPSBocihoeSwge1xuICBjaGVja2VkOiAhMVxufSksIFNPID0gLyogQF9fUFVSRV9fICovIGhlKChlLCB0KSA9PiB7XG4gIGNvbnN0IHsgX19zY29wZU1lbnU6IG4sIGZvcmNlTW91bnQ6IHIsIC4uLmkgfSA9IGUsIG8gPSB4TyhoeSwgbik7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gWShCbywge1xuICAgIHByZXNlbnQ6IHIgfHwga2Eoby5jaGVja2VkKSB8fCBvLmNoZWNrZWQgPT09ICEwXG4gIH0sIC8qIEBfX1BVUkVfXyAqLyBZKEZ0LnNwYW4sIGNlKHt9LCBpLCB7XG4gICAgcmVmOiB0LFxuICAgIFwiZGF0YS1zdGF0ZVwiOiBoZihvLmNoZWNrZWQpXG4gIH0pKSk7XG59KSwgJE8gPSAvKiBAX19QVVJFX18gKi8gaGUoKGUsIHQpID0+IHtcbiAgY29uc3QgeyBfX3Njb3BlTWVudTogbiwgLi4uciB9ID0gZTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBZKEZ0LmRpdiwgY2Uoe1xuICAgIHJvbGU6IFwic2VwYXJhdG9yXCIsXG4gICAgXCJhcmlhLW9yaWVudGF0aW9uXCI6IFwiaG9yaXpvbnRhbFwiXG4gIH0sIHIsIHtcbiAgICByZWY6IHRcbiAgfSkpO1xufSksIE9PID0gXCJNZW51U3ViXCIsIFtKVSwgdnldID0gaHIoT08pLCBjYSA9IFwiTWVudVN1YlRyaWdnZXJcIiwgX08gPSAvKiBAX19QVVJFX18gKi8gaGUoKGUsIHQpID0+IHtcbiAgY29uc3QgbiA9IGdyKGNhLCBlLl9fc2NvcGVNZW51KSwgciA9IHpvKGNhLCBlLl9fc2NvcGVNZW51KSwgaSA9IHZ5KGNhLCBlLl9fc2NvcGVNZW51KSwgbyA9IGZmKGNhLCBlLl9fc2NvcGVNZW51KSwgYSA9IF9lKG51bGwpLCB7IHBvaW50ZXJHcmFjZVRpbWVyUmVmOiBzLCBvblBvaW50ZXJHcmFjZUludGVudENoYW5nZTogdSB9ID0gbywgYyA9IHtcbiAgICBfX3Njb3BlTWVudTogZS5fX3Njb3BlTWVudVxuICB9LCBmID0gdXQoKCkgPT4ge1xuICAgIGEuY3VycmVudCAmJiB3aW5kb3cuY2xlYXJUaW1lb3V0KGEuY3VycmVudCksIGEuY3VycmVudCA9IG51bGw7XG4gIH0sIFtdKTtcbiAgcmV0dXJuIEZlKFxuICAgICgpID0+IGYsXG4gICAgW1xuICAgICAgZlxuICAgIF1cbiAgKSwgRmUoKCkgPT4ge1xuICAgIGNvbnN0IGwgPSBzLmN1cnJlbnQ7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHdpbmRvdy5jbGVhclRpbWVvdXQobCksIHUobnVsbCk7XG4gICAgfTtcbiAgfSwgW1xuICAgIHMsXG4gICAgdVxuICBdKSwgLyogQF9fUFVSRV9fICovIFkobHksIGNlKHtcbiAgICBhc0NoaWxkOiAhMFxuICB9LCBjKSwgLyogQF9fUFVSRV9fICovIFkocHksIGNlKHtcbiAgICBpZDogaS50cmlnZ2VySWQsXG4gICAgXCJhcmlhLWhhc3BvcHVwXCI6IFwibWVudVwiLFxuICAgIFwiYXJpYS1leHBhbmRlZFwiOiBuLm9wZW4sXG4gICAgXCJhcmlhLWNvbnRyb2xzXCI6IGkuY29udGVudElkLFxuICAgIFwiZGF0YS1zdGF0ZVwiOiBteShuLm9wZW4pXG4gIH0sIGUsIHtcbiAgICByZWY6IE1zKHQsIGkub25UcmlnZ2VyQ2hhbmdlKSxcbiAgICBvbkNsaWNrOiAobCkgPT4ge1xuICAgICAgdmFyIGQ7XG4gICAgICAoZCA9IGUub25DbGljaykgPT09IG51bGwgfHwgZCA9PT0gdm9pZCAwIHx8IGQuY2FsbChlLCBsKSwgIShlLmRpc2FibGVkIHx8IGwuZGVmYXVsdFByZXZlbnRlZCkgJiYgKGwuY3VycmVudFRhcmdldC5mb2N1cygpLCBuLm9wZW4gfHwgbi5vbk9wZW5DaGFuZ2UoITApKTtcbiAgICB9LFxuICAgIG9uUG9pbnRlck1vdmU6IHdlKGUub25Qb2ludGVyTW92ZSwgZW8oKGwpID0+IHtcbiAgICAgIG8ub25JdGVtRW50ZXIobCksICFsLmRlZmF1bHRQcmV2ZW50ZWQgJiYgIWUuZGlzYWJsZWQgJiYgIW4ub3BlbiAmJiAhYS5jdXJyZW50ICYmIChvLm9uUG9pbnRlckdyYWNlSW50ZW50Q2hhbmdlKG51bGwpLCBhLmN1cnJlbnQgPSB3aW5kb3cuc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIG4ub25PcGVuQ2hhbmdlKCEwKSwgZigpO1xuICAgICAgfSwgMTAwKSk7XG4gICAgfSkpLFxuICAgIG9uUG9pbnRlckxlYXZlOiB3ZShlLm9uUG9pbnRlckxlYXZlLCBlbygobCkgPT4ge1xuICAgICAgdmFyIGQ7XG4gICAgICBmKCk7XG4gICAgICBjb25zdCBwID0gKGQgPSBuLmNvbnRlbnQpID09PSBudWxsIHx8IGQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICBpZiAocCkge1xuICAgICAgICB2YXIgZztcbiAgICAgICAgY29uc3QgaCA9IChnID0gbi5jb250ZW50KSA9PT0gbnVsbCB8fCBnID09PSB2b2lkIDAgPyB2b2lkIDAgOiBnLmRhdGFzZXQuc2lkZSwgdiA9IGggPT09IFwicmlnaHRcIiwgdyA9IHYgPyAtNSA6IDUsIGIgPSBwW3YgPyBcImxlZnRcIiA6IFwicmlnaHRcIl0sIHggPSBwW3YgPyBcInJpZ2h0XCIgOiBcImxlZnRcIl07XG4gICAgICAgIG8ub25Qb2ludGVyR3JhY2VJbnRlbnRDaGFuZ2Uoe1xuICAgICAgICAgIGFyZWE6IFtcbiAgICAgICAgICAgIC8vIGNvbnNpc3RlbnRseSB3aXRoaW4gcG9seWdvbiBib3VuZHNcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgeDogbC5jbGllbnRYICsgdyxcbiAgICAgICAgICAgICAgeTogbC5jbGllbnRZXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICB4OiBiLFxuICAgICAgICAgICAgICB5OiBwLnRvcFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgeCxcbiAgICAgICAgICAgICAgeTogcC50b3BcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHgsXG4gICAgICAgICAgICAgIHk6IHAuYm90dG9tXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICB4OiBiLFxuICAgICAgICAgICAgICB5OiBwLmJvdHRvbVxuICAgICAgICAgICAgfVxuICAgICAgICAgIF0sXG4gICAgICAgICAgc2lkZTogaFxuICAgICAgICB9KSwgd2luZG93LmNsZWFyVGltZW91dChzLmN1cnJlbnQpLCBzLmN1cnJlbnQgPSB3aW5kb3cuc2V0VGltZW91dChcbiAgICAgICAgICAoKSA9PiBvLm9uUG9pbnRlckdyYWNlSW50ZW50Q2hhbmdlKG51bGwpLFxuICAgICAgICAgIDMwMFxuICAgICAgICApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKG8ub25UcmlnZ2VyTGVhdmUobCksIGwuZGVmYXVsdFByZXZlbnRlZClcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIG8ub25Qb2ludGVyR3JhY2VJbnRlbnRDaGFuZ2UobnVsbCk7XG4gICAgICB9XG4gICAgfSkpLFxuICAgIG9uS2V5RG93bjogd2UoZS5vbktleURvd24sIChsKSA9PiB7XG4gICAgICBjb25zdCBkID0gby5zZWFyY2hSZWYuY3VycmVudCAhPT0gXCJcIjtcbiAgICAgIGlmICghKGUuZGlzYWJsZWQgfHwgZCAmJiBsLmtleSA9PT0gXCIgXCIpICYmIG5PW3IuZGlyXS5pbmNsdWRlcyhsLmtleSkpIHtcbiAgICAgICAgdmFyIHA7XG4gICAgICAgIG4ub25PcGVuQ2hhbmdlKCEwKSwgKHAgPSBuLmNvbnRlbnQpID09PSBudWxsIHx8IHAgPT09IHZvaWQgMCB8fCBwLmZvY3VzKCksIGwucHJldmVudERlZmF1bHQoKTtcbiAgICAgIH1cbiAgICB9KVxuICB9KSkpO1xufSksIEFPID0gXCJNZW51U3ViQ29udGVudFwiLCBQTyA9IC8qIEBfX1BVUkVfXyAqLyBoZSgoZSwgdCkgPT4ge1xuICBjb25zdCBuID0gZHkoWXQsIGUuX19zY29wZU1lbnUpLCB7IGZvcmNlTW91bnQ6IHIgPSBuLmZvcmNlTW91bnQsIC4uLmkgfSA9IGUsIG8gPSBncihZdCwgZS5fX3Njb3BlTWVudSksIGEgPSB6byhZdCwgZS5fX3Njb3BlTWVudSksIHMgPSB2eShBTywgZS5fX3Njb3BlTWVudSksIHUgPSBfZShudWxsKSwgYyA9IF90KHQsIHUpO1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIFkoUWkuUHJvdmlkZXIsIHtcbiAgICBzY29wZTogZS5fX3Njb3BlTWVudVxuICB9LCAvKiBAX19QVVJFX18gKi8gWShCbywge1xuICAgIHByZXNlbnQ6IHIgfHwgby5vcGVuXG4gIH0sIC8qIEBfX1BVUkVfXyAqLyBZKFFpLlNsb3QsIHtcbiAgICBzY29wZTogZS5fX3Njb3BlTWVudVxuICB9LCAvKiBAX19QVVJFX18gKi8gWShkZiwgY2Uoe1xuICAgIGlkOiBzLmNvbnRlbnRJZCxcbiAgICBcImFyaWEtbGFiZWxsZWRieVwiOiBzLnRyaWdnZXJJZFxuICB9LCBpLCB7XG4gICAgcmVmOiBjLFxuICAgIGFsaWduOiBcInN0YXJ0XCIsXG4gICAgc2lkZTogYS5kaXIgPT09IFwicnRsXCIgPyBcImxlZnRcIiA6IFwicmlnaHRcIixcbiAgICBkaXNhYmxlT3V0c2lkZVBvaW50ZXJFdmVudHM6ICExLFxuICAgIGRpc2FibGVPdXRzaWRlU2Nyb2xsOiAhMSxcbiAgICB0cmFwRm9jdXM6ICExLFxuICAgIG9uT3BlbkF1dG9Gb2N1czogKGYpID0+IHtcbiAgICAgIHZhciBsO1xuICAgICAgYS5pc1VzaW5nS2V5Ym9hcmRSZWYuY3VycmVudCAmJiAoKGwgPSB1LmN1cnJlbnQpID09PSBudWxsIHx8IGwgPT09IHZvaWQgMCB8fCBsLmZvY3VzKCkpLCBmLnByZXZlbnREZWZhdWx0KCk7XG4gICAgfSxcbiAgICBvbkNsb3NlQXV0b0ZvY3VzOiAoZikgPT4gZi5wcmV2ZW50RGVmYXVsdCgpLFxuICAgIG9uRm9jdXNPdXRzaWRlOiB3ZShlLm9uRm9jdXNPdXRzaWRlLCAoZikgPT4ge1xuICAgICAgZi50YXJnZXQgIT09IHMudHJpZ2dlciAmJiBvLm9uT3BlbkNoYW5nZSghMSk7XG4gICAgfSksXG4gICAgb25Fc2NhcGVLZXlEb3duOiB3ZShlLm9uRXNjYXBlS2V5RG93biwgKGYpID0+IHtcbiAgICAgIGEub25DbG9zZSgpLCBmLnByZXZlbnREZWZhdWx0KCk7XG4gICAgfSksXG4gICAgb25LZXlEb3duOiB3ZShlLm9uS2V5RG93biwgKGYpID0+IHtcbiAgICAgIGNvbnN0IGwgPSBmLmN1cnJlbnRUYXJnZXQuY29udGFpbnMoZi50YXJnZXQpLCBkID0gck9bYS5kaXJdLmluY2x1ZGVzKGYua2V5KTtcbiAgICAgIGlmIChsICYmIGQpIHtcbiAgICAgICAgdmFyIHA7XG4gICAgICAgIG8ub25PcGVuQ2hhbmdlKCExKSwgKHAgPSBzLnRyaWdnZXIpID09PSBudWxsIHx8IHAgPT09IHZvaWQgMCB8fCBwLmZvY3VzKCksIGYucHJldmVudERlZmF1bHQoKTtcbiAgICAgIH1cbiAgICB9KVxuICB9KSkpKSk7XG59KTtcbmZ1bmN0aW9uIG15KGUpIHtcbiAgcmV0dXJuIGUgPyBcIm9wZW5cIiA6IFwiY2xvc2VkXCI7XG59XG5mdW5jdGlvbiBrYShlKSB7XG4gIHJldHVybiBlID09PSBcImluZGV0ZXJtaW5hdGVcIjtcbn1cbmZ1bmN0aW9uIGhmKGUpIHtcbiAgcmV0dXJuIGthKGUpID8gXCJpbmRldGVybWluYXRlXCIgOiBlID8gXCJjaGVja2VkXCIgOiBcInVuY2hlY2tlZFwiO1xufVxuZnVuY3Rpb24gQ08oZSkge1xuICBjb25zdCB0ID0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudDtcbiAgZm9yIChjb25zdCBuIG9mIGUpXG4gICAgaWYgKG4gPT09IHQgfHwgKG4uZm9jdXMoKSwgZG9jdW1lbnQuYWN0aXZlRWxlbWVudCAhPT0gdCkpXG4gICAgICByZXR1cm47XG59XG5mdW5jdGlvbiBFTyhlLCB0KSB7XG4gIHJldHVybiBlLm1hcChcbiAgICAobiwgcikgPT4gZVsodCArIHIpICUgZS5sZW5ndGhdXG4gICk7XG59XG5mdW5jdGlvbiBUTyhlLCB0LCBuKSB7XG4gIGNvbnN0IGkgPSB0Lmxlbmd0aCA+IDEgJiYgQXJyYXkuZnJvbSh0KS5ldmVyeShcbiAgICAoYykgPT4gYyA9PT0gdFswXVxuICApID8gdFswXSA6IHQsIG8gPSBuID8gZS5pbmRleE9mKG4pIDogLTE7XG4gIGxldCBhID0gRU8oZSwgTWF0aC5tYXgobywgMCkpO1xuICBpLmxlbmd0aCA9PT0gMSAmJiAoYSA9IGEuZmlsdGVyKFxuICAgIChjKSA9PiBjICE9PSBuXG4gICkpO1xuICBjb25zdCB1ID0gYS5maW5kKFxuICAgIChjKSA9PiBjLnRvTG93ZXJDYXNlKCkuc3RhcnRzV2l0aChpLnRvTG93ZXJDYXNlKCkpXG4gICk7XG4gIHJldHVybiB1ICE9PSBuID8gdSA6IHZvaWQgMDtcbn1cbmZ1bmN0aW9uIE1PKGUsIHQpIHtcbiAgY29uc3QgeyB4OiBuLCB5OiByIH0gPSBlO1xuICBsZXQgaSA9ICExO1xuICBmb3IgKGxldCBvID0gMCwgYSA9IHQubGVuZ3RoIC0gMTsgbyA8IHQubGVuZ3RoOyBhID0gbysrKSB7XG4gICAgY29uc3QgcyA9IHRbb10ueCwgdSA9IHRbb10ueSwgYyA9IHRbYV0ueCwgZiA9IHRbYV0ueTtcbiAgICB1ID4gciAhPSBmID4gciAmJiBuIDwgKGMgLSBzKSAqIChyIC0gdSkgLyAoZiAtIHUpICsgcyAmJiAoaSA9ICFpKTtcbiAgfVxuICByZXR1cm4gaTtcbn1cbmZ1bmN0aW9uIFJPKGUsIHQpIHtcbiAgaWYgKCF0KVxuICAgIHJldHVybiAhMTtcbiAgY29uc3QgbiA9IHtcbiAgICB4OiBlLmNsaWVudFgsXG4gICAgeTogZS5jbGllbnRZXG4gIH07XG4gIHJldHVybiBNTyhuLCB0KTtcbn1cbmZ1bmN0aW9uIGVvKGUpIHtcbiAgcmV0dXJuICh0KSA9PiB0LnBvaW50ZXJUeXBlID09PSBcIm1vdXNlXCIgPyBlKHQpIDogdm9pZCAwO1xufVxuY29uc3QgSU8gPSB1Tywgak8gPSBseSwga08gPSBsTywgRE8gPSBkTywgTk8gPSBnTywgRk8gPSBwZiwgTE8gPSB2TywgQk8gPSB3Tywgek8gPSBTTywgVk8gPSAkTywgR08gPSBfTywgV08gPSBQTywgeXkgPSBcIkRyb3Bkb3duTWVudVwiLCBbVU8sIFFVXSA9IEZvKHl5LCBbXG4gIHV5XG5dKSwgTHQgPSB1eSgpLCBbSE8sIGJ5XSA9IFVPKHl5KSwgcU8gPSAoZSkgPT4ge1xuICBjb25zdCB7IF9fc2NvcGVEcm9wZG93bk1lbnU6IHQsIGNoaWxkcmVuOiBuLCBkaXI6IHIsIG9wZW46IGksIGRlZmF1bHRPcGVuOiBvLCBvbk9wZW5DaGFuZ2U6IGEsIG1vZGFsOiBzID0gITAgfSA9IGUsIHUgPSBMdCh0KSwgYyA9IF9lKG51bGwpLCBbZiA9ICExLCBsXSA9IENtKHtcbiAgICBwcm9wOiBpLFxuICAgIGRlZmF1bHRQcm9wOiBvLFxuICAgIG9uQ2hhbmdlOiBhXG4gIH0pO1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIFkoSE8sIHtcbiAgICBzY29wZTogdCxcbiAgICB0cmlnZ2VySWQ6IHljKCksXG4gICAgdHJpZ2dlclJlZjogYyxcbiAgICBjb250ZW50SWQ6IHljKCksXG4gICAgb3BlbjogZixcbiAgICBvbk9wZW5DaGFuZ2U6IGwsXG4gICAgb25PcGVuVG9nZ2xlOiB1dChcbiAgICAgICgpID0+IGwoXG4gICAgICAgIChkKSA9PiAhZFxuICAgICAgKSxcbiAgICAgIFtcbiAgICAgICAgbFxuICAgICAgXVxuICAgICksXG4gICAgbW9kYWw6IHNcbiAgfSwgLyogQF9fUFVSRV9fICovIFkoSU8sIGNlKHt9LCB1LCB7XG4gICAgb3BlbjogZixcbiAgICBvbk9wZW5DaGFuZ2U6IGwsXG4gICAgZGlyOiByLFxuICAgIG1vZGFsOiBzXG4gIH0pLCBuKSk7XG59LCBLTyA9IFwiRHJvcGRvd25NZW51VHJpZ2dlclwiLCBZTyA9IC8qIEBfX1BVUkVfXyAqLyBoZSgoZSwgdCkgPT4ge1xuICBjb25zdCB7IF9fc2NvcGVEcm9wZG93bk1lbnU6IG4sIGRpc2FibGVkOiByID0gITEsIC4uLmkgfSA9IGUsIG8gPSBieShLTywgbiksIGEgPSBMdChuKTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBZKGpPLCBjZSh7XG4gICAgYXNDaGlsZDogITBcbiAgfSwgYSksIC8qIEBfX1BVUkVfXyAqLyBZKEZ0LmJ1dHRvbiwgY2Uoe1xuICAgIHR5cGU6IFwiYnV0dG9uXCIsXG4gICAgaWQ6IG8udHJpZ2dlcklkLFxuICAgIFwiYXJpYS1oYXNwb3B1cFwiOiBcIm1lbnVcIixcbiAgICBcImFyaWEtZXhwYW5kZWRcIjogby5vcGVuLFxuICAgIFwiYXJpYS1jb250cm9sc1wiOiBvLm9wZW4gPyBvLmNvbnRlbnRJZCA6IHZvaWQgMCxcbiAgICBcImRhdGEtc3RhdGVcIjogby5vcGVuID8gXCJvcGVuXCIgOiBcImNsb3NlZFwiLFxuICAgIFwiZGF0YS1kaXNhYmxlZFwiOiByID8gXCJcIiA6IHZvaWQgMCxcbiAgICBkaXNhYmxlZDogclxuICB9LCBpLCB7XG4gICAgcmVmOiBNcyh0LCBvLnRyaWdnZXJSZWYpLFxuICAgIG9uUG9pbnRlckRvd246IHdlKGUub25Qb2ludGVyRG93biwgKHMpID0+IHtcbiAgICAgICFyICYmIHMuYnV0dG9uID09PSAwICYmIHMuY3RybEtleSA9PT0gITEgJiYgKG8ub25PcGVuVG9nZ2xlKCksIG8ub3BlbiB8fCBzLnByZXZlbnREZWZhdWx0KCkpO1xuICAgIH0pLFxuICAgIG9uS2V5RG93bjogd2UoZS5vbktleURvd24sIChzKSA9PiB7XG4gICAgICByIHx8IChbXG4gICAgICAgIFwiRW50ZXJcIixcbiAgICAgICAgXCIgXCJcbiAgICAgIF0uaW5jbHVkZXMocy5rZXkpICYmIG8ub25PcGVuVG9nZ2xlKCksIHMua2V5ID09PSBcIkFycm93RG93blwiICYmIG8ub25PcGVuQ2hhbmdlKCEwKSwgW1xuICAgICAgICBcIkVudGVyXCIsXG4gICAgICAgIFwiIFwiLFxuICAgICAgICBcIkFycm93RG93blwiXG4gICAgICBdLmluY2x1ZGVzKHMua2V5KSAmJiBzLnByZXZlbnREZWZhdWx0KCkpO1xuICAgIH0pXG4gIH0pKSk7XG59KSwgWE8gPSAoZSkgPT4ge1xuICBjb25zdCB7IF9fc2NvcGVEcm9wZG93bk1lbnU6IHQsIC4uLm4gfSA9IGUsIHIgPSBMdCh0KTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBZKGtPLCBjZSh7fSwgciwgbikpO1xufSwgWk8gPSBcIkRyb3Bkb3duTWVudUNvbnRlbnRcIiwgSk8gPSAvKiBAX19QVVJFX18gKi8gaGUoKGUsIHQpID0+IHtcbiAgY29uc3QgeyBfX3Njb3BlRHJvcGRvd25NZW51OiBuLCAuLi5yIH0gPSBlLCBpID0gYnkoWk8sIG4pLCBvID0gTHQobiksIGEgPSBfZSghMSk7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gWShETywgY2Uoe1xuICAgIGlkOiBpLmNvbnRlbnRJZCxcbiAgICBcImFyaWEtbGFiZWxsZWRieVwiOiBpLnRyaWdnZXJJZFxuICB9LCBvLCByLCB7XG4gICAgcmVmOiB0LFxuICAgIG9uQ2xvc2VBdXRvRm9jdXM6IHdlKGUub25DbG9zZUF1dG9Gb2N1cywgKHMpID0+IHtcbiAgICAgIHZhciB1O1xuICAgICAgYS5jdXJyZW50IHx8ICh1ID0gaS50cmlnZ2VyUmVmLmN1cnJlbnQpID09PSBudWxsIHx8IHUgPT09IHZvaWQgMCB8fCB1LmZvY3VzKCksIGEuY3VycmVudCA9ICExLCBzLnByZXZlbnREZWZhdWx0KCk7XG4gICAgfSksXG4gICAgb25JbnRlcmFjdE91dHNpZGU6IHdlKGUub25JbnRlcmFjdE91dHNpZGUsIChzKSA9PiB7XG4gICAgICBjb25zdCB1ID0gcy5kZXRhaWwub3JpZ2luYWxFdmVudCwgYyA9IHUuYnV0dG9uID09PSAwICYmIHUuY3RybEtleSA9PT0gITAsIGYgPSB1LmJ1dHRvbiA9PT0gMiB8fCBjO1xuICAgICAgKCFpLm1vZGFsIHx8IGYpICYmIChhLmN1cnJlbnQgPSAhMCk7XG4gICAgfSksXG4gICAgc3R5bGU6IHtcbiAgICAgIC4uLmUuc3R5bGUsXG4gICAgICBcIi0tcmFkaXgtZHJvcGRvd24tbWVudS1jb250ZW50LXRyYW5zZm9ybS1vcmlnaW5cIjogXCJ2YXIoLS1yYWRpeC1wb3BwZXItdHJhbnNmb3JtLW9yaWdpbilcIixcbiAgICAgIFwiLS1yYWRpeC1kcm9wZG93bi1tZW51LWNvbnRlbnQtYXZhaWxhYmxlLXdpZHRoXCI6IFwidmFyKC0tcmFkaXgtcG9wcGVyLWF2YWlsYWJsZS13aWR0aClcIixcbiAgICAgIFwiLS1yYWRpeC1kcm9wZG93bi1tZW51LWNvbnRlbnQtYXZhaWxhYmxlLWhlaWdodFwiOiBcInZhcigtLXJhZGl4LXBvcHBlci1hdmFpbGFibGUtaGVpZ2h0KVwiLFxuICAgICAgXCItLXJhZGl4LWRyb3Bkb3duLW1lbnUtdHJpZ2dlci13aWR0aFwiOiBcInZhcigtLXJhZGl4LXBvcHBlci1hbmNob3Itd2lkdGgpXCIsXG4gICAgICBcIi0tcmFkaXgtZHJvcGRvd24tbWVudS10cmlnZ2VyLWhlaWdodFwiOiBcInZhcigtLXJhZGl4LXBvcHBlci1hbmNob3ItaGVpZ2h0KVwiXG4gICAgfVxuICB9KSk7XG59KSwgUU8gPSAvKiBAX19QVVJFX18gKi8gaGUoKGUsIHQpID0+IHtcbiAgY29uc3QgeyBfX3Njb3BlRHJvcGRvd25NZW51OiBuLCAuLi5yIH0gPSBlLCBpID0gTHQobik7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gWShOTywgY2Uoe30sIGksIHIsIHtcbiAgICByZWY6IHRcbiAgfSkpO1xufSksIGVfID0gLyogQF9fUFVSRV9fICovIGhlKChlLCB0KSA9PiB7XG4gIGNvbnN0IHsgX19zY29wZURyb3Bkb3duTWVudTogbiwgLi4uciB9ID0gZSwgaSA9IEx0KG4pO1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIFkoRk8sIGNlKHt9LCBpLCByLCB7XG4gICAgcmVmOiB0XG4gIH0pKTtcbn0pLCB0XyA9IC8qIEBfX1BVUkVfXyAqLyBoZSgoZSwgdCkgPT4ge1xuICBjb25zdCB7IF9fc2NvcGVEcm9wZG93bk1lbnU6IG4sIC4uLnIgfSA9IGUsIGkgPSBMdChuKTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBZKExPLCBjZSh7fSwgaSwgciwge1xuICAgIHJlZjogdFxuICB9KSk7XG59KSwgbl8gPSAvKiBAX19QVVJFX18gKi8gaGUoKGUsIHQpID0+IHtcbiAgY29uc3QgeyBfX3Njb3BlRHJvcGRvd25NZW51OiBuLCAuLi5yIH0gPSBlLCBpID0gTHQobik7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gWShCTywgY2Uoe30sIGksIHIsIHtcbiAgICByZWY6IHRcbiAgfSkpO1xufSksIHJfID0gLyogQF9fUFVSRV9fICovIGhlKChlLCB0KSA9PiB7XG4gIGNvbnN0IHsgX19zY29wZURyb3Bkb3duTWVudTogbiwgLi4uciB9ID0gZSwgaSA9IEx0KG4pO1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIFkoek8sIGNlKHt9LCBpLCByLCB7XG4gICAgcmVmOiB0XG4gIH0pKTtcbn0pLCBpXyA9IC8qIEBfX1BVUkVfXyAqLyBoZSgoZSwgdCkgPT4ge1xuICBjb25zdCB7IF9fc2NvcGVEcm9wZG93bk1lbnU6IG4sIC4uLnIgfSA9IGUsIGkgPSBMdChuKTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBZKFZPLCBjZSh7fSwgaSwgciwge1xuICAgIHJlZjogdFxuICB9KSk7XG59KSwgb18gPSAvKiBAX19QVVJFX18gKi8gaGUoKGUsIHQpID0+IHtcbiAgY29uc3QgeyBfX3Njb3BlRHJvcGRvd25NZW51OiBuLCAuLi5yIH0gPSBlLCBpID0gTHQobik7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gWShHTywgY2Uoe30sIGksIHIsIHtcbiAgICByZWY6IHRcbiAgfSkpO1xufSksIGFfID0gLyogQF9fUFVSRV9fICovIGhlKChlLCB0KSA9PiB7XG4gIGNvbnN0IHsgX19zY29wZURyb3Bkb3duTWVudTogbiwgLi4uciB9ID0gZSwgaSA9IEx0KG4pO1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIFkoV08sIGNlKHt9LCBpLCByLCB7XG4gICAgcmVmOiB0LFxuICAgIHN0eWxlOiB7XG4gICAgICAuLi5lLnN0eWxlLFxuICAgICAgXCItLXJhZGl4LWRyb3Bkb3duLW1lbnUtY29udGVudC10cmFuc2Zvcm0tb3JpZ2luXCI6IFwidmFyKC0tcmFkaXgtcG9wcGVyLXRyYW5zZm9ybS1vcmlnaW4pXCIsXG4gICAgICBcIi0tcmFkaXgtZHJvcGRvd24tbWVudS1jb250ZW50LWF2YWlsYWJsZS13aWR0aFwiOiBcInZhcigtLXJhZGl4LXBvcHBlci1hdmFpbGFibGUtd2lkdGgpXCIsXG4gICAgICBcIi0tcmFkaXgtZHJvcGRvd24tbWVudS1jb250ZW50LWF2YWlsYWJsZS1oZWlnaHRcIjogXCJ2YXIoLS1yYWRpeC1wb3BwZXItYXZhaWxhYmxlLWhlaWdodClcIixcbiAgICAgIFwiLS1yYWRpeC1kcm9wZG93bi1tZW51LXRyaWdnZXItd2lkdGhcIjogXCJ2YXIoLS1yYWRpeC1wb3BwZXItYW5jaG9yLXdpZHRoKVwiLFxuICAgICAgXCItLXJhZGl4LWRyb3Bkb3duLW1lbnUtdHJpZ2dlci1oZWlnaHRcIjogXCJ2YXIoLS1yYWRpeC1wb3BwZXItYW5jaG9yLWhlaWdodClcIlxuICAgIH1cbiAgfSkpO1xufSksIHNfID0gcU8sIHVfID0gWU8sIGNfID0gWE8sIHd5ID0gSk8sIHh5ID0gUU8sIFN5ID0gZV8sICR5ID0gdF8sIE95ID0gbl8sIF95ID0gcl8sIEF5ID0gaV8sIFB5ID0gb18sIEN5ID0gYV8sIEV5ID0gc18sIFR5ID0gdV8sIGxfID0gSC5mb3J3YXJkUmVmKCh7IGNsYXNzTmFtZTogZSwgaW5zZXQ6IHQsIGNoaWxkcmVuOiBuLCAuLi5yIH0sIGkpID0+IC8qIEBfX1BVUkVfXyAqLyB6ZShcbiAgUHksXG4gIHtcbiAgICByZWY6IGksXG4gICAgY2xhc3NOYW1lOiBMZShcbiAgICAgIFwiZmxleCBjdXJzb3ItZGVmYXVsdCBzZWxlY3Qtbm9uZSBpdGVtcy1jZW50ZXIgcm91bmRlZC1zbSBweC0yIHB5LTEuNSB0ZXh0LXNtIG91dGxpbmUtbm9uZSBmb2N1czpiZy1hY2NlbnQgZGF0YS1bc3RhdGU9b3Blbl06YmctYWNjZW50XCIsXG4gICAgICB0ICYmIFwicGwtOFwiLFxuICAgICAgZVxuICAgICksXG4gICAgLi4ucixcbiAgICBjaGlsZHJlbjogW1xuICAgICAgbixcbiAgICAgIC8qIEBfX1BVUkVfXyAqLyBYKGcxLCB7IGNsYXNzTmFtZTogXCJtbC1hdXRvIGgtNCB3LTRcIiB9KVxuICAgIF1cbiAgfVxuKSk7XG5sXy5kaXNwbGF5TmFtZSA9IFB5LmRpc3BsYXlOYW1lO1xuY29uc3QgZl8gPSBILmZvcndhcmRSZWYoKHsgY2xhc3NOYW1lOiBlLCAuLi50IH0sIG4pID0+IC8qIEBfX1BVUkVfXyAqLyBYKFxuICBDeSxcbiAge1xuICAgIHJlZjogbixcbiAgICBjbGFzc05hbWU6IExlKFxuICAgICAgXCJ6LTUwIG1pbi13LVs4cmVtXSBvdmVyZmxvdy1oaWRkZW4gcm91bmRlZC1tZCBib3JkZXIgYmctcG9wb3ZlciBwLTEgdGV4dC1wb3BvdmVyLWZvcmVncm91bmQgc2hhZG93LWxnIGRhdGEtW3N0YXRlPW9wZW5dOmFuaW1hdGUtaW4gZGF0YS1bc3RhdGU9Y2xvc2VkXTphbmltYXRlLW91dCBkYXRhLVtzdGF0ZT1jbG9zZWRdOmZhZGUtb3V0LTAgZGF0YS1bc3RhdGU9b3Blbl06ZmFkZS1pbi0wIGRhdGEtW3N0YXRlPWNsb3NlZF06em9vbS1vdXQtOTUgZGF0YS1bc3RhdGU9b3Blbl06em9vbS1pbi05NSBkYXRhLVtzaWRlPWJvdHRvbV06c2xpZGUtaW4tZnJvbS10b3AtMiBkYXRhLVtzaWRlPWxlZnRdOnNsaWRlLWluLWZyb20tcmlnaHQtMiBkYXRhLVtzaWRlPXJpZ2h0XTpzbGlkZS1pbi1mcm9tLWxlZnQtMiBkYXRhLVtzaWRlPXRvcF06c2xpZGUtaW4tZnJvbS1ib3R0b20tMlwiLFxuICAgICAgZVxuICAgICksXG4gICAgLi4udFxuICB9XG4pKTtcbmZfLmRpc3BsYXlOYW1lID0gQ3kuZGlzcGxheU5hbWU7XG5jb25zdCBnZiA9IEguZm9yd2FyZFJlZigoeyBjbGFzc05hbWU6IGUsIHNpZGVPZmZzZXQ6IHQgPSA0LCAuLi5uIH0sIHIpID0+IC8qIEBfX1BVUkVfXyAqLyBYKGNfLCB7IGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8gWChcbiAgd3ksXG4gIHtcbiAgICByZWY6IHIsXG4gICAgc2lkZU9mZnNldDogdCxcbiAgICBjbGFzc05hbWU6IExlKFxuICAgICAgXCJ6LTUwIG1pbi13LVs4cmVtXSBvdmVyZmxvdy1oaWRkZW4gcm91bmRlZC1tZCBib3JkZXIgYmctcG9wb3ZlciBwLTEgdGV4dC1wb3BvdmVyLWZvcmVncm91bmQgc2hhZG93LW1kIGRhdGEtW3N0YXRlPW9wZW5dOmFuaW1hdGUtaW4gZGF0YS1bc3RhdGU9Y2xvc2VkXTphbmltYXRlLW91dCBkYXRhLVtzdGF0ZT1jbG9zZWRdOmZhZGUtb3V0LTAgZGF0YS1bc3RhdGU9b3Blbl06ZmFkZS1pbi0wIGRhdGEtW3N0YXRlPWNsb3NlZF06em9vbS1vdXQtOTUgZGF0YS1bc3RhdGU9b3Blbl06em9vbS1pbi05NSBkYXRhLVtzaWRlPWJvdHRvbV06c2xpZGUtaW4tZnJvbS10b3AtMiBkYXRhLVtzaWRlPWxlZnRdOnNsaWRlLWluLWZyb20tcmlnaHQtMiBkYXRhLVtzaWRlPXJpZ2h0XTpzbGlkZS1pbi1mcm9tLWxlZnQtMiBkYXRhLVtzaWRlPXRvcF06c2xpZGUtaW4tZnJvbS1ib3R0b20tMlwiLFxuICAgICAgZVxuICAgICksXG4gICAgLi4ublxuICB9XG4pIH0pKTtcbmdmLmRpc3BsYXlOYW1lID0gd3kuZGlzcGxheU5hbWU7XG5jb25zdCBFYSA9IEguZm9yd2FyZFJlZigoeyBjbGFzc05hbWU6IGUsIGluc2V0OiB0LCAuLi5uIH0sIHIpID0+IC8qIEBfX1BVUkVfXyAqLyBYKFxuICBTeSxcbiAge1xuICAgIHJlZjogcixcbiAgICBjbGFzc05hbWU6IExlKFxuICAgICAgXCJyZWxhdGl2ZSBmbGV4IGN1cnNvci1kZWZhdWx0IHNlbGVjdC1ub25lIGl0ZW1zLWNlbnRlciByb3VuZGVkLXNtIHB4LTIgcHktMS41IHRleHQtc20gb3V0bGluZS1ub25lIHRyYW5zaXRpb24tY29sb3JzIGZvY3VzOmJnLWFjY2VudCBmb2N1czp0ZXh0LWFjY2VudC1mb3JlZ3JvdW5kIGRhdGEtW2Rpc2FibGVkXTpwb2ludGVyLWV2ZW50cy1ub25lIGRhdGEtW2Rpc2FibGVkXTpvcGFjaXR5LTUwXCIsXG4gICAgICB0ICYmIFwicGwtOFwiLFxuICAgICAgZVxuICAgICksXG4gICAgLi4ublxuICB9XG4pKTtcbkVhLmRpc3BsYXlOYW1lID0gU3kuZGlzcGxheU5hbWU7XG5jb25zdCBNeSA9IEguZm9yd2FyZFJlZigoeyBjbGFzc05hbWU6IGUsIGNoaWxkcmVuOiB0LCBjaGVja2VkOiBuLCAuLi5yIH0sIGkpID0+IC8qIEBfX1BVUkVfXyAqLyB6ZShcbiAgJHksXG4gIHtcbiAgICByZWY6IGksXG4gICAgY2xhc3NOYW1lOiBMZShcbiAgICAgIFwicmVsYXRpdmUgZmxleCBjdXJzb3ItZGVmYXVsdCBzZWxlY3Qtbm9uZSBpdGVtcy1jZW50ZXIgcm91bmRlZC1zbSBweS0xLjUgcGwtOCBwci0yIHRleHQtc20gb3V0bGluZS1ub25lIHRyYW5zaXRpb24tY29sb3JzIGZvY3VzOmJnLWFjY2VudCBmb2N1czp0ZXh0LWFjY2VudC1mb3JlZ3JvdW5kIGRhdGEtW2Rpc2FibGVkXTpwb2ludGVyLWV2ZW50cy1ub25lIGRhdGEtW2Rpc2FibGVkXTpvcGFjaXR5LTUwXCIsXG4gICAgICBlXG4gICAgKSxcbiAgICBjaGVja2VkOiBuLFxuICAgIC4uLnIsXG4gICAgY2hpbGRyZW46IFtcbiAgICAgIC8qIEBfX1BVUkVfXyAqLyBYKFwic3BhblwiLCB7IGNsYXNzTmFtZTogXCJhYnNvbHV0ZSBsZWZ0LTIgZmxleCBoLTMuNSB3LTMuNSBpdGVtcy1jZW50ZXIganVzdGlmeS1jZW50ZXJcIiwgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBYKF95LCB7IGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8gWCh4bSwgeyBjbGFzc05hbWU6IFwiaC00IHctNFwiIH0pIH0pIH0pLFxuICAgICAgdFxuICAgIF1cbiAgfVxuKSk7XG5NeS5kaXNwbGF5TmFtZSA9ICR5LmRpc3BsYXlOYW1lO1xuY29uc3QgZF8gPSBILmZvcndhcmRSZWYoKHsgY2xhc3NOYW1lOiBlLCBjaGlsZHJlbjogdCwgLi4ubiB9LCByKSA9PiAvKiBAX19QVVJFX18gKi8gemUoXG4gIE95LFxuICB7XG4gICAgcmVmOiByLFxuICAgIGNsYXNzTmFtZTogTGUoXG4gICAgICBcInJlbGF0aXZlIGZsZXggY3Vyc29yLWRlZmF1bHQgc2VsZWN0LW5vbmUgaXRlbXMtY2VudGVyIHJvdW5kZWQtc20gcHktMS41IHBsLTggcHItMiB0ZXh0LXNtIG91dGxpbmUtbm9uZSB0cmFuc2l0aW9uLWNvbG9ycyBmb2N1czpiZy1hY2NlbnQgZm9jdXM6dGV4dC1hY2NlbnQtZm9yZWdyb3VuZCBkYXRhLVtkaXNhYmxlZF06cG9pbnRlci1ldmVudHMtbm9uZSBkYXRhLVtkaXNhYmxlZF06b3BhY2l0eS01MFwiLFxuICAgICAgZVxuICAgICksXG4gICAgLi4ubixcbiAgICBjaGlsZHJlbjogW1xuICAgICAgLyogQF9fUFVSRV9fICovIFgoXCJzcGFuXCIsIHsgY2xhc3NOYW1lOiBcImFic29sdXRlIGxlZnQtMiBmbGV4IGgtMy41IHctMy41IGl0ZW1zLWNlbnRlciBqdXN0aWZ5LWNlbnRlclwiLCBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIFgoX3ksIHsgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBYKHYxLCB7IGNsYXNzTmFtZTogXCJoLTIgdy0yIGZpbGwtY3VycmVudFwiIH0pIH0pIH0pLFxuICAgICAgdFxuICAgIF1cbiAgfVxuKSk7XG5kXy5kaXNwbGF5TmFtZSA9IE95LmRpc3BsYXlOYW1lO1xuY29uc3QgcF8gPSBILmZvcndhcmRSZWYoKHsgY2xhc3NOYW1lOiBlLCBpbnNldDogdCwgLi4ubiB9LCByKSA9PiAvKiBAX19QVVJFX18gKi8gWChcbiAgeHksXG4gIHtcbiAgICByZWY6IHIsXG4gICAgY2xhc3NOYW1lOiBMZShcbiAgICAgIFwicHgtMiBweS0xLjUgdGV4dC1zbSBmb250LXNlbWlib2xkXCIsXG4gICAgICB0ICYmIFwicGwtOFwiLFxuICAgICAgZVxuICAgICksXG4gICAgLi4ublxuICB9XG4pKTtcbnBfLmRpc3BsYXlOYW1lID0geHkuZGlzcGxheU5hbWU7XG5jb25zdCBoXyA9IEguZm9yd2FyZFJlZigoeyBjbGFzc05hbWU6IGUsIC4uLnQgfSwgbikgPT4gLyogQF9fUFVSRV9fICovIFgoXG4gIEF5LFxuICB7XG4gICAgcmVmOiBuLFxuICAgIGNsYXNzTmFtZTogTGUoXCItbXgtMSBteS0xIGgtcHggYmctbXV0ZWRcIiwgZSksXG4gICAgLi4udFxuICB9XG4pKTtcbmhfLmRpc3BsYXlOYW1lID0gQXkuZGlzcGxheU5hbWU7XG5mdW5jdGlvbiBlSCh7XG4gIHNldFRoZW1lOiBlLFxuICBkYXJrQnV0dG9uVGV4dDogdCxcbiAgbGlnaHRCdXR0b25UZXh0OiBuLFxuICBzeXN0ZW1CdXR0b25UZXh0OiByXG59KSB7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gemUoRXksIHsgY2hpbGRyZW46IFtcbiAgICAvKiBAX19QVVJFX18gKi8gWChUeSwgeyBhc0NoaWxkOiAhMCwgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyB6ZShhciwgeyB2YXJpYW50OiBcIm91dGxpbmVcIiwgc2l6ZTogXCJpY29uXCIsIGNoaWxkcmVuOiBbXG4gICAgICAvKiBAX19QVVJFX18gKi8gWCh5MSwgeyBjbGFzc05hbWU6IFwiaC1bMS4ycmVtXSB3LVsxLjJyZW1dIHJvdGF0ZS0wIHNjYWxlLTEwMCB0cmFuc2l0aW9uLWFsbCBkYXJrOi1yb3RhdGUtOTAgZGFyazpzY2FsZS0wXCIgfSksXG4gICAgICAvKiBAX19QVVJFX18gKi8gWChtMSwgeyBjbGFzc05hbWU6IFwiYWJzb2x1dGUgaC1bMS4ycmVtXSB3LVsxLjJyZW1dIHJvdGF0ZS05MCBzY2FsZS0wIHRyYW5zaXRpb24tYWxsIGRhcms6cm90YXRlLTAgZGFyazpzY2FsZS0xMDBcIiB9KSxcbiAgICAgIC8qIEBfX1BVUkVfXyAqLyBYKFwic3BhblwiLCB7IGNsYXNzTmFtZTogXCJzci1vbmx5XCIsIGNoaWxkcmVuOiBcIlRvZ2dsZSB0aGVtZVwiIH0pXG4gICAgXSB9KSB9KSxcbiAgICAvKiBAX19QVVJFX18gKi8gemUoZ2YsIHsgYWxpZ246IFwiZW5kXCIsIGNoaWxkcmVuOiBbXG4gICAgICAvKiBAX19QVVJFX18gKi8gWChFYSwgeyBvbkNsaWNrOiAoKSA9PiBlKFwibGlnaHRcIiksIGNoaWxkcmVuOiBuIH0pLFxuICAgICAgLyogQF9fUFVSRV9fICovIFgoRWEsIHsgb25DbGljazogKCkgPT4gZShcImRhcmtcIiksIGNoaWxkcmVuOiB0IH0pLFxuICAgICAgLyogQF9fUFVSRV9fICovIFgoRWEsIHsgb25DbGljazogKCkgPT4gZShcInN5c3RlbVwiKSwgY2hpbGRyZW46IHIgfSlcbiAgICBdIH0pXG4gIF0gfSk7XG59XG52YXIgZ18gPSBBcnJheS5pc0FycmF5LCBtdCA9IGdfLCB2XyA9IHR5cGVvZiB0YSA9PSBcIm9iamVjdFwiICYmIHRhICYmIHRhLk9iamVjdCA9PT0gT2JqZWN0ICYmIHRhLCBSeSA9IHZfLCBtXyA9IFJ5LCB5XyA9IHR5cGVvZiBzZWxmID09IFwib2JqZWN0XCIgJiYgc2VsZiAmJiBzZWxmLk9iamVjdCA9PT0gT2JqZWN0ICYmIHNlbGYsIGJfID0gbV8gfHwgeV8gfHwgRnVuY3Rpb24oXCJyZXR1cm4gdGhpc1wiKSgpLCBkbiA9IGJfLCB3XyA9IGRuLCB4XyA9IHdfLlN5bWJvbCwgVm8gPSB4XywgY3AgPSBWbywgSXkgPSBPYmplY3QucHJvdG90eXBlLCBTXyA9IEl5Lmhhc093blByb3BlcnR5LCAkXyA9IEl5LnRvU3RyaW5nLCBUaSA9IGNwID8gY3AudG9TdHJpbmdUYWcgOiB2b2lkIDA7XG5mdW5jdGlvbiBPXyhlKSB7XG4gIHZhciB0ID0gU18uY2FsbChlLCBUaSksIG4gPSBlW1RpXTtcbiAgdHJ5IHtcbiAgICBlW1RpXSA9IHZvaWQgMDtcbiAgICB2YXIgciA9ICEwO1xuICB9IGNhdGNoIHtcbiAgfVxuICB2YXIgaSA9ICRfLmNhbGwoZSk7XG4gIHJldHVybiByICYmICh0ID8gZVtUaV0gPSBuIDogZGVsZXRlIGVbVGldKSwgaTtcbn1cbnZhciBfXyA9IE9fLCBBXyA9IE9iamVjdC5wcm90b3R5cGUsIFBfID0gQV8udG9TdHJpbmc7XG5mdW5jdGlvbiBDXyhlKSB7XG4gIHJldHVybiBQXy5jYWxsKGUpO1xufVxudmFyIEVfID0gQ18sIGxwID0gVm8sIFRfID0gX18sIE1fID0gRV8sIFJfID0gXCJbb2JqZWN0IE51bGxdXCIsIElfID0gXCJbb2JqZWN0IFVuZGVmaW5lZF1cIiwgZnAgPSBscCA/IGxwLnRvU3RyaW5nVGFnIDogdm9pZCAwO1xuZnVuY3Rpb24gal8oZSkge1xuICByZXR1cm4gZSA9PSBudWxsID8gZSA9PT0gdm9pZCAwID8gSV8gOiBSXyA6IGZwICYmIGZwIGluIE9iamVjdChlKSA/IFRfKGUpIDogTV8oZSk7XG59XG52YXIgUG4gPSBqXztcbmZ1bmN0aW9uIGtfKGUpIHtcbiAgcmV0dXJuIGUgIT0gbnVsbCAmJiB0eXBlb2YgZSA9PSBcIm9iamVjdFwiO1xufVxudmFyIENuID0ga18sIERfID0gUG4sIE5fID0gQ24sIEZfID0gXCJbb2JqZWN0IFN5bWJvbF1cIjtcbmZ1bmN0aW9uIExfKGUpIHtcbiAgcmV0dXJuIHR5cGVvZiBlID09IFwic3ltYm9sXCIgfHwgTl8oZSkgJiYgRF8oZSkgPT0gRl87XG59XG52YXIgdWkgPSBMXywgQl8gPSBtdCwgel8gPSB1aSwgVl8gPSAvXFwufFxcWyg/OlteW1xcXV0qfChbXCInXSkoPzooPyFcXDEpW15cXFxcXXxcXFxcLikqP1xcMSlcXF0vLCBHXyA9IC9eXFx3KiQvO1xuZnVuY3Rpb24gV18oZSwgdCkge1xuICBpZiAoQl8oZSkpXG4gICAgcmV0dXJuICExO1xuICB2YXIgbiA9IHR5cGVvZiBlO1xuICByZXR1cm4gbiA9PSBcIm51bWJlclwiIHx8IG4gPT0gXCJzeW1ib2xcIiB8fCBuID09IFwiYm9vbGVhblwiIHx8IGUgPT0gbnVsbCB8fCB6XyhlKSA/ICEwIDogR18udGVzdChlKSB8fCAhVl8udGVzdChlKSB8fCB0ICE9IG51bGwgJiYgZSBpbiBPYmplY3QodCk7XG59XG52YXIgdmYgPSBXXztcbmZ1bmN0aW9uIFVfKGUpIHtcbiAgdmFyIHQgPSB0eXBlb2YgZTtcbiAgcmV0dXJuIGUgIT0gbnVsbCAmJiAodCA9PSBcIm9iamVjdFwiIHx8IHQgPT0gXCJmdW5jdGlvblwiKTtcbn1cbnZhciBVbiA9IFVfO1xuY29uc3QgY2kgPSAvKiBAX19QVVJFX18gKi8gamUoVW4pO1xudmFyIEhfID0gUG4sIHFfID0gVW4sIEtfID0gXCJbb2JqZWN0IEFzeW5jRnVuY3Rpb25dXCIsIFlfID0gXCJbb2JqZWN0IEZ1bmN0aW9uXVwiLCBYXyA9IFwiW29iamVjdCBHZW5lcmF0b3JGdW5jdGlvbl1cIiwgWl8gPSBcIltvYmplY3QgUHJveHldXCI7XG5mdW5jdGlvbiBKXyhlKSB7XG4gIGlmICghcV8oZSkpXG4gICAgcmV0dXJuICExO1xuICB2YXIgdCA9IEhfKGUpO1xuICByZXR1cm4gdCA9PSBZXyB8fCB0ID09IFhfIHx8IHQgPT0gS18gfHwgdCA9PSBaXztcbn1cbnZhciBtZiA9IEpfO1xuY29uc3QgcGUgPSAvKiBAX19QVVJFX18gKi8gamUobWYpO1xudmFyIFFfID0gZG4sIGVBID0gUV9bXCJfX2NvcmUtanNfc2hhcmVkX19cIl0sIHRBID0gZUEsIF91ID0gdEEsIGRwID0gZnVuY3Rpb24oKSB7XG4gIHZhciBlID0gL1teLl0rJC8uZXhlYyhfdSAmJiBfdS5rZXlzICYmIF91LmtleXMuSUVfUFJPVE8gfHwgXCJcIik7XG4gIHJldHVybiBlID8gXCJTeW1ib2woc3JjKV8xLlwiICsgZSA6IFwiXCI7XG59KCk7XG5mdW5jdGlvbiBuQShlKSB7XG4gIHJldHVybiAhIWRwICYmIGRwIGluIGU7XG59XG52YXIgckEgPSBuQSwgaUEgPSBGdW5jdGlvbi5wcm90b3R5cGUsIG9BID0gaUEudG9TdHJpbmc7XG5mdW5jdGlvbiBhQShlKSB7XG4gIGlmIChlICE9IG51bGwpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIG9BLmNhbGwoZSk7XG4gICAgfSBjYXRjaCB7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICByZXR1cm4gZSArIFwiXCI7XG4gICAgfSBjYXRjaCB7XG4gICAgfVxuICB9XG4gIHJldHVybiBcIlwiO1xufVxudmFyIGp5ID0gYUEsIHNBID0gbWYsIHVBID0gckEsIGNBID0gVW4sIGxBID0ganksIGZBID0gL1tcXFxcXiQuKis/KClbXFxde318XS9nLCBkQSA9IC9eXFxbb2JqZWN0IC4rP0NvbnN0cnVjdG9yXFxdJC8sIHBBID0gRnVuY3Rpb24ucHJvdG90eXBlLCBoQSA9IE9iamVjdC5wcm90b3R5cGUsIGdBID0gcEEudG9TdHJpbmcsIHZBID0gaEEuaGFzT3duUHJvcGVydHksIG1BID0gUmVnRXhwKFxuICBcIl5cIiArIGdBLmNhbGwodkEpLnJlcGxhY2UoZkEsIFwiXFxcXCQmXCIpLnJlcGxhY2UoL2hhc093blByb3BlcnR5fChmdW5jdGlvbikuKj8oPz1cXFxcXFwoKXwgZm9yIC4rPyg/PVxcXFxcXF0pL2csIFwiJDEuKj9cIikgKyBcIiRcIlxuKTtcbmZ1bmN0aW9uIHlBKGUpIHtcbiAgaWYgKCFjQShlKSB8fCB1QShlKSlcbiAgICByZXR1cm4gITE7XG4gIHZhciB0ID0gc0EoZSkgPyBtQSA6IGRBO1xuICByZXR1cm4gdC50ZXN0KGxBKGUpKTtcbn1cbnZhciBiQSA9IHlBO1xuZnVuY3Rpb24gd0EoZSwgdCkge1xuICByZXR1cm4gZSA9PSBudWxsID8gdm9pZCAwIDogZVt0XTtcbn1cbnZhciB4QSA9IHdBLCBTQSA9IGJBLCAkQSA9IHhBO1xuZnVuY3Rpb24gT0EoZSwgdCkge1xuICB2YXIgbiA9ICRBKGUsIHQpO1xuICByZXR1cm4gU0EobikgPyBuIDogdm9pZCAwO1xufVxudmFyIHZyID0gT0EsIF9BID0gdnIsIEFBID0gX0EoT2JqZWN0LCBcImNyZWF0ZVwiKSwga3MgPSBBQSwgcHAgPSBrcztcbmZ1bmN0aW9uIFBBKCkge1xuICB0aGlzLl9fZGF0YV9fID0gcHAgPyBwcChudWxsKSA6IHt9LCB0aGlzLnNpemUgPSAwO1xufVxudmFyIENBID0gUEE7XG5mdW5jdGlvbiBFQShlKSB7XG4gIHZhciB0ID0gdGhpcy5oYXMoZSkgJiYgZGVsZXRlIHRoaXMuX19kYXRhX19bZV07XG4gIHJldHVybiB0aGlzLnNpemUgLT0gdCA/IDEgOiAwLCB0O1xufVxudmFyIFRBID0gRUEsIE1BID0ga3MsIFJBID0gXCJfX2xvZGFzaF9oYXNoX3VuZGVmaW5lZF9fXCIsIElBID0gT2JqZWN0LnByb3RvdHlwZSwgakEgPSBJQS5oYXNPd25Qcm9wZXJ0eTtcbmZ1bmN0aW9uIGtBKGUpIHtcbiAgdmFyIHQgPSB0aGlzLl9fZGF0YV9fO1xuICBpZiAoTUEpIHtcbiAgICB2YXIgbiA9IHRbZV07XG4gICAgcmV0dXJuIG4gPT09IFJBID8gdm9pZCAwIDogbjtcbiAgfVxuICByZXR1cm4gakEuY2FsbCh0LCBlKSA/IHRbZV0gOiB2b2lkIDA7XG59XG52YXIgREEgPSBrQSwgTkEgPSBrcywgRkEgPSBPYmplY3QucHJvdG90eXBlLCBMQSA9IEZBLmhhc093blByb3BlcnR5O1xuZnVuY3Rpb24gQkEoZSkge1xuICB2YXIgdCA9IHRoaXMuX19kYXRhX187XG4gIHJldHVybiBOQSA/IHRbZV0gIT09IHZvaWQgMCA6IExBLmNhbGwodCwgZSk7XG59XG52YXIgekEgPSBCQSwgVkEgPSBrcywgR0EgPSBcIl9fbG9kYXNoX2hhc2hfdW5kZWZpbmVkX19cIjtcbmZ1bmN0aW9uIFdBKGUsIHQpIHtcbiAgdmFyIG4gPSB0aGlzLl9fZGF0YV9fO1xuICByZXR1cm4gdGhpcy5zaXplICs9IHRoaXMuaGFzKGUpID8gMCA6IDEsIG5bZV0gPSBWQSAmJiB0ID09PSB2b2lkIDAgPyBHQSA6IHQsIHRoaXM7XG59XG52YXIgVUEgPSBXQSwgSEEgPSBDQSwgcUEgPSBUQSwgS0EgPSBEQSwgWUEgPSB6QSwgWEEgPSBVQTtcbmZ1bmN0aW9uIGxpKGUpIHtcbiAgdmFyIHQgPSAtMSwgbiA9IGUgPT0gbnVsbCA/IDAgOiBlLmxlbmd0aDtcbiAgZm9yICh0aGlzLmNsZWFyKCk7ICsrdCA8IG47ICkge1xuICAgIHZhciByID0gZVt0XTtcbiAgICB0aGlzLnNldChyWzBdLCByWzFdKTtcbiAgfVxufVxubGkucHJvdG90eXBlLmNsZWFyID0gSEE7XG5saS5wcm90b3R5cGUuZGVsZXRlID0gcUE7XG5saS5wcm90b3R5cGUuZ2V0ID0gS0E7XG5saS5wcm90b3R5cGUuaGFzID0gWUE7XG5saS5wcm90b3R5cGUuc2V0ID0gWEE7XG52YXIgWkEgPSBsaTtcbmZ1bmN0aW9uIEpBKCkge1xuICB0aGlzLl9fZGF0YV9fID0gW10sIHRoaXMuc2l6ZSA9IDA7XG59XG52YXIgUUEgPSBKQTtcbmZ1bmN0aW9uIGVQKGUsIHQpIHtcbiAgcmV0dXJuIGUgPT09IHQgfHwgZSAhPT0gZSAmJiB0ICE9PSB0O1xufVxudmFyIHlmID0gZVAsIHRQID0geWY7XG5mdW5jdGlvbiBuUChlLCB0KSB7XG4gIGZvciAodmFyIG4gPSBlLmxlbmd0aDsgbi0tOyApXG4gICAgaWYgKHRQKGVbbl1bMF0sIHQpKVxuICAgICAgcmV0dXJuIG47XG4gIHJldHVybiAtMTtcbn1cbnZhciBEcyA9IG5QLCByUCA9IERzLCBpUCA9IEFycmF5LnByb3RvdHlwZSwgb1AgPSBpUC5zcGxpY2U7XG5mdW5jdGlvbiBhUChlKSB7XG4gIHZhciB0ID0gdGhpcy5fX2RhdGFfXywgbiA9IHJQKHQsIGUpO1xuICBpZiAobiA8IDApXG4gICAgcmV0dXJuICExO1xuICB2YXIgciA9IHQubGVuZ3RoIC0gMTtcbiAgcmV0dXJuIG4gPT0gciA/IHQucG9wKCkgOiBvUC5jYWxsKHQsIG4sIDEpLCAtLXRoaXMuc2l6ZSwgITA7XG59XG52YXIgc1AgPSBhUCwgdVAgPSBEcztcbmZ1bmN0aW9uIGNQKGUpIHtcbiAgdmFyIHQgPSB0aGlzLl9fZGF0YV9fLCBuID0gdVAodCwgZSk7XG4gIHJldHVybiBuIDwgMCA/IHZvaWQgMCA6IHRbbl1bMV07XG59XG52YXIgbFAgPSBjUCwgZlAgPSBEcztcbmZ1bmN0aW9uIGRQKGUpIHtcbiAgcmV0dXJuIGZQKHRoaXMuX19kYXRhX18sIGUpID4gLTE7XG59XG52YXIgcFAgPSBkUCwgaFAgPSBEcztcbmZ1bmN0aW9uIGdQKGUsIHQpIHtcbiAgdmFyIG4gPSB0aGlzLl9fZGF0YV9fLCByID0gaFAobiwgZSk7XG4gIHJldHVybiByIDwgMCA/ICgrK3RoaXMuc2l6ZSwgbi5wdXNoKFtlLCB0XSkpIDogbltyXVsxXSA9IHQsIHRoaXM7XG59XG52YXIgdlAgPSBnUCwgbVAgPSBRQSwgeVAgPSBzUCwgYlAgPSBsUCwgd1AgPSBwUCwgeFAgPSB2UDtcbmZ1bmN0aW9uIGZpKGUpIHtcbiAgdmFyIHQgPSAtMSwgbiA9IGUgPT0gbnVsbCA/IDAgOiBlLmxlbmd0aDtcbiAgZm9yICh0aGlzLmNsZWFyKCk7ICsrdCA8IG47ICkge1xuICAgIHZhciByID0gZVt0XTtcbiAgICB0aGlzLnNldChyWzBdLCByWzFdKTtcbiAgfVxufVxuZmkucHJvdG90eXBlLmNsZWFyID0gbVA7XG5maS5wcm90b3R5cGUuZGVsZXRlID0geVA7XG5maS5wcm90b3R5cGUuZ2V0ID0gYlA7XG5maS5wcm90b3R5cGUuaGFzID0gd1A7XG5maS5wcm90b3R5cGUuc2V0ID0geFA7XG52YXIgTnMgPSBmaSwgU1AgPSB2ciwgJFAgPSBkbiwgT1AgPSBTUCgkUCwgXCJNYXBcIiksIGJmID0gT1AsIGhwID0gWkEsIF9QID0gTnMsIEFQID0gYmY7XG5mdW5jdGlvbiBQUCgpIHtcbiAgdGhpcy5zaXplID0gMCwgdGhpcy5fX2RhdGFfXyA9IHtcbiAgICBoYXNoOiBuZXcgaHAoKSxcbiAgICBtYXA6IG5ldyAoQVAgfHwgX1ApKCksXG4gICAgc3RyaW5nOiBuZXcgaHAoKVxuICB9O1xufVxudmFyIENQID0gUFA7XG5mdW5jdGlvbiBFUChlKSB7XG4gIHZhciB0ID0gdHlwZW9mIGU7XG4gIHJldHVybiB0ID09IFwic3RyaW5nXCIgfHwgdCA9PSBcIm51bWJlclwiIHx8IHQgPT0gXCJzeW1ib2xcIiB8fCB0ID09IFwiYm9vbGVhblwiID8gZSAhPT0gXCJfX3Byb3RvX19cIiA6IGUgPT09IG51bGw7XG59XG52YXIgVFAgPSBFUCwgTVAgPSBUUDtcbmZ1bmN0aW9uIFJQKGUsIHQpIHtcbiAgdmFyIG4gPSBlLl9fZGF0YV9fO1xuICByZXR1cm4gTVAodCkgPyBuW3R5cGVvZiB0ID09IFwic3RyaW5nXCIgPyBcInN0cmluZ1wiIDogXCJoYXNoXCJdIDogbi5tYXA7XG59XG52YXIgRnMgPSBSUCwgSVAgPSBGcztcbmZ1bmN0aW9uIGpQKGUpIHtcbiAgdmFyIHQgPSBJUCh0aGlzLCBlKS5kZWxldGUoZSk7XG4gIHJldHVybiB0aGlzLnNpemUgLT0gdCA/IDEgOiAwLCB0O1xufVxudmFyIGtQID0galAsIERQID0gRnM7XG5mdW5jdGlvbiBOUChlKSB7XG4gIHJldHVybiBEUCh0aGlzLCBlKS5nZXQoZSk7XG59XG52YXIgRlAgPSBOUCwgTFAgPSBGcztcbmZ1bmN0aW9uIEJQKGUpIHtcbiAgcmV0dXJuIExQKHRoaXMsIGUpLmhhcyhlKTtcbn1cbnZhciB6UCA9IEJQLCBWUCA9IEZzO1xuZnVuY3Rpb24gR1AoZSwgdCkge1xuICB2YXIgbiA9IFZQKHRoaXMsIGUpLCByID0gbi5zaXplO1xuICByZXR1cm4gbi5zZXQoZSwgdCksIHRoaXMuc2l6ZSArPSBuLnNpemUgPT0gciA/IDAgOiAxLCB0aGlzO1xufVxudmFyIFdQID0gR1AsIFVQID0gQ1AsIEhQID0ga1AsIHFQID0gRlAsIEtQID0gelAsIFlQID0gV1A7XG5mdW5jdGlvbiBkaShlKSB7XG4gIHZhciB0ID0gLTEsIG4gPSBlID09IG51bGwgPyAwIDogZS5sZW5ndGg7XG4gIGZvciAodGhpcy5jbGVhcigpOyArK3QgPCBuOyApIHtcbiAgICB2YXIgciA9IGVbdF07XG4gICAgdGhpcy5zZXQoclswXSwgclsxXSk7XG4gIH1cbn1cbmRpLnByb3RvdHlwZS5jbGVhciA9IFVQO1xuZGkucHJvdG90eXBlLmRlbGV0ZSA9IEhQO1xuZGkucHJvdG90eXBlLmdldCA9IHFQO1xuZGkucHJvdG90eXBlLmhhcyA9IEtQO1xuZGkucHJvdG90eXBlLnNldCA9IFlQO1xudmFyIHdmID0gZGksIGt5ID0gd2YsIFhQID0gXCJFeHBlY3RlZCBhIGZ1bmN0aW9uXCI7XG5mdW5jdGlvbiB4ZihlLCB0KSB7XG4gIGlmICh0eXBlb2YgZSAhPSBcImZ1bmN0aW9uXCIgfHwgdCAhPSBudWxsICYmIHR5cGVvZiB0ICE9IFwiZnVuY3Rpb25cIilcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFhQKTtcbiAgdmFyIG4gPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgciA9IGFyZ3VtZW50cywgaSA9IHQgPyB0LmFwcGx5KHRoaXMsIHIpIDogclswXSwgbyA9IG4uY2FjaGU7XG4gICAgaWYgKG8uaGFzKGkpKVxuICAgICAgcmV0dXJuIG8uZ2V0KGkpO1xuICAgIHZhciBhID0gZS5hcHBseSh0aGlzLCByKTtcbiAgICByZXR1cm4gbi5jYWNoZSA9IG8uc2V0KGksIGEpIHx8IG8sIGE7XG4gIH07XG4gIHJldHVybiBuLmNhY2hlID0gbmV3ICh4Zi5DYWNoZSB8fCBreSkoKSwgbjtcbn1cbnhmLkNhY2hlID0ga3k7XG52YXIgRHkgPSB4ZjtcbmNvbnN0IFpQID0gLyogQF9fUFVSRV9fICovIGplKER5KTtcbnZhciBKUCA9IER5LCBRUCA9IDUwMDtcbmZ1bmN0aW9uIGVDKGUpIHtcbiAgdmFyIHQgPSBKUChlLCBmdW5jdGlvbihyKSB7XG4gICAgcmV0dXJuIG4uc2l6ZSA9PT0gUVAgJiYgbi5jbGVhcigpLCByO1xuICB9KSwgbiA9IHQuY2FjaGU7XG4gIHJldHVybiB0O1xufVxudmFyIHRDID0gZUMsIG5DID0gdEMsIHJDID0gL1teLltcXF1dK3xcXFsoPzooLT9cXGQrKD86XFwuXFxkKyk/KXwoW1wiJ10pKCg/Oig/IVxcMilbXlxcXFxdfFxcXFwuKSo/KVxcMilcXF18KD89KD86XFwufFxcW1xcXSkoPzpcXC58XFxbXFxdfCQpKS9nLCBpQyA9IC9cXFxcKFxcXFwpPy9nLCBvQyA9IG5DKGZ1bmN0aW9uKGUpIHtcbiAgdmFyIHQgPSBbXTtcbiAgcmV0dXJuIGUuY2hhckNvZGVBdCgwKSA9PT0gNDYgJiYgdC5wdXNoKFwiXCIpLCBlLnJlcGxhY2UockMsIGZ1bmN0aW9uKG4sIHIsIGksIG8pIHtcbiAgICB0LnB1c2goaSA/IG8ucmVwbGFjZShpQywgXCIkMVwiKSA6IHIgfHwgbik7XG4gIH0pLCB0O1xufSksIGFDID0gb0M7XG5mdW5jdGlvbiBzQyhlLCB0KSB7XG4gIGZvciAodmFyIG4gPSAtMSwgciA9IGUgPT0gbnVsbCA/IDAgOiBlLmxlbmd0aCwgaSA9IEFycmF5KHIpOyArK24gPCByOyApXG4gICAgaVtuXSA9IHQoZVtuXSwgbiwgZSk7XG4gIHJldHVybiBpO1xufVxudmFyIFNmID0gc0MsIGdwID0gVm8sIHVDID0gU2YsIGNDID0gbXQsIGxDID0gdWksIGZDID0gMSAvIDAsIHZwID0gZ3AgPyBncC5wcm90b3R5cGUgOiB2b2lkIDAsIG1wID0gdnAgPyB2cC50b1N0cmluZyA6IHZvaWQgMDtcbmZ1bmN0aW9uIE55KGUpIHtcbiAgaWYgKHR5cGVvZiBlID09IFwic3RyaW5nXCIpXG4gICAgcmV0dXJuIGU7XG4gIGlmIChjQyhlKSlcbiAgICByZXR1cm4gdUMoZSwgTnkpICsgXCJcIjtcbiAgaWYgKGxDKGUpKVxuICAgIHJldHVybiBtcCA/IG1wLmNhbGwoZSkgOiBcIlwiO1xuICB2YXIgdCA9IGUgKyBcIlwiO1xuICByZXR1cm4gdCA9PSBcIjBcIiAmJiAxIC8gZSA9PSAtZkMgPyBcIi0wXCIgOiB0O1xufVxudmFyIGRDID0gTnksIHBDID0gZEM7XG5mdW5jdGlvbiBoQyhlKSB7XG4gIHJldHVybiBlID09IG51bGwgPyBcIlwiIDogcEMoZSk7XG59XG52YXIgRnkgPSBoQywgZ0MgPSBtdCwgdkMgPSB2ZiwgbUMgPSBhQywgeUMgPSBGeTtcbmZ1bmN0aW9uIGJDKGUsIHQpIHtcbiAgcmV0dXJuIGdDKGUpID8gZSA6IHZDKGUsIHQpID8gW2VdIDogbUMoeUMoZSkpO1xufVxudmFyIEx5ID0gYkMsIHdDID0gdWksIHhDID0gMSAvIDA7XG5mdW5jdGlvbiBTQyhlKSB7XG4gIGlmICh0eXBlb2YgZSA9PSBcInN0cmluZ1wiIHx8IHdDKGUpKVxuICAgIHJldHVybiBlO1xuICB2YXIgdCA9IGUgKyBcIlwiO1xuICByZXR1cm4gdCA9PSBcIjBcIiAmJiAxIC8gZSA9PSAteEMgPyBcIi0wXCIgOiB0O1xufVxudmFyIExzID0gU0MsICRDID0gTHksIE9DID0gTHM7XG5mdW5jdGlvbiBfQyhlLCB0KSB7XG4gIHQgPSAkQyh0LCBlKTtcbiAgZm9yICh2YXIgbiA9IDAsIHIgPSB0Lmxlbmd0aDsgZSAhPSBudWxsICYmIG4gPCByOyApXG4gICAgZSA9IGVbT0ModFtuKytdKV07XG4gIHJldHVybiBuICYmIG4gPT0gciA/IGUgOiB2b2lkIDA7XG59XG52YXIgJGYgPSBfQywgQUMgPSAkZjtcbmZ1bmN0aW9uIFBDKGUsIHQsIG4pIHtcbiAgdmFyIHIgPSBlID09IG51bGwgPyB2b2lkIDAgOiBBQyhlLCB0KTtcbiAgcmV0dXJuIHIgPT09IHZvaWQgMCA/IG4gOiByO1xufVxudmFyIEJ5ID0gUEM7XG5jb25zdCBqdCA9IC8qIEBfX1BVUkVfXyAqLyBqZShCeSk7XG5mdW5jdGlvbiBDQyhlKSB7XG4gIHJldHVybiBlID09IG51bGw7XG59XG52YXIgRUMgPSBDQztcbmNvbnN0IG1lID0gLyogQF9fUFVSRV9fICovIGplKEVDKTtcbnZhciBUQyA9IFBuLCBNQyA9IG10LCBSQyA9IENuLCBJQyA9IFwiW29iamVjdCBTdHJpbmddXCI7XG5mdW5jdGlvbiBqQyhlKSB7XG4gIHJldHVybiB0eXBlb2YgZSA9PSBcInN0cmluZ1wiIHx8ICFNQyhlKSAmJiBSQyhlKSAmJiBUQyhlKSA9PSBJQztcbn1cbnZhciBrQyA9IGpDO1xuY29uc3QgR28gPSAvKiBAX19QVVJFX18gKi8gamUoa0MpO1xudmFyIF9jID0geyBleHBvcnRzOiB7fSB9LCBQZSA9IHt9O1xuLyoqIEBsaWNlbnNlIFJlYWN0IHYxNi4xMy4xXG4gKiByZWFjdC1pcy5wcm9kdWN0aW9uLm1pbi5qc1xuICpcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG52YXIgeXA7XG5mdW5jdGlvbiBEQygpIHtcbiAgaWYgKHlwKVxuICAgIHJldHVybiBQZTtcbiAgeXAgPSAxO1xuICB2YXIgZSA9IHR5cGVvZiBTeW1ib2wgPT0gXCJmdW5jdGlvblwiICYmIFN5bWJvbC5mb3IsIHQgPSBlID8gU3ltYm9sLmZvcihcInJlYWN0LmVsZW1lbnRcIikgOiA2MDEwMywgbiA9IGUgPyBTeW1ib2wuZm9yKFwicmVhY3QucG9ydGFsXCIpIDogNjAxMDYsIHIgPSBlID8gU3ltYm9sLmZvcihcInJlYWN0LmZyYWdtZW50XCIpIDogNjAxMDcsIGkgPSBlID8gU3ltYm9sLmZvcihcInJlYWN0LnN0cmljdF9tb2RlXCIpIDogNjAxMDgsIG8gPSBlID8gU3ltYm9sLmZvcihcInJlYWN0LnByb2ZpbGVyXCIpIDogNjAxMTQsIGEgPSBlID8gU3ltYm9sLmZvcihcInJlYWN0LnByb3ZpZGVyXCIpIDogNjAxMDksIHMgPSBlID8gU3ltYm9sLmZvcihcInJlYWN0LmNvbnRleHRcIikgOiA2MDExMCwgdSA9IGUgPyBTeW1ib2wuZm9yKFwicmVhY3QuYXN5bmNfbW9kZVwiKSA6IDYwMTExLCBjID0gZSA/IFN5bWJvbC5mb3IoXCJyZWFjdC5jb25jdXJyZW50X21vZGVcIikgOiA2MDExMSwgZiA9IGUgPyBTeW1ib2wuZm9yKFwicmVhY3QuZm9yd2FyZF9yZWZcIikgOiA2MDExMiwgbCA9IGUgPyBTeW1ib2wuZm9yKFwicmVhY3Quc3VzcGVuc2VcIikgOiA2MDExMywgZCA9IGUgPyBTeW1ib2wuZm9yKFwicmVhY3Quc3VzcGVuc2VfbGlzdFwiKSA6IDYwMTIwLCBwID0gZSA/IFN5bWJvbC5mb3IoXCJyZWFjdC5tZW1vXCIpIDogNjAxMTUsIGcgPSBlID8gU3ltYm9sLmZvcihcInJlYWN0LmxhenlcIikgOiA2MDExNiwgaCA9IGUgPyBTeW1ib2wuZm9yKFwicmVhY3QuYmxvY2tcIikgOiA2MDEyMSwgdiA9IGUgPyBTeW1ib2wuZm9yKFwicmVhY3QuZnVuZGFtZW50YWxcIikgOiA2MDExNywgdyA9IGUgPyBTeW1ib2wuZm9yKFwicmVhY3QucmVzcG9uZGVyXCIpIDogNjAxMTgsIGIgPSBlID8gU3ltYm9sLmZvcihcInJlYWN0LnNjb3BlXCIpIDogNjAxMTk7XG4gIGZ1bmN0aW9uIHgoeSkge1xuICAgIGlmICh0eXBlb2YgeSA9PSBcIm9iamVjdFwiICYmIHkgIT09IG51bGwpIHtcbiAgICAgIHZhciBTID0geS4kJHR5cGVvZjtcbiAgICAgIHN3aXRjaCAoUykge1xuICAgICAgICBjYXNlIHQ6XG4gICAgICAgICAgc3dpdGNoICh5ID0geS50eXBlLCB5KSB7XG4gICAgICAgICAgICBjYXNlIHU6XG4gICAgICAgICAgICBjYXNlIGM6XG4gICAgICAgICAgICBjYXNlIHI6XG4gICAgICAgICAgICBjYXNlIG86XG4gICAgICAgICAgICBjYXNlIGk6XG4gICAgICAgICAgICBjYXNlIGw6XG4gICAgICAgICAgICAgIHJldHVybiB5O1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgc3dpdGNoICh5ID0geSAmJiB5LiQkdHlwZW9mLCB5KSB7XG4gICAgICAgICAgICAgICAgY2FzZSBzOlxuICAgICAgICAgICAgICAgIGNhc2UgZjpcbiAgICAgICAgICAgICAgICBjYXNlIGc6XG4gICAgICAgICAgICAgICAgY2FzZSBwOlxuICAgICAgICAgICAgICAgIGNhc2UgYTpcbiAgICAgICAgICAgICAgICAgIHJldHVybiB5O1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICByZXR1cm4gUztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgY2FzZSBuOlxuICAgICAgICAgIHJldHVybiBTO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBtKHkpIHtcbiAgICByZXR1cm4geCh5KSA9PT0gYztcbiAgfVxuICByZXR1cm4gUGUuQXN5bmNNb2RlID0gdSwgUGUuQ29uY3VycmVudE1vZGUgPSBjLCBQZS5Db250ZXh0Q29uc3VtZXIgPSBzLCBQZS5Db250ZXh0UHJvdmlkZXIgPSBhLCBQZS5FbGVtZW50ID0gdCwgUGUuRm9yd2FyZFJlZiA9IGYsIFBlLkZyYWdtZW50ID0gciwgUGUuTGF6eSA9IGcsIFBlLk1lbW8gPSBwLCBQZS5Qb3J0YWwgPSBuLCBQZS5Qcm9maWxlciA9IG8sIFBlLlN0cmljdE1vZGUgPSBpLCBQZS5TdXNwZW5zZSA9IGwsIFBlLmlzQXN5bmNNb2RlID0gZnVuY3Rpb24oeSkge1xuICAgIHJldHVybiBtKHkpIHx8IHgoeSkgPT09IHU7XG4gIH0sIFBlLmlzQ29uY3VycmVudE1vZGUgPSBtLCBQZS5pc0NvbnRleHRDb25zdW1lciA9IGZ1bmN0aW9uKHkpIHtcbiAgICByZXR1cm4geCh5KSA9PT0gcztcbiAgfSwgUGUuaXNDb250ZXh0UHJvdmlkZXIgPSBmdW5jdGlvbih5KSB7XG4gICAgcmV0dXJuIHgoeSkgPT09IGE7XG4gIH0sIFBlLmlzRWxlbWVudCA9IGZ1bmN0aW9uKHkpIHtcbiAgICByZXR1cm4gdHlwZW9mIHkgPT0gXCJvYmplY3RcIiAmJiB5ICE9PSBudWxsICYmIHkuJCR0eXBlb2YgPT09IHQ7XG4gIH0sIFBlLmlzRm9yd2FyZFJlZiA9IGZ1bmN0aW9uKHkpIHtcbiAgICByZXR1cm4geCh5KSA9PT0gZjtcbiAgfSwgUGUuaXNGcmFnbWVudCA9IGZ1bmN0aW9uKHkpIHtcbiAgICByZXR1cm4geCh5KSA9PT0gcjtcbiAgfSwgUGUuaXNMYXp5ID0gZnVuY3Rpb24oeSkge1xuICAgIHJldHVybiB4KHkpID09PSBnO1xuICB9LCBQZS5pc01lbW8gPSBmdW5jdGlvbih5KSB7XG4gICAgcmV0dXJuIHgoeSkgPT09IHA7XG4gIH0sIFBlLmlzUG9ydGFsID0gZnVuY3Rpb24oeSkge1xuICAgIHJldHVybiB4KHkpID09PSBuO1xuICB9LCBQZS5pc1Byb2ZpbGVyID0gZnVuY3Rpb24oeSkge1xuICAgIHJldHVybiB4KHkpID09PSBvO1xuICB9LCBQZS5pc1N0cmljdE1vZGUgPSBmdW5jdGlvbih5KSB7XG4gICAgcmV0dXJuIHgoeSkgPT09IGk7XG4gIH0sIFBlLmlzU3VzcGVuc2UgPSBmdW5jdGlvbih5KSB7XG4gICAgcmV0dXJuIHgoeSkgPT09IGw7XG4gIH0sIFBlLmlzVmFsaWRFbGVtZW50VHlwZSA9IGZ1bmN0aW9uKHkpIHtcbiAgICByZXR1cm4gdHlwZW9mIHkgPT0gXCJzdHJpbmdcIiB8fCB0eXBlb2YgeSA9PSBcImZ1bmN0aW9uXCIgfHwgeSA9PT0gciB8fCB5ID09PSBjIHx8IHkgPT09IG8gfHwgeSA9PT0gaSB8fCB5ID09PSBsIHx8IHkgPT09IGQgfHwgdHlwZW9mIHkgPT0gXCJvYmplY3RcIiAmJiB5ICE9PSBudWxsICYmICh5LiQkdHlwZW9mID09PSBnIHx8IHkuJCR0eXBlb2YgPT09IHAgfHwgeS4kJHR5cGVvZiA9PT0gYSB8fCB5LiQkdHlwZW9mID09PSBzIHx8IHkuJCR0eXBlb2YgPT09IGYgfHwgeS4kJHR5cGVvZiA9PT0gdiB8fCB5LiQkdHlwZW9mID09PSB3IHx8IHkuJCR0eXBlb2YgPT09IGIgfHwgeS4kJHR5cGVvZiA9PT0gaCk7XG4gIH0sIFBlLnR5cGVPZiA9IHgsIFBlO1xufVxudmFyIENlID0ge307XG4vKiogQGxpY2Vuc2UgUmVhY3QgdjE2LjEzLjFcbiAqIHJlYWN0LWlzLmRldmVsb3BtZW50LmpzXG4gKlxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cbnZhciBicDtcbmZ1bmN0aW9uIE5DKCkge1xuICByZXR1cm4gYnAgfHwgKGJwID0gMSwgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIGZ1bmN0aW9uKCkge1xuICAgIHZhciBlID0gdHlwZW9mIFN5bWJvbCA9PSBcImZ1bmN0aW9uXCIgJiYgU3ltYm9sLmZvciwgdCA9IGUgPyBTeW1ib2wuZm9yKFwicmVhY3QuZWxlbWVudFwiKSA6IDYwMTAzLCBuID0gZSA/IFN5bWJvbC5mb3IoXCJyZWFjdC5wb3J0YWxcIikgOiA2MDEwNiwgciA9IGUgPyBTeW1ib2wuZm9yKFwicmVhY3QuZnJhZ21lbnRcIikgOiA2MDEwNywgaSA9IGUgPyBTeW1ib2wuZm9yKFwicmVhY3Quc3RyaWN0X21vZGVcIikgOiA2MDEwOCwgbyA9IGUgPyBTeW1ib2wuZm9yKFwicmVhY3QucHJvZmlsZXJcIikgOiA2MDExNCwgYSA9IGUgPyBTeW1ib2wuZm9yKFwicmVhY3QucHJvdmlkZXJcIikgOiA2MDEwOSwgcyA9IGUgPyBTeW1ib2wuZm9yKFwicmVhY3QuY29udGV4dFwiKSA6IDYwMTEwLCB1ID0gZSA/IFN5bWJvbC5mb3IoXCJyZWFjdC5hc3luY19tb2RlXCIpIDogNjAxMTEsIGMgPSBlID8gU3ltYm9sLmZvcihcInJlYWN0LmNvbmN1cnJlbnRfbW9kZVwiKSA6IDYwMTExLCBmID0gZSA/IFN5bWJvbC5mb3IoXCJyZWFjdC5mb3J3YXJkX3JlZlwiKSA6IDYwMTEyLCBsID0gZSA/IFN5bWJvbC5mb3IoXCJyZWFjdC5zdXNwZW5zZVwiKSA6IDYwMTEzLCBkID0gZSA/IFN5bWJvbC5mb3IoXCJyZWFjdC5zdXNwZW5zZV9saXN0XCIpIDogNjAxMjAsIHAgPSBlID8gU3ltYm9sLmZvcihcInJlYWN0Lm1lbW9cIikgOiA2MDExNSwgZyA9IGUgPyBTeW1ib2wuZm9yKFwicmVhY3QubGF6eVwiKSA6IDYwMTE2LCBoID0gZSA/IFN5bWJvbC5mb3IoXCJyZWFjdC5ibG9ja1wiKSA6IDYwMTIxLCB2ID0gZSA/IFN5bWJvbC5mb3IoXCJyZWFjdC5mdW5kYW1lbnRhbFwiKSA6IDYwMTE3LCB3ID0gZSA/IFN5bWJvbC5mb3IoXCJyZWFjdC5yZXNwb25kZXJcIikgOiA2MDExOCwgYiA9IGUgPyBTeW1ib2wuZm9yKFwicmVhY3Quc2NvcGVcIikgOiA2MDExOTtcbiAgICBmdW5jdGlvbiB4KEMpIHtcbiAgICAgIHJldHVybiB0eXBlb2YgQyA9PSBcInN0cmluZ1wiIHx8IHR5cGVvZiBDID09IFwiZnVuY3Rpb25cIiB8fCAvLyBOb3RlOiBpdHMgdHlwZW9mIG1pZ2h0IGJlIG90aGVyIHRoYW4gJ3N5bWJvbCcgb3IgJ251bWJlcicgaWYgaXQncyBhIHBvbHlmaWxsLlxuICAgICAgQyA9PT0gciB8fCBDID09PSBjIHx8IEMgPT09IG8gfHwgQyA9PT0gaSB8fCBDID09PSBsIHx8IEMgPT09IGQgfHwgdHlwZW9mIEMgPT0gXCJvYmplY3RcIiAmJiBDICE9PSBudWxsICYmIChDLiQkdHlwZW9mID09PSBnIHx8IEMuJCR0eXBlb2YgPT09IHAgfHwgQy4kJHR5cGVvZiA9PT0gYSB8fCBDLiQkdHlwZW9mID09PSBzIHx8IEMuJCR0eXBlb2YgPT09IGYgfHwgQy4kJHR5cGVvZiA9PT0gdiB8fCBDLiQkdHlwZW9mID09PSB3IHx8IEMuJCR0eXBlb2YgPT09IGIgfHwgQy4kJHR5cGVvZiA9PT0gaCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG0oQykge1xuICAgICAgaWYgKHR5cGVvZiBDID09IFwib2JqZWN0XCIgJiYgQyAhPT0gbnVsbCkge1xuICAgICAgICB2YXIgZ2UgPSBDLiQkdHlwZW9mO1xuICAgICAgICBzd2l0Y2ggKGdlKSB7XG4gICAgICAgICAgY2FzZSB0OlxuICAgICAgICAgICAgdmFyIGxlID0gQy50eXBlO1xuICAgICAgICAgICAgc3dpdGNoIChsZSkge1xuICAgICAgICAgICAgICBjYXNlIHU6XG4gICAgICAgICAgICAgIGNhc2UgYzpcbiAgICAgICAgICAgICAgY2FzZSByOlxuICAgICAgICAgICAgICBjYXNlIG86XG4gICAgICAgICAgICAgIGNhc2UgaTpcbiAgICAgICAgICAgICAgY2FzZSBsOlxuICAgICAgICAgICAgICAgIHJldHVybiBsZTtcbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB2YXIgeGUgPSBsZSAmJiBsZS4kJHR5cGVvZjtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHhlKSB7XG4gICAgICAgICAgICAgICAgICBjYXNlIHM6XG4gICAgICAgICAgICAgICAgICBjYXNlIGY6XG4gICAgICAgICAgICAgICAgICBjYXNlIGc6XG4gICAgICAgICAgICAgICAgICBjYXNlIHA6XG4gICAgICAgICAgICAgICAgICBjYXNlIGE6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB4ZTtcbiAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBnZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSBuOlxuICAgICAgICAgICAgcmV0dXJuIGdlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHZhciB5ID0gdSwgUyA9IGMsICQgPSBzLCBPID0gYSwgVCA9IHQsIE0gPSBmLCBFID0gciwgQSA9IGcsIGogPSBwLCBSID0gbiwgTiA9IG8sIGsgPSBpLCBGID0gbCwgViA9ICExO1xuICAgIGZ1bmN0aW9uIEwoQykge1xuICAgICAgcmV0dXJuIFYgfHwgKFYgPSAhMCwgY29uc29sZS53YXJuKFwiVGhlIFJlYWN0SXMuaXNBc3luY01vZGUoKSBhbGlhcyBoYXMgYmVlbiBkZXByZWNhdGVkLCBhbmQgd2lsbCBiZSByZW1vdmVkIGluIFJlYWN0IDE3Ky4gVXBkYXRlIHlvdXIgY29kZSB0byB1c2UgUmVhY3RJcy5pc0NvbmN1cnJlbnRNb2RlKCkgaW5zdGVhZC4gSXQgaGFzIHRoZSBleGFjdCBzYW1lIEFQSS5cIikpLCBJKEMpIHx8IG0oQykgPT09IHU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIEkoQykge1xuICAgICAgcmV0dXJuIG0oQykgPT09IGM7XG4gICAgfVxuICAgIGZ1bmN0aW9uIEQoQykge1xuICAgICAgcmV0dXJuIG0oQykgPT09IHM7XG4gICAgfVxuICAgIGZ1bmN0aW9uIEcoQykge1xuICAgICAgcmV0dXJuIG0oQykgPT09IGE7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHEoQykge1xuICAgICAgcmV0dXJuIHR5cGVvZiBDID09IFwib2JqZWN0XCIgJiYgQyAhPT0gbnVsbCAmJiBDLiQkdHlwZW9mID09PSB0O1xuICAgIH1cbiAgICBmdW5jdGlvbiBKKEMpIHtcbiAgICAgIHJldHVybiBtKEMpID09PSBmO1xuICAgIH1cbiAgICBmdW5jdGlvbiBuZShDKSB7XG4gICAgICByZXR1cm4gbShDKSA9PT0gcjtcbiAgICB9XG4gICAgZnVuY3Rpb24gdGUoQykge1xuICAgICAgcmV0dXJuIG0oQykgPT09IGc7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGVlKEMpIHtcbiAgICAgIHJldHVybiBtKEMpID09PSBwO1xuICAgIH1cbiAgICBmdW5jdGlvbiBpZShDKSB7XG4gICAgICByZXR1cm4gbShDKSA9PT0gbjtcbiAgICB9XG4gICAgZnVuY3Rpb24gQihDKSB7XG4gICAgICByZXR1cm4gbShDKSA9PT0gbztcbiAgICB9XG4gICAgZnVuY3Rpb24gVShDKSB7XG4gICAgICByZXR1cm4gbShDKSA9PT0gaTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmUoQykge1xuICAgICAgcmV0dXJuIG0oQykgPT09IGw7XG4gICAgfVxuICAgIENlLkFzeW5jTW9kZSA9IHksIENlLkNvbmN1cnJlbnRNb2RlID0gUywgQ2UuQ29udGV4dENvbnN1bWVyID0gJCwgQ2UuQ29udGV4dFByb3ZpZGVyID0gTywgQ2UuRWxlbWVudCA9IFQsIENlLkZvcndhcmRSZWYgPSBNLCBDZS5GcmFnbWVudCA9IEUsIENlLkxhenkgPSBBLCBDZS5NZW1vID0gaiwgQ2UuUG9ydGFsID0gUiwgQ2UuUHJvZmlsZXIgPSBOLCBDZS5TdHJpY3RNb2RlID0gaywgQ2UuU3VzcGVuc2UgPSBGLCBDZS5pc0FzeW5jTW9kZSA9IEwsIENlLmlzQ29uY3VycmVudE1vZGUgPSBJLCBDZS5pc0NvbnRleHRDb25zdW1lciA9IEQsIENlLmlzQ29udGV4dFByb3ZpZGVyID0gRywgQ2UuaXNFbGVtZW50ID0gcSwgQ2UuaXNGb3J3YXJkUmVmID0gSiwgQ2UuaXNGcmFnbWVudCA9IG5lLCBDZS5pc0xhenkgPSB0ZSwgQ2UuaXNNZW1vID0gZWUsIENlLmlzUG9ydGFsID0gaWUsIENlLmlzUHJvZmlsZXIgPSBCLCBDZS5pc1N0cmljdE1vZGUgPSBVLCBDZS5pc1N1c3BlbnNlID0gcmUsIENlLmlzVmFsaWRFbGVtZW50VHlwZSA9IHgsIENlLnR5cGVPZiA9IG07XG4gIH0oKSksIENlO1xufVxucHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gX2MuZXhwb3J0cyA9IERDKCkgOiBfYy5leHBvcnRzID0gTkMoKTtcbnZhciBPZiA9IF9jLmV4cG9ydHMsIEZDID0gUG4sIExDID0gQ24sIEJDID0gXCJbb2JqZWN0IE51bWJlcl1cIjtcbmZ1bmN0aW9uIHpDKGUpIHtcbiAgcmV0dXJuIHR5cGVvZiBlID09IFwibnVtYmVyXCIgfHwgTEMoZSkgJiYgRkMoZSkgPT0gQkM7XG59XG52YXIgenkgPSB6QztcbmNvbnN0IFZDID0gLyogQF9fUFVSRV9fICovIGplKHp5KTtcbnZhciBHQyA9IHp5O1xuZnVuY3Rpb24gV0MoZSkge1xuICByZXR1cm4gR0MoZSkgJiYgZSAhPSArZTtcbn1cbnZhciBVQyA9IFdDO1xuY29uc3QgV28gPSAvKiBAX19QVVJFX18gKi8gamUoVUMpO1xudmFyIEt0ID0gZnVuY3Rpb24odCkge1xuICByZXR1cm4gdCA9PT0gMCA/IDAgOiB0ID4gMCA/IDEgOiAtMTtcbn0sIEFjID0gZnVuY3Rpb24odCkge1xuICByZXR1cm4gR28odCkgJiYgdC5pbmRleE9mKFwiJVwiKSA9PT0gdC5sZW5ndGggLSAxO1xufSwgSyA9IGZ1bmN0aW9uKHQpIHtcbiAgcmV0dXJuIFZDKHQpICYmICFXbyh0KTtcbn0sIEtlID0gZnVuY3Rpb24odCkge1xuICByZXR1cm4gSyh0KSB8fCBHbyh0KTtcbn0sIEhDID0gMCwgVW8gPSBmdW5jdGlvbih0KSB7XG4gIHZhciBuID0gKytIQztcbiAgcmV0dXJuIFwiXCIuY29uY2F0KHQgfHwgXCJcIikuY29uY2F0KG4pO1xufSwgbHIgPSBmdW5jdGlvbih0LCBuKSB7XG4gIHZhciByID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB2b2lkIDAgPyBhcmd1bWVudHNbMl0gOiAwLCBpID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB2b2lkIDAgPyBhcmd1bWVudHNbM10gOiAhMTtcbiAgaWYgKCFLKHQpICYmICFHbyh0KSlcbiAgICByZXR1cm4gcjtcbiAgdmFyIG87XG4gIGlmIChBYyh0KSkge1xuICAgIHZhciBhID0gdC5pbmRleE9mKFwiJVwiKTtcbiAgICBvID0gbiAqIHBhcnNlRmxvYXQodC5zbGljZSgwLCBhKSkgLyAxMDA7XG4gIH0gZWxzZVxuICAgIG8gPSArdDtcbiAgcmV0dXJuIFdvKG8pICYmIChvID0gciksIGkgJiYgbyA+IG4gJiYgKG8gPSBuKSwgbztcbn0sIGtuID0gZnVuY3Rpb24odCkge1xuICBpZiAoIXQpXG4gICAgcmV0dXJuIG51bGw7XG4gIHZhciBuID0gT2JqZWN0LmtleXModCk7XG4gIHJldHVybiBuICYmIG4ubGVuZ3RoID8gdFtuWzBdXSA6IG51bGw7XG59LCBxQyA9IGZ1bmN0aW9uKHQpIHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KHQpKVxuICAgIHJldHVybiAhMTtcbiAgZm9yICh2YXIgbiA9IHQubGVuZ3RoLCByID0ge30sIGkgPSAwOyBpIDwgbjsgaSsrKVxuICAgIGlmICghclt0W2ldXSlcbiAgICAgIHJbdFtpXV0gPSAhMDtcbiAgICBlbHNlXG4gICAgICByZXR1cm4gITA7XG4gIHJldHVybiAhMTtcbn0sIEh0ID0gZnVuY3Rpb24odCwgbikge1xuICByZXR1cm4gSyh0KSAmJiBLKG4pID8gZnVuY3Rpb24ocikge1xuICAgIHJldHVybiB0ICsgciAqIChuIC0gdCk7XG4gIH0gOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gbjtcbiAgfTtcbn07XG5mdW5jdGlvbiBEYShlLCB0LCBuKSB7XG4gIHJldHVybiAhZSB8fCAhZS5sZW5ndGggPyBudWxsIDogZS5maW5kKGZ1bmN0aW9uKHIpIHtcbiAgICByZXR1cm4gciAmJiAodHlwZW9mIHQgPT0gXCJmdW5jdGlvblwiID8gdChyKSA6IGp0KHIsIHQpKSA9PT0gbjtcbiAgfSk7XG59XG5mdW5jdGlvbiBScihlLCB0KSB7XG4gIGZvciAodmFyIG4gaW4gZSlcbiAgICBpZiAoe30uaGFzT3duUHJvcGVydHkuY2FsbChlLCBuKSAmJiAoIXt9Lmhhc093blByb3BlcnR5LmNhbGwodCwgbikgfHwgZVtuXSAhPT0gdFtuXSkpXG4gICAgICByZXR1cm4gITE7XG4gIGZvciAodmFyIHIgaW4gdClcbiAgICBpZiAoe30uaGFzT3duUHJvcGVydHkuY2FsbCh0LCByKSAmJiAhe30uaGFzT3duUHJvcGVydHkuY2FsbChlLCByKSlcbiAgICAgIHJldHVybiAhMTtcbiAgcmV0dXJuICEwO1xufVxuZnVuY3Rpb24gUGMoZSkge1xuICBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7XG4gIHJldHVybiBQYyA9IHR5cGVvZiBTeW1ib2wgPT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uKHQpIHtcbiAgICByZXR1cm4gdHlwZW9mIHQ7XG4gIH0gOiBmdW5jdGlvbih0KSB7XG4gICAgcmV0dXJuIHQgJiYgdHlwZW9mIFN5bWJvbCA9PSBcImZ1bmN0aW9uXCIgJiYgdC5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIHQgIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIHQ7XG4gIH0sIFBjKGUpO1xufVxudmFyIEtDID0gW1widmlld0JveFwiLCBcImNoaWxkcmVuXCJdLCBZQyA9IFtcbiAgXCJhcmlhLWFjdGl2ZWRlc2NlbmRhbnRcIixcbiAgXCJhcmlhLWF0b21pY1wiLFxuICBcImFyaWEtYXV0b2NvbXBsZXRlXCIsXG4gIFwiYXJpYS1idXN5XCIsXG4gIFwiYXJpYS1jaGVja2VkXCIsXG4gIFwiYXJpYS1jb2xjb3VudFwiLFxuICBcImFyaWEtY29saW5kZXhcIixcbiAgXCJhcmlhLWNvbHNwYW5cIixcbiAgXCJhcmlhLWNvbnRyb2xzXCIsXG4gIFwiYXJpYS1jdXJyZW50XCIsXG4gIFwiYXJpYS1kZXNjcmliZWRieVwiLFxuICBcImFyaWEtZGV0YWlsc1wiLFxuICBcImFyaWEtZGlzYWJsZWRcIixcbiAgXCJhcmlhLWVycm9ybWVzc2FnZVwiLFxuICBcImFyaWEtZXhwYW5kZWRcIixcbiAgXCJhcmlhLWZsb3d0b1wiLFxuICBcImFyaWEtaGFzcG9wdXBcIixcbiAgXCJhcmlhLWhpZGRlblwiLFxuICBcImFyaWEtaW52YWxpZFwiLFxuICBcImFyaWEta2V5c2hvcnRjdXRzXCIsXG4gIFwiYXJpYS1sYWJlbFwiLFxuICBcImFyaWEtbGFiZWxsZWRieVwiLFxuICBcImFyaWEtbGV2ZWxcIixcbiAgXCJhcmlhLWxpdmVcIixcbiAgXCJhcmlhLW1vZGFsXCIsXG4gIFwiYXJpYS1tdWx0aWxpbmVcIixcbiAgXCJhcmlhLW11bHRpc2VsZWN0YWJsZVwiLFxuICBcImFyaWEtb3JpZW50YXRpb25cIixcbiAgXCJhcmlhLW93bnNcIixcbiAgXCJhcmlhLXBsYWNlaG9sZGVyXCIsXG4gIFwiYXJpYS1wb3NpbnNldFwiLFxuICBcImFyaWEtcHJlc3NlZFwiLFxuICBcImFyaWEtcmVhZG9ubHlcIixcbiAgXCJhcmlhLXJlbGV2YW50XCIsXG4gIFwiYXJpYS1yZXF1aXJlZFwiLFxuICBcImFyaWEtcm9sZWRlc2NyaXB0aW9uXCIsXG4gIFwiYXJpYS1yb3djb3VudFwiLFxuICBcImFyaWEtcm93aW5kZXhcIixcbiAgXCJhcmlhLXJvd3NwYW5cIixcbiAgXCJhcmlhLXNlbGVjdGVkXCIsXG4gIFwiYXJpYS1zZXRzaXplXCIsXG4gIFwiYXJpYS1zb3J0XCIsXG4gIFwiYXJpYS12YWx1ZW1heFwiLFxuICBcImFyaWEtdmFsdWVtaW5cIixcbiAgXCJhcmlhLXZhbHVlbm93XCIsXG4gIFwiYXJpYS12YWx1ZXRleHRcIixcbiAgXCJjbGFzc05hbWVcIixcbiAgXCJjb2xvclwiLFxuICBcImhlaWdodFwiLFxuICBcImlkXCIsXG4gIFwibGFuZ1wiLFxuICBcIm1heFwiLFxuICBcIm1lZGlhXCIsXG4gIFwibWV0aG9kXCIsXG4gIFwibWluXCIsXG4gIFwibmFtZVwiLFxuICBcInN0eWxlXCIsXG4gIC8qXG4gICAqIHJlbW92ZWQgJ3R5cGUnIFNWR0VsZW1lbnRQcm9wS2V5IGJlY2F1c2Ugd2UgZG8gbm90IGN1cnJlbnRseSB1c2UgYW55IFNWRyBlbGVtZW50c1xuICAgKiB0aGF0IGNhbiB1c2UgaXQgYW5kIGl0IGNvbmZsaWN0cyB3aXRoIHRoZSByZWNoYXJ0cyBwcm9wICd0eXBlJ1xuICAgKiBodHRwczovL2dpdGh1Yi5jb20vcmVjaGFydHMvcmVjaGFydHMvcHVsbC8zMzI3XG4gICAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL1NWRy9BdHRyaWJ1dGUvdHlwZVxuICAgKi9cbiAgLy8gJ3R5cGUnLFxuICBcInRhcmdldFwiLFxuICBcIndpZHRoXCIsXG4gIFwicm9sZVwiLFxuICBcInRhYkluZGV4XCIsXG4gIFwiYWNjZW50SGVpZ2h0XCIsXG4gIFwiYWNjdW11bGF0ZVwiLFxuICBcImFkZGl0aXZlXCIsXG4gIFwiYWxpZ25tZW50QmFzZWxpbmVcIixcbiAgXCJhbGxvd1Jlb3JkZXJcIixcbiAgXCJhbHBoYWJldGljXCIsXG4gIFwiYW1wbGl0dWRlXCIsXG4gIFwiYXJhYmljRm9ybVwiLFxuICBcImFzY2VudFwiLFxuICBcImF0dHJpYnV0ZU5hbWVcIixcbiAgXCJhdHRyaWJ1dGVUeXBlXCIsXG4gIFwiYXV0b1JldmVyc2VcIixcbiAgXCJhemltdXRoXCIsXG4gIFwiYmFzZUZyZXF1ZW5jeVwiLFxuICBcImJhc2VsaW5lU2hpZnRcIixcbiAgXCJiYXNlUHJvZmlsZVwiLFxuICBcImJib3hcIixcbiAgXCJiZWdpblwiLFxuICBcImJpYXNcIixcbiAgXCJieVwiLFxuICBcImNhbGNNb2RlXCIsXG4gIFwiY2FwSGVpZ2h0XCIsXG4gIFwiY2xpcFwiLFxuICBcImNsaXBQYXRoXCIsXG4gIFwiY2xpcFBhdGhVbml0c1wiLFxuICBcImNsaXBSdWxlXCIsXG4gIFwiY29sb3JJbnRlcnBvbGF0aW9uXCIsXG4gIFwiY29sb3JJbnRlcnBvbGF0aW9uRmlsdGVyc1wiLFxuICBcImNvbG9yUHJvZmlsZVwiLFxuICBcImNvbG9yUmVuZGVyaW5nXCIsXG4gIFwiY29udGVudFNjcmlwdFR5cGVcIixcbiAgXCJjb250ZW50U3R5bGVUeXBlXCIsXG4gIFwiY3Vyc29yXCIsXG4gIFwiY3hcIixcbiAgXCJjeVwiLFxuICBcImRcIixcbiAgXCJkZWNlbGVyYXRlXCIsXG4gIFwiZGVzY2VudFwiLFxuICBcImRpZmZ1c2VDb25zdGFudFwiLFxuICBcImRpcmVjdGlvblwiLFxuICBcImRpc3BsYXlcIixcbiAgXCJkaXZpc29yXCIsXG4gIFwiZG9taW5hbnRCYXNlbGluZVwiLFxuICBcImR1clwiLFxuICBcImR4XCIsXG4gIFwiZHlcIixcbiAgXCJlZGdlTW9kZVwiLFxuICBcImVsZXZhdGlvblwiLFxuICBcImVuYWJsZUJhY2tncm91bmRcIixcbiAgXCJlbmRcIixcbiAgXCJleHBvbmVudFwiLFxuICBcImV4dGVybmFsUmVzb3VyY2VzUmVxdWlyZWRcIixcbiAgXCJmaWxsXCIsXG4gIFwiZmlsbE9wYWNpdHlcIixcbiAgXCJmaWxsUnVsZVwiLFxuICBcImZpbHRlclwiLFxuICBcImZpbHRlclJlc1wiLFxuICBcImZpbHRlclVuaXRzXCIsXG4gIFwiZmxvb2RDb2xvclwiLFxuICBcImZsb29kT3BhY2l0eVwiLFxuICBcImZvY3VzYWJsZVwiLFxuICBcImZvbnRGYW1pbHlcIixcbiAgXCJmb250U2l6ZVwiLFxuICBcImZvbnRTaXplQWRqdXN0XCIsXG4gIFwiZm9udFN0cmV0Y2hcIixcbiAgXCJmb250U3R5bGVcIixcbiAgXCJmb250VmFyaWFudFwiLFxuICBcImZvbnRXZWlnaHRcIixcbiAgXCJmb3JtYXRcIixcbiAgXCJmcm9tXCIsXG4gIFwiZnhcIixcbiAgXCJmeVwiLFxuICBcImcxXCIsXG4gIFwiZzJcIixcbiAgXCJnbHlwaE5hbWVcIixcbiAgXCJnbHlwaE9yaWVudGF0aW9uSG9yaXpvbnRhbFwiLFxuICBcImdseXBoT3JpZW50YXRpb25WZXJ0aWNhbFwiLFxuICBcImdseXBoUmVmXCIsXG4gIFwiZ3JhZGllbnRUcmFuc2Zvcm1cIixcbiAgXCJncmFkaWVudFVuaXRzXCIsXG4gIFwiaGFuZ2luZ1wiLFxuICBcImhvcml6QWR2WFwiLFxuICBcImhvcml6T3JpZ2luWFwiLFxuICBcImhyZWZcIixcbiAgXCJpZGVvZ3JhcGhpY1wiLFxuICBcImltYWdlUmVuZGVyaW5nXCIsXG4gIFwiaW4yXCIsXG4gIFwiaW5cIixcbiAgXCJpbnRlcmNlcHRcIixcbiAgXCJrMVwiLFxuICBcImsyXCIsXG4gIFwiazNcIixcbiAgXCJrNFwiLFxuICBcImtcIixcbiAgXCJrZXJuZWxNYXRyaXhcIixcbiAgXCJrZXJuZWxVbml0TGVuZ3RoXCIsXG4gIFwia2VybmluZ1wiLFxuICBcImtleVBvaW50c1wiLFxuICBcImtleVNwbGluZXNcIixcbiAgXCJrZXlUaW1lc1wiLFxuICBcImxlbmd0aEFkanVzdFwiLFxuICBcImxldHRlclNwYWNpbmdcIixcbiAgXCJsaWdodGluZ0NvbG9yXCIsXG4gIFwibGltaXRpbmdDb25lQW5nbGVcIixcbiAgXCJsb2NhbFwiLFxuICBcIm1hcmtlckVuZFwiLFxuICBcIm1hcmtlckhlaWdodFwiLFxuICBcIm1hcmtlck1pZFwiLFxuICBcIm1hcmtlclN0YXJ0XCIsXG4gIFwibWFya2VyVW5pdHNcIixcbiAgXCJtYXJrZXJXaWR0aFwiLFxuICBcIm1hc2tcIixcbiAgXCJtYXNrQ29udGVudFVuaXRzXCIsXG4gIFwibWFza1VuaXRzXCIsXG4gIFwibWF0aGVtYXRpY2FsXCIsXG4gIFwibW9kZVwiLFxuICBcIm51bU9jdGF2ZXNcIixcbiAgXCJvZmZzZXRcIixcbiAgXCJvcGFjaXR5XCIsXG4gIFwib3BlcmF0b3JcIixcbiAgXCJvcmRlclwiLFxuICBcIm9yaWVudFwiLFxuICBcIm9yaWVudGF0aW9uXCIsXG4gIFwib3JpZ2luXCIsXG4gIFwib3ZlcmZsb3dcIixcbiAgXCJvdmVybGluZVBvc2l0aW9uXCIsXG4gIFwib3ZlcmxpbmVUaGlja25lc3NcIixcbiAgXCJwYWludE9yZGVyXCIsXG4gIFwicGFub3NlMVwiLFxuICBcInBhdGhMZW5ndGhcIixcbiAgXCJwYXR0ZXJuQ29udGVudFVuaXRzXCIsXG4gIFwicGF0dGVyblRyYW5zZm9ybVwiLFxuICBcInBhdHRlcm5Vbml0c1wiLFxuICBcInBvaW50ZXJFdmVudHNcIixcbiAgXCJwb2ludHNBdFhcIixcbiAgXCJwb2ludHNBdFlcIixcbiAgXCJwb2ludHNBdFpcIixcbiAgXCJwcmVzZXJ2ZUFscGhhXCIsXG4gIFwicHJlc2VydmVBc3BlY3RSYXRpb1wiLFxuICBcInByaW1pdGl2ZVVuaXRzXCIsXG4gIFwiclwiLFxuICBcInJhZGl1c1wiLFxuICBcInJlZlhcIixcbiAgXCJyZWZZXCIsXG4gIFwicmVuZGVyaW5nSW50ZW50XCIsXG4gIFwicmVwZWF0Q291bnRcIixcbiAgXCJyZXBlYXREdXJcIixcbiAgXCJyZXF1aXJlZEV4dGVuc2lvbnNcIixcbiAgXCJyZXF1aXJlZEZlYXR1cmVzXCIsXG4gIFwicmVzdGFydFwiLFxuICBcInJlc3VsdFwiLFxuICBcInJvdGF0ZVwiLFxuICBcInJ4XCIsXG4gIFwicnlcIixcbiAgXCJzZWVkXCIsXG4gIFwic2hhcGVSZW5kZXJpbmdcIixcbiAgXCJzbG9wZVwiLFxuICBcInNwYWNpbmdcIixcbiAgXCJzcGVjdWxhckNvbnN0YW50XCIsXG4gIFwic3BlY3VsYXJFeHBvbmVudFwiLFxuICBcInNwZWVkXCIsXG4gIFwic3ByZWFkTWV0aG9kXCIsXG4gIFwic3RhcnRPZmZzZXRcIixcbiAgXCJzdGREZXZpYXRpb25cIixcbiAgXCJzdGVtaFwiLFxuICBcInN0ZW12XCIsXG4gIFwic3RpdGNoVGlsZXNcIixcbiAgXCJzdG9wQ29sb3JcIixcbiAgXCJzdG9wT3BhY2l0eVwiLFxuICBcInN0cmlrZXRocm91Z2hQb3NpdGlvblwiLFxuICBcInN0cmlrZXRocm91Z2hUaGlja25lc3NcIixcbiAgXCJzdHJpbmdcIixcbiAgXCJzdHJva2VcIixcbiAgXCJzdHJva2VEYXNoYXJyYXlcIixcbiAgXCJzdHJva2VEYXNob2Zmc2V0XCIsXG4gIFwic3Ryb2tlTGluZWNhcFwiLFxuICBcInN0cm9rZUxpbmVqb2luXCIsXG4gIFwic3Ryb2tlTWl0ZXJsaW1pdFwiLFxuICBcInN0cm9rZU9wYWNpdHlcIixcbiAgXCJzdHJva2VXaWR0aFwiLFxuICBcInN1cmZhY2VTY2FsZVwiLFxuICBcInN5c3RlbUxhbmd1YWdlXCIsXG4gIFwidGFibGVWYWx1ZXNcIixcbiAgXCJ0YXJnZXRYXCIsXG4gIFwidGFyZ2V0WVwiLFxuICBcInRleHRBbmNob3JcIixcbiAgXCJ0ZXh0RGVjb3JhdGlvblwiLFxuICBcInRleHRMZW5ndGhcIixcbiAgXCJ0ZXh0UmVuZGVyaW5nXCIsXG4gIFwidG9cIixcbiAgXCJ0cmFuc2Zvcm1cIixcbiAgXCJ1MVwiLFxuICBcInUyXCIsXG4gIFwidW5kZXJsaW5lUG9zaXRpb25cIixcbiAgXCJ1bmRlcmxpbmVUaGlja25lc3NcIixcbiAgXCJ1bmljb2RlXCIsXG4gIFwidW5pY29kZUJpZGlcIixcbiAgXCJ1bmljb2RlUmFuZ2VcIixcbiAgXCJ1bml0c1BlckVtXCIsXG4gIFwidkFscGhhYmV0aWNcIixcbiAgXCJ2YWx1ZXNcIixcbiAgXCJ2ZWN0b3JFZmZlY3RcIixcbiAgXCJ2ZXJzaW9uXCIsXG4gIFwidmVydEFkdllcIixcbiAgXCJ2ZXJ0T3JpZ2luWFwiLFxuICBcInZlcnRPcmlnaW5ZXCIsXG4gIFwidkhhbmdpbmdcIixcbiAgXCJ2SWRlb2dyYXBoaWNcIixcbiAgXCJ2aWV3VGFyZ2V0XCIsXG4gIFwidmlzaWJpbGl0eVwiLFxuICBcInZNYXRoZW1hdGljYWxcIixcbiAgXCJ3aWR0aHNcIixcbiAgXCJ3b3JkU3BhY2luZ1wiLFxuICBcIndyaXRpbmdNb2RlXCIsXG4gIFwieDFcIixcbiAgXCJ4MlwiLFxuICBcInhcIixcbiAgXCJ4Q2hhbm5lbFNlbGVjdG9yXCIsXG4gIFwieEhlaWdodFwiLFxuICBcInhsaW5rQWN0dWF0ZVwiLFxuICBcInhsaW5rQXJjcm9sZVwiLFxuICBcInhsaW5rSHJlZlwiLFxuICBcInhsaW5rUm9sZVwiLFxuICBcInhsaW5rU2hvd1wiLFxuICBcInhsaW5rVGl0bGVcIixcbiAgXCJ4bGlua1R5cGVcIixcbiAgXCJ4bWxCYXNlXCIsXG4gIFwieG1sTGFuZ1wiLFxuICBcInhtbG5zXCIsXG4gIFwieG1sbnNYbGlua1wiLFxuICBcInhtbFNwYWNlXCIsXG4gIFwieTFcIixcbiAgXCJ5MlwiLFxuICBcInlcIixcbiAgXCJ5Q2hhbm5lbFNlbGVjdG9yXCIsXG4gIFwielwiLFxuICBcInpvb21BbmRQYW5cIixcbiAgXCJyZWZcIixcbiAgXCJrZXlcIixcbiAgXCJhbmdsZVwiXG5dLCB3cCA9IFtcInBvaW50c1wiLCBcInBhdGhMZW5ndGhcIl0sIEF1ID0ge1xuICBzdmc6IEtDLFxuICBwb2x5Z29uOiB3cCxcbiAgcG9seWxpbmU6IHdwXG59LCBfZiA9IFtcImRhbmdlcm91c2x5U2V0SW5uZXJIVE1MXCIsIFwib25Db3B5XCIsIFwib25Db3B5Q2FwdHVyZVwiLCBcIm9uQ3V0XCIsIFwib25DdXRDYXB0dXJlXCIsIFwib25QYXN0ZVwiLCBcIm9uUGFzdGVDYXB0dXJlXCIsIFwib25Db21wb3NpdGlvbkVuZFwiLCBcIm9uQ29tcG9zaXRpb25FbmRDYXB0dXJlXCIsIFwib25Db21wb3NpdGlvblN0YXJ0XCIsIFwib25Db21wb3NpdGlvblN0YXJ0Q2FwdHVyZVwiLCBcIm9uQ29tcG9zaXRpb25VcGRhdGVcIiwgXCJvbkNvbXBvc2l0aW9uVXBkYXRlQ2FwdHVyZVwiLCBcIm9uRm9jdXNcIiwgXCJvbkZvY3VzQ2FwdHVyZVwiLCBcIm9uQmx1clwiLCBcIm9uQmx1ckNhcHR1cmVcIiwgXCJvbkNoYW5nZVwiLCBcIm9uQ2hhbmdlQ2FwdHVyZVwiLCBcIm9uQmVmb3JlSW5wdXRcIiwgXCJvbkJlZm9yZUlucHV0Q2FwdHVyZVwiLCBcIm9uSW5wdXRcIiwgXCJvbklucHV0Q2FwdHVyZVwiLCBcIm9uUmVzZXRcIiwgXCJvblJlc2V0Q2FwdHVyZVwiLCBcIm9uU3VibWl0XCIsIFwib25TdWJtaXRDYXB0dXJlXCIsIFwib25JbnZhbGlkXCIsIFwib25JbnZhbGlkQ2FwdHVyZVwiLCBcIm9uTG9hZFwiLCBcIm9uTG9hZENhcHR1cmVcIiwgXCJvbkVycm9yXCIsIFwib25FcnJvckNhcHR1cmVcIiwgXCJvbktleURvd25cIiwgXCJvbktleURvd25DYXB0dXJlXCIsIFwib25LZXlQcmVzc1wiLCBcIm9uS2V5UHJlc3NDYXB0dXJlXCIsIFwib25LZXlVcFwiLCBcIm9uS2V5VXBDYXB0dXJlXCIsIFwib25BYm9ydFwiLCBcIm9uQWJvcnRDYXB0dXJlXCIsIFwib25DYW5QbGF5XCIsIFwib25DYW5QbGF5Q2FwdHVyZVwiLCBcIm9uQ2FuUGxheVRocm91Z2hcIiwgXCJvbkNhblBsYXlUaHJvdWdoQ2FwdHVyZVwiLCBcIm9uRHVyYXRpb25DaGFuZ2VcIiwgXCJvbkR1cmF0aW9uQ2hhbmdlQ2FwdHVyZVwiLCBcIm9uRW1wdGllZFwiLCBcIm9uRW1wdGllZENhcHR1cmVcIiwgXCJvbkVuY3J5cHRlZFwiLCBcIm9uRW5jcnlwdGVkQ2FwdHVyZVwiLCBcIm9uRW5kZWRcIiwgXCJvbkVuZGVkQ2FwdHVyZVwiLCBcIm9uTG9hZGVkRGF0YVwiLCBcIm9uTG9hZGVkRGF0YUNhcHR1cmVcIiwgXCJvbkxvYWRlZE1ldGFkYXRhXCIsIFwib25Mb2FkZWRNZXRhZGF0YUNhcHR1cmVcIiwgXCJvbkxvYWRTdGFydFwiLCBcIm9uTG9hZFN0YXJ0Q2FwdHVyZVwiLCBcIm9uUGF1c2VcIiwgXCJvblBhdXNlQ2FwdHVyZVwiLCBcIm9uUGxheVwiLCBcIm9uUGxheUNhcHR1cmVcIiwgXCJvblBsYXlpbmdcIiwgXCJvblBsYXlpbmdDYXB0dXJlXCIsIFwib25Qcm9ncmVzc1wiLCBcIm9uUHJvZ3Jlc3NDYXB0dXJlXCIsIFwib25SYXRlQ2hhbmdlXCIsIFwib25SYXRlQ2hhbmdlQ2FwdHVyZVwiLCBcIm9uU2Vla2VkXCIsIFwib25TZWVrZWRDYXB0dXJlXCIsIFwib25TZWVraW5nXCIsIFwib25TZWVraW5nQ2FwdHVyZVwiLCBcIm9uU3RhbGxlZFwiLCBcIm9uU3RhbGxlZENhcHR1cmVcIiwgXCJvblN1c3BlbmRcIiwgXCJvblN1c3BlbmRDYXB0dXJlXCIsIFwib25UaW1lVXBkYXRlXCIsIFwib25UaW1lVXBkYXRlQ2FwdHVyZVwiLCBcIm9uVm9sdW1lQ2hhbmdlXCIsIFwib25Wb2x1bWVDaGFuZ2VDYXB0dXJlXCIsIFwib25XYWl0aW5nXCIsIFwib25XYWl0aW5nQ2FwdHVyZVwiLCBcIm9uQXV4Q2xpY2tcIiwgXCJvbkF1eENsaWNrQ2FwdHVyZVwiLCBcIm9uQ2xpY2tcIiwgXCJvbkNsaWNrQ2FwdHVyZVwiLCBcIm9uQ29udGV4dE1lbnVcIiwgXCJvbkNvbnRleHRNZW51Q2FwdHVyZVwiLCBcIm9uRG91YmxlQ2xpY2tcIiwgXCJvbkRvdWJsZUNsaWNrQ2FwdHVyZVwiLCBcIm9uRHJhZ1wiLCBcIm9uRHJhZ0NhcHR1cmVcIiwgXCJvbkRyYWdFbmRcIiwgXCJvbkRyYWdFbmRDYXB0dXJlXCIsIFwib25EcmFnRW50ZXJcIiwgXCJvbkRyYWdFbnRlckNhcHR1cmVcIiwgXCJvbkRyYWdFeGl0XCIsIFwib25EcmFnRXhpdENhcHR1cmVcIiwgXCJvbkRyYWdMZWF2ZVwiLCBcIm9uRHJhZ0xlYXZlQ2FwdHVyZVwiLCBcIm9uRHJhZ092ZXJcIiwgXCJvbkRyYWdPdmVyQ2FwdHVyZVwiLCBcIm9uRHJhZ1N0YXJ0XCIsIFwib25EcmFnU3RhcnRDYXB0dXJlXCIsIFwib25Ecm9wXCIsIFwib25Ecm9wQ2FwdHVyZVwiLCBcIm9uTW91c2VEb3duXCIsIFwib25Nb3VzZURvd25DYXB0dXJlXCIsIFwib25Nb3VzZUVudGVyXCIsIFwib25Nb3VzZUxlYXZlXCIsIFwib25Nb3VzZU1vdmVcIiwgXCJvbk1vdXNlTW92ZUNhcHR1cmVcIiwgXCJvbk1vdXNlT3V0XCIsIFwib25Nb3VzZU91dENhcHR1cmVcIiwgXCJvbk1vdXNlT3ZlclwiLCBcIm9uTW91c2VPdmVyQ2FwdHVyZVwiLCBcIm9uTW91c2VVcFwiLCBcIm9uTW91c2VVcENhcHR1cmVcIiwgXCJvblNlbGVjdFwiLCBcIm9uU2VsZWN0Q2FwdHVyZVwiLCBcIm9uVG91Y2hDYW5jZWxcIiwgXCJvblRvdWNoQ2FuY2VsQ2FwdHVyZVwiLCBcIm9uVG91Y2hFbmRcIiwgXCJvblRvdWNoRW5kQ2FwdHVyZVwiLCBcIm9uVG91Y2hNb3ZlXCIsIFwib25Ub3VjaE1vdmVDYXB0dXJlXCIsIFwib25Ub3VjaFN0YXJ0XCIsIFwib25Ub3VjaFN0YXJ0Q2FwdHVyZVwiLCBcIm9uUG9pbnRlckRvd25cIiwgXCJvblBvaW50ZXJEb3duQ2FwdHVyZVwiLCBcIm9uUG9pbnRlck1vdmVcIiwgXCJvblBvaW50ZXJNb3ZlQ2FwdHVyZVwiLCBcIm9uUG9pbnRlclVwXCIsIFwib25Qb2ludGVyVXBDYXB0dXJlXCIsIFwib25Qb2ludGVyQ2FuY2VsXCIsIFwib25Qb2ludGVyQ2FuY2VsQ2FwdHVyZVwiLCBcIm9uUG9pbnRlckVudGVyXCIsIFwib25Qb2ludGVyRW50ZXJDYXB0dXJlXCIsIFwib25Qb2ludGVyTGVhdmVcIiwgXCJvblBvaW50ZXJMZWF2ZUNhcHR1cmVcIiwgXCJvblBvaW50ZXJPdmVyXCIsIFwib25Qb2ludGVyT3ZlckNhcHR1cmVcIiwgXCJvblBvaW50ZXJPdXRcIiwgXCJvblBvaW50ZXJPdXRDYXB0dXJlXCIsIFwib25Hb3RQb2ludGVyQ2FwdHVyZVwiLCBcIm9uR290UG9pbnRlckNhcHR1cmVDYXB0dXJlXCIsIFwib25Mb3N0UG9pbnRlckNhcHR1cmVcIiwgXCJvbkxvc3RQb2ludGVyQ2FwdHVyZUNhcHR1cmVcIiwgXCJvblNjcm9sbFwiLCBcIm9uU2Nyb2xsQ2FwdHVyZVwiLCBcIm9uV2hlZWxcIiwgXCJvbldoZWVsQ2FwdHVyZVwiLCBcIm9uQW5pbWF0aW9uU3RhcnRcIiwgXCJvbkFuaW1hdGlvblN0YXJ0Q2FwdHVyZVwiLCBcIm9uQW5pbWF0aW9uRW5kXCIsIFwib25BbmltYXRpb25FbmRDYXB0dXJlXCIsIFwib25BbmltYXRpb25JdGVyYXRpb25cIiwgXCJvbkFuaW1hdGlvbkl0ZXJhdGlvbkNhcHR1cmVcIiwgXCJvblRyYW5zaXRpb25FbmRcIiwgXCJvblRyYW5zaXRpb25FbmRDYXB0dXJlXCJdLCBOYSA9IGZ1bmN0aW9uKHQsIG4pIHtcbiAgaWYgKCF0IHx8IHR5cGVvZiB0ID09IFwiZnVuY3Rpb25cIiB8fCB0eXBlb2YgdCA9PSBcImJvb2xlYW5cIilcbiAgICByZXR1cm4gbnVsbDtcbiAgdmFyIHIgPSB0O1xuICBpZiAoLyogQF9fUFVSRV9fICovIHZ0KHQpICYmIChyID0gdC5wcm9wcyksICFjaShyKSlcbiAgICByZXR1cm4gbnVsbDtcbiAgdmFyIGkgPSB7fTtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKHIpLmZvckVhY2goZnVuY3Rpb24obykge1xuICAgIF9mLmluY2x1ZGVzKG8pICYmIChpW29dID0gbiB8fCBmdW5jdGlvbihhKSB7XG4gICAgICByZXR1cm4gcltvXShyLCBhKTtcbiAgICB9KTtcbiAgfSksIGk7XG59LCBYQyA9IGZ1bmN0aW9uKHQsIG4sIHIpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGkpIHtcbiAgICByZXR1cm4gdChuLCByLCBpKSwgbnVsbDtcbiAgfTtcbn0sIEZhID0gZnVuY3Rpb24odCwgbiwgcikge1xuICBpZiAoIWNpKHQpIHx8IFBjKHQpICE9PSBcIm9iamVjdFwiKVxuICAgIHJldHVybiBudWxsO1xuICB2YXIgaSA9IG51bGw7XG4gIHJldHVybiBPYmplY3Qua2V5cyh0KS5mb3JFYWNoKGZ1bmN0aW9uKG8pIHtcbiAgICB2YXIgYSA9IHRbb107XG4gICAgX2YuaW5jbHVkZXMobykgJiYgdHlwZW9mIGEgPT0gXCJmdW5jdGlvblwiICYmIChpIHx8IChpID0ge30pLCBpW29dID0gWEMoYSwgbiwgcikpO1xuICB9KSwgaTtcbn0sIFpDID0gW1wiY2hpbGRyZW5cIl0sIEpDID0gW1wiY2hpbGRyZW5cIl07XG5mdW5jdGlvbiB4cChlLCB0KSB7XG4gIGlmIChlID09IG51bGwpXG4gICAgcmV0dXJuIHt9O1xuICB2YXIgbiA9IFFDKGUsIHQpLCByLCBpO1xuICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykge1xuICAgIHZhciBvID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhlKTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgby5sZW5ndGg7IGkrKylcbiAgICAgIHIgPSBvW2ldLCAhKHQuaW5kZXhPZihyKSA+PSAwKSAmJiBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwoZSwgcikgJiYgKG5bcl0gPSBlW3JdKTtcbiAgfVxuICByZXR1cm4gbjtcbn1cbmZ1bmN0aW9uIFFDKGUsIHQpIHtcbiAgaWYgKGUgPT0gbnVsbClcbiAgICByZXR1cm4ge307XG4gIHZhciBuID0ge30sIHIgPSBPYmplY3Qua2V5cyhlKSwgaSwgbztcbiAgZm9yIChvID0gMDsgbyA8IHIubGVuZ3RoOyBvKyspXG4gICAgaSA9IHJbb10sICEodC5pbmRleE9mKGkpID49IDApICYmIChuW2ldID0gZVtpXSk7XG4gIHJldHVybiBuO1xufVxuZnVuY3Rpb24gQ2MoZSkge1xuICBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7XG4gIHJldHVybiBDYyA9IHR5cGVvZiBTeW1ib2wgPT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uKHQpIHtcbiAgICByZXR1cm4gdHlwZW9mIHQ7XG4gIH0gOiBmdW5jdGlvbih0KSB7XG4gICAgcmV0dXJuIHQgJiYgdHlwZW9mIFN5bWJvbCA9PSBcImZ1bmN0aW9uXCIgJiYgdC5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIHQgIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIHQ7XG4gIH0sIENjKGUpO1xufVxudmFyIFNwID0ge1xuICBjbGljazogXCJvbkNsaWNrXCIsXG4gIG1vdXNlZG93bjogXCJvbk1vdXNlRG93blwiLFxuICBtb3VzZXVwOiBcIm9uTW91c2VVcFwiLFxuICBtb3VzZW92ZXI6IFwib25Nb3VzZU92ZXJcIixcbiAgbW91c2Vtb3ZlOiBcIm9uTW91c2VNb3ZlXCIsXG4gIG1vdXNlb3V0OiBcIm9uTW91c2VPdXRcIixcbiAgbW91c2VlbnRlcjogXCJvbk1vdXNlRW50ZXJcIixcbiAgbW91c2VsZWF2ZTogXCJvbk1vdXNlTGVhdmVcIixcbiAgdG91Y2hjYW5jZWw6IFwib25Ub3VjaENhbmNlbFwiLFxuICB0b3VjaGVuZDogXCJvblRvdWNoRW5kXCIsXG4gIHRvdWNobW92ZTogXCJvblRvdWNoTW92ZVwiLFxuICB0b3VjaHN0YXJ0OiBcIm9uVG91Y2hTdGFydFwiXG59LCBGbiA9IGZ1bmN0aW9uKHQpIHtcbiAgcmV0dXJuIHR5cGVvZiB0ID09IFwic3RyaW5nXCIgPyB0IDogdCA/IHQuZGlzcGxheU5hbWUgfHwgdC5uYW1lIHx8IFwiQ29tcG9uZW50XCIgOiBcIlwiO1xufSwgJHAgPSBudWxsLCBQdSA9IG51bGwsIEFmID0gZnVuY3Rpb24gZSh0KSB7XG4gIGlmICh0ID09PSAkcCAmJiBBcnJheS5pc0FycmF5KFB1KSlcbiAgICByZXR1cm4gUHU7XG4gIHZhciBuID0gW107XG4gIHJldHVybiAkdC5mb3JFYWNoKHQsIGZ1bmN0aW9uKHIpIHtcbiAgICBtZShyKSB8fCAoT2YuaXNGcmFnbWVudChyKSA/IG4gPSBuLmNvbmNhdChlKHIucHJvcHMuY2hpbGRyZW4pKSA6IG4ucHVzaChyKSk7XG4gIH0pLCBQdSA9IG4sICRwID0gdCwgbjtcbn07XG5mdW5jdGlvbiBrdChlLCB0KSB7XG4gIHZhciBuID0gW10sIHIgPSBbXTtcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkodCkgPyByID0gdC5tYXAoZnVuY3Rpb24oaSkge1xuICAgIHJldHVybiBGbihpKTtcbiAgfSkgOiByID0gW0ZuKHQpXSwgQWYoZSkuZm9yRWFjaChmdW5jdGlvbihpKSB7XG4gICAgdmFyIG8gPSBqdChpLCBcInR5cGUuZGlzcGxheU5hbWVcIikgfHwganQoaSwgXCJ0eXBlLm5hbWVcIik7XG4gICAgci5pbmRleE9mKG8pICE9PSAtMSAmJiBuLnB1c2goaSk7XG4gIH0pLCBuO1xufVxuZnVuY3Rpb24gd3QoZSwgdCkge1xuICB2YXIgbiA9IGt0KGUsIHQpO1xuICByZXR1cm4gbiAmJiBuWzBdO1xufVxudmFyIE9wID0gZnVuY3Rpb24odCkge1xuICBpZiAoIXQgfHwgIXQucHJvcHMpXG4gICAgcmV0dXJuICExO1xuICB2YXIgbiA9IHQucHJvcHMsIHIgPSBuLndpZHRoLCBpID0gbi5oZWlnaHQ7XG4gIHJldHVybiAhKCFLKHIpIHx8IHIgPD0gMCB8fCAhSyhpKSB8fCBpIDw9IDApO1xufSwgZUUgPSBbXCJhXCIsIFwiYWx0R2x5cGhcIiwgXCJhbHRHbHlwaERlZlwiLCBcImFsdEdseXBoSXRlbVwiLCBcImFuaW1hdGVcIiwgXCJhbmltYXRlQ29sb3JcIiwgXCJhbmltYXRlTW90aW9uXCIsIFwiYW5pbWF0ZVRyYW5zZm9ybVwiLCBcImNpcmNsZVwiLCBcImNsaXBQYXRoXCIsIFwiY29sb3ItcHJvZmlsZVwiLCBcImN1cnNvclwiLCBcImRlZnNcIiwgXCJkZXNjXCIsIFwiZWxsaXBzZVwiLCBcImZlQmxlbmRcIiwgXCJmZUNvbG9ybWF0cml4XCIsIFwiZmVDb21wb25lbnRUcmFuc2ZlclwiLCBcImZlQ29tcG9zaXRlXCIsIFwiZmVDb252b2x2ZU1hdHJpeFwiLCBcImZlRGlmZnVzZUxpZ2h0aW5nXCIsIFwiZmVEaXNwbGFjZW1lbnRNYXBcIiwgXCJmZURpc3RhbnRMaWdodFwiLCBcImZlRmxvb2RcIiwgXCJmZUZ1bmNBXCIsIFwiZmVGdW5jQlwiLCBcImZlRnVuY0dcIiwgXCJmZUZ1bmNSXCIsIFwiZmVHYXVzc2lhbkJsdXJcIiwgXCJmZUltYWdlXCIsIFwiZmVNZXJnZVwiLCBcImZlTWVyZ2VOb2RlXCIsIFwiZmVNb3JwaG9sb2d5XCIsIFwiZmVPZmZzZXRcIiwgXCJmZVBvaW50TGlnaHRcIiwgXCJmZVNwZWN1bGFyTGlnaHRpbmdcIiwgXCJmZVNwb3RMaWdodFwiLCBcImZlVGlsZVwiLCBcImZlVHVyYnVsZW5jZVwiLCBcImZpbHRlclwiLCBcImZvbnRcIiwgXCJmb250LWZhY2VcIiwgXCJmb250LWZhY2UtZm9ybWF0XCIsIFwiZm9udC1mYWNlLW5hbWVcIiwgXCJmb250LWZhY2UtdXJsXCIsIFwiZm9yZWlnbk9iamVjdFwiLCBcImdcIiwgXCJnbHlwaFwiLCBcImdseXBoUmVmXCIsIFwiaGtlcm5cIiwgXCJpbWFnZVwiLCBcImxpbmVcIiwgXCJsaW5lR3JhZGllbnRcIiwgXCJtYXJrZXJcIiwgXCJtYXNrXCIsIFwibWV0YWRhdGFcIiwgXCJtaXNzaW5nLWdseXBoXCIsIFwibXBhdGhcIiwgXCJwYXRoXCIsIFwicGF0dGVyblwiLCBcInBvbHlnb25cIiwgXCJwb2x5bGluZVwiLCBcInJhZGlhbEdyYWRpZW50XCIsIFwicmVjdFwiLCBcInNjcmlwdFwiLCBcInNldFwiLCBcInN0b3BcIiwgXCJzdHlsZVwiLCBcInN2Z1wiLCBcInN3aXRjaFwiLCBcInN5bWJvbFwiLCBcInRleHRcIiwgXCJ0ZXh0UGF0aFwiLCBcInRpdGxlXCIsIFwidHJlZlwiLCBcInRzcGFuXCIsIFwidXNlXCIsIFwidmlld1wiLCBcInZrZXJuXCJdLCB0RSA9IGZ1bmN0aW9uKHQpIHtcbiAgcmV0dXJuIHQgJiYgdC50eXBlICYmIEdvKHQudHlwZSkgJiYgZUUuaW5kZXhPZih0LnR5cGUpID49IDA7XG59LCBuRSA9IGZ1bmN0aW9uKHQpIHtcbiAgcmV0dXJuIHQgJiYgQ2ModCkgPT09IFwib2JqZWN0XCIgJiYgXCJjeFwiIGluIHQgJiYgXCJjeVwiIGluIHQgJiYgXCJyXCIgaW4gdDtcbn0sIHJFID0gZnVuY3Rpb24odCwgbiwgciwgaSkge1xuICB2YXIgbywgYSA9IChvID0gQXUgPT0gbnVsbCA/IHZvaWQgMCA6IEF1W2ldKSAhPT0gbnVsbCAmJiBvICE9PSB2b2lkIDAgPyBvIDogW107XG4gIHJldHVybiAhcGUodCkgJiYgKGkgJiYgYS5pbmNsdWRlcyhuKSB8fCBZQy5pbmNsdWRlcyhuKSkgfHwgciAmJiBfZi5pbmNsdWRlcyhuKTtcbn0sIHllID0gZnVuY3Rpb24odCwgbiwgcikge1xuICBpZiAoIXQgfHwgdHlwZW9mIHQgPT0gXCJmdW5jdGlvblwiIHx8IHR5cGVvZiB0ID09IFwiYm9vbGVhblwiKVxuICAgIHJldHVybiBudWxsO1xuICB2YXIgaSA9IHQ7XG4gIGlmICgvKiBAX19QVVJFX18gKi8gdnQodCkgJiYgKGkgPSB0LnByb3BzKSwgIWNpKGkpKVxuICAgIHJldHVybiBudWxsO1xuICB2YXIgbyA9IHt9O1xuICByZXR1cm4gT2JqZWN0LmtleXMoaSkuZm9yRWFjaChmdW5jdGlvbihhKSB7XG4gICAgdmFyIHM7XG4gICAgckUoKHMgPSBpKSA9PT0gbnVsbCB8fCBzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzW2FdLCBhLCBuLCByKSAmJiAob1thXSA9IGlbYV0pO1xuICB9KSwgbztcbn0sIEVjID0gZnVuY3Rpb24gZSh0LCBuKSB7XG4gIGlmICh0ID09PSBuKVxuICAgIHJldHVybiAhMDtcbiAgdmFyIHIgPSAkdC5jb3VudCh0KTtcbiAgaWYgKHIgIT09ICR0LmNvdW50KG4pKVxuICAgIHJldHVybiAhMTtcbiAgaWYgKHIgPT09IDApXG4gICAgcmV0dXJuICEwO1xuICBpZiAociA9PT0gMSlcbiAgICByZXR1cm4gX3AoQXJyYXkuaXNBcnJheSh0KSA/IHRbMF0gOiB0LCBBcnJheS5pc0FycmF5KG4pID8gblswXSA6IG4pO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHI7IGkrKykge1xuICAgIHZhciBvID0gdFtpXSwgYSA9IG5baV07XG4gICAgaWYgKEFycmF5LmlzQXJyYXkobykgfHwgQXJyYXkuaXNBcnJheShhKSkge1xuICAgICAgaWYgKCFlKG8sIGEpKVxuICAgICAgICByZXR1cm4gITE7XG4gICAgfSBlbHNlIGlmICghX3AobywgYSkpXG4gICAgICByZXR1cm4gITE7XG4gIH1cbiAgcmV0dXJuICEwO1xufSwgX3AgPSBmdW5jdGlvbih0LCBuKSB7XG4gIGlmIChtZSh0KSAmJiBtZShuKSlcbiAgICByZXR1cm4gITA7XG4gIGlmICghbWUodCkgJiYgIW1lKG4pKSB7XG4gICAgdmFyIHIgPSB0LnByb3BzIHx8IHt9LCBpID0gci5jaGlsZHJlbiwgbyA9IHhwKHIsIFpDKSwgYSA9IG4ucHJvcHMgfHwge30sIHMgPSBhLmNoaWxkcmVuLCB1ID0geHAoYSwgSkMpO1xuICAgIHJldHVybiBpICYmIHMgPyBScihvLCB1KSAmJiBFYyhpLCBzKSA6ICFpICYmICFzID8gUnIobywgdSkgOiAhMTtcbiAgfVxuICByZXR1cm4gITE7XG59LCBBcCA9IGZ1bmN0aW9uKHQsIG4pIHtcbiAgdmFyIHIgPSBbXSwgaSA9IHt9O1xuICByZXR1cm4gQWYodCkuZm9yRWFjaChmdW5jdGlvbihvLCBhKSB7XG4gICAgaWYgKHRFKG8pKVxuICAgICAgci5wdXNoKG8pO1xuICAgIGVsc2UgaWYgKG8pIHtcbiAgICAgIHZhciBzID0gRm4oby50eXBlKSwgdSA9IG5bc10gfHwge30sIGMgPSB1LmhhbmRsZXIsIGYgPSB1Lm9uY2U7XG4gICAgICBpZiAoYyAmJiAoIWYgfHwgIWlbc10pKSB7XG4gICAgICAgIHZhciBsID0gYyhvLCBzLCBhKTtcbiAgICAgICAgci5wdXNoKGwpLCBpW3NdID0gITA7XG4gICAgICB9XG4gICAgfVxuICB9KSwgcjtcbn0sIGlFID0gZnVuY3Rpb24odCkge1xuICB2YXIgbiA9IHQgJiYgdC50eXBlO1xuICByZXR1cm4gbiAmJiBTcFtuXSA/IFNwW25dIDogbnVsbDtcbn0sIG9FID0gZnVuY3Rpb24odCwgbikge1xuICByZXR1cm4gQWYobikuaW5kZXhPZih0KTtcbn0sIGFFID0gW1wiY2hpbGRyZW5cIiwgXCJ3aWR0aFwiLCBcImhlaWdodFwiLCBcInZpZXdCb3hcIiwgXCJjbGFzc05hbWVcIiwgXCJzdHlsZVwiLCBcInRpdGxlXCIsIFwiZGVzY1wiXTtcbmZ1bmN0aW9uIFRjKCkge1xuICByZXR1cm4gVGMgPSBPYmplY3QuYXNzaWduID8gT2JqZWN0LmFzc2lnbi5iaW5kKCkgOiBmdW5jdGlvbihlKSB7XG4gICAgZm9yICh2YXIgdCA9IDE7IHQgPCBhcmd1bWVudHMubGVuZ3RoOyB0KyspIHtcbiAgICAgIHZhciBuID0gYXJndW1lbnRzW3RdO1xuICAgICAgZm9yICh2YXIgciBpbiBuKVxuICAgICAgICBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobiwgcikgJiYgKGVbcl0gPSBuW3JdKTtcbiAgICB9XG4gICAgcmV0dXJuIGU7XG4gIH0sIFRjLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5mdW5jdGlvbiBzRShlLCB0KSB7XG4gIGlmIChlID09IG51bGwpXG4gICAgcmV0dXJuIHt9O1xuICB2YXIgbiA9IHVFKGUsIHQpLCByLCBpO1xuICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykge1xuICAgIHZhciBvID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhlKTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgby5sZW5ndGg7IGkrKylcbiAgICAgIHIgPSBvW2ldLCAhKHQuaW5kZXhPZihyKSA+PSAwKSAmJiBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwoZSwgcikgJiYgKG5bcl0gPSBlW3JdKTtcbiAgfVxuICByZXR1cm4gbjtcbn1cbmZ1bmN0aW9uIHVFKGUsIHQpIHtcbiAgaWYgKGUgPT0gbnVsbClcbiAgICByZXR1cm4ge307XG4gIHZhciBuID0ge30sIHIgPSBPYmplY3Qua2V5cyhlKSwgaSwgbztcbiAgZm9yIChvID0gMDsgbyA8IHIubGVuZ3RoOyBvKyspXG4gICAgaSA9IHJbb10sICEodC5pbmRleE9mKGkpID49IDApICYmIChuW2ldID0gZVtpXSk7XG4gIHJldHVybiBuO1xufVxuZnVuY3Rpb24gTWMoZSkge1xuICB2YXIgdCA9IGUuY2hpbGRyZW4sIG4gPSBlLndpZHRoLCByID0gZS5oZWlnaHQsIGkgPSBlLnZpZXdCb3gsIG8gPSBlLmNsYXNzTmFtZSwgYSA9IGUuc3R5bGUsIHMgPSBlLnRpdGxlLCB1ID0gZS5kZXNjLCBjID0gc0UoZSwgYUUpLCBmID0gaSB8fCB7XG4gICAgd2lkdGg6IG4sXG4gICAgaGVpZ2h0OiByLFxuICAgIHg6IDAsXG4gICAgeTogMFxuICB9LCBsID0gJGUoXCJyZWNoYXJ0cy1zdXJmYWNlXCIsIG8pO1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIFAuY3JlYXRlRWxlbWVudChcInN2Z1wiLCBUYyh7fSwgeWUoYywgITAsIFwic3ZnXCIpLCB7XG4gICAgY2xhc3NOYW1lOiBsLFxuICAgIHdpZHRoOiBuLFxuICAgIGhlaWdodDogcixcbiAgICBzdHlsZTogYSxcbiAgICB2aWV3Qm94OiBcIlwiLmNvbmNhdChmLngsIFwiIFwiKS5jb25jYXQoZi55LCBcIiBcIikuY29uY2F0KGYud2lkdGgsIFwiIFwiKS5jb25jYXQoZi5oZWlnaHQpXG4gIH0pLCAvKiBAX19QVVJFX18gKi8gUC5jcmVhdGVFbGVtZW50KFwidGl0bGVcIiwgbnVsbCwgcyksIC8qIEBfX1BVUkVfXyAqLyBQLmNyZWF0ZUVsZW1lbnQoXCJkZXNjXCIsIG51bGwsIHUpLCB0KTtcbn1cbnZhciBjRSA9IFtcImNoaWxkcmVuXCIsIFwiY2xhc3NOYW1lXCJdO1xuZnVuY3Rpb24gUmMoKSB7XG4gIHJldHVybiBSYyA9IE9iamVjdC5hc3NpZ24gPyBPYmplY3QuYXNzaWduLmJpbmQoKSA6IGZ1bmN0aW9uKGUpIHtcbiAgICBmb3IgKHZhciB0ID0gMTsgdCA8IGFyZ3VtZW50cy5sZW5ndGg7IHQrKykge1xuICAgICAgdmFyIG4gPSBhcmd1bWVudHNbdF07XG4gICAgICBmb3IgKHZhciByIGluIG4pXG4gICAgICAgIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChuLCByKSAmJiAoZVtyXSA9IG5bcl0pO1xuICAgIH1cbiAgICByZXR1cm4gZTtcbiAgfSwgUmMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cbmZ1bmN0aW9uIGxFKGUsIHQpIHtcbiAgaWYgKGUgPT0gbnVsbClcbiAgICByZXR1cm4ge307XG4gIHZhciBuID0gZkUoZSwgdCksIHIsIGk7XG4gIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gICAgdmFyIG8gPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGUpO1xuICAgIGZvciAoaSA9IDA7IGkgPCBvLmxlbmd0aDsgaSsrKVxuICAgICAgciA9IG9baV0sICEodC5pbmRleE9mKHIpID49IDApICYmIE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChlLCByKSAmJiAobltyXSA9IGVbcl0pO1xuICB9XG4gIHJldHVybiBuO1xufVxuZnVuY3Rpb24gZkUoZSwgdCkge1xuICBpZiAoZSA9PSBudWxsKVxuICAgIHJldHVybiB7fTtcbiAgdmFyIG4gPSB7fSwgciA9IE9iamVjdC5rZXlzKGUpLCBpLCBvO1xuICBmb3IgKG8gPSAwOyBvIDwgci5sZW5ndGg7IG8rKylcbiAgICBpID0gcltvXSwgISh0LmluZGV4T2YoaSkgPj0gMCkgJiYgKG5baV0gPSBlW2ldKTtcbiAgcmV0dXJuIG47XG59XG52YXIgV2UgPSAvKiBAX19QVVJFX18gKi8gUC5mb3J3YXJkUmVmKGZ1bmN0aW9uKGUsIHQpIHtcbiAgdmFyIG4gPSBlLmNoaWxkcmVuLCByID0gZS5jbGFzc05hbWUsIGkgPSBsRShlLCBjRSksIG8gPSAkZShcInJlY2hhcnRzLWxheWVyXCIsIHIpO1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIFAuY3JlYXRlRWxlbWVudChcImdcIiwgUmMoe1xuICAgIGNsYXNzTmFtZTogb1xuICB9LCB5ZShpLCAhMCksIHtcbiAgICByZWY6IHRcbiAgfSksIG4pO1xufSksIGRFID0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiLCBGciA9IGZ1bmN0aW9uKHQsIG4pIHtcbiAgZm9yICh2YXIgciA9IGFyZ3VtZW50cy5sZW5ndGgsIGkgPSBuZXcgQXJyYXkociA+IDIgPyByIC0gMiA6IDApLCBvID0gMjsgbyA8IHI7IG8rKylcbiAgICBpW28gLSAyXSA9IGFyZ3VtZW50c1tvXTtcbiAgaWYgKGRFICYmIHR5cGVvZiBjb25zb2xlIDwgXCJ1XCIgJiYgY29uc29sZS53YXJuICYmIChuID09PSB2b2lkIDAgJiYgY29uc29sZS53YXJuKFwiTG9nVXRpbHMgcmVxdWlyZXMgYW4gZXJyb3IgbWVzc2FnZSBhcmd1bWVudFwiKSwgIXQpKVxuICAgIGlmIChuID09PSB2b2lkIDApXG4gICAgICBjb25zb2xlLndhcm4oXCJNaW5pZmllZCBleGNlcHRpb24gb2NjdXJyZWQ7IHVzZSB0aGUgbm9uLW1pbmlmaWVkIGRldiBlbnZpcm9ubWVudCBmb3IgdGhlIGZ1bGwgZXJyb3IgbWVzc2FnZSBhbmQgYWRkaXRpb25hbCBoZWxwZnVsIHdhcm5pbmdzLlwiKTtcbiAgICBlbHNlIHtcbiAgICAgIHZhciBhID0gMDtcbiAgICAgIGNvbnNvbGUud2FybihuLnJlcGxhY2UoLyVzL2csIGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gaVthKytdO1xuICAgICAgfSkpO1xuICAgIH1cbn07XG5mdW5jdGlvbiBwRShlLCB0LCBuKSB7XG4gIHZhciByID0gLTEsIGkgPSBlLmxlbmd0aDtcbiAgdCA8IDAgJiYgKHQgPSAtdCA+IGkgPyAwIDogaSArIHQpLCBuID0gbiA+IGkgPyBpIDogbiwgbiA8IDAgJiYgKG4gKz0gaSksIGkgPSB0ID4gbiA/IDAgOiBuIC0gdCA+Pj4gMCwgdCA+Pj49IDA7XG4gIGZvciAodmFyIG8gPSBBcnJheShpKTsgKytyIDwgaTsgKVxuICAgIG9bcl0gPSBlW3IgKyB0XTtcbiAgcmV0dXJuIG87XG59XG52YXIgaEUgPSBwRSwgZ0UgPSBoRTtcbmZ1bmN0aW9uIHZFKGUsIHQsIG4pIHtcbiAgdmFyIHIgPSBlLmxlbmd0aDtcbiAgcmV0dXJuIG4gPSBuID09PSB2b2lkIDAgPyByIDogbiwgIXQgJiYgbiA+PSByID8gZSA6IGdFKGUsIHQsIG4pO1xufVxudmFyIG1FID0gdkUsIHlFID0gXCJcXFxcdWQ4MDAtXFxcXHVkZmZmXCIsIGJFID0gXCJcXFxcdTAzMDAtXFxcXHUwMzZmXCIsIHdFID0gXCJcXFxcdWZlMjAtXFxcXHVmZTJmXCIsIHhFID0gXCJcXFxcdTIwZDAtXFxcXHUyMGZmXCIsIFNFID0gYkUgKyB3RSArIHhFLCAkRSA9IFwiXFxcXHVmZTBlXFxcXHVmZTBmXCIsIE9FID0gXCJcXFxcdTIwMGRcIiwgX0UgPSBSZWdFeHAoXCJbXCIgKyBPRSArIHlFICsgU0UgKyAkRSArIFwiXVwiKTtcbmZ1bmN0aW9uIEFFKGUpIHtcbiAgcmV0dXJuIF9FLnRlc3QoZSk7XG59XG52YXIgVnkgPSBBRTtcbmZ1bmN0aW9uIFBFKGUpIHtcbiAgcmV0dXJuIGUuc3BsaXQoXCJcIik7XG59XG52YXIgQ0UgPSBQRSwgR3kgPSBcIlxcXFx1ZDgwMC1cXFxcdWRmZmZcIiwgRUUgPSBcIlxcXFx1MDMwMC1cXFxcdTAzNmZcIiwgVEUgPSBcIlxcXFx1ZmUyMC1cXFxcdWZlMmZcIiwgTUUgPSBcIlxcXFx1MjBkMC1cXFxcdTIwZmZcIiwgUkUgPSBFRSArIFRFICsgTUUsIElFID0gXCJcXFxcdWZlMGVcXFxcdWZlMGZcIiwgakUgPSBcIltcIiArIEd5ICsgXCJdXCIsIEljID0gXCJbXCIgKyBSRSArIFwiXVwiLCBqYyA9IFwiXFxcXHVkODNjW1xcXFx1ZGZmYi1cXFxcdWRmZmZdXCIsIGtFID0gXCIoPzpcIiArIEljICsgXCJ8XCIgKyBqYyArIFwiKVwiLCBXeSA9IFwiW15cIiArIEd5ICsgXCJdXCIsIFV5ID0gXCIoPzpcXFxcdWQ4M2NbXFxcXHVkZGU2LVxcXFx1ZGRmZl0pezJ9XCIsIEh5ID0gXCJbXFxcXHVkODAwLVxcXFx1ZGJmZl1bXFxcXHVkYzAwLVxcXFx1ZGZmZl1cIiwgREUgPSBcIlxcXFx1MjAwZFwiLCBxeSA9IGtFICsgXCI/XCIsIEt5ID0gXCJbXCIgKyBJRSArIFwiXT9cIiwgTkUgPSBcIig/OlwiICsgREUgKyBcIig/OlwiICsgW1d5LCBVeSwgSHldLmpvaW4oXCJ8XCIpICsgXCIpXCIgKyBLeSArIHF5ICsgXCIpKlwiLCBGRSA9IEt5ICsgcXkgKyBORSwgTEUgPSBcIig/OlwiICsgW1d5ICsgSWMgKyBcIj9cIiwgSWMsIFV5LCBIeSwgakVdLmpvaW4oXCJ8XCIpICsgXCIpXCIsIEJFID0gUmVnRXhwKGpjICsgXCIoPz1cIiArIGpjICsgXCIpfFwiICsgTEUgKyBGRSwgXCJnXCIpO1xuZnVuY3Rpb24gekUoZSkge1xuICByZXR1cm4gZS5tYXRjaChCRSkgfHwgW107XG59XG52YXIgVkUgPSB6RSwgR0UgPSBDRSwgV0UgPSBWeSwgVUUgPSBWRTtcbmZ1bmN0aW9uIEhFKGUpIHtcbiAgcmV0dXJuIFdFKGUpID8gVUUoZSkgOiBHRShlKTtcbn1cbnZhciBxRSA9IEhFLCBLRSA9IG1FLCBZRSA9IFZ5LCBYRSA9IHFFLCBaRSA9IEZ5O1xuZnVuY3Rpb24gSkUoZSkge1xuICByZXR1cm4gZnVuY3Rpb24odCkge1xuICAgIHQgPSBaRSh0KTtcbiAgICB2YXIgbiA9IFlFKHQpID8gWEUodCkgOiB2b2lkIDAsIHIgPSBuID8gblswXSA6IHQuY2hhckF0KDApLCBpID0gbiA/IEtFKG4sIDEpLmpvaW4oXCJcIikgOiB0LnNsaWNlKDEpO1xuICAgIHJldHVybiByW2VdKCkgKyBpO1xuICB9O1xufVxudmFyIFFFID0gSkUsIGVUID0gUUUsIHRUID0gZVQoXCJ0b1VwcGVyQ2FzZVwiKSwgblQgPSB0VDtcbmNvbnN0IEJzID0gLyogQF9fUFVSRV9fICovIGplKG5UKTtcbmZ1bmN0aW9uIEllKGUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBlO1xuICB9O1xufVxuY29uc3QgWXkgPSBNYXRoLmNvcywgTGEgPSBNYXRoLnNpbiwgUXQgPSBNYXRoLnNxcnQsIEJhID0gTWF0aC5QSSwgenMgPSAyICogQmEsIGtjID0gTWF0aC5QSSwgRGMgPSAyICoga2MsIFFuID0gMWUtNiwgclQgPSBEYyAtIFFuO1xuZnVuY3Rpb24gWHkoZSkge1xuICB0aGlzLl8gKz0gZVswXTtcbiAgZm9yIChsZXQgdCA9IDEsIG4gPSBlLmxlbmd0aDsgdCA8IG47ICsrdClcbiAgICB0aGlzLl8gKz0gYXJndW1lbnRzW3RdICsgZVt0XTtcbn1cbmZ1bmN0aW9uIGlUKGUpIHtcbiAgbGV0IHQgPSBNYXRoLmZsb29yKGUpO1xuICBpZiAoISh0ID49IDApKVxuICAgIHRocm93IG5ldyBFcnJvcihgaW52YWxpZCBkaWdpdHM6ICR7ZX1gKTtcbiAgaWYgKHQgPiAxNSlcbiAgICByZXR1cm4gWHk7XG4gIGNvbnN0IG4gPSAxMCAqKiB0O1xuICByZXR1cm4gZnVuY3Rpb24ocikge1xuICAgIHRoaXMuXyArPSByWzBdO1xuICAgIGZvciAobGV0IGkgPSAxLCBvID0gci5sZW5ndGg7IGkgPCBvOyArK2kpXG4gICAgICB0aGlzLl8gKz0gTWF0aC5yb3VuZChhcmd1bWVudHNbaV0gKiBuKSAvIG4gKyByW2ldO1xuICB9O1xufVxuY2xhc3Mgb1Qge1xuICBjb25zdHJ1Y3Rvcih0KSB7XG4gICAgdGhpcy5feDAgPSB0aGlzLl95MCA9IC8vIHN0YXJ0IG9mIGN1cnJlbnQgc3VicGF0aFxuICAgIHRoaXMuX3gxID0gdGhpcy5feTEgPSBudWxsLCB0aGlzLl8gPSBcIlwiLCB0aGlzLl9hcHBlbmQgPSB0ID09IG51bGwgPyBYeSA6IGlUKHQpO1xuICB9XG4gIG1vdmVUbyh0LCBuKSB7XG4gICAgdGhpcy5fYXBwZW5kYE0ke3RoaXMuX3gwID0gdGhpcy5feDEgPSArdH0sJHt0aGlzLl95MCA9IHRoaXMuX3kxID0gK259YDtcbiAgfVxuICBjbG9zZVBhdGgoKSB7XG4gICAgdGhpcy5feDEgIT09IG51bGwgJiYgKHRoaXMuX3gxID0gdGhpcy5feDAsIHRoaXMuX3kxID0gdGhpcy5feTAsIHRoaXMuX2FwcGVuZGBaYCk7XG4gIH1cbiAgbGluZVRvKHQsIG4pIHtcbiAgICB0aGlzLl9hcHBlbmRgTCR7dGhpcy5feDEgPSArdH0sJHt0aGlzLl95MSA9ICtufWA7XG4gIH1cbiAgcXVhZHJhdGljQ3VydmVUbyh0LCBuLCByLCBpKSB7XG4gICAgdGhpcy5fYXBwZW5kYFEkeyt0fSwkeytufSwke3RoaXMuX3gxID0gK3J9LCR7dGhpcy5feTEgPSAraX1gO1xuICB9XG4gIGJlemllckN1cnZlVG8odCwgbiwgciwgaSwgbywgYSkge1xuICAgIHRoaXMuX2FwcGVuZGBDJHsrdH0sJHsrbn0sJHsrcn0sJHsraX0sJHt0aGlzLl94MSA9ICtvfSwke3RoaXMuX3kxID0gK2F9YDtcbiAgfVxuICBhcmNUbyh0LCBuLCByLCBpLCBvKSB7XG4gICAgaWYgKHQgPSArdCwgbiA9ICtuLCByID0gK3IsIGkgPSAraSwgbyA9ICtvLCBvIDwgMClcbiAgICAgIHRocm93IG5ldyBFcnJvcihgbmVnYXRpdmUgcmFkaXVzOiAke299YCk7XG4gICAgbGV0IGEgPSB0aGlzLl94MSwgcyA9IHRoaXMuX3kxLCB1ID0gciAtIHQsIGMgPSBpIC0gbiwgZiA9IGEgLSB0LCBsID0gcyAtIG4sIGQgPSBmICogZiArIGwgKiBsO1xuICAgIGlmICh0aGlzLl94MSA9PT0gbnVsbClcbiAgICAgIHRoaXMuX2FwcGVuZGBNJHt0aGlzLl94MSA9IHR9LCR7dGhpcy5feTEgPSBufWA7XG4gICAgZWxzZSBpZiAoZCA+IFFuKVxuICAgICAgaWYgKCEoTWF0aC5hYnMobCAqIHUgLSBjICogZikgPiBRbikgfHwgIW8pXG4gICAgICAgIHRoaXMuX2FwcGVuZGBMJHt0aGlzLl94MSA9IHR9LCR7dGhpcy5feTEgPSBufWA7XG4gICAgICBlbHNlIHtcbiAgICAgICAgbGV0IHAgPSByIC0gYSwgZyA9IGkgLSBzLCBoID0gdSAqIHUgKyBjICogYywgdiA9IHAgKiBwICsgZyAqIGcsIHcgPSBNYXRoLnNxcnQoaCksIGIgPSBNYXRoLnNxcnQoZCksIHggPSBvICogTWF0aC50YW4oKGtjIC0gTWF0aC5hY29zKChoICsgZCAtIHYpIC8gKDIgKiB3ICogYikpKSAvIDIpLCBtID0geCAvIGIsIHkgPSB4IC8gdztcbiAgICAgICAgTWF0aC5hYnMobSAtIDEpID4gUW4gJiYgdGhpcy5fYXBwZW5kYEwke3QgKyBtICogZn0sJHtuICsgbSAqIGx9YCwgdGhpcy5fYXBwZW5kYEEke299LCR7b30sMCwwLCR7KyhsICogcCA+IGYgKiBnKX0sJHt0aGlzLl94MSA9IHQgKyB5ICogdX0sJHt0aGlzLl95MSA9IG4gKyB5ICogY31gO1xuICAgICAgfVxuICB9XG4gIGFyYyh0LCBuLCByLCBpLCBvLCBhKSB7XG4gICAgaWYgKHQgPSArdCwgbiA9ICtuLCByID0gK3IsIGEgPSAhIWEsIHIgPCAwKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBuZWdhdGl2ZSByYWRpdXM6ICR7cn1gKTtcbiAgICBsZXQgcyA9IHIgKiBNYXRoLmNvcyhpKSwgdSA9IHIgKiBNYXRoLnNpbihpKSwgYyA9IHQgKyBzLCBmID0gbiArIHUsIGwgPSAxIF4gYSwgZCA9IGEgPyBpIC0gbyA6IG8gLSBpO1xuICAgIHRoaXMuX3gxID09PSBudWxsID8gdGhpcy5fYXBwZW5kYE0ke2N9LCR7Zn1gIDogKE1hdGguYWJzKHRoaXMuX3gxIC0gYykgPiBRbiB8fCBNYXRoLmFicyh0aGlzLl95MSAtIGYpID4gUW4pICYmIHRoaXMuX2FwcGVuZGBMJHtjfSwke2Z9YCwgciAmJiAoZCA8IDAgJiYgKGQgPSBkICUgRGMgKyBEYyksIGQgPiByVCA/IHRoaXMuX2FwcGVuZGBBJHtyfSwke3J9LDAsMSwke2x9LCR7dCAtIHN9LCR7biAtIHV9QSR7cn0sJHtyfSwwLDEsJHtsfSwke3RoaXMuX3gxID0gY30sJHt0aGlzLl95MSA9IGZ9YCA6IGQgPiBRbiAmJiB0aGlzLl9hcHBlbmRgQSR7cn0sJHtyfSwwLCR7KyhkID49IGtjKX0sJHtsfSwke3RoaXMuX3gxID0gdCArIHIgKiBNYXRoLmNvcyhvKX0sJHt0aGlzLl95MSA9IG4gKyByICogTWF0aC5zaW4obyl9YCk7XG4gIH1cbiAgcmVjdCh0LCBuLCByLCBpKSB7XG4gICAgdGhpcy5fYXBwZW5kYE0ke3RoaXMuX3gwID0gdGhpcy5feDEgPSArdH0sJHt0aGlzLl95MCA9IHRoaXMuX3kxID0gK259aCR7ciA9ICtyfXYkeytpfWgkey1yfVpgO1xuICB9XG4gIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiB0aGlzLl87XG4gIH1cbn1cbmZ1bmN0aW9uIFBmKGUpIHtcbiAgbGV0IHQgPSAzO1xuICByZXR1cm4gZS5kaWdpdHMgPSBmdW5jdGlvbihuKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKVxuICAgICAgcmV0dXJuIHQ7XG4gICAgaWYgKG4gPT0gbnVsbClcbiAgICAgIHQgPSBudWxsO1xuICAgIGVsc2Uge1xuICAgICAgY29uc3QgciA9IE1hdGguZmxvb3Iobik7XG4gICAgICBpZiAoIShyID49IDApKVxuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgaW52YWxpZCBkaWdpdHM6ICR7bn1gKTtcbiAgICAgIHQgPSByO1xuICAgIH1cbiAgICByZXR1cm4gZTtcbiAgfSwgKCkgPT4gbmV3IG9UKHQpO1xufVxuZnVuY3Rpb24gQ2YoZSkge1xuICByZXR1cm4gdHlwZW9mIGUgPT0gXCJvYmplY3RcIiAmJiBcImxlbmd0aFwiIGluIGUgPyBlIDogQXJyYXkuZnJvbShlKTtcbn1cbmZ1bmN0aW9uIFp5KGUpIHtcbiAgdGhpcy5fY29udGV4dCA9IGU7XG59XG5aeS5wcm90b3R5cGUgPSB7XG4gIGFyZWFTdGFydDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fbGluZSA9IDA7XG4gIH0sXG4gIGFyZWFFbmQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2xpbmUgPSBOYU47XG4gIH0sXG4gIGxpbmVTdGFydDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fcG9pbnQgPSAwO1xuICB9LFxuICBsaW5lRW5kOiBmdW5jdGlvbigpIHtcbiAgICAodGhpcy5fbGluZSB8fCB0aGlzLl9saW5lICE9PSAwICYmIHRoaXMuX3BvaW50ID09PSAxKSAmJiB0aGlzLl9jb250ZXh0LmNsb3NlUGF0aCgpLCB0aGlzLl9saW5lID0gMSAtIHRoaXMuX2xpbmU7XG4gIH0sXG4gIHBvaW50OiBmdW5jdGlvbihlLCB0KSB7XG4gICAgc3dpdGNoIChlID0gK2UsIHQgPSArdCwgdGhpcy5fcG9pbnQpIHtcbiAgICAgIGNhc2UgMDpcbiAgICAgICAgdGhpcy5fcG9pbnQgPSAxLCB0aGlzLl9saW5lID8gdGhpcy5fY29udGV4dC5saW5lVG8oZSwgdCkgOiB0aGlzLl9jb250ZXh0Lm1vdmVUbyhlLCB0KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDE6XG4gICAgICAgIHRoaXMuX3BvaW50ID0gMjtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRoaXMuX2NvbnRleHQubGluZVRvKGUsIHQpO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cbn07XG5mdW5jdGlvbiBWcyhlKSB7XG4gIHJldHVybiBuZXcgWnkoZSk7XG59XG5mdW5jdGlvbiBKeShlKSB7XG4gIHJldHVybiBlWzBdO1xufVxuZnVuY3Rpb24gUXkoZSkge1xuICByZXR1cm4gZVsxXTtcbn1cbmZ1bmN0aW9uIGViKGUsIHQpIHtcbiAgdmFyIG4gPSBJZSghMCksIHIgPSBudWxsLCBpID0gVnMsIG8gPSBudWxsLCBhID0gUGYocyk7XG4gIGUgPSB0eXBlb2YgZSA9PSBcImZ1bmN0aW9uXCIgPyBlIDogZSA9PT0gdm9pZCAwID8gSnkgOiBJZShlKSwgdCA9IHR5cGVvZiB0ID09IFwiZnVuY3Rpb25cIiA/IHQgOiB0ID09PSB2b2lkIDAgPyBReSA6IEllKHQpO1xuICBmdW5jdGlvbiBzKHUpIHtcbiAgICB2YXIgYywgZiA9ICh1ID0gQ2YodSkpLmxlbmd0aCwgbCwgZCA9ICExLCBwO1xuICAgIGZvciAociA9PSBudWxsICYmIChvID0gaShwID0gYSgpKSksIGMgPSAwOyBjIDw9IGY7ICsrYylcbiAgICAgICEoYyA8IGYgJiYgbihsID0gdVtjXSwgYywgdSkpID09PSBkICYmICgoZCA9ICFkKSA/IG8ubGluZVN0YXJ0KCkgOiBvLmxpbmVFbmQoKSksIGQgJiYgby5wb2ludCgrZShsLCBjLCB1KSwgK3QobCwgYywgdSkpO1xuICAgIGlmIChwKVxuICAgICAgcmV0dXJuIG8gPSBudWxsLCBwICsgXCJcIiB8fCBudWxsO1xuICB9XG4gIHJldHVybiBzLnggPSBmdW5jdGlvbih1KSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoZSA9IHR5cGVvZiB1ID09IFwiZnVuY3Rpb25cIiA/IHUgOiBJZSgrdSksIHMpIDogZTtcbiAgfSwgcy55ID0gZnVuY3Rpb24odSkge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHQgPSB0eXBlb2YgdSA9PSBcImZ1bmN0aW9uXCIgPyB1IDogSWUoK3UpLCBzKSA6IHQ7XG4gIH0sIHMuZGVmaW5lZCA9IGZ1bmN0aW9uKHUpIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChuID0gdHlwZW9mIHUgPT0gXCJmdW5jdGlvblwiID8gdSA6IEllKCEhdSksIHMpIDogbjtcbiAgfSwgcy5jdXJ2ZSA9IGZ1bmN0aW9uKHUpIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChpID0gdSwgciAhPSBudWxsICYmIChvID0gaShyKSksIHMpIDogaTtcbiAgfSwgcy5jb250ZXh0ID0gZnVuY3Rpb24odSkge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHUgPT0gbnVsbCA/IHIgPSBvID0gbnVsbCA6IG8gPSBpKHIgPSB1KSwgcykgOiByO1xuICB9LCBzO1xufVxuZnVuY3Rpb24gbGEoZSwgdCwgbikge1xuICB2YXIgciA9IG51bGwsIGkgPSBJZSghMCksIG8gPSBudWxsLCBhID0gVnMsIHMgPSBudWxsLCB1ID0gUGYoYyk7XG4gIGUgPSB0eXBlb2YgZSA9PSBcImZ1bmN0aW9uXCIgPyBlIDogZSA9PT0gdm9pZCAwID8gSnkgOiBJZSgrZSksIHQgPSB0eXBlb2YgdCA9PSBcImZ1bmN0aW9uXCIgPyB0IDogSWUodCA9PT0gdm9pZCAwID8gMCA6ICt0KSwgbiA9IHR5cGVvZiBuID09IFwiZnVuY3Rpb25cIiA/IG4gOiBuID09PSB2b2lkIDAgPyBReSA6IEllKCtuKTtcbiAgZnVuY3Rpb24gYyhsKSB7XG4gICAgdmFyIGQsIHAsIGcsIGggPSAobCA9IENmKGwpKS5sZW5ndGgsIHYsIHcgPSAhMSwgYiwgeCA9IG5ldyBBcnJheShoKSwgbSA9IG5ldyBBcnJheShoKTtcbiAgICBmb3IgKG8gPT0gbnVsbCAmJiAocyA9IGEoYiA9IHUoKSkpLCBkID0gMDsgZCA8PSBoOyArK2QpIHtcbiAgICAgIGlmICghKGQgPCBoICYmIGkodiA9IGxbZF0sIGQsIGwpKSA9PT0gdylcbiAgICAgICAgaWYgKHcgPSAhdylcbiAgICAgICAgICBwID0gZCwgcy5hcmVhU3RhcnQoKSwgcy5saW5lU3RhcnQoKTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgZm9yIChzLmxpbmVFbmQoKSwgcy5saW5lU3RhcnQoKSwgZyA9IGQgLSAxOyBnID49IHA7IC0tZylcbiAgICAgICAgICAgIHMucG9pbnQoeFtnXSwgbVtnXSk7XG4gICAgICAgICAgcy5saW5lRW5kKCksIHMuYXJlYUVuZCgpO1xuICAgICAgICB9XG4gICAgICB3ICYmICh4W2RdID0gK2UodiwgZCwgbCksIG1bZF0gPSArdCh2LCBkLCBsKSwgcy5wb2ludChyID8gK3IodiwgZCwgbCkgOiB4W2RdLCBuID8gK24odiwgZCwgbCkgOiBtW2RdKSk7XG4gICAgfVxuICAgIGlmIChiKVxuICAgICAgcmV0dXJuIHMgPSBudWxsLCBiICsgXCJcIiB8fCBudWxsO1xuICB9XG4gIGZ1bmN0aW9uIGYoKSB7XG4gICAgcmV0dXJuIGViKCkuZGVmaW5lZChpKS5jdXJ2ZShhKS5jb250ZXh0KG8pO1xuICB9XG4gIHJldHVybiBjLnggPSBmdW5jdGlvbihsKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoZSA9IHR5cGVvZiBsID09IFwiZnVuY3Rpb25cIiA/IGwgOiBJZSgrbCksIHIgPSBudWxsLCBjKSA6IGU7XG4gIH0sIGMueDAgPSBmdW5jdGlvbihsKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoZSA9IHR5cGVvZiBsID09IFwiZnVuY3Rpb25cIiA/IGwgOiBJZSgrbCksIGMpIDogZTtcbiAgfSwgYy54MSA9IGZ1bmN0aW9uKGwpIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChyID0gbCA9PSBudWxsID8gbnVsbCA6IHR5cGVvZiBsID09IFwiZnVuY3Rpb25cIiA/IGwgOiBJZSgrbCksIGMpIDogcjtcbiAgfSwgYy55ID0gZnVuY3Rpb24obCkge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHQgPSB0eXBlb2YgbCA9PSBcImZ1bmN0aW9uXCIgPyBsIDogSWUoK2wpLCBuID0gbnVsbCwgYykgOiB0O1xuICB9LCBjLnkwID0gZnVuY3Rpb24obCkge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHQgPSB0eXBlb2YgbCA9PSBcImZ1bmN0aW9uXCIgPyBsIDogSWUoK2wpLCBjKSA6IHQ7XG4gIH0sIGMueTEgPSBmdW5jdGlvbihsKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAobiA9IGwgPT0gbnVsbCA/IG51bGwgOiB0eXBlb2YgbCA9PSBcImZ1bmN0aW9uXCIgPyBsIDogSWUoK2wpLCBjKSA6IG47XG4gIH0sIGMubGluZVgwID0gYy5saW5lWTAgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZigpLngoZSkueSh0KTtcbiAgfSwgYy5saW5lWTEgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZigpLngoZSkueShuKTtcbiAgfSwgYy5saW5lWDEgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZigpLngocikueSh0KTtcbiAgfSwgYy5kZWZpbmVkID0gZnVuY3Rpb24obCkge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGkgPSB0eXBlb2YgbCA9PSBcImZ1bmN0aW9uXCIgPyBsIDogSWUoISFsKSwgYykgOiBpO1xuICB9LCBjLmN1cnZlID0gZnVuY3Rpb24obCkge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGEgPSBsLCBvICE9IG51bGwgJiYgKHMgPSBhKG8pKSwgYykgOiBhO1xuICB9LCBjLmNvbnRleHQgPSBmdW5jdGlvbihsKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAobCA9PSBudWxsID8gbyA9IHMgPSBudWxsIDogcyA9IGEobyA9IGwpLCBjKSA6IG87XG4gIH0sIGM7XG59XG5jbGFzcyB0YiB7XG4gIGNvbnN0cnVjdG9yKHQsIG4pIHtcbiAgICB0aGlzLl9jb250ZXh0ID0gdCwgdGhpcy5feCA9IG47XG4gIH1cbiAgYXJlYVN0YXJ0KCkge1xuICAgIHRoaXMuX2xpbmUgPSAwO1xuICB9XG4gIGFyZWFFbmQoKSB7XG4gICAgdGhpcy5fbGluZSA9IE5hTjtcbiAgfVxuICBsaW5lU3RhcnQoKSB7XG4gICAgdGhpcy5fcG9pbnQgPSAwO1xuICB9XG4gIGxpbmVFbmQoKSB7XG4gICAgKHRoaXMuX2xpbmUgfHwgdGhpcy5fbGluZSAhPT0gMCAmJiB0aGlzLl9wb2ludCA9PT0gMSkgJiYgdGhpcy5fY29udGV4dC5jbG9zZVBhdGgoKSwgdGhpcy5fbGluZSA9IDEgLSB0aGlzLl9saW5lO1xuICB9XG4gIHBvaW50KHQsIG4pIHtcbiAgICBzd2l0Y2ggKHQgPSArdCwgbiA9ICtuLCB0aGlzLl9wb2ludCkge1xuICAgICAgY2FzZSAwOiB7XG4gICAgICAgIHRoaXMuX3BvaW50ID0gMSwgdGhpcy5fbGluZSA/IHRoaXMuX2NvbnRleHQubGluZVRvKHQsIG4pIDogdGhpcy5fY29udGV4dC5tb3ZlVG8odCwgbik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSAxOlxuICAgICAgICB0aGlzLl9wb2ludCA9IDI7XG4gICAgICBkZWZhdWx0OiB7XG4gICAgICAgIHRoaXMuX3ggPyB0aGlzLl9jb250ZXh0LmJlemllckN1cnZlVG8odGhpcy5feDAgPSAodGhpcy5feDAgKyB0KSAvIDIsIHRoaXMuX3kwLCB0aGlzLl94MCwgbiwgdCwgbikgOiB0aGlzLl9jb250ZXh0LmJlemllckN1cnZlVG8odGhpcy5feDAsIHRoaXMuX3kwID0gKHRoaXMuX3kwICsgbikgLyAyLCB0LCB0aGlzLl95MCwgdCwgbik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLl94MCA9IHQsIHRoaXMuX3kwID0gbjtcbiAgfVxufVxuZnVuY3Rpb24gYVQoZSkge1xuICByZXR1cm4gbmV3IHRiKGUsICEwKTtcbn1cbmZ1bmN0aW9uIHNUKGUpIHtcbiAgcmV0dXJuIG5ldyB0YihlLCAhMSk7XG59XG5jb25zdCBFZiA9IHtcbiAgZHJhdyhlLCB0KSB7XG4gICAgY29uc3QgbiA9IFF0KHQgLyBCYSk7XG4gICAgZS5tb3ZlVG8obiwgMCksIGUuYXJjKDAsIDAsIG4sIDAsIHpzKTtcbiAgfVxufSwgdVQgPSB7XG4gIGRyYXcoZSwgdCkge1xuICAgIGNvbnN0IG4gPSBRdCh0IC8gNSkgLyAyO1xuICAgIGUubW92ZVRvKC0zICogbiwgLW4pLCBlLmxpbmVUbygtbiwgLW4pLCBlLmxpbmVUbygtbiwgLTMgKiBuKSwgZS5saW5lVG8obiwgLTMgKiBuKSwgZS5saW5lVG8obiwgLW4pLCBlLmxpbmVUbygzICogbiwgLW4pLCBlLmxpbmVUbygzICogbiwgbiksIGUubGluZVRvKG4sIG4pLCBlLmxpbmVUbyhuLCAzICogbiksIGUubGluZVRvKC1uLCAzICogbiksIGUubGluZVRvKC1uLCBuKSwgZS5saW5lVG8oLTMgKiBuLCBuKSwgZS5jbG9zZVBhdGgoKTtcbiAgfVxufSwgbmIgPSBRdCgxIC8gMyksIGNUID0gbmIgKiAyLCBsVCA9IHtcbiAgZHJhdyhlLCB0KSB7XG4gICAgY29uc3QgbiA9IFF0KHQgLyBjVCksIHIgPSBuICogbmI7XG4gICAgZS5tb3ZlVG8oMCwgLW4pLCBlLmxpbmVUbyhyLCAwKSwgZS5saW5lVG8oMCwgbiksIGUubGluZVRvKC1yLCAwKSwgZS5jbG9zZVBhdGgoKTtcbiAgfVxufSwgZlQgPSB7XG4gIGRyYXcoZSwgdCkge1xuICAgIGNvbnN0IG4gPSBRdCh0KSwgciA9IC1uIC8gMjtcbiAgICBlLnJlY3Qociwgciwgbiwgbik7XG4gIH1cbn0sIGRUID0gMC44OTA4MTMwOTE1MjkyODUyLCByYiA9IExhKEJhIC8gMTApIC8gTGEoNyAqIEJhIC8gMTApLCBwVCA9IExhKHpzIC8gMTApICogcmIsIGhUID0gLVl5KHpzIC8gMTApICogcmIsIGdUID0ge1xuICBkcmF3KGUsIHQpIHtcbiAgICBjb25zdCBuID0gUXQodCAqIGRUKSwgciA9IHBUICogbiwgaSA9IGhUICogbjtcbiAgICBlLm1vdmVUbygwLCAtbiksIGUubGluZVRvKHIsIGkpO1xuICAgIGZvciAobGV0IG8gPSAxOyBvIDwgNTsgKytvKSB7XG4gICAgICBjb25zdCBhID0genMgKiBvIC8gNSwgcyA9IFl5KGEpLCB1ID0gTGEoYSk7XG4gICAgICBlLmxpbmVUbyh1ICogbiwgLXMgKiBuKSwgZS5saW5lVG8ocyAqIHIgLSB1ICogaSwgdSAqIHIgKyBzICogaSk7XG4gICAgfVxuICAgIGUuY2xvc2VQYXRoKCk7XG4gIH1cbn0sIEN1ID0gUXQoMyksIHZUID0ge1xuICBkcmF3KGUsIHQpIHtcbiAgICBjb25zdCBuID0gLVF0KHQgLyAoQ3UgKiAzKSk7XG4gICAgZS5tb3ZlVG8oMCwgbiAqIDIpLCBlLmxpbmVUbygtQ3UgKiBuLCAtbiksIGUubGluZVRvKEN1ICogbiwgLW4pLCBlLmNsb3NlUGF0aCgpO1xuICB9XG59LCBFdCA9IC0wLjUsIFR0ID0gUXQoMykgLyAyLCBOYyA9IDEgLyBRdCgxMiksIG1UID0gKE5jIC8gMiArIDEpICogMywgeVQgPSB7XG4gIGRyYXcoZSwgdCkge1xuICAgIGNvbnN0IG4gPSBRdCh0IC8gbVQpLCByID0gbiAvIDIsIGkgPSBuICogTmMsIG8gPSByLCBhID0gbiAqIE5jICsgbiwgcyA9IC1vLCB1ID0gYTtcbiAgICBlLm1vdmVUbyhyLCBpKSwgZS5saW5lVG8obywgYSksIGUubGluZVRvKHMsIHUpLCBlLmxpbmVUbyhFdCAqIHIgLSBUdCAqIGksIFR0ICogciArIEV0ICogaSksIGUubGluZVRvKEV0ICogbyAtIFR0ICogYSwgVHQgKiBvICsgRXQgKiBhKSwgZS5saW5lVG8oRXQgKiBzIC0gVHQgKiB1LCBUdCAqIHMgKyBFdCAqIHUpLCBlLmxpbmVUbyhFdCAqIHIgKyBUdCAqIGksIEV0ICogaSAtIFR0ICogciksIGUubGluZVRvKEV0ICogbyArIFR0ICogYSwgRXQgKiBhIC0gVHQgKiBvKSwgZS5saW5lVG8oRXQgKiBzICsgVHQgKiB1LCBFdCAqIHUgLSBUdCAqIHMpLCBlLmNsb3NlUGF0aCgpO1xuICB9XG59O1xuZnVuY3Rpb24gYlQoZSwgdCkge1xuICBsZXQgbiA9IG51bGwsIHIgPSBQZihpKTtcbiAgZSA9IHR5cGVvZiBlID09IFwiZnVuY3Rpb25cIiA/IGUgOiBJZShlIHx8IEVmKSwgdCA9IHR5cGVvZiB0ID09IFwiZnVuY3Rpb25cIiA/IHQgOiBJZSh0ID09PSB2b2lkIDAgPyA2NCA6ICt0KTtcbiAgZnVuY3Rpb24gaSgpIHtcbiAgICBsZXQgbztcbiAgICBpZiAobiB8fCAobiA9IG8gPSByKCkpLCBlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykuZHJhdyhuLCArdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpKSwgbylcbiAgICAgIHJldHVybiBuID0gbnVsbCwgbyArIFwiXCIgfHwgbnVsbDtcbiAgfVxuICByZXR1cm4gaS50eXBlID0gZnVuY3Rpb24obykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGUgPSB0eXBlb2YgbyA9PSBcImZ1bmN0aW9uXCIgPyBvIDogSWUobyksIGkpIDogZTtcbiAgfSwgaS5zaXplID0gZnVuY3Rpb24obykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHQgPSB0eXBlb2YgbyA9PSBcImZ1bmN0aW9uXCIgPyBvIDogSWUoK28pLCBpKSA6IHQ7XG4gIH0sIGkuY29udGV4dCA9IGZ1bmN0aW9uKG8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChuID0gbyA/PyBudWxsLCBpKSA6IG47XG4gIH0sIGk7XG59XG5mdW5jdGlvbiB6YSgpIHtcbn1cbmZ1bmN0aW9uIFZhKGUsIHQsIG4pIHtcbiAgZS5fY29udGV4dC5iZXppZXJDdXJ2ZVRvKFxuICAgICgyICogZS5feDAgKyBlLl94MSkgLyAzLFxuICAgICgyICogZS5feTAgKyBlLl95MSkgLyAzLFxuICAgIChlLl94MCArIDIgKiBlLl94MSkgLyAzLFxuICAgIChlLl95MCArIDIgKiBlLl95MSkgLyAzLFxuICAgIChlLl94MCArIDQgKiBlLl94MSArIHQpIC8gNixcbiAgICAoZS5feTAgKyA0ICogZS5feTEgKyBuKSAvIDZcbiAgKTtcbn1cbmZ1bmN0aW9uIGliKGUpIHtcbiAgdGhpcy5fY29udGV4dCA9IGU7XG59XG5pYi5wcm90b3R5cGUgPSB7XG4gIGFyZWFTdGFydDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fbGluZSA9IDA7XG4gIH0sXG4gIGFyZWFFbmQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2xpbmUgPSBOYU47XG4gIH0sXG4gIGxpbmVTdGFydDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5feDAgPSB0aGlzLl94MSA9IHRoaXMuX3kwID0gdGhpcy5feTEgPSBOYU4sIHRoaXMuX3BvaW50ID0gMDtcbiAgfSxcbiAgbGluZUVuZDogZnVuY3Rpb24oKSB7XG4gICAgc3dpdGNoICh0aGlzLl9wb2ludCkge1xuICAgICAgY2FzZSAzOlxuICAgICAgICBWYSh0aGlzLCB0aGlzLl94MSwgdGhpcy5feTEpO1xuICAgICAgY2FzZSAyOlxuICAgICAgICB0aGlzLl9jb250ZXh0LmxpbmVUbyh0aGlzLl94MSwgdGhpcy5feTEpO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgKHRoaXMuX2xpbmUgfHwgdGhpcy5fbGluZSAhPT0gMCAmJiB0aGlzLl9wb2ludCA9PT0gMSkgJiYgdGhpcy5fY29udGV4dC5jbG9zZVBhdGgoKSwgdGhpcy5fbGluZSA9IDEgLSB0aGlzLl9saW5lO1xuICB9LFxuICBwb2ludDogZnVuY3Rpb24oZSwgdCkge1xuICAgIHN3aXRjaCAoZSA9ICtlLCB0ID0gK3QsIHRoaXMuX3BvaW50KSB7XG4gICAgICBjYXNlIDA6XG4gICAgICAgIHRoaXMuX3BvaW50ID0gMSwgdGhpcy5fbGluZSA/IHRoaXMuX2NvbnRleHQubGluZVRvKGUsIHQpIDogdGhpcy5fY29udGV4dC5tb3ZlVG8oZSwgdCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAxOlxuICAgICAgICB0aGlzLl9wb2ludCA9IDI7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAyOlxuICAgICAgICB0aGlzLl9wb2ludCA9IDMsIHRoaXMuX2NvbnRleHQubGluZVRvKCg1ICogdGhpcy5feDAgKyB0aGlzLl94MSkgLyA2LCAoNSAqIHRoaXMuX3kwICsgdGhpcy5feTEpIC8gNik7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBWYSh0aGlzLCBlLCB0KTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHRoaXMuX3gwID0gdGhpcy5feDEsIHRoaXMuX3gxID0gZSwgdGhpcy5feTAgPSB0aGlzLl95MSwgdGhpcy5feTEgPSB0O1xuICB9XG59O1xuZnVuY3Rpb24gd1QoZSkge1xuICByZXR1cm4gbmV3IGliKGUpO1xufVxuZnVuY3Rpb24gb2IoZSkge1xuICB0aGlzLl9jb250ZXh0ID0gZTtcbn1cbm9iLnByb3RvdHlwZSA9IHtcbiAgYXJlYVN0YXJ0OiB6YSxcbiAgYXJlYUVuZDogemEsXG4gIGxpbmVTdGFydDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5feDAgPSB0aGlzLl94MSA9IHRoaXMuX3gyID0gdGhpcy5feDMgPSB0aGlzLl94NCA9IHRoaXMuX3kwID0gdGhpcy5feTEgPSB0aGlzLl95MiA9IHRoaXMuX3kzID0gdGhpcy5feTQgPSBOYU4sIHRoaXMuX3BvaW50ID0gMDtcbiAgfSxcbiAgbGluZUVuZDogZnVuY3Rpb24oKSB7XG4gICAgc3dpdGNoICh0aGlzLl9wb2ludCkge1xuICAgICAgY2FzZSAxOiB7XG4gICAgICAgIHRoaXMuX2NvbnRleHQubW92ZVRvKHRoaXMuX3gyLCB0aGlzLl95MiksIHRoaXMuX2NvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSAyOiB7XG4gICAgICAgIHRoaXMuX2NvbnRleHQubW92ZVRvKCh0aGlzLl94MiArIDIgKiB0aGlzLl94MykgLyAzLCAodGhpcy5feTIgKyAyICogdGhpcy5feTMpIC8gMyksIHRoaXMuX2NvbnRleHQubGluZVRvKCh0aGlzLl94MyArIDIgKiB0aGlzLl94MikgLyAzLCAodGhpcy5feTMgKyAyICogdGhpcy5feTIpIC8gMyksIHRoaXMuX2NvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSAzOiB7XG4gICAgICAgIHRoaXMucG9pbnQodGhpcy5feDIsIHRoaXMuX3kyKSwgdGhpcy5wb2ludCh0aGlzLl94MywgdGhpcy5feTMpLCB0aGlzLnBvaW50KHRoaXMuX3g0LCB0aGlzLl95NCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgcG9pbnQ6IGZ1bmN0aW9uKGUsIHQpIHtcbiAgICBzd2l0Y2ggKGUgPSArZSwgdCA9ICt0LCB0aGlzLl9wb2ludCkge1xuICAgICAgY2FzZSAwOlxuICAgICAgICB0aGlzLl9wb2ludCA9IDEsIHRoaXMuX3gyID0gZSwgdGhpcy5feTIgPSB0O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMTpcbiAgICAgICAgdGhpcy5fcG9pbnQgPSAyLCB0aGlzLl94MyA9IGUsIHRoaXMuX3kzID0gdDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDI6XG4gICAgICAgIHRoaXMuX3BvaW50ID0gMywgdGhpcy5feDQgPSBlLCB0aGlzLl95NCA9IHQsIHRoaXMuX2NvbnRleHQubW92ZVRvKCh0aGlzLl94MCArIDQgKiB0aGlzLl94MSArIGUpIC8gNiwgKHRoaXMuX3kwICsgNCAqIHRoaXMuX3kxICsgdCkgLyA2KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBWYSh0aGlzLCBlLCB0KTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHRoaXMuX3gwID0gdGhpcy5feDEsIHRoaXMuX3gxID0gZSwgdGhpcy5feTAgPSB0aGlzLl95MSwgdGhpcy5feTEgPSB0O1xuICB9XG59O1xuZnVuY3Rpb24geFQoZSkge1xuICByZXR1cm4gbmV3IG9iKGUpO1xufVxuZnVuY3Rpb24gYWIoZSkge1xuICB0aGlzLl9jb250ZXh0ID0gZTtcbn1cbmFiLnByb3RvdHlwZSA9IHtcbiAgYXJlYVN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9saW5lID0gMDtcbiAgfSxcbiAgYXJlYUVuZDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fbGluZSA9IE5hTjtcbiAgfSxcbiAgbGluZVN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl94MCA9IHRoaXMuX3gxID0gdGhpcy5feTAgPSB0aGlzLl95MSA9IE5hTiwgdGhpcy5fcG9pbnQgPSAwO1xuICB9LFxuICBsaW5lRW5kOiBmdW5jdGlvbigpIHtcbiAgICAodGhpcy5fbGluZSB8fCB0aGlzLl9saW5lICE9PSAwICYmIHRoaXMuX3BvaW50ID09PSAzKSAmJiB0aGlzLl9jb250ZXh0LmNsb3NlUGF0aCgpLCB0aGlzLl9saW5lID0gMSAtIHRoaXMuX2xpbmU7XG4gIH0sXG4gIHBvaW50OiBmdW5jdGlvbihlLCB0KSB7XG4gICAgc3dpdGNoIChlID0gK2UsIHQgPSArdCwgdGhpcy5fcG9pbnQpIHtcbiAgICAgIGNhc2UgMDpcbiAgICAgICAgdGhpcy5fcG9pbnQgPSAxO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMTpcbiAgICAgICAgdGhpcy5fcG9pbnQgPSAyO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMjpcbiAgICAgICAgdGhpcy5fcG9pbnQgPSAzO1xuICAgICAgICB2YXIgbiA9ICh0aGlzLl94MCArIDQgKiB0aGlzLl94MSArIGUpIC8gNiwgciA9ICh0aGlzLl95MCArIDQgKiB0aGlzLl95MSArIHQpIC8gNjtcbiAgICAgICAgdGhpcy5fbGluZSA/IHRoaXMuX2NvbnRleHQubGluZVRvKG4sIHIpIDogdGhpcy5fY29udGV4dC5tb3ZlVG8obiwgcik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAzOlxuICAgICAgICB0aGlzLl9wb2ludCA9IDQ7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBWYSh0aGlzLCBlLCB0KTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHRoaXMuX3gwID0gdGhpcy5feDEsIHRoaXMuX3gxID0gZSwgdGhpcy5feTAgPSB0aGlzLl95MSwgdGhpcy5feTEgPSB0O1xuICB9XG59O1xuZnVuY3Rpb24gU1QoZSkge1xuICByZXR1cm4gbmV3IGFiKGUpO1xufVxuZnVuY3Rpb24gc2IoZSkge1xuICB0aGlzLl9jb250ZXh0ID0gZTtcbn1cbnNiLnByb3RvdHlwZSA9IHtcbiAgYXJlYVN0YXJ0OiB6YSxcbiAgYXJlYUVuZDogemEsXG4gIGxpbmVTdGFydDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fcG9pbnQgPSAwO1xuICB9LFxuICBsaW5lRW5kOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9wb2ludCAmJiB0aGlzLl9jb250ZXh0LmNsb3NlUGF0aCgpO1xuICB9LFxuICBwb2ludDogZnVuY3Rpb24oZSwgdCkge1xuICAgIGUgPSArZSwgdCA9ICt0LCB0aGlzLl9wb2ludCA/IHRoaXMuX2NvbnRleHQubGluZVRvKGUsIHQpIDogKHRoaXMuX3BvaW50ID0gMSwgdGhpcy5fY29udGV4dC5tb3ZlVG8oZSwgdCkpO1xuICB9XG59O1xuZnVuY3Rpb24gJFQoZSkge1xuICByZXR1cm4gbmV3IHNiKGUpO1xufVxuZnVuY3Rpb24gUHAoZSkge1xuICByZXR1cm4gZSA8IDAgPyAtMSA6IDE7XG59XG5mdW5jdGlvbiBDcChlLCB0LCBuKSB7XG4gIHZhciByID0gZS5feDEgLSBlLl94MCwgaSA9IHQgLSBlLl94MSwgbyA9IChlLl95MSAtIGUuX3kwKSAvIChyIHx8IGkgPCAwICYmIC0wKSwgYSA9IChuIC0gZS5feTEpIC8gKGkgfHwgciA8IDAgJiYgLTApLCBzID0gKG8gKiBpICsgYSAqIHIpIC8gKHIgKyBpKTtcbiAgcmV0dXJuIChQcChvKSArIFBwKGEpKSAqIE1hdGgubWluKE1hdGguYWJzKG8pLCBNYXRoLmFicyhhKSwgMC41ICogTWF0aC5hYnMocykpIHx8IDA7XG59XG5mdW5jdGlvbiBFcChlLCB0KSB7XG4gIHZhciBuID0gZS5feDEgLSBlLl94MDtcbiAgcmV0dXJuIG4gPyAoMyAqIChlLl95MSAtIGUuX3kwKSAvIG4gLSB0KSAvIDIgOiB0O1xufVxuZnVuY3Rpb24gRXUoZSwgdCwgbikge1xuICB2YXIgciA9IGUuX3gwLCBpID0gZS5feTAsIG8gPSBlLl94MSwgYSA9IGUuX3kxLCBzID0gKG8gLSByKSAvIDM7XG4gIGUuX2NvbnRleHQuYmV6aWVyQ3VydmVUbyhyICsgcywgaSArIHMgKiB0LCBvIC0gcywgYSAtIHMgKiBuLCBvLCBhKTtcbn1cbmZ1bmN0aW9uIEdhKGUpIHtcbiAgdGhpcy5fY29udGV4dCA9IGU7XG59XG5HYS5wcm90b3R5cGUgPSB7XG4gIGFyZWFTdGFydDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fbGluZSA9IDA7XG4gIH0sXG4gIGFyZWFFbmQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2xpbmUgPSBOYU47XG4gIH0sXG4gIGxpbmVTdGFydDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5feDAgPSB0aGlzLl94MSA9IHRoaXMuX3kwID0gdGhpcy5feTEgPSB0aGlzLl90MCA9IE5hTiwgdGhpcy5fcG9pbnQgPSAwO1xuICB9LFxuICBsaW5lRW5kOiBmdW5jdGlvbigpIHtcbiAgICBzd2l0Y2ggKHRoaXMuX3BvaW50KSB7XG4gICAgICBjYXNlIDI6XG4gICAgICAgIHRoaXMuX2NvbnRleHQubGluZVRvKHRoaXMuX3gxLCB0aGlzLl95MSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAzOlxuICAgICAgICBFdSh0aGlzLCB0aGlzLl90MCwgRXAodGhpcywgdGhpcy5fdDApKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgICh0aGlzLl9saW5lIHx8IHRoaXMuX2xpbmUgIT09IDAgJiYgdGhpcy5fcG9pbnQgPT09IDEpICYmIHRoaXMuX2NvbnRleHQuY2xvc2VQYXRoKCksIHRoaXMuX2xpbmUgPSAxIC0gdGhpcy5fbGluZTtcbiAgfSxcbiAgcG9pbnQ6IGZ1bmN0aW9uKGUsIHQpIHtcbiAgICB2YXIgbiA9IE5hTjtcbiAgICBpZiAoZSA9ICtlLCB0ID0gK3QsICEoZSA9PT0gdGhpcy5feDEgJiYgdCA9PT0gdGhpcy5feTEpKSB7XG4gICAgICBzd2l0Y2ggKHRoaXMuX3BvaW50KSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICB0aGlzLl9wb2ludCA9IDEsIHRoaXMuX2xpbmUgPyB0aGlzLl9jb250ZXh0LmxpbmVUbyhlLCB0KSA6IHRoaXMuX2NvbnRleHQubW92ZVRvKGUsIHQpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgdGhpcy5fcG9pbnQgPSAyO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgdGhpcy5fcG9pbnQgPSAzLCBFdSh0aGlzLCBFcCh0aGlzLCBuID0gQ3AodGhpcywgZSwgdCkpLCBuKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBFdSh0aGlzLCB0aGlzLl90MCwgbiA9IENwKHRoaXMsIGUsIHQpKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHRoaXMuX3gwID0gdGhpcy5feDEsIHRoaXMuX3gxID0gZSwgdGhpcy5feTAgPSB0aGlzLl95MSwgdGhpcy5feTEgPSB0LCB0aGlzLl90MCA9IG47XG4gICAgfVxuICB9XG59O1xuZnVuY3Rpb24gdWIoZSkge1xuICB0aGlzLl9jb250ZXh0ID0gbmV3IGNiKGUpO1xufVxuKHViLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoR2EucHJvdG90eXBlKSkucG9pbnQgPSBmdW5jdGlvbihlLCB0KSB7XG4gIEdhLnByb3RvdHlwZS5wb2ludC5jYWxsKHRoaXMsIHQsIGUpO1xufTtcbmZ1bmN0aW9uIGNiKGUpIHtcbiAgdGhpcy5fY29udGV4dCA9IGU7XG59XG5jYi5wcm90b3R5cGUgPSB7XG4gIG1vdmVUbzogZnVuY3Rpb24oZSwgdCkge1xuICAgIHRoaXMuX2NvbnRleHQubW92ZVRvKHQsIGUpO1xuICB9LFxuICBjbG9zZVBhdGg6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2NvbnRleHQuY2xvc2VQYXRoKCk7XG4gIH0sXG4gIGxpbmVUbzogZnVuY3Rpb24oZSwgdCkge1xuICAgIHRoaXMuX2NvbnRleHQubGluZVRvKHQsIGUpO1xuICB9LFxuICBiZXppZXJDdXJ2ZVRvOiBmdW5jdGlvbihlLCB0LCBuLCByLCBpLCBvKSB7XG4gICAgdGhpcy5fY29udGV4dC5iZXppZXJDdXJ2ZVRvKHQsIGUsIHIsIG4sIG8sIGkpO1xuICB9XG59O1xuZnVuY3Rpb24gT1QoZSkge1xuICByZXR1cm4gbmV3IEdhKGUpO1xufVxuZnVuY3Rpb24gX1QoZSkge1xuICByZXR1cm4gbmV3IHViKGUpO1xufVxuZnVuY3Rpb24gbGIoZSkge1xuICB0aGlzLl9jb250ZXh0ID0gZTtcbn1cbmxiLnByb3RvdHlwZSA9IHtcbiAgYXJlYVN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9saW5lID0gMDtcbiAgfSxcbiAgYXJlYUVuZDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fbGluZSA9IE5hTjtcbiAgfSxcbiAgbGluZVN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl94ID0gW10sIHRoaXMuX3kgPSBbXTtcbiAgfSxcbiAgbGluZUVuZDogZnVuY3Rpb24oKSB7XG4gICAgdmFyIGUgPSB0aGlzLl94LCB0ID0gdGhpcy5feSwgbiA9IGUubGVuZ3RoO1xuICAgIGlmIChuKVxuICAgICAgaWYgKHRoaXMuX2xpbmUgPyB0aGlzLl9jb250ZXh0LmxpbmVUbyhlWzBdLCB0WzBdKSA6IHRoaXMuX2NvbnRleHQubW92ZVRvKGVbMF0sIHRbMF0pLCBuID09PSAyKVxuICAgICAgICB0aGlzLl9jb250ZXh0LmxpbmVUbyhlWzFdLCB0WzFdKTtcbiAgICAgIGVsc2VcbiAgICAgICAgZm9yICh2YXIgciA9IFRwKGUpLCBpID0gVHAodCksIG8gPSAwLCBhID0gMTsgYSA8IG47ICsrbywgKythKVxuICAgICAgICAgIHRoaXMuX2NvbnRleHQuYmV6aWVyQ3VydmVUbyhyWzBdW29dLCBpWzBdW29dLCByWzFdW29dLCBpWzFdW29dLCBlW2FdLCB0W2FdKTtcbiAgICAodGhpcy5fbGluZSB8fCB0aGlzLl9saW5lICE9PSAwICYmIG4gPT09IDEpICYmIHRoaXMuX2NvbnRleHQuY2xvc2VQYXRoKCksIHRoaXMuX2xpbmUgPSAxIC0gdGhpcy5fbGluZSwgdGhpcy5feCA9IHRoaXMuX3kgPSBudWxsO1xuICB9LFxuICBwb2ludDogZnVuY3Rpb24oZSwgdCkge1xuICAgIHRoaXMuX3gucHVzaCgrZSksIHRoaXMuX3kucHVzaCgrdCk7XG4gIH1cbn07XG5mdW5jdGlvbiBUcChlKSB7XG4gIHZhciB0LCBuID0gZS5sZW5ndGggLSAxLCByLCBpID0gbmV3IEFycmF5KG4pLCBvID0gbmV3IEFycmF5KG4pLCBhID0gbmV3IEFycmF5KG4pO1xuICBmb3IgKGlbMF0gPSAwLCBvWzBdID0gMiwgYVswXSA9IGVbMF0gKyAyICogZVsxXSwgdCA9IDE7IHQgPCBuIC0gMTsgKyt0KVxuICAgIGlbdF0gPSAxLCBvW3RdID0gNCwgYVt0XSA9IDQgKiBlW3RdICsgMiAqIGVbdCArIDFdO1xuICBmb3IgKGlbbiAtIDFdID0gMiwgb1tuIC0gMV0gPSA3LCBhW24gLSAxXSA9IDggKiBlW24gLSAxXSArIGVbbl0sIHQgPSAxOyB0IDwgbjsgKyt0KVxuICAgIHIgPSBpW3RdIC8gb1t0IC0gMV0sIG9bdF0gLT0gciwgYVt0XSAtPSByICogYVt0IC0gMV07XG4gIGZvciAoaVtuIC0gMV0gPSBhW24gLSAxXSAvIG9bbiAtIDFdLCB0ID0gbiAtIDI7IHQgPj0gMDsgLS10KVxuICAgIGlbdF0gPSAoYVt0XSAtIGlbdCArIDFdKSAvIG9bdF07XG4gIGZvciAob1tuIC0gMV0gPSAoZVtuXSArIGlbbiAtIDFdKSAvIDIsIHQgPSAwOyB0IDwgbiAtIDE7ICsrdClcbiAgICBvW3RdID0gMiAqIGVbdCArIDFdIC0gaVt0ICsgMV07XG4gIHJldHVybiBbaSwgb107XG59XG5mdW5jdGlvbiBBVChlKSB7XG4gIHJldHVybiBuZXcgbGIoZSk7XG59XG5mdW5jdGlvbiBHcyhlLCB0KSB7XG4gIHRoaXMuX2NvbnRleHQgPSBlLCB0aGlzLl90ID0gdDtcbn1cbkdzLnByb3RvdHlwZSA9IHtcbiAgYXJlYVN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9saW5lID0gMDtcbiAgfSxcbiAgYXJlYUVuZDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fbGluZSA9IE5hTjtcbiAgfSxcbiAgbGluZVN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl94ID0gdGhpcy5feSA9IE5hTiwgdGhpcy5fcG9pbnQgPSAwO1xuICB9LFxuICBsaW5lRW5kOiBmdW5jdGlvbigpIHtcbiAgICAwIDwgdGhpcy5fdCAmJiB0aGlzLl90IDwgMSAmJiB0aGlzLl9wb2ludCA9PT0gMiAmJiB0aGlzLl9jb250ZXh0LmxpbmVUbyh0aGlzLl94LCB0aGlzLl95KSwgKHRoaXMuX2xpbmUgfHwgdGhpcy5fbGluZSAhPT0gMCAmJiB0aGlzLl9wb2ludCA9PT0gMSkgJiYgdGhpcy5fY29udGV4dC5jbG9zZVBhdGgoKSwgdGhpcy5fbGluZSA+PSAwICYmICh0aGlzLl90ID0gMSAtIHRoaXMuX3QsIHRoaXMuX2xpbmUgPSAxIC0gdGhpcy5fbGluZSk7XG4gIH0sXG4gIHBvaW50OiBmdW5jdGlvbihlLCB0KSB7XG4gICAgc3dpdGNoIChlID0gK2UsIHQgPSArdCwgdGhpcy5fcG9pbnQpIHtcbiAgICAgIGNhc2UgMDpcbiAgICAgICAgdGhpcy5fcG9pbnQgPSAxLCB0aGlzLl9saW5lID8gdGhpcy5fY29udGV4dC5saW5lVG8oZSwgdCkgOiB0aGlzLl9jb250ZXh0Lm1vdmVUbyhlLCB0KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDE6XG4gICAgICAgIHRoaXMuX3BvaW50ID0gMjtcbiAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgaWYgKHRoaXMuX3QgPD0gMClcbiAgICAgICAgICB0aGlzLl9jb250ZXh0LmxpbmVUbyh0aGlzLl94LCB0KSwgdGhpcy5fY29udGV4dC5saW5lVG8oZSwgdCk7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHZhciBuID0gdGhpcy5feCAqICgxIC0gdGhpcy5fdCkgKyBlICogdGhpcy5fdDtcbiAgICAgICAgICB0aGlzLl9jb250ZXh0LmxpbmVUbyhuLCB0aGlzLl95KSwgdGhpcy5fY29udGV4dC5saW5lVG8obiwgdCk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuX3ggPSBlLCB0aGlzLl95ID0gdDtcbiAgfVxufTtcbmZ1bmN0aW9uIFBUKGUpIHtcbiAgcmV0dXJuIG5ldyBHcyhlLCAwLjUpO1xufVxuZnVuY3Rpb24gQ1QoZSkge1xuICByZXR1cm4gbmV3IEdzKGUsIDApO1xufVxuZnVuY3Rpb24gRVQoZSkge1xuICByZXR1cm4gbmV3IEdzKGUsIDEpO1xufVxuZnVuY3Rpb24gTHIoZSwgdCkge1xuICBpZiAoKGEgPSBlLmxlbmd0aCkgPiAxKVxuICAgIGZvciAodmFyIG4gPSAxLCByLCBpLCBvID0gZVt0WzBdXSwgYSwgcyA9IG8ubGVuZ3RoOyBuIDwgYTsgKytuKVxuICAgICAgZm9yIChpID0gbywgbyA9IGVbdFtuXV0sIHIgPSAwOyByIDwgczsgKytyKVxuICAgICAgICBvW3JdWzFdICs9IG9bcl1bMF0gPSBpc05hTihpW3JdWzFdKSA/IGlbcl1bMF0gOiBpW3JdWzFdO1xufVxuZnVuY3Rpb24gRmMoZSkge1xuICBmb3IgKHZhciB0ID0gZS5sZW5ndGgsIG4gPSBuZXcgQXJyYXkodCk7IC0tdCA+PSAwOyApXG4gICAgblt0XSA9IHQ7XG4gIHJldHVybiBuO1xufVxuZnVuY3Rpb24gVFQoZSwgdCkge1xuICByZXR1cm4gZVt0XTtcbn1cbmZ1bmN0aW9uIE1UKGUpIHtcbiAgY29uc3QgdCA9IFtdO1xuICByZXR1cm4gdC5rZXkgPSBlLCB0O1xufVxuZnVuY3Rpb24gUlQoKSB7XG4gIHZhciBlID0gSWUoW10pLCB0ID0gRmMsIG4gPSBMciwgciA9IFRUO1xuICBmdW5jdGlvbiBpKG8pIHtcbiAgICB2YXIgYSA9IEFycmF5LmZyb20oZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpLCBNVCksIHMsIHUgPSBhLmxlbmd0aCwgYyA9IC0xLCBmO1xuICAgIGZvciAoY29uc3QgbCBvZiBvKVxuICAgICAgZm9yIChzID0gMCwgKytjOyBzIDwgdTsgKytzKVxuICAgICAgICAoYVtzXVtjXSA9IFswLCArcihsLCBhW3NdLmtleSwgYywgbyldKS5kYXRhID0gbDtcbiAgICBmb3IgKHMgPSAwLCBmID0gQ2YodChhKSk7IHMgPCB1OyArK3MpXG4gICAgICBhW2Zbc11dLmluZGV4ID0gcztcbiAgICByZXR1cm4gbihhLCBmKSwgYTtcbiAgfVxuICByZXR1cm4gaS5rZXlzID0gZnVuY3Rpb24obykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGUgPSB0eXBlb2YgbyA9PSBcImZ1bmN0aW9uXCIgPyBvIDogSWUoQXJyYXkuZnJvbShvKSksIGkpIDogZTtcbiAgfSwgaS52YWx1ZSA9IGZ1bmN0aW9uKG8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChyID0gdHlwZW9mIG8gPT0gXCJmdW5jdGlvblwiID8gbyA6IEllKCtvKSwgaSkgOiByO1xuICB9LCBpLm9yZGVyID0gZnVuY3Rpb24obykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHQgPSBvID09IG51bGwgPyBGYyA6IHR5cGVvZiBvID09IFwiZnVuY3Rpb25cIiA/IG8gOiBJZShBcnJheS5mcm9tKG8pKSwgaSkgOiB0O1xuICB9LCBpLm9mZnNldCA9IGZ1bmN0aW9uKG8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChuID0gbyA/PyBMciwgaSkgOiBuO1xuICB9LCBpO1xufVxuZnVuY3Rpb24gSVQoZSwgdCkge1xuICBpZiAoKHIgPSBlLmxlbmd0aCkgPiAwKSB7XG4gICAgZm9yICh2YXIgbiwgciwgaSA9IDAsIG8gPSBlWzBdLmxlbmd0aCwgYTsgaSA8IG87ICsraSkge1xuICAgICAgZm9yIChhID0gbiA9IDA7IG4gPCByOyArK24pXG4gICAgICAgIGEgKz0gZVtuXVtpXVsxXSB8fCAwO1xuICAgICAgaWYgKGEpXG4gICAgICAgIGZvciAobiA9IDA7IG4gPCByOyArK24pXG4gICAgICAgICAgZVtuXVtpXVsxXSAvPSBhO1xuICAgIH1cbiAgICBMcihlLCB0KTtcbiAgfVxufVxuZnVuY3Rpb24galQoZSwgdCkge1xuICBpZiAoKGkgPSBlLmxlbmd0aCkgPiAwKSB7XG4gICAgZm9yICh2YXIgbiA9IDAsIHIgPSBlW3RbMF1dLCBpLCBvID0gci5sZW5ndGg7IG4gPCBvOyArK24pIHtcbiAgICAgIGZvciAodmFyIGEgPSAwLCBzID0gMDsgYSA8IGk7ICsrYSlcbiAgICAgICAgcyArPSBlW2FdW25dWzFdIHx8IDA7XG4gICAgICByW25dWzFdICs9IHJbbl1bMF0gPSAtcyAvIDI7XG4gICAgfVxuICAgIExyKGUsIHQpO1xuICB9XG59XG5mdW5jdGlvbiBrVChlLCB0KSB7XG4gIGlmICghKCEoKGEgPSBlLmxlbmd0aCkgPiAwKSB8fCAhKChvID0gKGkgPSBlW3RbMF1dKS5sZW5ndGgpID4gMCkpKSB7XG4gICAgZm9yICh2YXIgbiA9IDAsIHIgPSAxLCBpLCBvLCBhOyByIDwgbzsgKytyKSB7XG4gICAgICBmb3IgKHZhciBzID0gMCwgdSA9IDAsIGMgPSAwOyBzIDwgYTsgKytzKSB7XG4gICAgICAgIGZvciAodmFyIGYgPSBlW3Rbc11dLCBsID0gZltyXVsxXSB8fCAwLCBkID0gZltyIC0gMV1bMV0gfHwgMCwgcCA9IChsIC0gZCkgLyAyLCBnID0gMDsgZyA8IHM7ICsrZykge1xuICAgICAgICAgIHZhciBoID0gZVt0W2ddXSwgdiA9IGhbcl1bMV0gfHwgMCwgdyA9IGhbciAtIDFdWzFdIHx8IDA7XG4gICAgICAgICAgcCArPSB2IC0gdztcbiAgICAgICAgfVxuICAgICAgICB1ICs9IGwsIGMgKz0gcCAqIGw7XG4gICAgICB9XG4gICAgICBpW3IgLSAxXVsxXSArPSBpW3IgLSAxXVswXSA9IG4sIHUgJiYgKG4gLT0gYyAvIHUpO1xuICAgIH1cbiAgICBpW3IgLSAxXVsxXSArPSBpW3IgLSAxXVswXSA9IG4sIExyKGUsIHQpO1xuICB9XG59XG5mdW5jdGlvbiB0byhlKSB7XG4gIFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjtcbiAgcmV0dXJuIHRvID0gdHlwZW9mIFN5bWJvbCA9PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PSBcInN5bWJvbFwiID8gZnVuY3Rpb24odCkge1xuICAgIHJldHVybiB0eXBlb2YgdDtcbiAgfSA6IGZ1bmN0aW9uKHQpIHtcbiAgICByZXR1cm4gdCAmJiB0eXBlb2YgU3ltYm9sID09IFwiZnVuY3Rpb25cIiAmJiB0LmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgdCAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2YgdDtcbiAgfSwgdG8oZSk7XG59XG52YXIgRFQgPSBbXCJ0eXBlXCIsIFwic2l6ZVwiLCBcInNpemVUeXBlXCJdO1xuZnVuY3Rpb24gTGMoKSB7XG4gIHJldHVybiBMYyA9IE9iamVjdC5hc3NpZ24gPyBPYmplY3QuYXNzaWduLmJpbmQoKSA6IGZ1bmN0aW9uKGUpIHtcbiAgICBmb3IgKHZhciB0ID0gMTsgdCA8IGFyZ3VtZW50cy5sZW5ndGg7IHQrKykge1xuICAgICAgdmFyIG4gPSBhcmd1bWVudHNbdF07XG4gICAgICBmb3IgKHZhciByIGluIG4pXG4gICAgICAgIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChuLCByKSAmJiAoZVtyXSA9IG5bcl0pO1xuICAgIH1cbiAgICByZXR1cm4gZTtcbiAgfSwgTGMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cbmZ1bmN0aW9uIE1wKGUsIHQpIHtcbiAgdmFyIG4gPSBPYmplY3Qua2V5cyhlKTtcbiAgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcbiAgICB2YXIgciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZSk7XG4gICAgdCAmJiAociA9IHIuZmlsdGVyKGZ1bmN0aW9uKGkpIHtcbiAgICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsIGkpLmVudW1lcmFibGU7XG4gICAgfSkpLCBuLnB1c2guYXBwbHkobiwgcik7XG4gIH1cbiAgcmV0dXJuIG47XG59XG5mdW5jdGlvbiBScChlKSB7XG4gIGZvciAodmFyIHQgPSAxOyB0IDwgYXJndW1lbnRzLmxlbmd0aDsgdCsrKSB7XG4gICAgdmFyIG4gPSBhcmd1bWVudHNbdF0gIT0gbnVsbCA/IGFyZ3VtZW50c1t0XSA6IHt9O1xuICAgIHQgJSAyID8gTXAoT2JqZWN0KG4pLCAhMCkuZm9yRWFjaChmdW5jdGlvbihyKSB7XG4gICAgICBOVChlLCByLCBuW3JdKTtcbiAgICB9KSA6IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoZSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMobikpIDogTXAoT2JqZWN0KG4pKS5mb3JFYWNoKGZ1bmN0aW9uKHIpIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCByLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG4sIHIpKTtcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gZTtcbn1cbmZ1bmN0aW9uIE5UKGUsIHQsIG4pIHtcbiAgcmV0dXJuIHQgPSBGVCh0KSwgdCBpbiBlID8gT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIHQsIHsgdmFsdWU6IG4sIGVudW1lcmFibGU6ICEwLCBjb25maWd1cmFibGU6ICEwLCB3cml0YWJsZTogITAgfSkgOiBlW3RdID0gbiwgZTtcbn1cbmZ1bmN0aW9uIEZUKGUpIHtcbiAgdmFyIHQgPSBMVChlLCBcInN0cmluZ1wiKTtcbiAgcmV0dXJuIHRvKHQpID09IFwic3ltYm9sXCIgPyB0IDogU3RyaW5nKHQpO1xufVxuZnVuY3Rpb24gTFQoZSwgdCkge1xuICBpZiAodG8oZSkgIT0gXCJvYmplY3RcIiB8fCAhZSlcbiAgICByZXR1cm4gZTtcbiAgdmFyIG4gPSBlW1N5bWJvbC50b1ByaW1pdGl2ZV07XG4gIGlmIChuICE9PSB2b2lkIDApIHtcbiAgICB2YXIgciA9IG4uY2FsbChlLCB0IHx8IFwiZGVmYXVsdFwiKTtcbiAgICBpZiAodG8ocikgIT0gXCJvYmplY3RcIilcbiAgICAgIHJldHVybiByO1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJAQHRvUHJpbWl0aXZlIG11c3QgcmV0dXJuIGEgcHJpbWl0aXZlIHZhbHVlLlwiKTtcbiAgfVxuICByZXR1cm4gKHQgPT09IFwic3RyaW5nXCIgPyBTdHJpbmcgOiBOdW1iZXIpKGUpO1xufVxuZnVuY3Rpb24gQlQoZSwgdCkge1xuICBpZiAoZSA9PSBudWxsKVxuICAgIHJldHVybiB7fTtcbiAgdmFyIG4gPSB6VChlLCB0KSwgciwgaTtcbiAgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcbiAgICB2YXIgbyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZSk7XG4gICAgZm9yIChpID0gMDsgaSA8IG8ubGVuZ3RoOyBpKyspXG4gICAgICByID0gb1tpXSwgISh0LmluZGV4T2YocikgPj0gMCkgJiYgT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKGUsIHIpICYmIChuW3JdID0gZVtyXSk7XG4gIH1cbiAgcmV0dXJuIG47XG59XG5mdW5jdGlvbiB6VChlLCB0KSB7XG4gIGlmIChlID09IG51bGwpXG4gICAgcmV0dXJuIHt9O1xuICB2YXIgbiA9IHt9LCByID0gT2JqZWN0LmtleXMoZSksIGksIG87XG4gIGZvciAobyA9IDA7IG8gPCByLmxlbmd0aDsgbysrKVxuICAgIGkgPSByW29dLCAhKHQuaW5kZXhPZihpKSA+PSAwKSAmJiAobltpXSA9IGVbaV0pO1xuICByZXR1cm4gbjtcbn1cbnZhciBmYiA9IHtcbiAgc3ltYm9sQ2lyY2xlOiBFZixcbiAgc3ltYm9sQ3Jvc3M6IHVULFxuICBzeW1ib2xEaWFtb25kOiBsVCxcbiAgc3ltYm9sU3F1YXJlOiBmVCxcbiAgc3ltYm9sU3RhcjogZ1QsXG4gIHN5bWJvbFRyaWFuZ2xlOiB2VCxcbiAgc3ltYm9sV3llOiB5VFxufSwgVlQgPSBNYXRoLlBJIC8gMTgwLCBHVCA9IGZ1bmN0aW9uKHQpIHtcbiAgdmFyIG4gPSBcInN5bWJvbFwiLmNvbmNhdChCcyh0KSk7XG4gIHJldHVybiBmYltuXSB8fCBFZjtcbn0sIFdUID0gZnVuY3Rpb24odCwgbiwgcikge1xuICBpZiAobiA9PT0gXCJhcmVhXCIpXG4gICAgcmV0dXJuIHQ7XG4gIHN3aXRjaCAocikge1xuICAgIGNhc2UgXCJjcm9zc1wiOlxuICAgICAgcmV0dXJuIDUgKiB0ICogdCAvIDk7XG4gICAgY2FzZSBcImRpYW1vbmRcIjpcbiAgICAgIHJldHVybiAwLjUgKiB0ICogdCAvIE1hdGguc3FydCgzKTtcbiAgICBjYXNlIFwic3F1YXJlXCI6XG4gICAgICByZXR1cm4gdCAqIHQ7XG4gICAgY2FzZSBcInN0YXJcIjoge1xuICAgICAgdmFyIGkgPSAxOCAqIFZUO1xuICAgICAgcmV0dXJuIDEuMjUgKiB0ICogdCAqIChNYXRoLnRhbihpKSAtIE1hdGgudGFuKGkgKiAyKSAqIE1hdGgucG93KE1hdGgudGFuKGkpLCAyKSk7XG4gICAgfVxuICAgIGNhc2UgXCJ0cmlhbmdsZVwiOlxuICAgICAgcmV0dXJuIE1hdGguc3FydCgzKSAqIHQgKiB0IC8gNDtcbiAgICBjYXNlIFwid3llXCI6XG4gICAgICByZXR1cm4gKDIxIC0gMTAgKiBNYXRoLnNxcnQoMykpICogdCAqIHQgLyA4O1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gTWF0aC5QSSAqIHQgKiB0IC8gNDtcbiAgfVxufSwgVVQgPSBmdW5jdGlvbih0LCBuKSB7XG4gIGZiW1wic3ltYm9sXCIuY29uY2F0KEJzKHQpKV0gPSBuO1xufSwgVGYgPSBmdW5jdGlvbih0KSB7XG4gIHZhciBuID0gdC50eXBlLCByID0gbiA9PT0gdm9pZCAwID8gXCJjaXJjbGVcIiA6IG4sIGkgPSB0LnNpemUsIG8gPSBpID09PSB2b2lkIDAgPyA2NCA6IGksIGEgPSB0LnNpemVUeXBlLCBzID0gYSA9PT0gdm9pZCAwID8gXCJhcmVhXCIgOiBhLCB1ID0gQlQodCwgRFQpLCBjID0gUnAoUnAoe30sIHUpLCB7fSwge1xuICAgIHR5cGU6IHIsXG4gICAgc2l6ZTogbyxcbiAgICBzaXplVHlwZTogc1xuICB9KSwgZiA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciB2ID0gR1QociksIHcgPSBiVCgpLnR5cGUodikuc2l6ZShXVChvLCBzLCByKSk7XG4gICAgcmV0dXJuIHcoKTtcbiAgfSwgbCA9IGMuY2xhc3NOYW1lLCBkID0gYy5jeCwgcCA9IGMuY3ksIGcgPSB5ZShjLCAhMCk7XG4gIHJldHVybiBkID09PSArZCAmJiBwID09PSArcCAmJiBvID09PSArbyA/IC8qIEBfX1BVUkVfXyAqLyBQLmNyZWF0ZUVsZW1lbnQoXCJwYXRoXCIsIExjKHt9LCBnLCB7XG4gICAgY2xhc3NOYW1lOiAkZShcInJlY2hhcnRzLXN5bWJvbHNcIiwgbCksXG4gICAgdHJhbnNmb3JtOiBcInRyYW5zbGF0ZShcIi5jb25jYXQoZCwgXCIsIFwiKS5jb25jYXQocCwgXCIpXCIpLFxuICAgIGQ6IGYoKVxuICB9KSkgOiBudWxsO1xufTtcblRmLnJlZ2lzdGVyU3ltYm9sID0gVVQ7XG5mdW5jdGlvbiBCcihlKSB7XG4gIFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjtcbiAgcmV0dXJuIEJyID0gdHlwZW9mIFN5bWJvbCA9PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PSBcInN5bWJvbFwiID8gZnVuY3Rpb24odCkge1xuICAgIHJldHVybiB0eXBlb2YgdDtcbiAgfSA6IGZ1bmN0aW9uKHQpIHtcbiAgICByZXR1cm4gdCAmJiB0eXBlb2YgU3ltYm9sID09IFwiZnVuY3Rpb25cIiAmJiB0LmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgdCAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2YgdDtcbiAgfSwgQnIoZSk7XG59XG5mdW5jdGlvbiBCYygpIHtcbiAgcmV0dXJuIEJjID0gT2JqZWN0LmFzc2lnbiA/IE9iamVjdC5hc3NpZ24uYmluZCgpIDogZnVuY3Rpb24oZSkge1xuICAgIGZvciAodmFyIHQgPSAxOyB0IDwgYXJndW1lbnRzLmxlbmd0aDsgdCsrKSB7XG4gICAgICB2YXIgbiA9IGFyZ3VtZW50c1t0XTtcbiAgICAgIGZvciAodmFyIHIgaW4gbilcbiAgICAgICAgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG4sIHIpICYmIChlW3JdID0gbltyXSk7XG4gICAgfVxuICAgIHJldHVybiBlO1xuICB9LCBCYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuZnVuY3Rpb24gSXAoZSwgdCkge1xuICB2YXIgbiA9IE9iamVjdC5rZXlzKGUpO1xuICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykge1xuICAgIHZhciByID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhlKTtcbiAgICB0ICYmIChyID0gci5maWx0ZXIoZnVuY3Rpb24oaSkge1xuICAgICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSwgaSkuZW51bWVyYWJsZTtcbiAgICB9KSksIG4ucHVzaC5hcHBseShuLCByKTtcbiAgfVxuICByZXR1cm4gbjtcbn1cbmZ1bmN0aW9uIEhUKGUpIHtcbiAgZm9yICh2YXIgdCA9IDE7IHQgPCBhcmd1bWVudHMubGVuZ3RoOyB0KyspIHtcbiAgICB2YXIgbiA9IGFyZ3VtZW50c1t0XSAhPSBudWxsID8gYXJndW1lbnRzW3RdIDoge307XG4gICAgdCAlIDIgPyBJcChPYmplY3QobiksICEwKS5mb3JFYWNoKGZ1bmN0aW9uKHIpIHtcbiAgICAgIG5vKGUsIHIsIG5bcl0pO1xuICAgIH0pIDogT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhlLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhuKSkgOiBJcChPYmplY3QobikpLmZvckVhY2goZnVuY3Rpb24ocikge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIHIsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobiwgcikpO1xuICAgIH0pO1xuICB9XG4gIHJldHVybiBlO1xufVxuZnVuY3Rpb24gcVQoZSwgdCkge1xuICBpZiAoIShlIGluc3RhbmNlb2YgdCkpXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcbn1cbmZ1bmN0aW9uIEtUKGUsIHQpIHtcbiAgZm9yICh2YXIgbiA9IDA7IG4gPCB0Lmxlbmd0aDsgbisrKSB7XG4gICAgdmFyIHIgPSB0W25dO1xuICAgIHIuZW51bWVyYWJsZSA9IHIuZW51bWVyYWJsZSB8fCAhMSwgci5jb25maWd1cmFibGUgPSAhMCwgXCJ2YWx1ZVwiIGluIHIgJiYgKHIud3JpdGFibGUgPSAhMCksIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCBwYihyLmtleSksIHIpO1xuICB9XG59XG5mdW5jdGlvbiBZVChlLCB0LCBuKSB7XG4gIHJldHVybiB0ICYmIEtUKGUucHJvdG90eXBlLCB0KSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIFwicHJvdG90eXBlXCIsIHsgd3JpdGFibGU6ICExIH0pLCBlO1xufVxuZnVuY3Rpb24gWFQoZSwgdCwgbikge1xuICByZXR1cm4gdCA9IFdhKHQpLCBaVChlLCBkYigpID8gUmVmbGVjdC5jb25zdHJ1Y3QodCwgbiB8fCBbXSwgV2EoZSkuY29uc3RydWN0b3IpIDogdC5hcHBseShlLCBuKSk7XG59XG5mdW5jdGlvbiBaVChlLCB0KSB7XG4gIGlmICh0ICYmIChCcih0KSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgdCA9PSBcImZ1bmN0aW9uXCIpKVxuICAgIHJldHVybiB0O1xuICBpZiAodCAhPT0gdm9pZCAwKVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJEZXJpdmVkIGNvbnN0cnVjdG9ycyBtYXkgb25seSByZXR1cm4gb2JqZWN0IG9yIHVuZGVmaW5lZFwiKTtcbiAgcmV0dXJuIEpUKGUpO1xufVxuZnVuY3Rpb24gSlQoZSkge1xuICBpZiAoZSA9PT0gdm9pZCAwKVxuICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTtcbiAgcmV0dXJuIGU7XG59XG5mdW5jdGlvbiBkYigpIHtcbiAgdHJ5IHtcbiAgICB2YXIgZSA9ICFCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uKCkge1xuICAgIH0pKTtcbiAgfSBjYXRjaCB7XG4gIH1cbiAgcmV0dXJuIChkYiA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiAhIWU7XG4gIH0pKCk7XG59XG5mdW5jdGlvbiBXYShlKSB7XG4gIHJldHVybiBXYSA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZi5iaW5kKCkgOiBmdW5jdGlvbihuKSB7XG4gICAgcmV0dXJuIG4uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihuKTtcbiAgfSwgV2EoZSk7XG59XG5mdW5jdGlvbiBRVChlLCB0KSB7XG4gIGlmICh0eXBlb2YgdCAhPSBcImZ1bmN0aW9uXCIgJiYgdCAhPT0gbnVsbClcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7XG4gIGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSh0ICYmIHQucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBlLCB3cml0YWJsZTogITAsIGNvbmZpZ3VyYWJsZTogITAgfSB9KSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIFwicHJvdG90eXBlXCIsIHsgd3JpdGFibGU6ICExIH0pLCB0ICYmIHpjKGUsIHQpO1xufVxuZnVuY3Rpb24gemMoZSwgdCkge1xuICByZXR1cm4gemMgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2YuYmluZCgpIDogZnVuY3Rpb24ociwgaSkge1xuICAgIHJldHVybiByLl9fcHJvdG9fXyA9IGksIHI7XG4gIH0sIHpjKGUsIHQpO1xufVxuZnVuY3Rpb24gbm8oZSwgdCwgbikge1xuICByZXR1cm4gdCA9IHBiKHQpLCB0IGluIGUgPyBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgdCwgeyB2YWx1ZTogbiwgZW51bWVyYWJsZTogITAsIGNvbmZpZ3VyYWJsZTogITAsIHdyaXRhYmxlOiAhMCB9KSA6IGVbdF0gPSBuLCBlO1xufVxuZnVuY3Rpb24gcGIoZSkge1xuICB2YXIgdCA9IGVNKGUsIFwic3RyaW5nXCIpO1xuICByZXR1cm4gQnIodCkgPT0gXCJzeW1ib2xcIiA/IHQgOiBTdHJpbmcodCk7XG59XG5mdW5jdGlvbiBlTShlLCB0KSB7XG4gIGlmIChCcihlKSAhPSBcIm9iamVjdFwiIHx8ICFlKVxuICAgIHJldHVybiBlO1xuICB2YXIgbiA9IGVbU3ltYm9sLnRvUHJpbWl0aXZlXTtcbiAgaWYgKG4gIT09IHZvaWQgMCkge1xuICAgIHZhciByID0gbi5jYWxsKGUsIHQgfHwgXCJkZWZhdWx0XCIpO1xuICAgIGlmIChCcihyKSAhPSBcIm9iamVjdFwiKVxuICAgICAgcmV0dXJuIHI7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkBAdG9QcmltaXRpdmUgbXVzdCByZXR1cm4gYSBwcmltaXRpdmUgdmFsdWUuXCIpO1xuICB9XG4gIHJldHVybiAodCA9PT0gXCJzdHJpbmdcIiA/IFN0cmluZyA6IE51bWJlcikoZSk7XG59XG52YXIgTXQgPSAzMiwgTWYgPSAvKiBAX19QVVJFX18gKi8gZnVuY3Rpb24oZSkge1xuICBRVCh0LCBlKTtcbiAgZnVuY3Rpb24gdCgpIHtcbiAgICByZXR1cm4gcVQodGhpcywgdCksIFhUKHRoaXMsIHQsIGFyZ3VtZW50cyk7XG4gIH1cbiAgcmV0dXJuIFlUKHQsIFt7XG4gICAga2V5OiBcInJlbmRlckljb25cIixcbiAgICB2YWx1ZTogKFxuICAgICAgLyoqXG4gICAgICAgKiBSZW5kZXIgdGhlIHBhdGggb2YgaWNvblxuICAgICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGEgRGF0YSBvZiBlYWNoIGxlZ2VuZCBpdGVtXG4gICAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IFBhdGggZWxlbWVudFxuICAgICAgICovXG4gICAgICBmdW5jdGlvbihyKSB7XG4gICAgICAgIHZhciBpID0gdGhpcy5wcm9wcy5pbmFjdGl2ZUNvbG9yLCBvID0gTXQgLyAyLCBhID0gTXQgLyA2LCBzID0gTXQgLyAzLCB1ID0gci5pbmFjdGl2ZSA/IGkgOiByLmNvbG9yO1xuICAgICAgICBpZiAoci50eXBlID09PSBcInBsYWlubGluZVwiKVxuICAgICAgICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8gUC5jcmVhdGVFbGVtZW50KFwibGluZVwiLCB7XG4gICAgICAgICAgICBzdHJva2VXaWR0aDogNCxcbiAgICAgICAgICAgIGZpbGw6IFwibm9uZVwiLFxuICAgICAgICAgICAgc3Ryb2tlOiB1LFxuICAgICAgICAgICAgc3Ryb2tlRGFzaGFycmF5OiByLnBheWxvYWQuc3Ryb2tlRGFzaGFycmF5LFxuICAgICAgICAgICAgeDE6IDAsXG4gICAgICAgICAgICB5MTogbyxcbiAgICAgICAgICAgIHgyOiBNdCxcbiAgICAgICAgICAgIHkyOiBvLFxuICAgICAgICAgICAgY2xhc3NOYW1lOiBcInJlY2hhcnRzLWxlZ2VuZC1pY29uXCJcbiAgICAgICAgICB9KTtcbiAgICAgICAgaWYgKHIudHlwZSA9PT0gXCJsaW5lXCIpXG4gICAgICAgICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBQLmNyZWF0ZUVsZW1lbnQoXCJwYXRoXCIsIHtcbiAgICAgICAgICAgIHN0cm9rZVdpZHRoOiA0LFxuICAgICAgICAgICAgZmlsbDogXCJub25lXCIsXG4gICAgICAgICAgICBzdHJva2U6IHUsXG4gICAgICAgICAgICBkOiBcIk0wLFwiLmNvbmNhdChvLCBcImhcIikuY29uY2F0KHMsIGBcbiAgICAgICAgICAgIEFgKS5jb25jYXQoYSwgXCIsXCIpLmNvbmNhdChhLCBcIiwwLDEsMSxcIikuY29uY2F0KDIgKiBzLCBcIixcIikuY29uY2F0KG8sIGBcbiAgICAgICAgICAgIEhgKS5jb25jYXQoTXQsIFwiTVwiKS5jb25jYXQoMiAqIHMsIFwiLFwiKS5jb25jYXQobywgYFxuICAgICAgICAgICAgQWApLmNvbmNhdChhLCBcIixcIikuY29uY2F0KGEsIFwiLDAsMSwxLFwiKS5jb25jYXQocywgXCIsXCIpLmNvbmNhdChvKSxcbiAgICAgICAgICAgIGNsYXNzTmFtZTogXCJyZWNoYXJ0cy1sZWdlbmQtaWNvblwiXG4gICAgICAgICAgfSk7XG4gICAgICAgIGlmIChyLnR5cGUgPT09IFwicmVjdFwiKVxuICAgICAgICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8gUC5jcmVhdGVFbGVtZW50KFwicGF0aFwiLCB7XG4gICAgICAgICAgICBzdHJva2U6IFwibm9uZVwiLFxuICAgICAgICAgICAgZmlsbDogdSxcbiAgICAgICAgICAgIGQ6IFwiTTAsXCIuY29uY2F0KE10IC8gOCwgXCJoXCIpLmNvbmNhdChNdCwgXCJ2XCIpLmNvbmNhdChNdCAqIDMgLyA0LCBcImhcIikuY29uY2F0KC1NdCwgXCJ6XCIpLFxuICAgICAgICAgICAgY2xhc3NOYW1lOiBcInJlY2hhcnRzLWxlZ2VuZC1pY29uXCJcbiAgICAgICAgICB9KTtcbiAgICAgICAgaWYgKC8qIEBfX1BVUkVfXyAqLyBQLmlzVmFsaWRFbGVtZW50KHIubGVnZW5kSWNvbikpIHtcbiAgICAgICAgICB2YXIgYyA9IEhUKHt9LCByKTtcbiAgICAgICAgICByZXR1cm4gZGVsZXRlIGMubGVnZW5kSWNvbiwgLyogQF9fUFVSRV9fICovIFAuY2xvbmVFbGVtZW50KHIubGVnZW5kSWNvbiwgYyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBQLmNyZWF0ZUVsZW1lbnQoVGYsIHtcbiAgICAgICAgICBmaWxsOiB1LFxuICAgICAgICAgIGN4OiBvLFxuICAgICAgICAgIGN5OiBvLFxuICAgICAgICAgIHNpemU6IE10LFxuICAgICAgICAgIHNpemVUeXBlOiBcImRpYW1ldGVyXCIsXG4gICAgICAgICAgdHlwZTogci50eXBlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIClcbiAgICAvKipcbiAgICAgKiBEcmF3IGl0ZW1zIG9mIGxlZ2VuZFxuICAgICAqIEByZXR1cm4ge1JlYWN0RWxlbWVudH0gSXRlbXNcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJyZW5kZXJJdGVtc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciByID0gdGhpcywgaSA9IHRoaXMucHJvcHMsIG8gPSBpLnBheWxvYWQsIGEgPSBpLmljb25TaXplLCBzID0gaS5sYXlvdXQsIHUgPSBpLmZvcm1hdHRlciwgYyA9IGkuaW5hY3RpdmVDb2xvciwgZiA9IHtcbiAgICAgICAgeDogMCxcbiAgICAgICAgeTogMCxcbiAgICAgICAgd2lkdGg6IE10LFxuICAgICAgICBoZWlnaHQ6IE10XG4gICAgICB9LCBsID0ge1xuICAgICAgICBkaXNwbGF5OiBzID09PSBcImhvcml6b250YWxcIiA/IFwiaW5saW5lLWJsb2NrXCIgOiBcImJsb2NrXCIsXG4gICAgICAgIG1hcmdpblJpZ2h0OiAxMFxuICAgICAgfSwgZCA9IHtcbiAgICAgICAgZGlzcGxheTogXCJpbmxpbmUtYmxvY2tcIixcbiAgICAgICAgdmVydGljYWxBbGlnbjogXCJtaWRkbGVcIixcbiAgICAgICAgbWFyZ2luUmlnaHQ6IDRcbiAgICAgIH07XG4gICAgICByZXR1cm4gby5tYXAoZnVuY3Rpb24ocCwgZykge1xuICAgICAgICB2YXIgaCA9IHAuZm9ybWF0dGVyIHx8IHUsIHYgPSAkZShubyhubyh7XG4gICAgICAgICAgXCJyZWNoYXJ0cy1sZWdlbmQtaXRlbVwiOiAhMFxuICAgICAgICB9LCBcImxlZ2VuZC1pdGVtLVwiLmNvbmNhdChnKSwgITApLCBcImluYWN0aXZlXCIsIHAuaW5hY3RpdmUpKTtcbiAgICAgICAgaWYgKHAudHlwZSA9PT0gXCJub25lXCIpXG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIHZhciB3ID0gcGUocC52YWx1ZSkgPyBudWxsIDogcC52YWx1ZTtcbiAgICAgICAgRnIoXG4gICAgICAgICAgIXBlKHAudmFsdWUpLFxuICAgICAgICAgIGBUaGUgbmFtZSBwcm9wZXJ0eSBpcyBhbHNvIHJlcXVpcmVkIHdoZW4gdXNpbmcgYSBmdW5jdGlvbiBmb3IgdGhlIGRhdGFLZXkgb2YgYSBjaGFydCdzIGNhcnRlc2lhbiBjb21wb25lbnRzLiBFeDogPEJhciBuYW1lPVwiTmFtZSBvZiBteSBEYXRhXCIvPmBcbiAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG1heC1sZW5cbiAgICAgICAgKTtcbiAgICAgICAgdmFyIGIgPSBwLmluYWN0aXZlID8gYyA6IHAuY29sb3I7XG4gICAgICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8gUC5jcmVhdGVFbGVtZW50KFwibGlcIiwgQmMoe1xuICAgICAgICAgIGNsYXNzTmFtZTogdixcbiAgICAgICAgICBzdHlsZTogbCxcbiAgICAgICAgICBrZXk6IFwibGVnZW5kLWl0ZW0tXCIuY29uY2F0KGcpXG4gICAgICAgIH0sIEZhKHIucHJvcHMsIHAsIGcpKSwgLyogQF9fUFVSRV9fICovIFAuY3JlYXRlRWxlbWVudChNYywge1xuICAgICAgICAgIHdpZHRoOiBhLFxuICAgICAgICAgIGhlaWdodDogYSxcbiAgICAgICAgICB2aWV3Qm94OiBmLFxuICAgICAgICAgIHN0eWxlOiBkXG4gICAgICAgIH0sIHIucmVuZGVySWNvbihwKSksIC8qIEBfX1BVUkVfXyAqLyBQLmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIHtcbiAgICAgICAgICBjbGFzc05hbWU6IFwicmVjaGFydHMtbGVnZW5kLWl0ZW0tdGV4dFwiLFxuICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICBjb2xvcjogYlxuICAgICAgICAgIH1cbiAgICAgICAgfSwgaCA/IGgodywgcCwgZykgOiB3KSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVuZGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHIgPSB0aGlzLnByb3BzLCBpID0gci5wYXlsb2FkLCBvID0gci5sYXlvdXQsIGEgPSByLmFsaWduO1xuICAgICAgaWYgKCFpIHx8ICFpLmxlbmd0aClcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB2YXIgcyA9IHtcbiAgICAgICAgcGFkZGluZzogMCxcbiAgICAgICAgbWFyZ2luOiAwLFxuICAgICAgICB0ZXh0QWxpZ246IG8gPT09IFwiaG9yaXpvbnRhbFwiID8gYSA6IFwibGVmdFwiXG4gICAgICB9O1xuICAgICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBQLmNyZWF0ZUVsZW1lbnQoXCJ1bFwiLCB7XG4gICAgICAgIGNsYXNzTmFtZTogXCJyZWNoYXJ0cy1kZWZhdWx0LWxlZ2VuZFwiLFxuICAgICAgICBzdHlsZTogc1xuICAgICAgfSwgdGhpcy5yZW5kZXJJdGVtcygpKTtcbiAgICB9XG4gIH1dKSwgdDtcbn0oV24pO1xubm8oTWYsIFwiZGlzcGxheU5hbWVcIiwgXCJMZWdlbmRcIik7XG5ubyhNZiwgXCJkZWZhdWx0UHJvcHNcIiwge1xuICBpY29uU2l6ZTogMTQsXG4gIGxheW91dDogXCJob3Jpem9udGFsXCIsXG4gIGFsaWduOiBcImNlbnRlclwiLFxuICB2ZXJ0aWNhbEFsaWduOiBcIm1pZGRsZVwiLFxuICBpbmFjdGl2ZUNvbG9yOiBcIiNjY2NcIlxufSk7XG52YXIgdE0gPSBOcztcbmZ1bmN0aW9uIG5NKCkge1xuICB0aGlzLl9fZGF0YV9fID0gbmV3IHRNKCksIHRoaXMuc2l6ZSA9IDA7XG59XG52YXIgck0gPSBuTTtcbmZ1bmN0aW9uIGlNKGUpIHtcbiAgdmFyIHQgPSB0aGlzLl9fZGF0YV9fLCBuID0gdC5kZWxldGUoZSk7XG4gIHJldHVybiB0aGlzLnNpemUgPSB0LnNpemUsIG47XG59XG52YXIgb00gPSBpTTtcbmZ1bmN0aW9uIGFNKGUpIHtcbiAgcmV0dXJuIHRoaXMuX19kYXRhX18uZ2V0KGUpO1xufVxudmFyIHNNID0gYU07XG5mdW5jdGlvbiB1TShlKSB7XG4gIHJldHVybiB0aGlzLl9fZGF0YV9fLmhhcyhlKTtcbn1cbnZhciBjTSA9IHVNLCBsTSA9IE5zLCBmTSA9IGJmLCBkTSA9IHdmLCBwTSA9IDIwMDtcbmZ1bmN0aW9uIGhNKGUsIHQpIHtcbiAgdmFyIG4gPSB0aGlzLl9fZGF0YV9fO1xuICBpZiAobiBpbnN0YW5jZW9mIGxNKSB7XG4gICAgdmFyIHIgPSBuLl9fZGF0YV9fO1xuICAgIGlmICghZk0gfHwgci5sZW5ndGggPCBwTSAtIDEpXG4gICAgICByZXR1cm4gci5wdXNoKFtlLCB0XSksIHRoaXMuc2l6ZSA9ICsrbi5zaXplLCB0aGlzO1xuICAgIG4gPSB0aGlzLl9fZGF0YV9fID0gbmV3IGRNKHIpO1xuICB9XG4gIHJldHVybiBuLnNldChlLCB0KSwgdGhpcy5zaXplID0gbi5zaXplLCB0aGlzO1xufVxudmFyIGdNID0gaE0sIHZNID0gTnMsIG1NID0gck0sIHlNID0gb00sIGJNID0gc00sIHdNID0gY00sIHhNID0gZ007XG5mdW5jdGlvbiBwaShlKSB7XG4gIHZhciB0ID0gdGhpcy5fX2RhdGFfXyA9IG5ldyB2TShlKTtcbiAgdGhpcy5zaXplID0gdC5zaXplO1xufVxucGkucHJvdG90eXBlLmNsZWFyID0gbU07XG5waS5wcm90b3R5cGUuZGVsZXRlID0geU07XG5waS5wcm90b3R5cGUuZ2V0ID0gYk07XG5waS5wcm90b3R5cGUuaGFzID0gd007XG5waS5wcm90b3R5cGUuc2V0ID0geE07XG52YXIgaGIgPSBwaSwgU00gPSBcIl9fbG9kYXNoX2hhc2hfdW5kZWZpbmVkX19cIjtcbmZ1bmN0aW9uICRNKGUpIHtcbiAgcmV0dXJuIHRoaXMuX19kYXRhX18uc2V0KGUsIFNNKSwgdGhpcztcbn1cbnZhciBPTSA9ICRNO1xuZnVuY3Rpb24gX00oZSkge1xuICByZXR1cm4gdGhpcy5fX2RhdGFfXy5oYXMoZSk7XG59XG52YXIgQU0gPSBfTSwgUE0gPSB3ZiwgQ00gPSBPTSwgRU0gPSBBTTtcbmZ1bmN0aW9uIFVhKGUpIHtcbiAgdmFyIHQgPSAtMSwgbiA9IGUgPT0gbnVsbCA/IDAgOiBlLmxlbmd0aDtcbiAgZm9yICh0aGlzLl9fZGF0YV9fID0gbmV3IFBNKCk7ICsrdCA8IG47IClcbiAgICB0aGlzLmFkZChlW3RdKTtcbn1cblVhLnByb3RvdHlwZS5hZGQgPSBVYS5wcm90b3R5cGUucHVzaCA9IENNO1xuVWEucHJvdG90eXBlLmhhcyA9IEVNO1xudmFyIGdiID0gVWE7XG5mdW5jdGlvbiBUTShlLCB0KSB7XG4gIGZvciAodmFyIG4gPSAtMSwgciA9IGUgPT0gbnVsbCA/IDAgOiBlLmxlbmd0aDsgKytuIDwgcjsgKVxuICAgIGlmICh0KGVbbl0sIG4sIGUpKVxuICAgICAgcmV0dXJuICEwO1xuICByZXR1cm4gITE7XG59XG52YXIgdmIgPSBUTTtcbmZ1bmN0aW9uIE1NKGUsIHQpIHtcbiAgcmV0dXJuIGUuaGFzKHQpO1xufVxudmFyIG1iID0gTU0sIFJNID0gZ2IsIElNID0gdmIsIGpNID0gbWIsIGtNID0gMSwgRE0gPSAyO1xuZnVuY3Rpb24gTk0oZSwgdCwgbiwgciwgaSwgbykge1xuICB2YXIgYSA9IG4gJiBrTSwgcyA9IGUubGVuZ3RoLCB1ID0gdC5sZW5ndGg7XG4gIGlmIChzICE9IHUgJiYgIShhICYmIHUgPiBzKSlcbiAgICByZXR1cm4gITE7XG4gIHZhciBjID0gby5nZXQoZSksIGYgPSBvLmdldCh0KTtcbiAgaWYgKGMgJiYgZilcbiAgICByZXR1cm4gYyA9PSB0ICYmIGYgPT0gZTtcbiAgdmFyIGwgPSAtMSwgZCA9ICEwLCBwID0gbiAmIERNID8gbmV3IFJNKCkgOiB2b2lkIDA7XG4gIGZvciAoby5zZXQoZSwgdCksIG8uc2V0KHQsIGUpOyArK2wgPCBzOyApIHtcbiAgICB2YXIgZyA9IGVbbF0sIGggPSB0W2xdO1xuICAgIGlmIChyKVxuICAgICAgdmFyIHYgPSBhID8gcihoLCBnLCBsLCB0LCBlLCBvKSA6IHIoZywgaCwgbCwgZSwgdCwgbyk7XG4gICAgaWYgKHYgIT09IHZvaWQgMCkge1xuICAgICAgaWYgKHYpXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgZCA9ICExO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGlmIChwKSB7XG4gICAgICBpZiAoIUlNKHQsIGZ1bmN0aW9uKHcsIGIpIHtcbiAgICAgICAgaWYgKCFqTShwLCBiKSAmJiAoZyA9PT0gdyB8fCBpKGcsIHcsIG4sIHIsIG8pKSlcbiAgICAgICAgICByZXR1cm4gcC5wdXNoKGIpO1xuICAgICAgfSkpIHtcbiAgICAgICAgZCA9ICExO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCEoZyA9PT0gaCB8fCBpKGcsIGgsIG4sIHIsIG8pKSkge1xuICAgICAgZCA9ICExO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiBvLmRlbGV0ZShlKSwgby5kZWxldGUodCksIGQ7XG59XG52YXIgeWIgPSBOTSwgRk0gPSBkbiwgTE0gPSBGTS5VaW50OEFycmF5LCBCTSA9IExNO1xuZnVuY3Rpb24gek0oZSkge1xuICB2YXIgdCA9IC0xLCBuID0gQXJyYXkoZS5zaXplKTtcbiAgcmV0dXJuIGUuZm9yRWFjaChmdW5jdGlvbihyLCBpKSB7XG4gICAgblsrK3RdID0gW2ksIHJdO1xuICB9KSwgbjtcbn1cbnZhciBWTSA9IHpNO1xuZnVuY3Rpb24gR00oZSkge1xuICB2YXIgdCA9IC0xLCBuID0gQXJyYXkoZS5zaXplKTtcbiAgcmV0dXJuIGUuZm9yRWFjaChmdW5jdGlvbihyKSB7XG4gICAgblsrK3RdID0gcjtcbiAgfSksIG47XG59XG52YXIgUmYgPSBHTSwganAgPSBWbywga3AgPSBCTSwgV00gPSB5ZiwgVU0gPSB5YiwgSE0gPSBWTSwgcU0gPSBSZiwgS00gPSAxLCBZTSA9IDIsIFhNID0gXCJbb2JqZWN0IEJvb2xlYW5dXCIsIFpNID0gXCJbb2JqZWN0IERhdGVdXCIsIEpNID0gXCJbb2JqZWN0IEVycm9yXVwiLCBRTSA9IFwiW29iamVjdCBNYXBdXCIsIGVSID0gXCJbb2JqZWN0IE51bWJlcl1cIiwgdFIgPSBcIltvYmplY3QgUmVnRXhwXVwiLCBuUiA9IFwiW29iamVjdCBTZXRdXCIsIHJSID0gXCJbb2JqZWN0IFN0cmluZ11cIiwgaVIgPSBcIltvYmplY3QgU3ltYm9sXVwiLCBvUiA9IFwiW29iamVjdCBBcnJheUJ1ZmZlcl1cIiwgYVIgPSBcIltvYmplY3QgRGF0YVZpZXddXCIsIERwID0ganAgPyBqcC5wcm90b3R5cGUgOiB2b2lkIDAsIFR1ID0gRHAgPyBEcC52YWx1ZU9mIDogdm9pZCAwO1xuZnVuY3Rpb24gc1IoZSwgdCwgbiwgciwgaSwgbywgYSkge1xuICBzd2l0Y2ggKG4pIHtcbiAgICBjYXNlIGFSOlxuICAgICAgaWYgKGUuYnl0ZUxlbmd0aCAhPSB0LmJ5dGVMZW5ndGggfHwgZS5ieXRlT2Zmc2V0ICE9IHQuYnl0ZU9mZnNldClcbiAgICAgICAgcmV0dXJuICExO1xuICAgICAgZSA9IGUuYnVmZmVyLCB0ID0gdC5idWZmZXI7XG4gICAgY2FzZSBvUjpcbiAgICAgIHJldHVybiAhKGUuYnl0ZUxlbmd0aCAhPSB0LmJ5dGVMZW5ndGggfHwgIW8obmV3IGtwKGUpLCBuZXcga3AodCkpKTtcbiAgICBjYXNlIFhNOlxuICAgIGNhc2UgWk06XG4gICAgY2FzZSBlUjpcbiAgICAgIHJldHVybiBXTSgrZSwgK3QpO1xuICAgIGNhc2UgSk06XG4gICAgICByZXR1cm4gZS5uYW1lID09IHQubmFtZSAmJiBlLm1lc3NhZ2UgPT0gdC5tZXNzYWdlO1xuICAgIGNhc2UgdFI6XG4gICAgY2FzZSByUjpcbiAgICAgIHJldHVybiBlID09IHQgKyBcIlwiO1xuICAgIGNhc2UgUU06XG4gICAgICB2YXIgcyA9IEhNO1xuICAgIGNhc2UgblI6XG4gICAgICB2YXIgdSA9IHIgJiBLTTtcbiAgICAgIGlmIChzIHx8IChzID0gcU0pLCBlLnNpemUgIT0gdC5zaXplICYmICF1KVxuICAgICAgICByZXR1cm4gITE7XG4gICAgICB2YXIgYyA9IGEuZ2V0KGUpO1xuICAgICAgaWYgKGMpXG4gICAgICAgIHJldHVybiBjID09IHQ7XG4gICAgICByIHw9IFlNLCBhLnNldChlLCB0KTtcbiAgICAgIHZhciBmID0gVU0ocyhlKSwgcyh0KSwgciwgaSwgbywgYSk7XG4gICAgICByZXR1cm4gYS5kZWxldGUoZSksIGY7XG4gICAgY2FzZSBpUjpcbiAgICAgIGlmIChUdSlcbiAgICAgICAgcmV0dXJuIFR1LmNhbGwoZSkgPT0gVHUuY2FsbCh0KTtcbiAgfVxuICByZXR1cm4gITE7XG59XG52YXIgdVIgPSBzUjtcbmZ1bmN0aW9uIGNSKGUsIHQpIHtcbiAgZm9yICh2YXIgbiA9IC0xLCByID0gdC5sZW5ndGgsIGkgPSBlLmxlbmd0aDsgKytuIDwgcjsgKVxuICAgIGVbaSArIG5dID0gdFtuXTtcbiAgcmV0dXJuIGU7XG59XG52YXIgYmIgPSBjUiwgbFIgPSBiYiwgZlIgPSBtdDtcbmZ1bmN0aW9uIGRSKGUsIHQsIG4pIHtcbiAgdmFyIHIgPSB0KGUpO1xuICByZXR1cm4gZlIoZSkgPyByIDogbFIociwgbihlKSk7XG59XG52YXIgcFIgPSBkUjtcbmZ1bmN0aW9uIGhSKGUsIHQpIHtcbiAgZm9yICh2YXIgbiA9IC0xLCByID0gZSA9PSBudWxsID8gMCA6IGUubGVuZ3RoLCBpID0gMCwgbyA9IFtdOyArK24gPCByOyApIHtcbiAgICB2YXIgYSA9IGVbbl07XG4gICAgdChhLCBuLCBlKSAmJiAob1tpKytdID0gYSk7XG4gIH1cbiAgcmV0dXJuIG87XG59XG52YXIgZ1IgPSBoUjtcbmZ1bmN0aW9uIHZSKCkge1xuICByZXR1cm4gW107XG59XG52YXIgbVIgPSB2UiwgeVIgPSBnUiwgYlIgPSBtUiwgd1IgPSBPYmplY3QucHJvdG90eXBlLCB4UiA9IHdSLnByb3BlcnR5SXNFbnVtZXJhYmxlLCBOcCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMsIFNSID0gTnAgPyBmdW5jdGlvbihlKSB7XG4gIHJldHVybiBlID09IG51bGwgPyBbXSA6IChlID0gT2JqZWN0KGUpLCB5UihOcChlKSwgZnVuY3Rpb24odCkge1xuICAgIHJldHVybiB4Ui5jYWxsKGUsIHQpO1xuICB9KSk7XG59IDogYlIsICRSID0gU1I7XG5mdW5jdGlvbiBPUihlLCB0KSB7XG4gIGZvciAodmFyIG4gPSAtMSwgciA9IEFycmF5KGUpOyArK24gPCBlOyApXG4gICAgcltuXSA9IHQobik7XG4gIHJldHVybiByO1xufVxudmFyIF9SID0gT1IsIEFSID0gUG4sIFBSID0gQ24sIENSID0gXCJbb2JqZWN0IEFyZ3VtZW50c11cIjtcbmZ1bmN0aW9uIEVSKGUpIHtcbiAgcmV0dXJuIFBSKGUpICYmIEFSKGUpID09IENSO1xufVxudmFyIFRSID0gRVIsIEZwID0gVFIsIE1SID0gQ24sIHdiID0gT2JqZWN0LnByb3RvdHlwZSwgUlIgPSB3Yi5oYXNPd25Qcm9wZXJ0eSwgSVIgPSB3Yi5wcm9wZXJ0eUlzRW51bWVyYWJsZSwgalIgPSBGcCgvKiBAX19QVVJFX18gKi8gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBhcmd1bWVudHM7XG59KCkpID8gRnAgOiBmdW5jdGlvbihlKSB7XG4gIHJldHVybiBNUihlKSAmJiBSUi5jYWxsKGUsIFwiY2FsbGVlXCIpICYmICFJUi5jYWxsKGUsIFwiY2FsbGVlXCIpO1xufSwgSWYgPSBqUiwgSGEgPSB7IGV4cG9ydHM6IHt9IH07XG5mdW5jdGlvbiBrUigpIHtcbiAgcmV0dXJuICExO1xufVxudmFyIERSID0ga1I7XG5IYS5leHBvcnRzO1xuKGZ1bmN0aW9uKGUsIHQpIHtcbiAgdmFyIG4gPSBkbiwgciA9IERSLCBpID0gdCAmJiAhdC5ub2RlVHlwZSAmJiB0LCBvID0gaSAmJiAhMCAmJiBlICYmICFlLm5vZGVUeXBlICYmIGUsIGEgPSBvICYmIG8uZXhwb3J0cyA9PT0gaSwgcyA9IGEgPyBuLkJ1ZmZlciA6IHZvaWQgMCwgdSA9IHMgPyBzLmlzQnVmZmVyIDogdm9pZCAwLCBjID0gdSB8fCByO1xuICBlLmV4cG9ydHMgPSBjO1xufSkoSGEsIEhhLmV4cG9ydHMpO1xudmFyIHhiID0gSGEuZXhwb3J0cywgTlIgPSA5MDA3MTk5MjU0NzQwOTkxLCBGUiA9IC9eKD86MHxbMS05XVxcZCopJC87XG5mdW5jdGlvbiBMUihlLCB0KSB7XG4gIHZhciBuID0gdHlwZW9mIGU7XG4gIHJldHVybiB0ID0gdCA/PyBOUiwgISF0ICYmIChuID09IFwibnVtYmVyXCIgfHwgbiAhPSBcInN5bWJvbFwiICYmIEZSLnRlc3QoZSkpICYmIGUgPiAtMSAmJiBlICUgMSA9PSAwICYmIGUgPCB0O1xufVxudmFyIGpmID0gTFIsIEJSID0gOTAwNzE5OTI1NDc0MDk5MTtcbmZ1bmN0aW9uIHpSKGUpIHtcbiAgcmV0dXJuIHR5cGVvZiBlID09IFwibnVtYmVyXCIgJiYgZSA+IC0xICYmIGUgJSAxID09IDAgJiYgZSA8PSBCUjtcbn1cbnZhciBrZiA9IHpSLCBWUiA9IFBuLCBHUiA9IGtmLCBXUiA9IENuLCBVUiA9IFwiW29iamVjdCBBcmd1bWVudHNdXCIsIEhSID0gXCJbb2JqZWN0IEFycmF5XVwiLCBxUiA9IFwiW29iamVjdCBCb29sZWFuXVwiLCBLUiA9IFwiW29iamVjdCBEYXRlXVwiLCBZUiA9IFwiW29iamVjdCBFcnJvcl1cIiwgWFIgPSBcIltvYmplY3QgRnVuY3Rpb25dXCIsIFpSID0gXCJbb2JqZWN0IE1hcF1cIiwgSlIgPSBcIltvYmplY3QgTnVtYmVyXVwiLCBRUiA9IFwiW29iamVjdCBPYmplY3RdXCIsIGVJID0gXCJbb2JqZWN0IFJlZ0V4cF1cIiwgdEkgPSBcIltvYmplY3QgU2V0XVwiLCBuSSA9IFwiW29iamVjdCBTdHJpbmddXCIsIHJJID0gXCJbb2JqZWN0IFdlYWtNYXBdXCIsIGlJID0gXCJbb2JqZWN0IEFycmF5QnVmZmVyXVwiLCBvSSA9IFwiW29iamVjdCBEYXRhVmlld11cIiwgYUkgPSBcIltvYmplY3QgRmxvYXQzMkFycmF5XVwiLCBzSSA9IFwiW29iamVjdCBGbG9hdDY0QXJyYXldXCIsIHVJID0gXCJbb2JqZWN0IEludDhBcnJheV1cIiwgY0kgPSBcIltvYmplY3QgSW50MTZBcnJheV1cIiwgbEkgPSBcIltvYmplY3QgSW50MzJBcnJheV1cIiwgZkkgPSBcIltvYmplY3QgVWludDhBcnJheV1cIiwgZEkgPSBcIltvYmplY3QgVWludDhDbGFtcGVkQXJyYXldXCIsIHBJID0gXCJbb2JqZWN0IFVpbnQxNkFycmF5XVwiLCBoSSA9IFwiW29iamVjdCBVaW50MzJBcnJheV1cIiwgRGUgPSB7fTtcbkRlW2FJXSA9IERlW3NJXSA9IERlW3VJXSA9IERlW2NJXSA9IERlW2xJXSA9IERlW2ZJXSA9IERlW2RJXSA9IERlW3BJXSA9IERlW2hJXSA9ICEwO1xuRGVbVVJdID0gRGVbSFJdID0gRGVbaUldID0gRGVbcVJdID0gRGVbb0ldID0gRGVbS1JdID0gRGVbWVJdID0gRGVbWFJdID0gRGVbWlJdID0gRGVbSlJdID0gRGVbUVJdID0gRGVbZUldID0gRGVbdEldID0gRGVbbkldID0gRGVbckldID0gITE7XG5mdW5jdGlvbiBnSShlKSB7XG4gIHJldHVybiBXUihlKSAmJiBHUihlLmxlbmd0aCkgJiYgISFEZVtWUihlKV07XG59XG52YXIgdkkgPSBnSTtcbmZ1bmN0aW9uIG1JKGUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcbiAgICByZXR1cm4gZSh0KTtcbiAgfTtcbn1cbnZhciBTYiA9IG1JLCBxYSA9IHsgZXhwb3J0czoge30gfTtcbnFhLmV4cG9ydHM7XG4oZnVuY3Rpb24oZSwgdCkge1xuICB2YXIgbiA9IFJ5LCByID0gdCAmJiAhdC5ub2RlVHlwZSAmJiB0LCBpID0gciAmJiAhMCAmJiBlICYmICFlLm5vZGVUeXBlICYmIGUsIG8gPSBpICYmIGkuZXhwb3J0cyA9PT0gciwgYSA9IG8gJiYgbi5wcm9jZXNzLCBzID0gZnVuY3Rpb24oKSB7XG4gICAgdHJ5IHtcbiAgICAgIHZhciB1ID0gaSAmJiBpLnJlcXVpcmUgJiYgaS5yZXF1aXJlKFwidXRpbFwiKS50eXBlcztcbiAgICAgIHJldHVybiB1IHx8IGEgJiYgYS5iaW5kaW5nICYmIGEuYmluZGluZyhcInV0aWxcIik7XG4gICAgfSBjYXRjaCB7XG4gICAgfVxuICB9KCk7XG4gIGUuZXhwb3J0cyA9IHM7XG59KShxYSwgcWEuZXhwb3J0cyk7XG52YXIgeUkgPSBxYS5leHBvcnRzLCBiSSA9IHZJLCB3SSA9IFNiLCBMcCA9IHlJLCBCcCA9IExwICYmIExwLmlzVHlwZWRBcnJheSwgeEkgPSBCcCA/IHdJKEJwKSA6IGJJLCAkYiA9IHhJLCBTSSA9IF9SLCAkSSA9IElmLCBPSSA9IG10LCBfSSA9IHhiLCBBSSA9IGpmLCBQSSA9ICRiLCBDSSA9IE9iamVjdC5wcm90b3R5cGUsIEVJID0gQ0kuaGFzT3duUHJvcGVydHk7XG5mdW5jdGlvbiBUSShlLCB0KSB7XG4gIHZhciBuID0gT0koZSksIHIgPSAhbiAmJiAkSShlKSwgaSA9ICFuICYmICFyICYmIF9JKGUpLCBvID0gIW4gJiYgIXIgJiYgIWkgJiYgUEkoZSksIGEgPSBuIHx8IHIgfHwgaSB8fCBvLCBzID0gYSA/IFNJKGUubGVuZ3RoLCBTdHJpbmcpIDogW10sIHUgPSBzLmxlbmd0aDtcbiAgZm9yICh2YXIgYyBpbiBlKVxuICAgICh0IHx8IEVJLmNhbGwoZSwgYykpICYmICEoYSAmJiAvLyBTYWZhcmkgOSBoYXMgZW51bWVyYWJsZSBgYXJndW1lbnRzLmxlbmd0aGAgaW4gc3RyaWN0IG1vZGUuXG4gICAgKGMgPT0gXCJsZW5ndGhcIiB8fCAvLyBOb2RlLmpzIDAuMTAgaGFzIGVudW1lcmFibGUgbm9uLWluZGV4IHByb3BlcnRpZXMgb24gYnVmZmVycy5cbiAgICBpICYmIChjID09IFwib2Zmc2V0XCIgfHwgYyA9PSBcInBhcmVudFwiKSB8fCAvLyBQaGFudG9tSlMgMiBoYXMgZW51bWVyYWJsZSBub24taW5kZXggcHJvcGVydGllcyBvbiB0eXBlZCBhcnJheXMuXG4gICAgbyAmJiAoYyA9PSBcImJ1ZmZlclwiIHx8IGMgPT0gXCJieXRlTGVuZ3RoXCIgfHwgYyA9PSBcImJ5dGVPZmZzZXRcIikgfHwgLy8gU2tpcCBpbmRleCBwcm9wZXJ0aWVzLlxuICAgIEFJKGMsIHUpKSkgJiYgcy5wdXNoKGMpO1xuICByZXR1cm4gcztcbn1cbnZhciBNSSA9IFRJLCBSSSA9IE9iamVjdC5wcm90b3R5cGU7XG5mdW5jdGlvbiBJSShlKSB7XG4gIHZhciB0ID0gZSAmJiBlLmNvbnN0cnVjdG9yLCBuID0gdHlwZW9mIHQgPT0gXCJmdW5jdGlvblwiICYmIHQucHJvdG90eXBlIHx8IFJJO1xuICByZXR1cm4gZSA9PT0gbjtcbn1cbnZhciBqSSA9IElJO1xuZnVuY3Rpb24ga0koZSwgdCkge1xuICByZXR1cm4gZnVuY3Rpb24obikge1xuICAgIHJldHVybiBlKHQobikpO1xuICB9O1xufVxudmFyIE9iID0ga0ksIERJID0gT2IsIE5JID0gREkoT2JqZWN0LmtleXMsIE9iamVjdCksIEZJID0gTkksIExJID0gakksIEJJID0gRkksIHpJID0gT2JqZWN0LnByb3RvdHlwZSwgVkkgPSB6SS5oYXNPd25Qcm9wZXJ0eTtcbmZ1bmN0aW9uIEdJKGUpIHtcbiAgaWYgKCFMSShlKSlcbiAgICByZXR1cm4gQkkoZSk7XG4gIHZhciB0ID0gW107XG4gIGZvciAodmFyIG4gaW4gT2JqZWN0KGUpKVxuICAgIFZJLmNhbGwoZSwgbikgJiYgbiAhPSBcImNvbnN0cnVjdG9yXCIgJiYgdC5wdXNoKG4pO1xuICByZXR1cm4gdDtcbn1cbnZhciBXSSA9IEdJLCBVSSA9IG1mLCBISSA9IGtmO1xuZnVuY3Rpb24gcUkoZSkge1xuICByZXR1cm4gZSAhPSBudWxsICYmIEhJKGUubGVuZ3RoKSAmJiAhVUkoZSk7XG59XG52YXIgSG8gPSBxSSwgS0kgPSBNSSwgWUkgPSBXSSwgWEkgPSBIbztcbmZ1bmN0aW9uIFpJKGUpIHtcbiAgcmV0dXJuIFhJKGUpID8gS0koZSkgOiBZSShlKTtcbn1cbnZhciBXcyA9IFpJLCBKSSA9IHBSLCBRSSA9ICRSLCBlMiA9IFdzO1xuZnVuY3Rpb24gdDIoZSkge1xuICByZXR1cm4gSkkoZSwgZTIsIFFJKTtcbn1cbnZhciBuMiA9IHQyLCB6cCA9IG4yLCByMiA9IDEsIGkyID0gT2JqZWN0LnByb3RvdHlwZSwgbzIgPSBpMi5oYXNPd25Qcm9wZXJ0eTtcbmZ1bmN0aW9uIGEyKGUsIHQsIG4sIHIsIGksIG8pIHtcbiAgdmFyIGEgPSBuICYgcjIsIHMgPSB6cChlKSwgdSA9IHMubGVuZ3RoLCBjID0genAodCksIGYgPSBjLmxlbmd0aDtcbiAgaWYgKHUgIT0gZiAmJiAhYSlcbiAgICByZXR1cm4gITE7XG4gIGZvciAodmFyIGwgPSB1OyBsLS07ICkge1xuICAgIHZhciBkID0gc1tsXTtcbiAgICBpZiAoIShhID8gZCBpbiB0IDogbzIuY2FsbCh0LCBkKSkpXG4gICAgICByZXR1cm4gITE7XG4gIH1cbiAgdmFyIHAgPSBvLmdldChlKSwgZyA9IG8uZ2V0KHQpO1xuICBpZiAocCAmJiBnKVxuICAgIHJldHVybiBwID09IHQgJiYgZyA9PSBlO1xuICB2YXIgaCA9ICEwO1xuICBvLnNldChlLCB0KSwgby5zZXQodCwgZSk7XG4gIGZvciAodmFyIHYgPSBhOyArK2wgPCB1OyApIHtcbiAgICBkID0gc1tsXTtcbiAgICB2YXIgdyA9IGVbZF0sIGIgPSB0W2RdO1xuICAgIGlmIChyKVxuICAgICAgdmFyIHggPSBhID8gcihiLCB3LCBkLCB0LCBlLCBvKSA6IHIodywgYiwgZCwgZSwgdCwgbyk7XG4gICAgaWYgKCEoeCA9PT0gdm9pZCAwID8gdyA9PT0gYiB8fCBpKHcsIGIsIG4sIHIsIG8pIDogeCkpIHtcbiAgICAgIGggPSAhMTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICB2IHx8ICh2ID0gZCA9PSBcImNvbnN0cnVjdG9yXCIpO1xuICB9XG4gIGlmIChoICYmICF2KSB7XG4gICAgdmFyIG0gPSBlLmNvbnN0cnVjdG9yLCB5ID0gdC5jb25zdHJ1Y3RvcjtcbiAgICBtICE9IHkgJiYgXCJjb25zdHJ1Y3RvclwiIGluIGUgJiYgXCJjb25zdHJ1Y3RvclwiIGluIHQgJiYgISh0eXBlb2YgbSA9PSBcImZ1bmN0aW9uXCIgJiYgbSBpbnN0YW5jZW9mIG0gJiYgdHlwZW9mIHkgPT0gXCJmdW5jdGlvblwiICYmIHkgaW5zdGFuY2VvZiB5KSAmJiAoaCA9ICExKTtcbiAgfVxuICByZXR1cm4gby5kZWxldGUoZSksIG8uZGVsZXRlKHQpLCBoO1xufVxudmFyIHMyID0gYTIsIHUyID0gdnIsIGMyID0gZG4sIGwyID0gdTIoYzIsIFwiRGF0YVZpZXdcIiksIGYyID0gbDIsIGQyID0gdnIsIHAyID0gZG4sIGgyID0gZDIocDIsIFwiUHJvbWlzZVwiKSwgZzIgPSBoMiwgdjIgPSB2ciwgbTIgPSBkbiwgeTIgPSB2MihtMiwgXCJTZXRcIiksIF9iID0geTIsIGIyID0gdnIsIHcyID0gZG4sIHgyID0gYjIodzIsIFwiV2Vha01hcFwiKSwgUzIgPSB4MiwgVmMgPSBmMiwgR2MgPSBiZiwgV2MgPSBnMiwgVWMgPSBfYiwgSGMgPSBTMiwgQWIgPSBQbiwgaGkgPSBqeSwgVnAgPSBcIltvYmplY3QgTWFwXVwiLCAkMiA9IFwiW29iamVjdCBPYmplY3RdXCIsIEdwID0gXCJbb2JqZWN0IFByb21pc2VdXCIsIFdwID0gXCJbb2JqZWN0IFNldF1cIiwgVXAgPSBcIltvYmplY3QgV2Vha01hcF1cIiwgSHAgPSBcIltvYmplY3QgRGF0YVZpZXddXCIsIE8yID0gaGkoVmMpLCBfMiA9IGhpKEdjKSwgQTIgPSBoaShXYyksIFAyID0gaGkoVWMpLCBDMiA9IGhpKEhjKSwgZXIgPSBBYjtcbihWYyAmJiBlcihuZXcgVmMobmV3IEFycmF5QnVmZmVyKDEpKSkgIT0gSHAgfHwgR2MgJiYgZXIobmV3IEdjKCkpICE9IFZwIHx8IFdjICYmIGVyKFdjLnJlc29sdmUoKSkgIT0gR3AgfHwgVWMgJiYgZXIobmV3IFVjKCkpICE9IFdwIHx8IEhjICYmIGVyKG5ldyBIYygpKSAhPSBVcCkgJiYgKGVyID0gZnVuY3Rpb24oZSkge1xuICB2YXIgdCA9IEFiKGUpLCBuID0gdCA9PSAkMiA/IGUuY29uc3RydWN0b3IgOiB2b2lkIDAsIHIgPSBuID8gaGkobikgOiBcIlwiO1xuICBpZiAocilcbiAgICBzd2l0Y2ggKHIpIHtcbiAgICAgIGNhc2UgTzI6XG4gICAgICAgIHJldHVybiBIcDtcbiAgICAgIGNhc2UgXzI6XG4gICAgICAgIHJldHVybiBWcDtcbiAgICAgIGNhc2UgQTI6XG4gICAgICAgIHJldHVybiBHcDtcbiAgICAgIGNhc2UgUDI6XG4gICAgICAgIHJldHVybiBXcDtcbiAgICAgIGNhc2UgQzI6XG4gICAgICAgIHJldHVybiBVcDtcbiAgICB9XG4gIHJldHVybiB0O1xufSk7XG52YXIgRTIgPSBlciwgTXUgPSBoYiwgVDIgPSB5YiwgTTIgPSB1UiwgUjIgPSBzMiwgcXAgPSBFMiwgS3AgPSBtdCwgWXAgPSB4YiwgSTIgPSAkYiwgajIgPSAxLCBYcCA9IFwiW29iamVjdCBBcmd1bWVudHNdXCIsIFpwID0gXCJbb2JqZWN0IEFycmF5XVwiLCBmYSA9IFwiW29iamVjdCBPYmplY3RdXCIsIGsyID0gT2JqZWN0LnByb3RvdHlwZSwgSnAgPSBrMi5oYXNPd25Qcm9wZXJ0eTtcbmZ1bmN0aW9uIEQyKGUsIHQsIG4sIHIsIGksIG8pIHtcbiAgdmFyIGEgPSBLcChlKSwgcyA9IEtwKHQpLCB1ID0gYSA/IFpwIDogcXAoZSksIGMgPSBzID8gWnAgOiBxcCh0KTtcbiAgdSA9IHUgPT0gWHAgPyBmYSA6IHUsIGMgPSBjID09IFhwID8gZmEgOiBjO1xuICB2YXIgZiA9IHUgPT0gZmEsIGwgPSBjID09IGZhLCBkID0gdSA9PSBjO1xuICBpZiAoZCAmJiBZcChlKSkge1xuICAgIGlmICghWXAodCkpXG4gICAgICByZXR1cm4gITE7XG4gICAgYSA9ICEwLCBmID0gITE7XG4gIH1cbiAgaWYgKGQgJiYgIWYpXG4gICAgcmV0dXJuIG8gfHwgKG8gPSBuZXcgTXUoKSksIGEgfHwgSTIoZSkgPyBUMihlLCB0LCBuLCByLCBpLCBvKSA6IE0yKGUsIHQsIHUsIG4sIHIsIGksIG8pO1xuICBpZiAoIShuICYgajIpKSB7XG4gICAgdmFyIHAgPSBmICYmIEpwLmNhbGwoZSwgXCJfX3dyYXBwZWRfX1wiKSwgZyA9IGwgJiYgSnAuY2FsbCh0LCBcIl9fd3JhcHBlZF9fXCIpO1xuICAgIGlmIChwIHx8IGcpIHtcbiAgICAgIHZhciBoID0gcCA/IGUudmFsdWUoKSA6IGUsIHYgPSBnID8gdC52YWx1ZSgpIDogdDtcbiAgICAgIHJldHVybiBvIHx8IChvID0gbmV3IE11KCkpLCBpKGgsIHYsIG4sIHIsIG8pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZCA/IChvIHx8IChvID0gbmV3IE11KCkpLCBSMihlLCB0LCBuLCByLCBpLCBvKSkgOiAhMTtcbn1cbnZhciBOMiA9IEQyLCBGMiA9IE4yLCBRcCA9IENuO1xuZnVuY3Rpb24gUGIoZSwgdCwgbiwgciwgaSkge1xuICByZXR1cm4gZSA9PT0gdCA/ICEwIDogZSA9PSBudWxsIHx8IHQgPT0gbnVsbCB8fCAhUXAoZSkgJiYgIVFwKHQpID8gZSAhPT0gZSAmJiB0ICE9PSB0IDogRjIoZSwgdCwgbiwgciwgUGIsIGkpO1xufVxudmFyIERmID0gUGIsIEwyID0gaGIsIEIyID0gRGYsIHoyID0gMSwgVjIgPSAyO1xuZnVuY3Rpb24gRzIoZSwgdCwgbiwgcikge1xuICB2YXIgaSA9IG4ubGVuZ3RoLCBvID0gaSwgYSA9ICFyO1xuICBpZiAoZSA9PSBudWxsKVxuICAgIHJldHVybiAhbztcbiAgZm9yIChlID0gT2JqZWN0KGUpOyBpLS07ICkge1xuICAgIHZhciBzID0gbltpXTtcbiAgICBpZiAoYSAmJiBzWzJdID8gc1sxXSAhPT0gZVtzWzBdXSA6ICEoc1swXSBpbiBlKSlcbiAgICAgIHJldHVybiAhMTtcbiAgfVxuICBmb3IgKDsgKytpIDwgbzsgKSB7XG4gICAgcyA9IG5baV07XG4gICAgdmFyIHUgPSBzWzBdLCBjID0gZVt1XSwgZiA9IHNbMV07XG4gICAgaWYgKGEgJiYgc1syXSkge1xuICAgICAgaWYgKGMgPT09IHZvaWQgMCAmJiAhKHUgaW4gZSkpXG4gICAgICAgIHJldHVybiAhMTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGwgPSBuZXcgTDIoKTtcbiAgICAgIGlmIChyKVxuICAgICAgICB2YXIgZCA9IHIoYywgZiwgdSwgZSwgdCwgbCk7XG4gICAgICBpZiAoIShkID09PSB2b2lkIDAgPyBCMihmLCBjLCB6MiB8IFYyLCByLCBsKSA6IGQpKVxuICAgICAgICByZXR1cm4gITE7XG4gICAgfVxuICB9XG4gIHJldHVybiAhMDtcbn1cbnZhciBXMiA9IEcyLCBVMiA9IFVuO1xuZnVuY3Rpb24gSDIoZSkge1xuICByZXR1cm4gZSA9PT0gZSAmJiAhVTIoZSk7XG59XG52YXIgQ2IgPSBIMiwgcTIgPSBDYiwgSzIgPSBXcztcbmZ1bmN0aW9uIFkyKGUpIHtcbiAgZm9yICh2YXIgdCA9IEsyKGUpLCBuID0gdC5sZW5ndGg7IG4tLTsgKSB7XG4gICAgdmFyIHIgPSB0W25dLCBpID0gZVtyXTtcbiAgICB0W25dID0gW3IsIGksIHEyKGkpXTtcbiAgfVxuICByZXR1cm4gdDtcbn1cbnZhciBYMiA9IFkyO1xuZnVuY3Rpb24gWjIoZSwgdCkge1xuICByZXR1cm4gZnVuY3Rpb24obikge1xuICAgIHJldHVybiBuID09IG51bGwgPyAhMSA6IG5bZV0gPT09IHQgJiYgKHQgIT09IHZvaWQgMCB8fCBlIGluIE9iamVjdChuKSk7XG4gIH07XG59XG52YXIgRWIgPSBaMiwgSjIgPSBXMiwgUTIgPSBYMiwgZWogPSBFYjtcbmZ1bmN0aW9uIHRqKGUpIHtcbiAgdmFyIHQgPSBRMihlKTtcbiAgcmV0dXJuIHQubGVuZ3RoID09IDEgJiYgdFswXVsyXSA/IGVqKHRbMF1bMF0sIHRbMF1bMV0pIDogZnVuY3Rpb24obikge1xuICAgIHJldHVybiBuID09PSBlIHx8IEoyKG4sIGUsIHQpO1xuICB9O1xufVxudmFyIG5qID0gdGo7XG5mdW5jdGlvbiByaihlLCB0KSB7XG4gIHJldHVybiBlICE9IG51bGwgJiYgdCBpbiBPYmplY3QoZSk7XG59XG52YXIgaWogPSByaiwgb2ogPSBMeSwgYWogPSBJZiwgc2ogPSBtdCwgdWogPSBqZiwgY2ogPSBrZiwgbGogPSBMcztcbmZ1bmN0aW9uIGZqKGUsIHQsIG4pIHtcbiAgdCA9IG9qKHQsIGUpO1xuICBmb3IgKHZhciByID0gLTEsIGkgPSB0Lmxlbmd0aCwgbyA9ICExOyArK3IgPCBpOyApIHtcbiAgICB2YXIgYSA9IGxqKHRbcl0pO1xuICAgIGlmICghKG8gPSBlICE9IG51bGwgJiYgbihlLCBhKSkpXG4gICAgICBicmVhaztcbiAgICBlID0gZVthXTtcbiAgfVxuICByZXR1cm4gbyB8fCArK3IgIT0gaSA/IG8gOiAoaSA9IGUgPT0gbnVsbCA/IDAgOiBlLmxlbmd0aCwgISFpICYmIGNqKGkpICYmIHVqKGEsIGkpICYmIChzaihlKSB8fCBhaihlKSkpO1xufVxudmFyIGRqID0gZmosIHBqID0gaWosIGhqID0gZGo7XG5mdW5jdGlvbiBnaihlLCB0KSB7XG4gIHJldHVybiBlICE9IG51bGwgJiYgaGooZSwgdCwgcGopO1xufVxudmFyIHZqID0gZ2osIG1qID0gRGYsIHlqID0gQnksIGJqID0gdmosIHdqID0gdmYsIHhqID0gQ2IsIFNqID0gRWIsICRqID0gTHMsIE9qID0gMSwgX2ogPSAyO1xuZnVuY3Rpb24gQWooZSwgdCkge1xuICByZXR1cm4gd2ooZSkgJiYgeGoodCkgPyBTaigkaihlKSwgdCkgOiBmdW5jdGlvbihuKSB7XG4gICAgdmFyIHIgPSB5aihuLCBlKTtcbiAgICByZXR1cm4gciA9PT0gdm9pZCAwICYmIHIgPT09IHQgPyBiaihuLCBlKSA6IG1qKHQsIHIsIE9qIHwgX2opO1xuICB9O1xufVxudmFyIFBqID0gQWo7XG5mdW5jdGlvbiBDaihlKSB7XG4gIHJldHVybiBlO1xufVxudmFyIGdpID0gQ2o7XG5mdW5jdGlvbiBFaihlKSB7XG4gIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgcmV0dXJuIHQgPT0gbnVsbCA/IHZvaWQgMCA6IHRbZV07XG4gIH07XG59XG52YXIgVGogPSBFaiwgTWogPSAkZjtcbmZ1bmN0aW9uIFJqKGUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcbiAgICByZXR1cm4gTWoodCwgZSk7XG4gIH07XG59XG52YXIgSWogPSBSaiwgamogPSBUaiwga2ogPSBJaiwgRGogPSB2ZiwgTmogPSBMcztcbmZ1bmN0aW9uIEZqKGUpIHtcbiAgcmV0dXJuIERqKGUpID8gamooTmooZSkpIDoga2ooZSk7XG59XG52YXIgTGogPSBGaiwgQmogPSBuaiwgemogPSBQaiwgVmogPSBnaSwgR2ogPSBtdCwgV2ogPSBMajtcbmZ1bmN0aW9uIFVqKGUpIHtcbiAgcmV0dXJuIHR5cGVvZiBlID09IFwiZnVuY3Rpb25cIiA/IGUgOiBlID09IG51bGwgPyBWaiA6IHR5cGVvZiBlID09IFwib2JqZWN0XCIgPyBHaihlKSA/IHpqKGVbMF0sIGVbMV0pIDogQmooZSkgOiBXaihlKTtcbn1cbnZhciBIbiA9IFVqO1xuZnVuY3Rpb24gSGooZSwgdCwgbiwgcikge1xuICBmb3IgKHZhciBpID0gZS5sZW5ndGgsIG8gPSBuICsgKHIgPyAxIDogLTEpOyByID8gby0tIDogKytvIDwgaTsgKVxuICAgIGlmICh0KGVbb10sIG8sIGUpKVxuICAgICAgcmV0dXJuIG87XG4gIHJldHVybiAtMTtcbn1cbnZhciBUYiA9IEhqO1xuZnVuY3Rpb24gcWooZSkge1xuICByZXR1cm4gZSAhPT0gZTtcbn1cbnZhciBLaiA9IHFqO1xuZnVuY3Rpb24gWWooZSwgdCwgbikge1xuICBmb3IgKHZhciByID0gbiAtIDEsIGkgPSBlLmxlbmd0aDsgKytyIDwgaTsgKVxuICAgIGlmIChlW3JdID09PSB0KVxuICAgICAgcmV0dXJuIHI7XG4gIHJldHVybiAtMTtcbn1cbnZhciBYaiA9IFlqLCBaaiA9IFRiLCBKaiA9IEtqLCBRaiA9IFhqO1xuZnVuY3Rpb24gZWsoZSwgdCwgbikge1xuICByZXR1cm4gdCA9PT0gdCA/IFFqKGUsIHQsIG4pIDogWmooZSwgSmosIG4pO1xufVxudmFyIHRrID0gZWssIG5rID0gdGs7XG5mdW5jdGlvbiByayhlLCB0KSB7XG4gIHZhciBuID0gZSA9PSBudWxsID8gMCA6IGUubGVuZ3RoO1xuICByZXR1cm4gISFuICYmIG5rKGUsIHQsIDApID4gLTE7XG59XG52YXIgaWsgPSByaztcbmZ1bmN0aW9uIG9rKGUsIHQsIG4pIHtcbiAgZm9yICh2YXIgciA9IC0xLCBpID0gZSA9PSBudWxsID8gMCA6IGUubGVuZ3RoOyArK3IgPCBpOyApXG4gICAgaWYgKG4odCwgZVtyXSkpXG4gICAgICByZXR1cm4gITA7XG4gIHJldHVybiAhMTtcbn1cbnZhciBhayA9IG9rO1xuZnVuY3Rpb24gc2soKSB7XG59XG52YXIgdWsgPSBzaywgUnUgPSBfYiwgY2sgPSB1aywgbGsgPSBSZiwgZmsgPSAxIC8gMCwgZGsgPSBSdSAmJiAxIC8gbGsobmV3IFJ1KFssIC0wXSkpWzFdID09IGZrID8gZnVuY3Rpb24oZSkge1xuICByZXR1cm4gbmV3IFJ1KGUpO1xufSA6IGNrLCBwayA9IGRrLCBoayA9IGdiLCBnayA9IGlrLCB2ayA9IGFrLCBtayA9IG1iLCB5ayA9IHBrLCBiayA9IFJmLCB3ayA9IDIwMDtcbmZ1bmN0aW9uIHhrKGUsIHQsIG4pIHtcbiAgdmFyIHIgPSAtMSwgaSA9IGdrLCBvID0gZS5sZW5ndGgsIGEgPSAhMCwgcyA9IFtdLCB1ID0gcztcbiAgaWYgKG4pXG4gICAgYSA9ICExLCBpID0gdms7XG4gIGVsc2UgaWYgKG8gPj0gd2spIHtcbiAgICB2YXIgYyA9IHQgPyBudWxsIDogeWsoZSk7XG4gICAgaWYgKGMpXG4gICAgICByZXR1cm4gYmsoYyk7XG4gICAgYSA9ICExLCBpID0gbWssIHUgPSBuZXcgaGsoKTtcbiAgfSBlbHNlXG4gICAgdSA9IHQgPyBbXSA6IHM7XG4gIGU6XG4gICAgZm9yICg7ICsrciA8IG87ICkge1xuICAgICAgdmFyIGYgPSBlW3JdLCBsID0gdCA/IHQoZikgOiBmO1xuICAgICAgaWYgKGYgPSBuIHx8IGYgIT09IDAgPyBmIDogMCwgYSAmJiBsID09PSBsKSB7XG4gICAgICAgIGZvciAodmFyIGQgPSB1Lmxlbmd0aDsgZC0tOyApXG4gICAgICAgICAgaWYgKHVbZF0gPT09IGwpXG4gICAgICAgICAgICBjb250aW51ZSBlO1xuICAgICAgICB0ICYmIHUucHVzaChsKSwgcy5wdXNoKGYpO1xuICAgICAgfSBlbHNlXG4gICAgICAgIGkodSwgbCwgbikgfHwgKHUgIT09IHMgJiYgdS5wdXNoKGwpLCBzLnB1c2goZikpO1xuICAgIH1cbiAgcmV0dXJuIHM7XG59XG52YXIgU2sgPSB4aywgJGsgPSBIbiwgT2sgPSBTaztcbmZ1bmN0aW9uIF9rKGUsIHQpIHtcbiAgcmV0dXJuIGUgJiYgZS5sZW5ndGggPyBPayhlLCAkayh0KSkgOiBbXTtcbn1cbnZhciBBayA9IF9rO1xuY29uc3QgZWggPSAvKiBAX19QVVJFX18gKi8gamUoQWspO1xuZnVuY3Rpb24gTWIoZSwgdCwgbikge1xuICByZXR1cm4gdCA9PT0gITAgPyBlaChlLCBuKSA6IHBlKHQpID8gZWgoZSwgdCkgOiBlO1xufVxuZnVuY3Rpb24genIoZSkge1xuICBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7XG4gIHJldHVybiB6ciA9IHR5cGVvZiBTeW1ib2wgPT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uKHQpIHtcbiAgICByZXR1cm4gdHlwZW9mIHQ7XG4gIH0gOiBmdW5jdGlvbih0KSB7XG4gICAgcmV0dXJuIHQgJiYgdHlwZW9mIFN5bWJvbCA9PSBcImZ1bmN0aW9uXCIgJiYgdC5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIHQgIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIHQ7XG4gIH0sIHpyKGUpO1xufVxudmFyIFBrID0gW1wicmVmXCJdO1xuZnVuY3Rpb24gdGgoZSwgdCkge1xuICB2YXIgbiA9IE9iamVjdC5rZXlzKGUpO1xuICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykge1xuICAgIHZhciByID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhlKTtcbiAgICB0ICYmIChyID0gci5maWx0ZXIoZnVuY3Rpb24oaSkge1xuICAgICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSwgaSkuZW51bWVyYWJsZTtcbiAgICB9KSksIG4ucHVzaC5hcHBseShuLCByKTtcbiAgfVxuICByZXR1cm4gbjtcbn1cbmZ1bmN0aW9uIEpuKGUpIHtcbiAgZm9yICh2YXIgdCA9IDE7IHQgPCBhcmd1bWVudHMubGVuZ3RoOyB0KyspIHtcbiAgICB2YXIgbiA9IGFyZ3VtZW50c1t0XSAhPSBudWxsID8gYXJndW1lbnRzW3RdIDoge307XG4gICAgdCAlIDIgPyB0aChPYmplY3QobiksICEwKS5mb3JFYWNoKGZ1bmN0aW9uKHIpIHtcbiAgICAgIFVzKGUsIHIsIG5bcl0pO1xuICAgIH0pIDogT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhlLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhuKSkgOiB0aChPYmplY3QobikpLmZvckVhY2goZnVuY3Rpb24ocikge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIHIsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobiwgcikpO1xuICAgIH0pO1xuICB9XG4gIHJldHVybiBlO1xufVxuZnVuY3Rpb24gQ2soZSwgdCkge1xuICBpZiAoIShlIGluc3RhbmNlb2YgdCkpXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcbn1cbmZ1bmN0aW9uIG5oKGUsIHQpIHtcbiAgZm9yICh2YXIgbiA9IDA7IG4gPCB0Lmxlbmd0aDsgbisrKSB7XG4gICAgdmFyIHIgPSB0W25dO1xuICAgIHIuZW51bWVyYWJsZSA9IHIuZW51bWVyYWJsZSB8fCAhMSwgci5jb25maWd1cmFibGUgPSAhMCwgXCJ2YWx1ZVwiIGluIHIgJiYgKHIud3JpdGFibGUgPSAhMCksIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCBqYihyLmtleSksIHIpO1xuICB9XG59XG5mdW5jdGlvbiBFayhlLCB0LCBuKSB7XG4gIHJldHVybiB0ICYmIG5oKGUucHJvdG90eXBlLCB0KSwgbiAmJiBuaChlLCBuKSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIFwicHJvdG90eXBlXCIsIHsgd3JpdGFibGU6ICExIH0pLCBlO1xufVxuZnVuY3Rpb24gVGsoZSwgdCwgbikge1xuICByZXR1cm4gdCA9IEthKHQpLCBNayhlLCBSYigpID8gUmVmbGVjdC5jb25zdHJ1Y3QodCwgbiB8fCBbXSwgS2EoZSkuY29uc3RydWN0b3IpIDogdC5hcHBseShlLCBuKSk7XG59XG5mdW5jdGlvbiBNayhlLCB0KSB7XG4gIGlmICh0ICYmICh6cih0KSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgdCA9PSBcImZ1bmN0aW9uXCIpKVxuICAgIHJldHVybiB0O1xuICBpZiAodCAhPT0gdm9pZCAwKVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJEZXJpdmVkIGNvbnN0cnVjdG9ycyBtYXkgb25seSByZXR1cm4gb2JqZWN0IG9yIHVuZGVmaW5lZFwiKTtcbiAgcmV0dXJuIEliKGUpO1xufVxuZnVuY3Rpb24gUmIoKSB7XG4gIHRyeSB7XG4gICAgdmFyIGUgPSAhQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbigpIHtcbiAgICB9KSk7XG4gIH0gY2F0Y2gge1xuICB9XG4gIHJldHVybiAoUmIgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gISFlO1xuICB9KSgpO1xufVxuZnVuY3Rpb24gS2EoZSkge1xuICByZXR1cm4gS2EgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YuYmluZCgpIDogZnVuY3Rpb24obikge1xuICAgIHJldHVybiBuLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobik7XG4gIH0sIEthKGUpO1xufVxuZnVuY3Rpb24gSWIoZSkge1xuICBpZiAoZSA9PT0gdm9pZCAwKVxuICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTtcbiAgcmV0dXJuIGU7XG59XG5mdW5jdGlvbiBSayhlLCB0KSB7XG4gIGlmICh0eXBlb2YgdCAhPSBcImZ1bmN0aW9uXCIgJiYgdCAhPT0gbnVsbClcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7XG4gIGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSh0ICYmIHQucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBlLCB3cml0YWJsZTogITAsIGNvbmZpZ3VyYWJsZTogITAgfSB9KSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIFwicHJvdG90eXBlXCIsIHsgd3JpdGFibGU6ICExIH0pLCB0ICYmIHFjKGUsIHQpO1xufVxuZnVuY3Rpb24gcWMoZSwgdCkge1xuICByZXR1cm4gcWMgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2YuYmluZCgpIDogZnVuY3Rpb24ociwgaSkge1xuICAgIHJldHVybiByLl9fcHJvdG9fXyA9IGksIHI7XG4gIH0sIHFjKGUsIHQpO1xufVxuZnVuY3Rpb24gVXMoZSwgdCwgbikge1xuICByZXR1cm4gdCA9IGpiKHQpLCB0IGluIGUgPyBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgdCwgeyB2YWx1ZTogbiwgZW51bWVyYWJsZTogITAsIGNvbmZpZ3VyYWJsZTogITAsIHdyaXRhYmxlOiAhMCB9KSA6IGVbdF0gPSBuLCBlO1xufVxuZnVuY3Rpb24gamIoZSkge1xuICB2YXIgdCA9IElrKGUsIFwic3RyaW5nXCIpO1xuICByZXR1cm4genIodCkgPT0gXCJzeW1ib2xcIiA/IHQgOiBTdHJpbmcodCk7XG59XG5mdW5jdGlvbiBJayhlLCB0KSB7XG4gIGlmICh6cihlKSAhPSBcIm9iamVjdFwiIHx8ICFlKVxuICAgIHJldHVybiBlO1xuICB2YXIgbiA9IGVbU3ltYm9sLnRvUHJpbWl0aXZlXTtcbiAgaWYgKG4gIT09IHZvaWQgMCkge1xuICAgIHZhciByID0gbi5jYWxsKGUsIHQgfHwgXCJkZWZhdWx0XCIpO1xuICAgIGlmICh6cihyKSAhPSBcIm9iamVjdFwiKVxuICAgICAgcmV0dXJuIHI7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkBAdG9QcmltaXRpdmUgbXVzdCByZXR1cm4gYSBwcmltaXRpdmUgdmFsdWUuXCIpO1xuICB9XG4gIHJldHVybiAodCA9PT0gXCJzdHJpbmdcIiA/IFN0cmluZyA6IE51bWJlcikoZSk7XG59XG5mdW5jdGlvbiBqayhlLCB0KSB7XG4gIGlmIChlID09IG51bGwpXG4gICAgcmV0dXJuIHt9O1xuICB2YXIgbiA9IGtrKGUsIHQpLCByLCBpO1xuICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykge1xuICAgIHZhciBvID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhlKTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgby5sZW5ndGg7IGkrKylcbiAgICAgIHIgPSBvW2ldLCAhKHQuaW5kZXhPZihyKSA+PSAwKSAmJiBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwoZSwgcikgJiYgKG5bcl0gPSBlW3JdKTtcbiAgfVxuICByZXR1cm4gbjtcbn1cbmZ1bmN0aW9uIGtrKGUsIHQpIHtcbiAgaWYgKGUgPT0gbnVsbClcbiAgICByZXR1cm4ge307XG4gIHZhciBuID0ge30sIHIgPSBPYmplY3Qua2V5cyhlKSwgaSwgbztcbiAgZm9yIChvID0gMDsgbyA8IHIubGVuZ3RoOyBvKyspXG4gICAgaSA9IHJbb10sICEodC5pbmRleE9mKGkpID49IDApICYmIChuW2ldID0gZVtpXSk7XG4gIHJldHVybiBuO1xufVxuZnVuY3Rpb24gRGsoZSkge1xuICByZXR1cm4gZS52YWx1ZTtcbn1cbmZ1bmN0aW9uIE5rKGUsIHQpIHtcbiAgaWYgKC8qIEBfX1BVUkVfXyAqLyBQLmlzVmFsaWRFbGVtZW50KGUpKVxuICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8gUC5jbG9uZUVsZW1lbnQoZSwgdCk7XG4gIGlmICh0eXBlb2YgZSA9PSBcImZ1bmN0aW9uXCIpXG4gICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBQLmNyZWF0ZUVsZW1lbnQoZSwgdCk7XG4gIHQucmVmO1xuICB2YXIgbiA9IGprKHQsIFBrKTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBQLmNyZWF0ZUVsZW1lbnQoTWYsIG4pO1xufVxudmFyIHJoID0gMSwgVnIgPSAvKiBAX19QVVJFX18gKi8gZnVuY3Rpb24oZSkge1xuICBSayh0LCBlKTtcbiAgZnVuY3Rpb24gdCgpIHtcbiAgICB2YXIgbjtcbiAgICBDayh0aGlzLCB0KTtcbiAgICBmb3IgKHZhciByID0gYXJndW1lbnRzLmxlbmd0aCwgaSA9IG5ldyBBcnJheShyKSwgbyA9IDA7IG8gPCByOyBvKyspXG4gICAgICBpW29dID0gYXJndW1lbnRzW29dO1xuICAgIHJldHVybiBuID0gVGsodGhpcywgdCwgW10uY29uY2F0KGkpKSwgVXMoSWIobiksIFwibGFzdEJvdW5kaW5nQm94XCIsIHtcbiAgICAgIHdpZHRoOiAtMSxcbiAgICAgIGhlaWdodDogLTFcbiAgICB9KSwgbjtcbiAgfVxuICByZXR1cm4gRWsodCwgW3tcbiAgICBrZXk6IFwiY29tcG9uZW50RGlkTW91bnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLnVwZGF0ZUJCb3goKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY29tcG9uZW50RGlkVXBkYXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy51cGRhdGVCQm94KCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldEJCb3hcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAodGhpcy53cmFwcGVyTm9kZSAmJiB0aGlzLndyYXBwZXJOb2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCkge1xuICAgICAgICB2YXIgciA9IHRoaXMud3JhcHBlck5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIHJldHVybiByLmhlaWdodCA9IHRoaXMud3JhcHBlck5vZGUub2Zmc2V0SGVpZ2h0LCByLndpZHRoID0gdGhpcy53cmFwcGVyTm9kZS5vZmZzZXRXaWR0aCwgcjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ1cGRhdGVCQm94XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHIgPSB0aGlzLnByb3BzLm9uQkJveFVwZGF0ZSwgaSA9IHRoaXMuZ2V0QkJveCgpO1xuICAgICAgaSA/IChNYXRoLmFicyhpLndpZHRoIC0gdGhpcy5sYXN0Qm91bmRpbmdCb3gud2lkdGgpID4gcmggfHwgTWF0aC5hYnMoaS5oZWlnaHQgLSB0aGlzLmxhc3RCb3VuZGluZ0JveC5oZWlnaHQpID4gcmgpICYmICh0aGlzLmxhc3RCb3VuZGluZ0JveC53aWR0aCA9IGkud2lkdGgsIHRoaXMubGFzdEJvdW5kaW5nQm94LmhlaWdodCA9IGkuaGVpZ2h0LCByICYmIHIoaSkpIDogKHRoaXMubGFzdEJvdW5kaW5nQm94LndpZHRoICE9PSAtMSB8fCB0aGlzLmxhc3RCb3VuZGluZ0JveC5oZWlnaHQgIT09IC0xKSAmJiAodGhpcy5sYXN0Qm91bmRpbmdCb3gud2lkdGggPSAtMSwgdGhpcy5sYXN0Qm91bmRpbmdCb3guaGVpZ2h0ID0gLTEsIHIgJiYgcihudWxsKSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldEJCb3hTbmFwc2hvdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmxhc3RCb3VuZGluZ0JveC53aWR0aCA+PSAwICYmIHRoaXMubGFzdEJvdW5kaW5nQm94LmhlaWdodCA+PSAwID8gSm4oe30sIHRoaXMubGFzdEJvdW5kaW5nQm94KSA6IHtcbiAgICAgICAgd2lkdGg6IDAsXG4gICAgICAgIGhlaWdodDogMFxuICAgICAgfTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0RGVmYXVsdFBvc2l0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uKHIpIHtcbiAgICAgIHZhciBpID0gdGhpcy5wcm9wcywgbyA9IGkubGF5b3V0LCBhID0gaS5hbGlnbiwgcyA9IGkudmVydGljYWxBbGlnbiwgdSA9IGkubWFyZ2luLCBjID0gaS5jaGFydFdpZHRoLCBmID0gaS5jaGFydEhlaWdodCwgbCwgZDtcbiAgICAgIGlmICghciB8fCAoci5sZWZ0ID09PSB2b2lkIDAgfHwgci5sZWZ0ID09PSBudWxsKSAmJiAoci5yaWdodCA9PT0gdm9pZCAwIHx8IHIucmlnaHQgPT09IG51bGwpKVxuICAgICAgICBpZiAoYSA9PT0gXCJjZW50ZXJcIiAmJiBvID09PSBcInZlcnRpY2FsXCIpIHtcbiAgICAgICAgICB2YXIgcCA9IHRoaXMuZ2V0QkJveFNuYXBzaG90KCk7XG4gICAgICAgICAgbCA9IHtcbiAgICAgICAgICAgIGxlZnQ6ICgoYyB8fCAwKSAtIHAud2lkdGgpIC8gMlxuICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZVxuICAgICAgICAgIGwgPSBhID09PSBcInJpZ2h0XCIgPyB7XG4gICAgICAgICAgICByaWdodDogdSAmJiB1LnJpZ2h0IHx8IDBcbiAgICAgICAgICB9IDoge1xuICAgICAgICAgICAgbGVmdDogdSAmJiB1LmxlZnQgfHwgMFxuICAgICAgICAgIH07XG4gICAgICBpZiAoIXIgfHwgKHIudG9wID09PSB2b2lkIDAgfHwgci50b3AgPT09IG51bGwpICYmIChyLmJvdHRvbSA9PT0gdm9pZCAwIHx8IHIuYm90dG9tID09PSBudWxsKSlcbiAgICAgICAgaWYgKHMgPT09IFwibWlkZGxlXCIpIHtcbiAgICAgICAgICB2YXIgZyA9IHRoaXMuZ2V0QkJveFNuYXBzaG90KCk7XG4gICAgICAgICAgZCA9IHtcbiAgICAgICAgICAgIHRvcDogKChmIHx8IDApIC0gZy5oZWlnaHQpIC8gMlxuICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZVxuICAgICAgICAgIGQgPSBzID09PSBcImJvdHRvbVwiID8ge1xuICAgICAgICAgICAgYm90dG9tOiB1ICYmIHUuYm90dG9tIHx8IDBcbiAgICAgICAgICB9IDoge1xuICAgICAgICAgICAgdG9wOiB1ICYmIHUudG9wIHx8IDBcbiAgICAgICAgICB9O1xuICAgICAgcmV0dXJuIEpuKEpuKHt9LCBsKSwgZCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJlbmRlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciByID0gdGhpcywgaSA9IHRoaXMucHJvcHMsIG8gPSBpLmNvbnRlbnQsIGEgPSBpLndpZHRoLCBzID0gaS5oZWlnaHQsIHUgPSBpLndyYXBwZXJTdHlsZSwgYyA9IGkucGF5bG9hZFVuaXFCeSwgZiA9IGkucGF5bG9hZCwgbCA9IEpuKEpuKHtcbiAgICAgICAgcG9zaXRpb246IFwiYWJzb2x1dGVcIixcbiAgICAgICAgd2lkdGg6IGEgfHwgXCJhdXRvXCIsXG4gICAgICAgIGhlaWdodDogcyB8fCBcImF1dG9cIlxuICAgICAgfSwgdGhpcy5nZXREZWZhdWx0UG9zaXRpb24odSkpLCB1KTtcbiAgICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8gUC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtcbiAgICAgICAgY2xhc3NOYW1lOiBcInJlY2hhcnRzLWxlZ2VuZC13cmFwcGVyXCIsXG4gICAgICAgIHN0eWxlOiBsLFxuICAgICAgICByZWY6IGZ1bmN0aW9uKHApIHtcbiAgICAgICAgICByLndyYXBwZXJOb2RlID0gcDtcbiAgICAgICAgfVxuICAgICAgfSwgTmsobywgSm4oSm4oe30sIHRoaXMucHJvcHMpLCB7fSwge1xuICAgICAgICBwYXlsb2FkOiBNYihmLCBjLCBEaylcbiAgICAgIH0pKSk7XG4gICAgfVxuICB9XSwgW3tcbiAgICBrZXk6IFwiZ2V0V2l0aEhlaWdodFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbihyLCBpKSB7XG4gICAgICB2YXIgbyA9IHIucHJvcHMubGF5b3V0O1xuICAgICAgcmV0dXJuIG8gPT09IFwidmVydGljYWxcIiAmJiBLKHIucHJvcHMuaGVpZ2h0KSA/IHtcbiAgICAgICAgaGVpZ2h0OiByLnByb3BzLmhlaWdodFxuICAgICAgfSA6IG8gPT09IFwiaG9yaXpvbnRhbFwiID8ge1xuICAgICAgICB3aWR0aDogci5wcm9wcy53aWR0aCB8fCBpXG4gICAgICB9IDogbnVsbDtcbiAgICB9XG4gIH1dKSwgdDtcbn0oV24pO1xuVXMoVnIsIFwiZGlzcGxheU5hbWVcIiwgXCJMZWdlbmRcIik7XG5VcyhWciwgXCJkZWZhdWx0UHJvcHNcIiwge1xuICBpY29uU2l6ZTogMTQsXG4gIGxheW91dDogXCJob3Jpem9udGFsXCIsXG4gIGFsaWduOiBcImNlbnRlclwiLFxuICB2ZXJ0aWNhbEFsaWduOiBcImJvdHRvbVwiXG59KTtcbnZhciBpaCA9IFZvLCBGayA9IElmLCBMayA9IG10LCBvaCA9IGloID8gaWguaXNDb25jYXRTcHJlYWRhYmxlIDogdm9pZCAwO1xuZnVuY3Rpb24gQmsoZSkge1xuICByZXR1cm4gTGsoZSkgfHwgRmsoZSkgfHwgISEob2ggJiYgZSAmJiBlW29oXSk7XG59XG52YXIgemsgPSBCaywgVmsgPSBiYiwgR2sgPSB6aztcbmZ1bmN0aW9uIGtiKGUsIHQsIG4sIHIsIGkpIHtcbiAgdmFyIG8gPSAtMSwgYSA9IGUubGVuZ3RoO1xuICBmb3IgKG4gfHwgKG4gPSBHayksIGkgfHwgKGkgPSBbXSk7ICsrbyA8IGE7ICkge1xuICAgIHZhciBzID0gZVtvXTtcbiAgICB0ID4gMCAmJiBuKHMpID8gdCA+IDEgPyBrYihzLCB0IC0gMSwgbiwgciwgaSkgOiBWayhpLCBzKSA6IHIgfHwgKGlbaS5sZW5ndGhdID0gcyk7XG4gIH1cbiAgcmV0dXJuIGk7XG59XG52YXIgRGIgPSBrYjtcbmZ1bmN0aW9uIFdrKGUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHQsIG4sIHIpIHtcbiAgICBmb3IgKHZhciBpID0gLTEsIG8gPSBPYmplY3QodCksIGEgPSByKHQpLCBzID0gYS5sZW5ndGg7IHMtLTsgKSB7XG4gICAgICB2YXIgdSA9IGFbZSA/IHMgOiArK2ldO1xuICAgICAgaWYgKG4ob1t1XSwgdSwgbykgPT09ICExKVxuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgcmV0dXJuIHQ7XG4gIH07XG59XG52YXIgVWsgPSBXaywgSGsgPSBVaywgcWsgPSBIaygpLCBLayA9IHFrLCBZayA9IEtrLCBYayA9IFdzO1xuZnVuY3Rpb24gWmsoZSwgdCkge1xuICByZXR1cm4gZSAmJiBZayhlLCB0LCBYayk7XG59XG52YXIgTmIgPSBaaywgSmsgPSBIbztcbmZ1bmN0aW9uIFFrKGUsIHQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKG4sIHIpIHtcbiAgICBpZiAobiA9PSBudWxsKVxuICAgICAgcmV0dXJuIG47XG4gICAgaWYgKCFKayhuKSlcbiAgICAgIHJldHVybiBlKG4sIHIpO1xuICAgIGZvciAodmFyIGkgPSBuLmxlbmd0aCwgbyA9IHQgPyBpIDogLTEsIGEgPSBPYmplY3Qobik7ICh0ID8gby0tIDogKytvIDwgaSkgJiYgcihhW29dLCBvLCBhKSAhPT0gITE7IClcbiAgICAgIDtcbiAgICByZXR1cm4gbjtcbiAgfTtcbn1cbnZhciBlRCA9IFFrLCB0RCA9IE5iLCBuRCA9IGVELCByRCA9IG5EKHREKSwgTmYgPSByRCwgaUQgPSBOZiwgb0QgPSBIbztcbmZ1bmN0aW9uIGFEKGUsIHQpIHtcbiAgdmFyIG4gPSAtMSwgciA9IG9EKGUpID8gQXJyYXkoZS5sZW5ndGgpIDogW107XG4gIHJldHVybiBpRChlLCBmdW5jdGlvbihpLCBvLCBhKSB7XG4gICAgclsrK25dID0gdChpLCBvLCBhKTtcbiAgfSksIHI7XG59XG52YXIgRmIgPSBhRDtcbmZ1bmN0aW9uIHNEKGUsIHQpIHtcbiAgdmFyIG4gPSBlLmxlbmd0aDtcbiAgZm9yIChlLnNvcnQodCk7IG4tLTsgKVxuICAgIGVbbl0gPSBlW25dLnZhbHVlO1xuICByZXR1cm4gZTtcbn1cbnZhciB1RCA9IHNELCBhaCA9IHVpO1xuZnVuY3Rpb24gY0QoZSwgdCkge1xuICBpZiAoZSAhPT0gdCkge1xuICAgIHZhciBuID0gZSAhPT0gdm9pZCAwLCByID0gZSA9PT0gbnVsbCwgaSA9IGUgPT09IGUsIG8gPSBhaChlKSwgYSA9IHQgIT09IHZvaWQgMCwgcyA9IHQgPT09IG51bGwsIHUgPSB0ID09PSB0LCBjID0gYWgodCk7XG4gICAgaWYgKCFzICYmICFjICYmICFvICYmIGUgPiB0IHx8IG8gJiYgYSAmJiB1ICYmICFzICYmICFjIHx8IHIgJiYgYSAmJiB1IHx8ICFuICYmIHUgfHwgIWkpXG4gICAgICByZXR1cm4gMTtcbiAgICBpZiAoIXIgJiYgIW8gJiYgIWMgJiYgZSA8IHQgfHwgYyAmJiBuICYmIGkgJiYgIXIgJiYgIW8gfHwgcyAmJiBuICYmIGkgfHwgIWEgJiYgaSB8fCAhdSlcbiAgICAgIHJldHVybiAtMTtcbiAgfVxuICByZXR1cm4gMDtcbn1cbnZhciBsRCA9IGNELCBmRCA9IGxEO1xuZnVuY3Rpb24gZEQoZSwgdCwgbikge1xuICBmb3IgKHZhciByID0gLTEsIGkgPSBlLmNyaXRlcmlhLCBvID0gdC5jcml0ZXJpYSwgYSA9IGkubGVuZ3RoLCBzID0gbi5sZW5ndGg7ICsrciA8IGE7ICkge1xuICAgIHZhciB1ID0gZkQoaVtyXSwgb1tyXSk7XG4gICAgaWYgKHUpIHtcbiAgICAgIGlmIChyID49IHMpXG4gICAgICAgIHJldHVybiB1O1xuICAgICAgdmFyIGMgPSBuW3JdO1xuICAgICAgcmV0dXJuIHUgKiAoYyA9PSBcImRlc2NcIiA/IC0xIDogMSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBlLmluZGV4IC0gdC5pbmRleDtcbn1cbnZhciBwRCA9IGRELCBJdSA9IFNmLCBoRCA9ICRmLCBnRCA9IEhuLCB2RCA9IEZiLCBtRCA9IHVELCB5RCA9IFNiLCBiRCA9IHBELCB3RCA9IGdpLCB4RCA9IG10O1xuZnVuY3Rpb24gU0QoZSwgdCwgbikge1xuICB0Lmxlbmd0aCA/IHQgPSBJdSh0LCBmdW5jdGlvbihvKSB7XG4gICAgcmV0dXJuIHhEKG8pID8gZnVuY3Rpb24oYSkge1xuICAgICAgcmV0dXJuIGhEKGEsIG8ubGVuZ3RoID09PSAxID8gb1swXSA6IG8pO1xuICAgIH0gOiBvO1xuICB9KSA6IHQgPSBbd0RdO1xuICB2YXIgciA9IC0xO1xuICB0ID0gSXUodCwgeUQoZ0QpKTtcbiAgdmFyIGkgPSB2RChlLCBmdW5jdGlvbihvLCBhLCBzKSB7XG4gICAgdmFyIHUgPSBJdSh0LCBmdW5jdGlvbihjKSB7XG4gICAgICByZXR1cm4gYyhvKTtcbiAgICB9KTtcbiAgICByZXR1cm4geyBjcml0ZXJpYTogdSwgaW5kZXg6ICsrciwgdmFsdWU6IG8gfTtcbiAgfSk7XG4gIHJldHVybiBtRChpLCBmdW5jdGlvbihvLCBhKSB7XG4gICAgcmV0dXJuIGJEKG8sIGEsIG4pO1xuICB9KTtcbn1cbnZhciAkRCA9IFNEO1xuZnVuY3Rpb24gT0QoZSwgdCwgbikge1xuICBzd2l0Y2ggKG4ubGVuZ3RoKSB7XG4gICAgY2FzZSAwOlxuICAgICAgcmV0dXJuIGUuY2FsbCh0KTtcbiAgICBjYXNlIDE6XG4gICAgICByZXR1cm4gZS5jYWxsKHQsIG5bMF0pO1xuICAgIGNhc2UgMjpcbiAgICAgIHJldHVybiBlLmNhbGwodCwgblswXSwgblsxXSk7XG4gICAgY2FzZSAzOlxuICAgICAgcmV0dXJuIGUuY2FsbCh0LCBuWzBdLCBuWzFdLCBuWzJdKTtcbiAgfVxuICByZXR1cm4gZS5hcHBseSh0LCBuKTtcbn1cbnZhciBfRCA9IE9ELCBBRCA9IF9ELCBzaCA9IE1hdGgubWF4O1xuZnVuY3Rpb24gUEQoZSwgdCwgbikge1xuICByZXR1cm4gdCA9IHNoKHQgPT09IHZvaWQgMCA/IGUubGVuZ3RoIC0gMSA6IHQsIDApLCBmdW5jdGlvbigpIHtcbiAgICBmb3IgKHZhciByID0gYXJndW1lbnRzLCBpID0gLTEsIG8gPSBzaChyLmxlbmd0aCAtIHQsIDApLCBhID0gQXJyYXkobyk7ICsraSA8IG87IClcbiAgICAgIGFbaV0gPSByW3QgKyBpXTtcbiAgICBpID0gLTE7XG4gICAgZm9yICh2YXIgcyA9IEFycmF5KHQgKyAxKTsgKytpIDwgdDsgKVxuICAgICAgc1tpXSA9IHJbaV07XG4gICAgcmV0dXJuIHNbdF0gPSBuKGEpLCBBRChlLCB0aGlzLCBzKTtcbiAgfTtcbn1cbnZhciBDRCA9IFBEO1xuZnVuY3Rpb24gRUQoZSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGU7XG4gIH07XG59XG52YXIgVEQgPSBFRCwgTUQgPSB2ciwgUkQgPSBmdW5jdGlvbigpIHtcbiAgdHJ5IHtcbiAgICB2YXIgZSA9IE1EKE9iamVjdCwgXCJkZWZpbmVQcm9wZXJ0eVwiKTtcbiAgICByZXR1cm4gZSh7fSwgXCJcIiwge30pLCBlO1xuICB9IGNhdGNoIHtcbiAgfVxufSgpLCBMYiA9IFJELCBJRCA9IFRELCB1aCA9IExiLCBqRCA9IGdpLCBrRCA9IHVoID8gZnVuY3Rpb24oZSwgdCkge1xuICByZXR1cm4gdWgoZSwgXCJ0b1N0cmluZ1wiLCB7XG4gICAgY29uZmlndXJhYmxlOiAhMCxcbiAgICBlbnVtZXJhYmxlOiAhMSxcbiAgICB2YWx1ZTogSUQodCksXG4gICAgd3JpdGFibGU6ICEwXG4gIH0pO1xufSA6IGpELCBERCA9IGtELCBORCA9IDgwMCwgRkQgPSAxNiwgTEQgPSBEYXRlLm5vdztcbmZ1bmN0aW9uIEJEKGUpIHtcbiAgdmFyIHQgPSAwLCBuID0gMDtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciByID0gTEQoKSwgaSA9IEZEIC0gKHIgLSBuKTtcbiAgICBpZiAobiA9IHIsIGkgPiAwKSB7XG4gICAgICBpZiAoKyt0ID49IE5EKVxuICAgICAgICByZXR1cm4gYXJndW1lbnRzWzBdO1xuICAgIH0gZWxzZVxuICAgICAgdCA9IDA7XG4gICAgcmV0dXJuIGUuYXBwbHkodm9pZCAwLCBhcmd1bWVudHMpO1xuICB9O1xufVxudmFyIHpEID0gQkQsIFZEID0gREQsIEdEID0gekQsIFdEID0gR0QoVkQpLCBVRCA9IFdELCBIRCA9IGdpLCBxRCA9IENELCBLRCA9IFVEO1xuZnVuY3Rpb24gWUQoZSwgdCkge1xuICByZXR1cm4gS0QocUQoZSwgdCwgSEQpLCBlICsgXCJcIik7XG59XG52YXIgWEQgPSBZRCwgWkQgPSB5ZiwgSkQgPSBIbywgUUQgPSBqZiwgZU4gPSBVbjtcbmZ1bmN0aW9uIHROKGUsIHQsIG4pIHtcbiAgaWYgKCFlTihuKSlcbiAgICByZXR1cm4gITE7XG4gIHZhciByID0gdHlwZW9mIHQ7XG4gIHJldHVybiAociA9PSBcIm51bWJlclwiID8gSkQobikgJiYgUUQodCwgbi5sZW5ndGgpIDogciA9PSBcInN0cmluZ1wiICYmIHQgaW4gbikgPyBaRChuW3RdLCBlKSA6ICExO1xufVxudmFyIEhzID0gdE4sIG5OID0gRGIsIHJOID0gJEQsIGlOID0gWEQsIGNoID0gSHMsIG9OID0gaU4oZnVuY3Rpb24oZSwgdCkge1xuICBpZiAoZSA9PSBudWxsKVxuICAgIHJldHVybiBbXTtcbiAgdmFyIG4gPSB0Lmxlbmd0aDtcbiAgcmV0dXJuIG4gPiAxICYmIGNoKGUsIHRbMF0sIHRbMV0pID8gdCA9IFtdIDogbiA+IDIgJiYgY2godFswXSwgdFsxXSwgdFsyXSkgJiYgKHQgPSBbdFswXV0pLCByTihlLCBuTih0LCAxKSwgW10pO1xufSksIGFOID0gb047XG5jb25zdCBGZiA9IC8qIEBfX1BVUkVfXyAqLyBqZShhTik7XG5mdW5jdGlvbiBybyhlKSB7XG4gIFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjtcbiAgcmV0dXJuIHJvID0gdHlwZW9mIFN5bWJvbCA9PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PSBcInN5bWJvbFwiID8gZnVuY3Rpb24odCkge1xuICAgIHJldHVybiB0eXBlb2YgdDtcbiAgfSA6IGZ1bmN0aW9uKHQpIHtcbiAgICByZXR1cm4gdCAmJiB0eXBlb2YgU3ltYm9sID09IFwiZnVuY3Rpb25cIiAmJiB0LmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgdCAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2YgdDtcbiAgfSwgcm8oZSk7XG59XG5mdW5jdGlvbiBLYygpIHtcbiAgcmV0dXJuIEtjID0gT2JqZWN0LmFzc2lnbiA/IE9iamVjdC5hc3NpZ24uYmluZCgpIDogZnVuY3Rpb24oZSkge1xuICAgIGZvciAodmFyIHQgPSAxOyB0IDwgYXJndW1lbnRzLmxlbmd0aDsgdCsrKSB7XG4gICAgICB2YXIgbiA9IGFyZ3VtZW50c1t0XTtcbiAgICAgIGZvciAodmFyIHIgaW4gbilcbiAgICAgICAgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG4sIHIpICYmIChlW3JdID0gbltyXSk7XG4gICAgfVxuICAgIHJldHVybiBlO1xuICB9LCBLYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuZnVuY3Rpb24gc04oZSwgdCkge1xuICByZXR1cm4gZk4oZSkgfHwgbE4oZSwgdCkgfHwgY04oZSwgdCkgfHwgdU4oKTtcbn1cbmZ1bmN0aW9uIHVOKCkge1xuICB0aHJvdyBuZXcgVHlwZUVycm9yKGBJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLmApO1xufVxuZnVuY3Rpb24gY04oZSwgdCkge1xuICBpZiAoZSkge1xuICAgIGlmICh0eXBlb2YgZSA9PSBcInN0cmluZ1wiKVxuICAgICAgcmV0dXJuIGxoKGUsIHQpO1xuICAgIHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGUpLnNsaWNlKDgsIC0xKTtcbiAgICBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBlLmNvbnN0cnVjdG9yICYmIChuID0gZS5jb25zdHJ1Y3Rvci5uYW1lKSwgbiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKVxuICAgICAgcmV0dXJuIEFycmF5LmZyb20oZSk7XG4gICAgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpXG4gICAgICByZXR1cm4gbGgoZSwgdCk7XG4gIH1cbn1cbmZ1bmN0aW9uIGxoKGUsIHQpIHtcbiAgKHQgPT0gbnVsbCB8fCB0ID4gZS5sZW5ndGgpICYmICh0ID0gZS5sZW5ndGgpO1xuICBmb3IgKHZhciBuID0gMCwgciA9IG5ldyBBcnJheSh0KTsgbiA8IHQ7IG4rKylcbiAgICByW25dID0gZVtuXTtcbiAgcmV0dXJuIHI7XG59XG5mdW5jdGlvbiBsTihlLCB0KSB7XG4gIHZhciBuID0gZSA9PSBudWxsID8gbnVsbCA6IHR5cGVvZiBTeW1ib2wgPCBcInVcIiAmJiBlW1N5bWJvbC5pdGVyYXRvcl0gfHwgZVtcIkBAaXRlcmF0b3JcIl07XG4gIGlmIChuICE9IG51bGwpIHtcbiAgICB2YXIgciwgaSwgbywgYSwgcyA9IFtdLCB1ID0gITAsIGMgPSAhMTtcbiAgICB0cnkge1xuICAgICAgaWYgKG8gPSAobiA9IG4uY2FsbChlKSkubmV4dCwgdCAhPT0gMClcbiAgICAgICAgZm9yICg7ICEodSA9IChyID0gby5jYWxsKG4pKS5kb25lKSAmJiAocy5wdXNoKHIudmFsdWUpLCBzLmxlbmd0aCAhPT0gdCk7IHUgPSAhMClcbiAgICAgICAgICA7XG4gICAgfSBjYXRjaCAoZikge1xuICAgICAgYyA9ICEwLCBpID0gZjtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKCF1ICYmIG4ucmV0dXJuICE9IG51bGwgJiYgKGEgPSBuLnJldHVybigpLCBPYmplY3QoYSkgIT09IGEpKVxuICAgICAgICAgIHJldHVybjtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGlmIChjKVxuICAgICAgICAgIHRocm93IGk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzO1xuICB9XG59XG5mdW5jdGlvbiBmTihlKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGUpKVxuICAgIHJldHVybiBlO1xufVxuZnVuY3Rpb24gZmgoZSwgdCkge1xuICB2YXIgbiA9IE9iamVjdC5rZXlzKGUpO1xuICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykge1xuICAgIHZhciByID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhlKTtcbiAgICB0ICYmIChyID0gci5maWx0ZXIoZnVuY3Rpb24oaSkge1xuICAgICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSwgaSkuZW51bWVyYWJsZTtcbiAgICB9KSksIG4ucHVzaC5hcHBseShuLCByKTtcbiAgfVxuICByZXR1cm4gbjtcbn1cbmZ1bmN0aW9uIGp1KGUpIHtcbiAgZm9yICh2YXIgdCA9IDE7IHQgPCBhcmd1bWVudHMubGVuZ3RoOyB0KyspIHtcbiAgICB2YXIgbiA9IGFyZ3VtZW50c1t0XSAhPSBudWxsID8gYXJndW1lbnRzW3RdIDoge307XG4gICAgdCAlIDIgPyBmaChPYmplY3QobiksICEwKS5mb3JFYWNoKGZ1bmN0aW9uKHIpIHtcbiAgICAgIGROKGUsIHIsIG5bcl0pO1xuICAgIH0pIDogT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhlLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhuKSkgOiBmaChPYmplY3QobikpLmZvckVhY2goZnVuY3Rpb24ocikge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIHIsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobiwgcikpO1xuICAgIH0pO1xuICB9XG4gIHJldHVybiBlO1xufVxuZnVuY3Rpb24gZE4oZSwgdCwgbikge1xuICByZXR1cm4gdCA9IHBOKHQpLCB0IGluIGUgPyBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgdCwgeyB2YWx1ZTogbiwgZW51bWVyYWJsZTogITAsIGNvbmZpZ3VyYWJsZTogITAsIHdyaXRhYmxlOiAhMCB9KSA6IGVbdF0gPSBuLCBlO1xufVxuZnVuY3Rpb24gcE4oZSkge1xuICB2YXIgdCA9IGhOKGUsIFwic3RyaW5nXCIpO1xuICByZXR1cm4gcm8odCkgPT0gXCJzeW1ib2xcIiA/IHQgOiBTdHJpbmcodCk7XG59XG5mdW5jdGlvbiBoTihlLCB0KSB7XG4gIGlmIChybyhlKSAhPSBcIm9iamVjdFwiIHx8ICFlKVxuICAgIHJldHVybiBlO1xuICB2YXIgbiA9IGVbU3ltYm9sLnRvUHJpbWl0aXZlXTtcbiAgaWYgKG4gIT09IHZvaWQgMCkge1xuICAgIHZhciByID0gbi5jYWxsKGUsIHQgfHwgXCJkZWZhdWx0XCIpO1xuICAgIGlmIChybyhyKSAhPSBcIm9iamVjdFwiKVxuICAgICAgcmV0dXJuIHI7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkBAdG9QcmltaXRpdmUgbXVzdCByZXR1cm4gYSBwcmltaXRpdmUgdmFsdWUuXCIpO1xuICB9XG4gIHJldHVybiAodCA9PT0gXCJzdHJpbmdcIiA/IFN0cmluZyA6IE51bWJlcikoZSk7XG59XG5mdW5jdGlvbiBnTihlKSB7XG4gIHJldHVybiBBcnJheS5pc0FycmF5KGUpICYmIEtlKGVbMF0pICYmIEtlKGVbMV0pID8gZS5qb2luKFwiIH4gXCIpIDogZTtcbn1cbnZhciB2TiA9IGZ1bmN0aW9uKHQpIHtcbiAgdmFyIG4gPSB0LnNlcGFyYXRvciwgciA9IG4gPT09IHZvaWQgMCA/IFwiIDogXCIgOiBuLCBpID0gdC5jb250ZW50U3R5bGUsIG8gPSBpID09PSB2b2lkIDAgPyB7fSA6IGksIGEgPSB0Lml0ZW1TdHlsZSwgcyA9IGEgPT09IHZvaWQgMCA/IHt9IDogYSwgdSA9IHQubGFiZWxTdHlsZSwgYyA9IHUgPT09IHZvaWQgMCA/IHt9IDogdSwgZiA9IHQucGF5bG9hZCwgbCA9IHQuZm9ybWF0dGVyLCBkID0gdC5pdGVtU29ydGVyLCBwID0gdC53cmFwcGVyQ2xhc3NOYW1lLCBnID0gdC5sYWJlbENsYXNzTmFtZSwgaCA9IHQubGFiZWwsIHYgPSB0LmxhYmVsRm9ybWF0dGVyLCB3ID0gdC5hY2Nlc3NpYmlsaXR5TGF5ZXIsIGIgPSB3ID09PSB2b2lkIDAgPyAhMSA6IHcsIHggPSBmdW5jdGlvbigpIHtcbiAgICBpZiAoZiAmJiBmLmxlbmd0aCkge1xuICAgICAgdmFyIEEgPSB7XG4gICAgICAgIHBhZGRpbmc6IDAsXG4gICAgICAgIG1hcmdpbjogMFxuICAgICAgfSwgaiA9IChkID8gRmYoZiwgZCkgOiBmKS5tYXAoZnVuY3Rpb24oUiwgTikge1xuICAgICAgICBpZiAoUi50eXBlID09PSBcIm5vbmVcIilcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgdmFyIGsgPSBqdSh7XG4gICAgICAgICAgZGlzcGxheTogXCJibG9ja1wiLFxuICAgICAgICAgIHBhZGRpbmdUb3A6IDQsXG4gICAgICAgICAgcGFkZGluZ0JvdHRvbTogNCxcbiAgICAgICAgICBjb2xvcjogUi5jb2xvciB8fCBcIiMwMDBcIlxuICAgICAgICB9LCBzKSwgRiA9IFIuZm9ybWF0dGVyIHx8IGwgfHwgZ04sIFYgPSBSLnZhbHVlLCBMID0gUi5uYW1lLCBJID0gViwgRCA9IEw7XG4gICAgICAgIGlmIChGICYmIEkgIT0gbnVsbCAmJiBEICE9IG51bGwpIHtcbiAgICAgICAgICB2YXIgRyA9IEYoViwgTCwgUiwgTiwgZik7XG4gICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoRykpIHtcbiAgICAgICAgICAgIHZhciBxID0gc04oRywgMik7XG4gICAgICAgICAgICBJID0gcVswXSwgRCA9IHFbMV07XG4gICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICBJID0gRztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC9uby1hcnJheS1pbmRleC1rZXlcbiAgICAgICAgICAvKiBAX19QVVJFX18gKi8gUC5jcmVhdGVFbGVtZW50KFwibGlcIiwge1xuICAgICAgICAgICAgY2xhc3NOYW1lOiBcInJlY2hhcnRzLXRvb2x0aXAtaXRlbVwiLFxuICAgICAgICAgICAga2V5OiBcInRvb2x0aXAtaXRlbS1cIi5jb25jYXQoTiksXG4gICAgICAgICAgICBzdHlsZToga1xuICAgICAgICAgIH0sIEtlKEQpID8gLyogQF9fUFVSRV9fICovIFAuY3JlYXRlRWxlbWVudChcInNwYW5cIiwge1xuICAgICAgICAgICAgY2xhc3NOYW1lOiBcInJlY2hhcnRzLXRvb2x0aXAtaXRlbS1uYW1lXCJcbiAgICAgICAgICB9LCBEKSA6IG51bGwsIEtlKEQpID8gLyogQF9fUFVSRV9fICovIFAuY3JlYXRlRWxlbWVudChcInNwYW5cIiwge1xuICAgICAgICAgICAgY2xhc3NOYW1lOiBcInJlY2hhcnRzLXRvb2x0aXAtaXRlbS1zZXBhcmF0b3JcIlxuICAgICAgICAgIH0sIHIpIDogbnVsbCwgLyogQF9fUFVSRV9fICovIFAuY3JlYXRlRWxlbWVudChcInNwYW5cIiwge1xuICAgICAgICAgICAgY2xhc3NOYW1lOiBcInJlY2hhcnRzLXRvb2x0aXAtaXRlbS12YWx1ZVwiXG4gICAgICAgICAgfSwgSSksIC8qIEBfX1BVUkVfXyAqLyBQLmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIHtcbiAgICAgICAgICAgIGNsYXNzTmFtZTogXCJyZWNoYXJ0cy10b29sdGlwLWl0ZW0tdW5pdFwiXG4gICAgICAgICAgfSwgUi51bml0IHx8IFwiXCIpKVxuICAgICAgICApO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIFAuY3JlYXRlRWxlbWVudChcInVsXCIsIHtcbiAgICAgICAgY2xhc3NOYW1lOiBcInJlY2hhcnRzLXRvb2x0aXAtaXRlbS1saXN0XCIsXG4gICAgICAgIHN0eWxlOiBBXG4gICAgICB9LCBqKTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH0sIG0gPSBqdSh7XG4gICAgbWFyZ2luOiAwLFxuICAgIHBhZGRpbmc6IDEwLFxuICAgIGJhY2tncm91bmRDb2xvcjogXCIjZmZmXCIsXG4gICAgYm9yZGVyOiBcIjFweCBzb2xpZCAjY2NjXCIsXG4gICAgd2hpdGVTcGFjZTogXCJub3dyYXBcIlxuICB9LCBvKSwgeSA9IGp1KHtcbiAgICBtYXJnaW46IDBcbiAgfSwgYyksIFMgPSAhbWUoaCksICQgPSBTID8gaCA6IFwiXCIsIE8gPSAkZShcInJlY2hhcnRzLWRlZmF1bHQtdG9vbHRpcFwiLCBwKSwgVCA9ICRlKFwicmVjaGFydHMtdG9vbHRpcC1sYWJlbFwiLCBnKTtcbiAgUyAmJiB2ICYmIGYgIT09IHZvaWQgMCAmJiBmICE9PSBudWxsICYmICgkID0gdihoLCBmKSk7XG4gIHZhciBNID0gYiA/IHtcbiAgICByb2xlOiBcInN0YXR1c1wiLFxuICAgIFwiYXJpYS1saXZlXCI6IFwiYXNzZXJ0aXZlXCJcbiAgfSA6IHt9O1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIFAuY3JlYXRlRWxlbWVudChcImRpdlwiLCBLYyh7XG4gICAgY2xhc3NOYW1lOiBPLFxuICAgIHN0eWxlOiBtXG4gIH0sIE0pLCAvKiBAX19QVVJFX18gKi8gUC5jcmVhdGVFbGVtZW50KFwicFwiLCB7XG4gICAgY2xhc3NOYW1lOiBULFxuICAgIHN0eWxlOiB5XG4gIH0sIC8qIEBfX1BVUkVfXyAqLyBQLmlzVmFsaWRFbGVtZW50KCQpID8gJCA6IFwiXCIuY29uY2F0KCQpKSwgeCgpKTtcbn07XG5mdW5jdGlvbiBpbyhlKSB7XG4gIFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjtcbiAgcmV0dXJuIGlvID0gdHlwZW9mIFN5bWJvbCA9PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PSBcInN5bWJvbFwiID8gZnVuY3Rpb24odCkge1xuICAgIHJldHVybiB0eXBlb2YgdDtcbiAgfSA6IGZ1bmN0aW9uKHQpIHtcbiAgICByZXR1cm4gdCAmJiB0eXBlb2YgU3ltYm9sID09IFwiZnVuY3Rpb25cIiAmJiB0LmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgdCAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2YgdDtcbiAgfSwgaW8oZSk7XG59XG5mdW5jdGlvbiBkYShlLCB0LCBuKSB7XG4gIHJldHVybiB0ID0gbU4odCksIHQgaW4gZSA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCB0LCB7IHZhbHVlOiBuLCBlbnVtZXJhYmxlOiAhMCwgY29uZmlndXJhYmxlOiAhMCwgd3JpdGFibGU6ICEwIH0pIDogZVt0XSA9IG4sIGU7XG59XG5mdW5jdGlvbiBtTihlKSB7XG4gIHZhciB0ID0geU4oZSwgXCJzdHJpbmdcIik7XG4gIHJldHVybiBpbyh0KSA9PSBcInN5bWJvbFwiID8gdCA6IFN0cmluZyh0KTtcbn1cbmZ1bmN0aW9uIHlOKGUsIHQpIHtcbiAgaWYgKGlvKGUpICE9IFwib2JqZWN0XCIgfHwgIWUpXG4gICAgcmV0dXJuIGU7XG4gIHZhciBuID0gZVtTeW1ib2wudG9QcmltaXRpdmVdO1xuICBpZiAobiAhPT0gdm9pZCAwKSB7XG4gICAgdmFyIHIgPSBuLmNhbGwoZSwgdCB8fCBcImRlZmF1bHRcIik7XG4gICAgaWYgKGlvKHIpICE9IFwib2JqZWN0XCIpXG4gICAgICByZXR1cm4gcjtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQEB0b1ByaW1pdGl2ZSBtdXN0IHJldHVybiBhIHByaW1pdGl2ZSB2YWx1ZS5cIik7XG4gIH1cbiAgcmV0dXJuICh0ID09PSBcInN0cmluZ1wiID8gU3RyaW5nIDogTnVtYmVyKShlKTtcbn1cbnZhciBNaSA9IFwicmVjaGFydHMtdG9vbHRpcC13cmFwcGVyXCIsIGJOID0ge1xuICB2aXNpYmlsaXR5OiBcImhpZGRlblwiXG59O1xuZnVuY3Rpb24gd04oZSkge1xuICB2YXIgdCA9IGUuY29vcmRpbmF0ZSwgbiA9IGUudHJhbnNsYXRlWCwgciA9IGUudHJhbnNsYXRlWTtcbiAgcmV0dXJuICRlKE1pLCBkYShkYShkYShkYSh7fSwgXCJcIi5jb25jYXQoTWksIFwiLXJpZ2h0XCIpLCBLKG4pICYmIHQgJiYgSyh0LngpICYmIG4gPj0gdC54KSwgXCJcIi5jb25jYXQoTWksIFwiLWxlZnRcIiksIEsobikgJiYgdCAmJiBLKHQueCkgJiYgbiA8IHQueCksIFwiXCIuY29uY2F0KE1pLCBcIi1ib3R0b21cIiksIEsocikgJiYgdCAmJiBLKHQueSkgJiYgciA+PSB0LnkpLCBcIlwiLmNvbmNhdChNaSwgXCItdG9wXCIpLCBLKHIpICYmIHQgJiYgSyh0LnkpICYmIHIgPCB0LnkpKTtcbn1cbmZ1bmN0aW9uIGRoKGUpIHtcbiAgdmFyIHQgPSBlLmFsbG93RXNjYXBlVmlld0JveCwgbiA9IGUuY29vcmRpbmF0ZSwgciA9IGUua2V5LCBpID0gZS5vZmZzZXRUb3BMZWZ0LCBvID0gZS5wb3NpdGlvbiwgYSA9IGUucmV2ZXJzZURpcmVjdGlvbiwgcyA9IGUudG9vbHRpcERpbWVuc2lvbiwgdSA9IGUudmlld0JveCwgYyA9IGUudmlld0JveERpbWVuc2lvbjtcbiAgaWYgKG8gJiYgSyhvW3JdKSlcbiAgICByZXR1cm4gb1tyXTtcbiAgdmFyIGYgPSBuW3JdIC0gcyAtIGksIGwgPSBuW3JdICsgaTtcbiAgaWYgKHRbcl0pXG4gICAgcmV0dXJuIGFbcl0gPyBmIDogbDtcbiAgaWYgKGFbcl0pIHtcbiAgICB2YXIgZCA9IGYsIHAgPSB1W3JdO1xuICAgIHJldHVybiBkIDwgcCA/IE1hdGgubWF4KGwsIHVbcl0pIDogTWF0aC5tYXgoZiwgdVtyXSk7XG4gIH1cbiAgdmFyIGcgPSBsICsgcywgaCA9IHVbcl0gKyBjO1xuICByZXR1cm4gZyA+IGggPyBNYXRoLm1heChmLCB1W3JdKSA6IE1hdGgubWF4KGwsIHVbcl0pO1xufVxuZnVuY3Rpb24geE4oZSkge1xuICB2YXIgdCA9IGUudHJhbnNsYXRlWCwgbiA9IGUudHJhbnNsYXRlWSwgciA9IGUudXNlVHJhbnNsYXRlM2Q7XG4gIHJldHVybiB7XG4gICAgdHJhbnNmb3JtOiByID8gXCJ0cmFuc2xhdGUzZChcIi5jb25jYXQodCwgXCJweCwgXCIpLmNvbmNhdChuLCBcInB4LCAwKVwiKSA6IFwidHJhbnNsYXRlKFwiLmNvbmNhdCh0LCBcInB4LCBcIikuY29uY2F0KG4sIFwicHgpXCIpXG4gIH07XG59XG5mdW5jdGlvbiBTTihlKSB7XG4gIHZhciB0ID0gZS5hbGxvd0VzY2FwZVZpZXdCb3gsIG4gPSBlLmNvb3JkaW5hdGUsIHIgPSBlLm9mZnNldFRvcExlZnQsIGkgPSBlLnBvc2l0aW9uLCBvID0gZS5yZXZlcnNlRGlyZWN0aW9uLCBhID0gZS50b29sdGlwQm94LCBzID0gZS51c2VUcmFuc2xhdGUzZCwgdSA9IGUudmlld0JveCwgYywgZiwgbDtcbiAgcmV0dXJuIGEuaGVpZ2h0ID4gMCAmJiBhLndpZHRoID4gMCAmJiBuID8gKGYgPSBkaCh7XG4gICAgYWxsb3dFc2NhcGVWaWV3Qm94OiB0LFxuICAgIGNvb3JkaW5hdGU6IG4sXG4gICAga2V5OiBcInhcIixcbiAgICBvZmZzZXRUb3BMZWZ0OiByLFxuICAgIHBvc2l0aW9uOiBpLFxuICAgIHJldmVyc2VEaXJlY3Rpb246IG8sXG4gICAgdG9vbHRpcERpbWVuc2lvbjogYS53aWR0aCxcbiAgICB2aWV3Qm94OiB1LFxuICAgIHZpZXdCb3hEaW1lbnNpb246IHUud2lkdGhcbiAgfSksIGwgPSBkaCh7XG4gICAgYWxsb3dFc2NhcGVWaWV3Qm94OiB0LFxuICAgIGNvb3JkaW5hdGU6IG4sXG4gICAga2V5OiBcInlcIixcbiAgICBvZmZzZXRUb3BMZWZ0OiByLFxuICAgIHBvc2l0aW9uOiBpLFxuICAgIHJldmVyc2VEaXJlY3Rpb246IG8sXG4gICAgdG9vbHRpcERpbWVuc2lvbjogYS5oZWlnaHQsXG4gICAgdmlld0JveDogdSxcbiAgICB2aWV3Qm94RGltZW5zaW9uOiB1LmhlaWdodFxuICB9KSwgYyA9IHhOKHtcbiAgICB0cmFuc2xhdGVYOiBmLFxuICAgIHRyYW5zbGF0ZVk6IGwsXG4gICAgdXNlVHJhbnNsYXRlM2Q6IHNcbiAgfSkpIDogYyA9IGJOLCB7XG4gICAgY3NzUHJvcGVydGllczogYyxcbiAgICBjc3NDbGFzc2VzOiB3Tih7XG4gICAgICB0cmFuc2xhdGVYOiBmLFxuICAgICAgdHJhbnNsYXRlWTogbCxcbiAgICAgIGNvb3JkaW5hdGU6IG5cbiAgICB9KVxuICB9O1xufVxuZnVuY3Rpb24gR3IoZSkge1xuICBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7XG4gIHJldHVybiBHciA9IHR5cGVvZiBTeW1ib2wgPT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uKHQpIHtcbiAgICByZXR1cm4gdHlwZW9mIHQ7XG4gIH0gOiBmdW5jdGlvbih0KSB7XG4gICAgcmV0dXJuIHQgJiYgdHlwZW9mIFN5bWJvbCA9PSBcImZ1bmN0aW9uXCIgJiYgdC5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIHQgIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIHQ7XG4gIH0sIEdyKGUpO1xufVxuZnVuY3Rpb24gcGgoZSwgdCkge1xuICB2YXIgbiA9IE9iamVjdC5rZXlzKGUpO1xuICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykge1xuICAgIHZhciByID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhlKTtcbiAgICB0ICYmIChyID0gci5maWx0ZXIoZnVuY3Rpb24oaSkge1xuICAgICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSwgaSkuZW51bWVyYWJsZTtcbiAgICB9KSksIG4ucHVzaC5hcHBseShuLCByKTtcbiAgfVxuICByZXR1cm4gbjtcbn1cbmZ1bmN0aW9uIGhoKGUpIHtcbiAgZm9yICh2YXIgdCA9IDE7IHQgPCBhcmd1bWVudHMubGVuZ3RoOyB0KyspIHtcbiAgICB2YXIgbiA9IGFyZ3VtZW50c1t0XSAhPSBudWxsID8gYXJndW1lbnRzW3RdIDoge307XG4gICAgdCAlIDIgPyBwaChPYmplY3QobiksICEwKS5mb3JFYWNoKGZ1bmN0aW9uKHIpIHtcbiAgICAgIFpjKGUsIHIsIG5bcl0pO1xuICAgIH0pIDogT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhlLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhuKSkgOiBwaChPYmplY3QobikpLmZvckVhY2goZnVuY3Rpb24ocikge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIHIsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobiwgcikpO1xuICAgIH0pO1xuICB9XG4gIHJldHVybiBlO1xufVxuZnVuY3Rpb24gJE4oZSwgdCkge1xuICBpZiAoIShlIGluc3RhbmNlb2YgdCkpXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcbn1cbmZ1bmN0aW9uIE9OKGUsIHQpIHtcbiAgZm9yICh2YXIgbiA9IDA7IG4gPCB0Lmxlbmd0aDsgbisrKSB7XG4gICAgdmFyIHIgPSB0W25dO1xuICAgIHIuZW51bWVyYWJsZSA9IHIuZW51bWVyYWJsZSB8fCAhMSwgci5jb25maWd1cmFibGUgPSAhMCwgXCJ2YWx1ZVwiIGluIHIgJiYgKHIud3JpdGFibGUgPSAhMCksIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCB6YihyLmtleSksIHIpO1xuICB9XG59XG5mdW5jdGlvbiBfTihlLCB0LCBuKSB7XG4gIHJldHVybiB0ICYmIE9OKGUucHJvdG90eXBlLCB0KSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIFwicHJvdG90eXBlXCIsIHsgd3JpdGFibGU6ICExIH0pLCBlO1xufVxuZnVuY3Rpb24gQU4oZSwgdCwgbikge1xuICByZXR1cm4gdCA9IFlhKHQpLCBQTihlLCBCYigpID8gUmVmbGVjdC5jb25zdHJ1Y3QodCwgbiB8fCBbXSwgWWEoZSkuY29uc3RydWN0b3IpIDogdC5hcHBseShlLCBuKSk7XG59XG5mdW5jdGlvbiBQTihlLCB0KSB7XG4gIGlmICh0ICYmIChHcih0KSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgdCA9PSBcImZ1bmN0aW9uXCIpKVxuICAgIHJldHVybiB0O1xuICBpZiAodCAhPT0gdm9pZCAwKVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJEZXJpdmVkIGNvbnN0cnVjdG9ycyBtYXkgb25seSByZXR1cm4gb2JqZWN0IG9yIHVuZGVmaW5lZFwiKTtcbiAgcmV0dXJuIFljKGUpO1xufVxuZnVuY3Rpb24gQmIoKSB7XG4gIHRyeSB7XG4gICAgdmFyIGUgPSAhQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbigpIHtcbiAgICB9KSk7XG4gIH0gY2F0Y2gge1xuICB9XG4gIHJldHVybiAoQmIgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gISFlO1xuICB9KSgpO1xufVxuZnVuY3Rpb24gWWEoZSkge1xuICByZXR1cm4gWWEgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YuYmluZCgpIDogZnVuY3Rpb24obikge1xuICAgIHJldHVybiBuLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobik7XG4gIH0sIFlhKGUpO1xufVxuZnVuY3Rpb24gWWMoZSkge1xuICBpZiAoZSA9PT0gdm9pZCAwKVxuICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTtcbiAgcmV0dXJuIGU7XG59XG5mdW5jdGlvbiBDTihlLCB0KSB7XG4gIGlmICh0eXBlb2YgdCAhPSBcImZ1bmN0aW9uXCIgJiYgdCAhPT0gbnVsbClcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7XG4gIGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSh0ICYmIHQucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBlLCB3cml0YWJsZTogITAsIGNvbmZpZ3VyYWJsZTogITAgfSB9KSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIFwicHJvdG90eXBlXCIsIHsgd3JpdGFibGU6ICExIH0pLCB0ICYmIFhjKGUsIHQpO1xufVxuZnVuY3Rpb24gWGMoZSwgdCkge1xuICByZXR1cm4gWGMgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2YuYmluZCgpIDogZnVuY3Rpb24ociwgaSkge1xuICAgIHJldHVybiByLl9fcHJvdG9fXyA9IGksIHI7XG4gIH0sIFhjKGUsIHQpO1xufVxuZnVuY3Rpb24gWmMoZSwgdCwgbikge1xuICByZXR1cm4gdCA9IHpiKHQpLCB0IGluIGUgPyBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgdCwgeyB2YWx1ZTogbiwgZW51bWVyYWJsZTogITAsIGNvbmZpZ3VyYWJsZTogITAsIHdyaXRhYmxlOiAhMCB9KSA6IGVbdF0gPSBuLCBlO1xufVxuZnVuY3Rpb24gemIoZSkge1xuICB2YXIgdCA9IEVOKGUsIFwic3RyaW5nXCIpO1xuICByZXR1cm4gR3IodCkgPT0gXCJzeW1ib2xcIiA/IHQgOiBTdHJpbmcodCk7XG59XG5mdW5jdGlvbiBFTihlLCB0KSB7XG4gIGlmIChHcihlKSAhPSBcIm9iamVjdFwiIHx8ICFlKVxuICAgIHJldHVybiBlO1xuICB2YXIgbiA9IGVbU3ltYm9sLnRvUHJpbWl0aXZlXTtcbiAgaWYgKG4gIT09IHZvaWQgMCkge1xuICAgIHZhciByID0gbi5jYWxsKGUsIHQgfHwgXCJkZWZhdWx0XCIpO1xuICAgIGlmIChHcihyKSAhPSBcIm9iamVjdFwiKVxuICAgICAgcmV0dXJuIHI7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkBAdG9QcmltaXRpdmUgbXVzdCByZXR1cm4gYSBwcmltaXRpdmUgdmFsdWUuXCIpO1xuICB9XG4gIHJldHVybiAodCA9PT0gXCJzdHJpbmdcIiA/IFN0cmluZyA6IE51bWJlcikoZSk7XG59XG52YXIgZ2ggPSAxLCBUTiA9IC8qIEBfX1BVUkVfXyAqLyBmdW5jdGlvbihlKSB7XG4gIENOKHQsIGUpO1xuICBmdW5jdGlvbiB0KCkge1xuICAgIHZhciBuO1xuICAgICROKHRoaXMsIHQpO1xuICAgIGZvciAodmFyIHIgPSBhcmd1bWVudHMubGVuZ3RoLCBpID0gbmV3IEFycmF5KHIpLCBvID0gMDsgbyA8IHI7IG8rKylcbiAgICAgIGlbb10gPSBhcmd1bWVudHNbb107XG4gICAgcmV0dXJuIG4gPSBBTih0aGlzLCB0LCBbXS5jb25jYXQoaSkpLCBaYyhZYyhuKSwgXCJzdGF0ZVwiLCB7XG4gICAgICBkaXNtaXNzZWQ6ICExLFxuICAgICAgZGlzbWlzc2VkQXRDb29yZGluYXRlOiB7XG4gICAgICAgIHg6IDAsXG4gICAgICAgIHk6IDBcbiAgICAgIH0sXG4gICAgICBsYXN0Qm91bmRpbmdCb3g6IHtcbiAgICAgICAgd2lkdGg6IC0xLFxuICAgICAgICBoZWlnaHQ6IC0xXG4gICAgICB9XG4gICAgfSksIFpjKFljKG4pLCBcImhhbmRsZUtleURvd25cIiwgZnVuY3Rpb24oYSkge1xuICAgICAgaWYgKGEua2V5ID09PSBcIkVzY2FwZVwiKSB7XG4gICAgICAgIHZhciBzLCB1LCBjLCBmO1xuICAgICAgICBuLnNldFN0YXRlKHtcbiAgICAgICAgICBkaXNtaXNzZWQ6ICEwLFxuICAgICAgICAgIGRpc21pc3NlZEF0Q29vcmRpbmF0ZToge1xuICAgICAgICAgICAgeDogKHMgPSAodSA9IG4ucHJvcHMuY29vcmRpbmF0ZSkgPT09IG51bGwgfHwgdSA9PT0gdm9pZCAwID8gdm9pZCAwIDogdS54KSAhPT0gbnVsbCAmJiBzICE9PSB2b2lkIDAgPyBzIDogMCxcbiAgICAgICAgICAgIHk6IChjID0gKGYgPSBuLnByb3BzLmNvb3JkaW5hdGUpID09PSBudWxsIHx8IGYgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGYueSkgIT09IG51bGwgJiYgYyAhPT0gdm9pZCAwID8gYyA6IDBcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pLCBuO1xuICB9XG4gIHJldHVybiBfTih0LCBbe1xuICAgIGtleTogXCJ1cGRhdGVCQm94XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHRoaXMud3JhcHBlck5vZGUgJiYgdGhpcy53cmFwcGVyTm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QpIHtcbiAgICAgICAgdmFyIHIgPSB0aGlzLndyYXBwZXJOb2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAoTWF0aC5hYnMoci53aWR0aCAtIHRoaXMuc3RhdGUubGFzdEJvdW5kaW5nQm94LndpZHRoKSA+IGdoIHx8IE1hdGguYWJzKHIuaGVpZ2h0IC0gdGhpcy5zdGF0ZS5sYXN0Qm91bmRpbmdCb3guaGVpZ2h0KSA+IGdoKSAmJiB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICBsYXN0Qm91bmRpbmdCb3g6IHtcbiAgICAgICAgICAgIHdpZHRoOiByLndpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0OiByLmhlaWdodFxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2VcbiAgICAgICAgKHRoaXMuc3RhdGUubGFzdEJvdW5kaW5nQm94LndpZHRoICE9PSAtMSB8fCB0aGlzLnN0YXRlLmxhc3RCb3VuZGluZ0JveC5oZWlnaHQgIT09IC0xKSAmJiB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICBsYXN0Qm91bmRpbmdCb3g6IHtcbiAgICAgICAgICAgIHdpZHRoOiAtMSxcbiAgICAgICAgICAgIGhlaWdodDogLTFcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjb21wb25lbnREaWRNb3VudFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIHRoaXMuaGFuZGxlS2V5RG93biksIHRoaXMudXBkYXRlQkJveCgpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjb21wb25lbnRXaWxsVW5tb3VudFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIHRoaXMuaGFuZGxlS2V5RG93bik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNvbXBvbmVudERpZFVwZGF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciByLCBpO1xuICAgICAgdGhpcy5wcm9wcy5hY3RpdmUgJiYgdGhpcy51cGRhdGVCQm94KCksIHRoaXMuc3RhdGUuZGlzbWlzc2VkICYmICgoKHIgPSB0aGlzLnByb3BzLmNvb3JkaW5hdGUpID09PSBudWxsIHx8IHIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHIueCkgIT09IHRoaXMuc3RhdGUuZGlzbWlzc2VkQXRDb29yZGluYXRlLnggfHwgKChpID0gdGhpcy5wcm9wcy5jb29yZGluYXRlKSA9PT0gbnVsbCB8fCBpID09PSB2b2lkIDAgPyB2b2lkIDAgOiBpLnkpICE9PSB0aGlzLnN0YXRlLmRpc21pc3NlZEF0Q29vcmRpbmF0ZS55KSAmJiAodGhpcy5zdGF0ZS5kaXNtaXNzZWQgPSAhMSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJlbmRlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciByID0gdGhpcywgaSA9IHRoaXMucHJvcHMsIG8gPSBpLmFjdGl2ZSwgYSA9IGkuYWxsb3dFc2NhcGVWaWV3Qm94LCBzID0gaS5hbmltYXRpb25EdXJhdGlvbiwgdSA9IGkuYW5pbWF0aW9uRWFzaW5nLCBjID0gaS5jaGlsZHJlbiwgZiA9IGkuY29vcmRpbmF0ZSwgbCA9IGkuaGFzUGF5bG9hZCwgZCA9IGkuaXNBbmltYXRpb25BY3RpdmUsIHAgPSBpLm9mZnNldCwgZyA9IGkucG9zaXRpb24sIGggPSBpLnJldmVyc2VEaXJlY3Rpb24sIHYgPSBpLnVzZVRyYW5zbGF0ZTNkLCB3ID0gaS52aWV3Qm94LCBiID0gaS53cmFwcGVyU3R5bGUsIHggPSBTTih7XG4gICAgICAgIGFsbG93RXNjYXBlVmlld0JveDogYSxcbiAgICAgICAgY29vcmRpbmF0ZTogZixcbiAgICAgICAgb2Zmc2V0VG9wTGVmdDogcCxcbiAgICAgICAgcG9zaXRpb246IGcsXG4gICAgICAgIHJldmVyc2VEaXJlY3Rpb246IGgsXG4gICAgICAgIHRvb2x0aXBCb3g6IHRoaXMuc3RhdGUubGFzdEJvdW5kaW5nQm94LFxuICAgICAgICB1c2VUcmFuc2xhdGUzZDogdixcbiAgICAgICAgdmlld0JveDogd1xuICAgICAgfSksIG0gPSB4LmNzc0NsYXNzZXMsIHkgPSB4LmNzc1Byb3BlcnRpZXMsIFMgPSBoaChoaCh7XG4gICAgICAgIHRyYW5zaXRpb246IGQgJiYgbyA/IFwidHJhbnNmb3JtIFwiLmNvbmNhdChzLCBcIm1zIFwiKS5jb25jYXQodSkgOiB2b2lkIDBcbiAgICAgIH0sIHkpLCB7fSwge1xuICAgICAgICBwb2ludGVyRXZlbnRzOiBcIm5vbmVcIixcbiAgICAgICAgdmlzaWJpbGl0eTogIXRoaXMuc3RhdGUuZGlzbWlzc2VkICYmIG8gJiYgbCA/IFwidmlzaWJsZVwiIDogXCJoaWRkZW5cIixcbiAgICAgICAgcG9zaXRpb246IFwiYWJzb2x1dGVcIixcbiAgICAgICAgdG9wOiAwLFxuICAgICAgICBsZWZ0OiAwXG4gICAgICB9LCBiKTtcbiAgICAgIHJldHVybiAoXG4gICAgICAgIC8vIFRoaXMgZWxlbWVudCBhbGxvdyBsaXN0ZW5pbmcgdG8gdGhlIGBFc2NhcGVgIGtleS5cbiAgICAgICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9yZWNoYXJ0cy9yZWNoYXJ0cy9wdWxsLzI5MjVcbiAgICAgICAgLyogQF9fUFVSRV9fICovIFAuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgICAgICAgdGFiSW5kZXg6IC0xLFxuICAgICAgICAgIGNsYXNzTmFtZTogbSxcbiAgICAgICAgICBzdHlsZTogUyxcbiAgICAgICAgICByZWY6IGZ1bmN0aW9uKE8pIHtcbiAgICAgICAgICAgIHIud3JhcHBlck5vZGUgPSBPO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgYylcbiAgICAgICk7XG4gICAgfVxuICB9XSksIHQ7XG59KFduKSwgTU4gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuICEodHlwZW9mIHdpbmRvdyA8IFwidVwiICYmIHdpbmRvdy5kb2N1bWVudCAmJiB3aW5kb3cuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCAmJiB3aW5kb3cuc2V0VGltZW91dCk7XG59LCB5biA9IHtcbiAgaXNTc3I6IE1OKCksXG4gIGdldDogZnVuY3Rpb24odCkge1xuICAgIHJldHVybiB5blt0XTtcbiAgfSxcbiAgc2V0OiBmdW5jdGlvbih0LCBuKSB7XG4gICAgaWYgKHR5cGVvZiB0ID09IFwic3RyaW5nXCIpXG4gICAgICB5blt0XSA9IG47XG4gICAgZWxzZSB7XG4gICAgICB2YXIgciA9IE9iamVjdC5rZXlzKHQpO1xuICAgICAgciAmJiByLmxlbmd0aCAmJiByLmZvckVhY2goZnVuY3Rpb24oaSkge1xuICAgICAgICB5bltpXSA9IHRbaV07XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbn07XG5mdW5jdGlvbiBXcihlKSB7XG4gIFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjtcbiAgcmV0dXJuIFdyID0gdHlwZW9mIFN5bWJvbCA9PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PSBcInN5bWJvbFwiID8gZnVuY3Rpb24odCkge1xuICAgIHJldHVybiB0eXBlb2YgdDtcbiAgfSA6IGZ1bmN0aW9uKHQpIHtcbiAgICByZXR1cm4gdCAmJiB0eXBlb2YgU3ltYm9sID09IFwiZnVuY3Rpb25cIiAmJiB0LmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgdCAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2YgdDtcbiAgfSwgV3IoZSk7XG59XG5mdW5jdGlvbiB2aChlLCB0KSB7XG4gIHZhciBuID0gT2JqZWN0LmtleXMoZSk7XG4gIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gICAgdmFyIHIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGUpO1xuICAgIHQgJiYgKHIgPSByLmZpbHRlcihmdW5jdGlvbihpKSB7XG4gICAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLCBpKS5lbnVtZXJhYmxlO1xuICAgIH0pKSwgbi5wdXNoLmFwcGx5KG4sIHIpO1xuICB9XG4gIHJldHVybiBuO1xufVxuZnVuY3Rpb24gbWgoZSkge1xuICBmb3IgKHZhciB0ID0gMTsgdCA8IGFyZ3VtZW50cy5sZW5ndGg7IHQrKykge1xuICAgIHZhciBuID0gYXJndW1lbnRzW3RdICE9IG51bGwgPyBhcmd1bWVudHNbdF0gOiB7fTtcbiAgICB0ICUgMiA/IHZoKE9iamVjdChuKSwgITApLmZvckVhY2goZnVuY3Rpb24ocikge1xuICAgICAgTGYoZSwgciwgbltyXSk7XG4gICAgfSkgOiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGUsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKG4pKSA6IHZoKE9iamVjdChuKSkuZm9yRWFjaChmdW5jdGlvbihyKSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgciwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihuLCByKSk7XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIGU7XG59XG5mdW5jdGlvbiBSTihlLCB0KSB7XG4gIGlmICghKGUgaW5zdGFuY2VvZiB0KSlcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xufVxuZnVuY3Rpb24gSU4oZSwgdCkge1xuICBmb3IgKHZhciBuID0gMDsgbiA8IHQubGVuZ3RoOyBuKyspIHtcbiAgICB2YXIgciA9IHRbbl07XG4gICAgci5lbnVtZXJhYmxlID0gci5lbnVtZXJhYmxlIHx8ICExLCByLmNvbmZpZ3VyYWJsZSA9ICEwLCBcInZhbHVlXCIgaW4gciAmJiAoci53cml0YWJsZSA9ICEwKSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIEdiKHIua2V5KSwgcik7XG4gIH1cbn1cbmZ1bmN0aW9uIGpOKGUsIHQsIG4pIHtcbiAgcmV0dXJuIHQgJiYgSU4oZS5wcm90b3R5cGUsIHQpLCBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgXCJwcm90b3R5cGVcIiwgeyB3cml0YWJsZTogITEgfSksIGU7XG59XG5mdW5jdGlvbiBrTihlLCB0LCBuKSB7XG4gIHJldHVybiB0ID0gWGEodCksIEROKGUsIFZiKCkgPyBSZWZsZWN0LmNvbnN0cnVjdCh0LCBuIHx8IFtdLCBYYShlKS5jb25zdHJ1Y3RvcikgOiB0LmFwcGx5KGUsIG4pKTtcbn1cbmZ1bmN0aW9uIEROKGUsIHQpIHtcbiAgaWYgKHQgJiYgKFdyKHQpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiB0ID09IFwiZnVuY3Rpb25cIikpXG4gICAgcmV0dXJuIHQ7XG4gIGlmICh0ICE9PSB2b2lkIDApXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkRlcml2ZWQgY29uc3RydWN0b3JzIG1heSBvbmx5IHJldHVybiBvYmplY3Qgb3IgdW5kZWZpbmVkXCIpO1xuICByZXR1cm4gTk4oZSk7XG59XG5mdW5jdGlvbiBOTihlKSB7XG4gIGlmIChlID09PSB2b2lkIDApXG4gICAgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpO1xuICByZXR1cm4gZTtcbn1cbmZ1bmN0aW9uIFZiKCkge1xuICB0cnkge1xuICAgIHZhciBlID0gIUJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24oKSB7XG4gICAgfSkpO1xuICB9IGNhdGNoIHtcbiAgfVxuICByZXR1cm4gKFZiID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuICEhZTtcbiAgfSkoKTtcbn1cbmZ1bmN0aW9uIFhhKGUpIHtcbiAgcmV0dXJuIFhhID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mLmJpbmQoKSA6IGZ1bmN0aW9uKG4pIHtcbiAgICByZXR1cm4gbi5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG4pO1xuICB9LCBYYShlKTtcbn1cbmZ1bmN0aW9uIEZOKGUsIHQpIHtcbiAgaWYgKHR5cGVvZiB0ICE9IFwiZnVuY3Rpb25cIiAmJiB0ICE9PSBudWxsKVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTtcbiAgZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHQgJiYgdC5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IGUsIHdyaXRhYmxlOiAhMCwgY29uZmlndXJhYmxlOiAhMCB9IH0pLCBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgXCJwcm90b3R5cGVcIiwgeyB3cml0YWJsZTogITEgfSksIHQgJiYgSmMoZSwgdCk7XG59XG5mdW5jdGlvbiBKYyhlLCB0KSB7XG4gIHJldHVybiBKYyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZi5iaW5kKCkgOiBmdW5jdGlvbihyLCBpKSB7XG4gICAgcmV0dXJuIHIuX19wcm90b19fID0gaSwgcjtcbiAgfSwgSmMoZSwgdCk7XG59XG5mdW5jdGlvbiBMZihlLCB0LCBuKSB7XG4gIHJldHVybiB0ID0gR2IodCksIHQgaW4gZSA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCB0LCB7IHZhbHVlOiBuLCBlbnVtZXJhYmxlOiAhMCwgY29uZmlndXJhYmxlOiAhMCwgd3JpdGFibGU6ICEwIH0pIDogZVt0XSA9IG4sIGU7XG59XG5mdW5jdGlvbiBHYihlKSB7XG4gIHZhciB0ID0gTE4oZSwgXCJzdHJpbmdcIik7XG4gIHJldHVybiBXcih0KSA9PSBcInN5bWJvbFwiID8gdCA6IFN0cmluZyh0KTtcbn1cbmZ1bmN0aW9uIExOKGUsIHQpIHtcbiAgaWYgKFdyKGUpICE9IFwib2JqZWN0XCIgfHwgIWUpXG4gICAgcmV0dXJuIGU7XG4gIHZhciBuID0gZVtTeW1ib2wudG9QcmltaXRpdmVdO1xuICBpZiAobiAhPT0gdm9pZCAwKSB7XG4gICAgdmFyIHIgPSBuLmNhbGwoZSwgdCB8fCBcImRlZmF1bHRcIik7XG4gICAgaWYgKFdyKHIpICE9IFwib2JqZWN0XCIpXG4gICAgICByZXR1cm4gcjtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQEB0b1ByaW1pdGl2ZSBtdXN0IHJldHVybiBhIHByaW1pdGl2ZSB2YWx1ZS5cIik7XG4gIH1cbiAgcmV0dXJuICh0ID09PSBcInN0cmluZ1wiID8gU3RyaW5nIDogTnVtYmVyKShlKTtcbn1cbmZ1bmN0aW9uIEJOKGUpIHtcbiAgcmV0dXJuIGUuZGF0YUtleTtcbn1cbmZ1bmN0aW9uIHpOKGUsIHQpIHtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBQLmlzVmFsaWRFbGVtZW50KGUpID8gLyogQF9fUFVSRV9fICovIFAuY2xvbmVFbGVtZW50KGUsIHQpIDogdHlwZW9mIGUgPT0gXCJmdW5jdGlvblwiID8gLyogQF9fUFVSRV9fICovIFAuY3JlYXRlRWxlbWVudChlLCB0KSA6IC8qIEBfX1BVUkVfXyAqLyBQLmNyZWF0ZUVsZW1lbnQodk4sIHQpO1xufVxudmFyIHRuID0gLyogQF9fUFVSRV9fICovIGZ1bmN0aW9uKGUpIHtcbiAgRk4odCwgZSk7XG4gIGZ1bmN0aW9uIHQoKSB7XG4gICAgcmV0dXJuIFJOKHRoaXMsIHQpLCBrTih0aGlzLCB0LCBhcmd1bWVudHMpO1xuICB9XG4gIHJldHVybiBqTih0LCBbe1xuICAgIGtleTogXCJyZW5kZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgciA9IHRoaXMsIGkgPSB0aGlzLnByb3BzLCBvID0gaS5hY3RpdmUsIGEgPSBpLmFsbG93RXNjYXBlVmlld0JveCwgcyA9IGkuYW5pbWF0aW9uRHVyYXRpb24sIHUgPSBpLmFuaW1hdGlvbkVhc2luZywgYyA9IGkuY29udGVudCwgZiA9IGkuY29vcmRpbmF0ZSwgbCA9IGkuZmlsdGVyTnVsbCwgZCA9IGkuaXNBbmltYXRpb25BY3RpdmUsIHAgPSBpLm9mZnNldCwgZyA9IGkucGF5bG9hZCwgaCA9IGkucGF5bG9hZFVuaXFCeSwgdiA9IGkucG9zaXRpb24sIHcgPSBpLnJldmVyc2VEaXJlY3Rpb24sIGIgPSBpLnVzZVRyYW5zbGF0ZTNkLCB4ID0gaS52aWV3Qm94LCBtID0gaS53cmFwcGVyU3R5bGUsIHkgPSBnID8/IFtdO1xuICAgICAgbCAmJiB5Lmxlbmd0aCAmJiAoeSA9IE1iKGcuZmlsdGVyKGZ1bmN0aW9uKCQpIHtcbiAgICAgICAgcmV0dXJuICQudmFsdWUgIT0gbnVsbCAmJiAoJC5oaWRlICE9PSAhMCB8fCByLnByb3BzLmluY2x1ZGVIaWRkZW4pO1xuICAgICAgfSksIGgsIEJOKSk7XG4gICAgICB2YXIgUyA9IHkubGVuZ3RoID4gMDtcbiAgICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8gUC5jcmVhdGVFbGVtZW50KFROLCB7XG4gICAgICAgIGFsbG93RXNjYXBlVmlld0JveDogYSxcbiAgICAgICAgYW5pbWF0aW9uRHVyYXRpb246IHMsXG4gICAgICAgIGFuaW1hdGlvbkVhc2luZzogdSxcbiAgICAgICAgaXNBbmltYXRpb25BY3RpdmU6IGQsXG4gICAgICAgIGFjdGl2ZTogbyxcbiAgICAgICAgY29vcmRpbmF0ZTogZixcbiAgICAgICAgaGFzUGF5bG9hZDogUyxcbiAgICAgICAgb2Zmc2V0OiBwLFxuICAgICAgICBwb3NpdGlvbjogdixcbiAgICAgICAgcmV2ZXJzZURpcmVjdGlvbjogdyxcbiAgICAgICAgdXNlVHJhbnNsYXRlM2Q6IGIsXG4gICAgICAgIHZpZXdCb3g6IHgsXG4gICAgICAgIHdyYXBwZXJTdHlsZTogbVxuICAgICAgfSwgek4oYywgbWgobWgoe30sIHRoaXMucHJvcHMpLCB7fSwge1xuICAgICAgICBwYXlsb2FkOiB5XG4gICAgICB9KSkpO1xuICAgIH1cbiAgfV0pLCB0O1xufShXbik7XG5MZih0biwgXCJkaXNwbGF5TmFtZVwiLCBcIlRvb2x0aXBcIik7XG5MZih0biwgXCJkZWZhdWx0UHJvcHNcIiwge1xuICBhY2Nlc3NpYmlsaXR5TGF5ZXI6ICExLFxuICBhbGxvd0VzY2FwZVZpZXdCb3g6IHtcbiAgICB4OiAhMSxcbiAgICB5OiAhMVxuICB9LFxuICBhbmltYXRpb25EdXJhdGlvbjogNDAwLFxuICBhbmltYXRpb25FYXNpbmc6IFwiZWFzZVwiLFxuICBjb250ZW50U3R5bGU6IHt9LFxuICBjb29yZGluYXRlOiB7XG4gICAgeDogMCxcbiAgICB5OiAwXG4gIH0sXG4gIGN1cnNvcjogITAsXG4gIGN1cnNvclN0eWxlOiB7fSxcbiAgZmlsdGVyTnVsbDogITAsXG4gIGlzQW5pbWF0aW9uQWN0aXZlOiAheW4uaXNTc3IsXG4gIGl0ZW1TdHlsZToge30sXG4gIGxhYmVsU3R5bGU6IHt9LFxuICBvZmZzZXQ6IDEwLFxuICByZXZlcnNlRGlyZWN0aW9uOiB7XG4gICAgeDogITEsXG4gICAgeTogITFcbiAgfSxcbiAgc2VwYXJhdG9yOiBcIiA6IFwiLFxuICB0cmlnZ2VyOiBcImhvdmVyXCIsXG4gIHVzZVRyYW5zbGF0ZTNkOiAhMSxcbiAgdmlld0JveDoge1xuICAgIHg6IDAsXG4gICAgeTogMCxcbiAgICBoZWlnaHQ6IDAsXG4gICAgd2lkdGg6IDBcbiAgfSxcbiAgd3JhcHBlclN0eWxlOiB7fVxufSk7XG52YXIgVk4gPSBkbiwgR04gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIFZOLkRhdGUubm93KCk7XG59LCBXTiA9IEdOLCBVTiA9IC9cXHMvO1xuZnVuY3Rpb24gSE4oZSkge1xuICBmb3IgKHZhciB0ID0gZS5sZW5ndGg7IHQtLSAmJiBVTi50ZXN0KGUuY2hhckF0KHQpKTsgKVxuICAgIDtcbiAgcmV0dXJuIHQ7XG59XG52YXIgcU4gPSBITiwgS04gPSBxTiwgWU4gPSAvXlxccysvO1xuZnVuY3Rpb24gWE4oZSkge1xuICByZXR1cm4gZSAmJiBlLnNsaWNlKDAsIEtOKGUpICsgMSkucmVwbGFjZShZTiwgXCJcIik7XG59XG52YXIgWk4gPSBYTiwgSk4gPSBaTiwgeWggPSBVbiwgUU4gPSB1aSwgYmggPSBOYU4sIGVGID0gL15bLStdMHhbMC05YS1mXSskL2ksIHRGID0gL14wYlswMV0rJC9pLCBuRiA9IC9eMG9bMC03XSskL2ksIHJGID0gcGFyc2VJbnQ7XG5mdW5jdGlvbiBpRihlKSB7XG4gIGlmICh0eXBlb2YgZSA9PSBcIm51bWJlclwiKVxuICAgIHJldHVybiBlO1xuICBpZiAoUU4oZSkpXG4gICAgcmV0dXJuIGJoO1xuICBpZiAoeWgoZSkpIHtcbiAgICB2YXIgdCA9IHR5cGVvZiBlLnZhbHVlT2YgPT0gXCJmdW5jdGlvblwiID8gZS52YWx1ZU9mKCkgOiBlO1xuICAgIGUgPSB5aCh0KSA/IHQgKyBcIlwiIDogdDtcbiAgfVxuICBpZiAodHlwZW9mIGUgIT0gXCJzdHJpbmdcIilcbiAgICByZXR1cm4gZSA9PT0gMCA/IGUgOiArZTtcbiAgZSA9IEpOKGUpO1xuICB2YXIgbiA9IHRGLnRlc3QoZSk7XG4gIHJldHVybiBuIHx8IG5GLnRlc3QoZSkgPyByRihlLnNsaWNlKDIpLCBuID8gMiA6IDgpIDogZUYudGVzdChlKSA/IGJoIDogK2U7XG59XG52YXIgV2IgPSBpRiwgb0YgPSBVbiwga3UgPSBXTiwgd2ggPSBXYiwgYUYgPSBcIkV4cGVjdGVkIGEgZnVuY3Rpb25cIiwgc0YgPSBNYXRoLm1heCwgdUYgPSBNYXRoLm1pbjtcbmZ1bmN0aW9uIGNGKGUsIHQsIG4pIHtcbiAgdmFyIHIsIGksIG8sIGEsIHMsIHUsIGMgPSAwLCBmID0gITEsIGwgPSAhMSwgZCA9ICEwO1xuICBpZiAodHlwZW9mIGUgIT0gXCJmdW5jdGlvblwiKVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYUYpO1xuICB0ID0gd2godCkgfHwgMCwgb0YobikgJiYgKGYgPSAhIW4ubGVhZGluZywgbCA9IFwibWF4V2FpdFwiIGluIG4sIG8gPSBsID8gc0Yod2gobi5tYXhXYWl0KSB8fCAwLCB0KSA6IG8sIGQgPSBcInRyYWlsaW5nXCIgaW4gbiA/ICEhbi50cmFpbGluZyA6IGQpO1xuICBmdW5jdGlvbiBwKFMpIHtcbiAgICB2YXIgJCA9IHIsIE8gPSBpO1xuICAgIHJldHVybiByID0gaSA9IHZvaWQgMCwgYyA9IFMsIGEgPSBlLmFwcGx5KE8sICQpLCBhO1xuICB9XG4gIGZ1bmN0aW9uIGcoUykge1xuICAgIHJldHVybiBjID0gUywgcyA9IHNldFRpbWVvdXQodywgdCksIGYgPyBwKFMpIDogYTtcbiAgfVxuICBmdW5jdGlvbiBoKFMpIHtcbiAgICB2YXIgJCA9IFMgLSB1LCBPID0gUyAtIGMsIFQgPSB0IC0gJDtcbiAgICByZXR1cm4gbCA/IHVGKFQsIG8gLSBPKSA6IFQ7XG4gIH1cbiAgZnVuY3Rpb24gdihTKSB7XG4gICAgdmFyICQgPSBTIC0gdSwgTyA9IFMgLSBjO1xuICAgIHJldHVybiB1ID09PSB2b2lkIDAgfHwgJCA+PSB0IHx8ICQgPCAwIHx8IGwgJiYgTyA+PSBvO1xuICB9XG4gIGZ1bmN0aW9uIHcoKSB7XG4gICAgdmFyIFMgPSBrdSgpO1xuICAgIGlmICh2KFMpKVxuICAgICAgcmV0dXJuIGIoUyk7XG4gICAgcyA9IHNldFRpbWVvdXQodywgaChTKSk7XG4gIH1cbiAgZnVuY3Rpb24gYihTKSB7XG4gICAgcmV0dXJuIHMgPSB2b2lkIDAsIGQgJiYgciA/IHAoUykgOiAociA9IGkgPSB2b2lkIDAsIGEpO1xuICB9XG4gIGZ1bmN0aW9uIHgoKSB7XG4gICAgcyAhPT0gdm9pZCAwICYmIGNsZWFyVGltZW91dChzKSwgYyA9IDAsIHIgPSB1ID0gaSA9IHMgPSB2b2lkIDA7XG4gIH1cbiAgZnVuY3Rpb24gbSgpIHtcbiAgICByZXR1cm4gcyA9PT0gdm9pZCAwID8gYSA6IGIoa3UoKSk7XG4gIH1cbiAgZnVuY3Rpb24geSgpIHtcbiAgICB2YXIgUyA9IGt1KCksICQgPSB2KFMpO1xuICAgIGlmIChyID0gYXJndW1lbnRzLCBpID0gdGhpcywgdSA9IFMsICQpIHtcbiAgICAgIGlmIChzID09PSB2b2lkIDApXG4gICAgICAgIHJldHVybiBnKHUpO1xuICAgICAgaWYgKGwpXG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQocyksIHMgPSBzZXRUaW1lb3V0KHcsIHQpLCBwKHUpO1xuICAgIH1cbiAgICByZXR1cm4gcyA9PT0gdm9pZCAwICYmIChzID0gc2V0VGltZW91dCh3LCB0KSksIGE7XG4gIH1cbiAgcmV0dXJuIHkuY2FuY2VsID0geCwgeS5mbHVzaCA9IG0sIHk7XG59XG52YXIgbEYgPSBjRiwgZkYgPSBsRiwgZEYgPSBVbiwgcEYgPSBcIkV4cGVjdGVkIGEgZnVuY3Rpb25cIjtcbmZ1bmN0aW9uIGhGKGUsIHQsIG4pIHtcbiAgdmFyIHIgPSAhMCwgaSA9ICEwO1xuICBpZiAodHlwZW9mIGUgIT0gXCJmdW5jdGlvblwiKVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IocEYpO1xuICByZXR1cm4gZEYobikgJiYgKHIgPSBcImxlYWRpbmdcIiBpbiBuID8gISFuLmxlYWRpbmcgOiByLCBpID0gXCJ0cmFpbGluZ1wiIGluIG4gPyAhIW4udHJhaWxpbmcgOiBpKSwgZkYoZSwgdCwge1xuICAgIGxlYWRpbmc6IHIsXG4gICAgbWF4V2FpdDogdCxcbiAgICB0cmFpbGluZzogaVxuICB9KTtcbn1cbnZhciBnRiA9IGhGO1xuY29uc3QgdkYgPSAvKiBAX19QVVJFX18gKi8gamUoZ0YpO1xudmFyIFViID0gZnVuY3Rpb24odCkge1xuICByZXR1cm4gbnVsbDtcbn07XG5VYi5kaXNwbGF5TmFtZSA9IFwiQ2VsbFwiO1xuZnVuY3Rpb24gb28oZSkge1xuICBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7XG4gIHJldHVybiBvbyA9IHR5cGVvZiBTeW1ib2wgPT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uKHQpIHtcbiAgICByZXR1cm4gdHlwZW9mIHQ7XG4gIH0gOiBmdW5jdGlvbih0KSB7XG4gICAgcmV0dXJuIHQgJiYgdHlwZW9mIFN5bWJvbCA9PSBcImZ1bmN0aW9uXCIgJiYgdC5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIHQgIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIHQ7XG4gIH0sIG9vKGUpO1xufVxuZnVuY3Rpb24geGgoZSwgdCkge1xuICB2YXIgbiA9IE9iamVjdC5rZXlzKGUpO1xuICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykge1xuICAgIHZhciByID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhlKTtcbiAgICB0ICYmIChyID0gci5maWx0ZXIoZnVuY3Rpb24oaSkge1xuICAgICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSwgaSkuZW51bWVyYWJsZTtcbiAgICB9KSksIG4ucHVzaC5hcHBseShuLCByKTtcbiAgfVxuICByZXR1cm4gbjtcbn1cbmZ1bmN0aW9uIFFjKGUpIHtcbiAgZm9yICh2YXIgdCA9IDE7IHQgPCBhcmd1bWVudHMubGVuZ3RoOyB0KyspIHtcbiAgICB2YXIgbiA9IGFyZ3VtZW50c1t0XSAhPSBudWxsID8gYXJndW1lbnRzW3RdIDoge307XG4gICAgdCAlIDIgPyB4aChPYmplY3QobiksICEwKS5mb3JFYWNoKGZ1bmN0aW9uKHIpIHtcbiAgICAgIG1GKGUsIHIsIG5bcl0pO1xuICAgIH0pIDogT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhlLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhuKSkgOiB4aChPYmplY3QobikpLmZvckVhY2goZnVuY3Rpb24ocikge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIHIsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobiwgcikpO1xuICAgIH0pO1xuICB9XG4gIHJldHVybiBlO1xufVxuZnVuY3Rpb24gbUYoZSwgdCwgbikge1xuICByZXR1cm4gdCA9IHlGKHQpLCB0IGluIGUgPyBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgdCwgeyB2YWx1ZTogbiwgZW51bWVyYWJsZTogITAsIGNvbmZpZ3VyYWJsZTogITAsIHdyaXRhYmxlOiAhMCB9KSA6IGVbdF0gPSBuLCBlO1xufVxuZnVuY3Rpb24geUYoZSkge1xuICB2YXIgdCA9IGJGKGUsIFwic3RyaW5nXCIpO1xuICByZXR1cm4gb28odCkgPT0gXCJzeW1ib2xcIiA/IHQgOiBTdHJpbmcodCk7XG59XG5mdW5jdGlvbiBiRihlLCB0KSB7XG4gIGlmIChvbyhlKSAhPSBcIm9iamVjdFwiIHx8ICFlKVxuICAgIHJldHVybiBlO1xuICB2YXIgbiA9IGVbU3ltYm9sLnRvUHJpbWl0aXZlXTtcbiAgaWYgKG4gIT09IHZvaWQgMCkge1xuICAgIHZhciByID0gbi5jYWxsKGUsIHQgfHwgXCJkZWZhdWx0XCIpO1xuICAgIGlmIChvbyhyKSAhPSBcIm9iamVjdFwiKVxuICAgICAgcmV0dXJuIHI7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkBAdG9QcmltaXRpdmUgbXVzdCByZXR1cm4gYSBwcmltaXRpdmUgdmFsdWUuXCIpO1xuICB9XG4gIHJldHVybiAodCA9PT0gXCJzdHJpbmdcIiA/IFN0cmluZyA6IE51bWJlcikoZSk7XG59XG52YXIgT3IgPSB7XG4gIHdpZHRoQ2FjaGU6IHt9LFxuICBjYWNoZUNvdW50OiAwXG59LCB3RiA9IDJlMywgeEYgPSB7XG4gIHBvc2l0aW9uOiBcImFic29sdXRlXCIsXG4gIHRvcDogXCItMjAwMDBweFwiLFxuICBsZWZ0OiAwLFxuICBwYWRkaW5nOiAwLFxuICBtYXJnaW46IDAsXG4gIGJvcmRlcjogXCJub25lXCIsXG4gIHdoaXRlU3BhY2U6IFwicHJlXCJcbn0sIFNoID0gXCJyZWNoYXJ0c19tZWFzdXJlbWVudF9zcGFuXCI7XG5mdW5jdGlvbiBTRihlKSB7XG4gIHZhciB0ID0gUWMoe30sIGUpO1xuICByZXR1cm4gT2JqZWN0LmtleXModCkuZm9yRWFjaChmdW5jdGlvbihuKSB7XG4gICAgdFtuXSB8fCBkZWxldGUgdFtuXTtcbiAgfSksIHQ7XG59XG52YXIgR2kgPSBmdW5jdGlvbih0KSB7XG4gIHZhciBuID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB2b2lkIDAgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgaWYgKHQgPT0gbnVsbCB8fCB5bi5pc1NzcilcbiAgICByZXR1cm4ge1xuICAgICAgd2lkdGg6IDAsXG4gICAgICBoZWlnaHQ6IDBcbiAgICB9O1xuICB2YXIgciA9IFNGKG4pLCBpID0gSlNPTi5zdHJpbmdpZnkoe1xuICAgIHRleHQ6IHQsXG4gICAgY29weVN0eWxlOiByXG4gIH0pO1xuICBpZiAoT3Iud2lkdGhDYWNoZVtpXSlcbiAgICByZXR1cm4gT3Iud2lkdGhDYWNoZVtpXTtcbiAgdHJ5IHtcbiAgICB2YXIgbyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFNoKTtcbiAgICBvIHx8IChvID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIiksIG8uc2V0QXR0cmlidXRlKFwiaWRcIiwgU2gpLCBvLnNldEF0dHJpYnV0ZShcImFyaWEtaGlkZGVuXCIsIFwidHJ1ZVwiKSwgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChvKSk7XG4gICAgdmFyIGEgPSBRYyhRYyh7fSwgeEYpLCByKTtcbiAgICBPYmplY3QuYXNzaWduKG8uc3R5bGUsIGEpLCBvLnRleHRDb250ZW50ID0gXCJcIi5jb25jYXQodCk7XG4gICAgdmFyIHMgPSBvLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLCB1ID0ge1xuICAgICAgd2lkdGg6IHMud2lkdGgsXG4gICAgICBoZWlnaHQ6IHMuaGVpZ2h0XG4gICAgfTtcbiAgICByZXR1cm4gT3Iud2lkdGhDYWNoZVtpXSA9IHUsICsrT3IuY2FjaGVDb3VudCA+IHdGICYmIChPci5jYWNoZUNvdW50ID0gMCwgT3Iud2lkdGhDYWNoZSA9IHt9KSwgdTtcbiAgfSBjYXRjaCB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHdpZHRoOiAwLFxuICAgICAgaGVpZ2h0OiAwXG4gICAgfTtcbiAgfVxufSwgJEYgPSBmdW5jdGlvbih0KSB7XG4gIHJldHVybiB7XG4gICAgdG9wOiB0LnRvcCArIHdpbmRvdy5zY3JvbGxZIC0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudFRvcCxcbiAgICBsZWZ0OiB0LmxlZnQgKyB3aW5kb3cuc2Nyb2xsWCAtIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRMZWZ0XG4gIH07XG59O1xuZnVuY3Rpb24gYW8oZSkge1xuICBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7XG4gIHJldHVybiBhbyA9IHR5cGVvZiBTeW1ib2wgPT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uKHQpIHtcbiAgICByZXR1cm4gdHlwZW9mIHQ7XG4gIH0gOiBmdW5jdGlvbih0KSB7XG4gICAgcmV0dXJuIHQgJiYgdHlwZW9mIFN5bWJvbCA9PSBcImZ1bmN0aW9uXCIgJiYgdC5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIHQgIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIHQ7XG4gIH0sIGFvKGUpO1xufVxuZnVuY3Rpb24gWmEoZSwgdCkge1xuICByZXR1cm4gUEYoZSkgfHwgQUYoZSwgdCkgfHwgX0YoZSwgdCkgfHwgT0YoKTtcbn1cbmZ1bmN0aW9uIE9GKCkge1xuICB0aHJvdyBuZXcgVHlwZUVycm9yKGBJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLmApO1xufVxuZnVuY3Rpb24gX0YoZSwgdCkge1xuICBpZiAoZSkge1xuICAgIGlmICh0eXBlb2YgZSA9PSBcInN0cmluZ1wiKVxuICAgICAgcmV0dXJuICRoKGUsIHQpO1xuICAgIHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGUpLnNsaWNlKDgsIC0xKTtcbiAgICBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBlLmNvbnN0cnVjdG9yICYmIChuID0gZS5jb25zdHJ1Y3Rvci5uYW1lKSwgbiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKVxuICAgICAgcmV0dXJuIEFycmF5LmZyb20oZSk7XG4gICAgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpXG4gICAgICByZXR1cm4gJGgoZSwgdCk7XG4gIH1cbn1cbmZ1bmN0aW9uICRoKGUsIHQpIHtcbiAgKHQgPT0gbnVsbCB8fCB0ID4gZS5sZW5ndGgpICYmICh0ID0gZS5sZW5ndGgpO1xuICBmb3IgKHZhciBuID0gMCwgciA9IG5ldyBBcnJheSh0KTsgbiA8IHQ7IG4rKylcbiAgICByW25dID0gZVtuXTtcbiAgcmV0dXJuIHI7XG59XG5mdW5jdGlvbiBBRihlLCB0KSB7XG4gIHZhciBuID0gZSA9PSBudWxsID8gbnVsbCA6IHR5cGVvZiBTeW1ib2wgPCBcInVcIiAmJiBlW1N5bWJvbC5pdGVyYXRvcl0gfHwgZVtcIkBAaXRlcmF0b3JcIl07XG4gIGlmIChuICE9IG51bGwpIHtcbiAgICB2YXIgciwgaSwgbywgYSwgcyA9IFtdLCB1ID0gITAsIGMgPSAhMTtcbiAgICB0cnkge1xuICAgICAgaWYgKG8gPSAobiA9IG4uY2FsbChlKSkubmV4dCwgdCA9PT0gMCkge1xuICAgICAgICBpZiAoT2JqZWN0KG4pICE9PSBuKVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdSA9ICExO1xuICAgICAgfSBlbHNlXG4gICAgICAgIGZvciAoOyAhKHUgPSAociA9IG8uY2FsbChuKSkuZG9uZSkgJiYgKHMucHVzaChyLnZhbHVlKSwgcy5sZW5ndGggIT09IHQpOyB1ID0gITApXG4gICAgICAgICAgO1xuICAgIH0gY2F0Y2ggKGYpIHtcbiAgICAgIGMgPSAhMCwgaSA9IGY7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmICghdSAmJiBuLnJldHVybiAhPSBudWxsICYmIChhID0gbi5yZXR1cm4oKSwgT2JqZWN0KGEpICE9PSBhKSlcbiAgICAgICAgICByZXR1cm47XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBpZiAoYylcbiAgICAgICAgICB0aHJvdyBpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcztcbiAgfVxufVxuZnVuY3Rpb24gUEYoZSkge1xuICBpZiAoQXJyYXkuaXNBcnJheShlKSlcbiAgICByZXR1cm4gZTtcbn1cbmZ1bmN0aW9uIENGKGUsIHQpIHtcbiAgaWYgKCEoZSBpbnN0YW5jZW9mIHQpKVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XG59XG5mdW5jdGlvbiBPaChlLCB0KSB7XG4gIGZvciAodmFyIG4gPSAwOyBuIDwgdC5sZW5ndGg7IG4rKykge1xuICAgIHZhciByID0gdFtuXTtcbiAgICByLmVudW1lcmFibGUgPSByLmVudW1lcmFibGUgfHwgITEsIHIuY29uZmlndXJhYmxlID0gITAsIFwidmFsdWVcIiBpbiByICYmIChyLndyaXRhYmxlID0gITApLCBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgVEYoci5rZXkpLCByKTtcbiAgfVxufVxuZnVuY3Rpb24gRUYoZSwgdCwgbikge1xuICByZXR1cm4gdCAmJiBPaChlLnByb3RvdHlwZSwgdCksIG4gJiYgT2goZSwgbiksIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCBcInByb3RvdHlwZVwiLCB7IHdyaXRhYmxlOiAhMSB9KSwgZTtcbn1cbmZ1bmN0aW9uIFRGKGUpIHtcbiAgdmFyIHQgPSBNRihlLCBcInN0cmluZ1wiKTtcbiAgcmV0dXJuIGFvKHQpID09IFwic3ltYm9sXCIgPyB0IDogU3RyaW5nKHQpO1xufVxuZnVuY3Rpb24gTUYoZSwgdCkge1xuICBpZiAoYW8oZSkgIT0gXCJvYmplY3RcIiB8fCAhZSlcbiAgICByZXR1cm4gZTtcbiAgdmFyIG4gPSBlW1N5bWJvbC50b1ByaW1pdGl2ZV07XG4gIGlmIChuICE9PSB2b2lkIDApIHtcbiAgICB2YXIgciA9IG4uY2FsbChlLCB0KTtcbiAgICBpZiAoYW8ocikgIT0gXCJvYmplY3RcIilcbiAgICAgIHJldHVybiByO1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJAQHRvUHJpbWl0aXZlIG11c3QgcmV0dXJuIGEgcHJpbWl0aXZlIHZhbHVlLlwiKTtcbiAgfVxuICByZXR1cm4gU3RyaW5nKGUpO1xufVxudmFyIF9oID0gLygtP1xcZCsoPzpcXC5cXGQrKT9bYS16QS1aJV0qKShbKi9dKSgtP1xcZCsoPzpcXC5cXGQrKT9bYS16QS1aJV0qKS8sIEFoID0gLygtP1xcZCsoPzpcXC5cXGQrKT9bYS16QS1aJV0qKShbKy1dKSgtP1xcZCsoPzpcXC5cXGQrKT9bYS16QS1aJV0qKS8sIFJGID0gL15weHxjbXx2aHx2d3xlbXxyZW18JXxtbXxpbnxwdHxwY3xleHxjaHx2bWlufHZtYXh8USQvLCBJRiA9IC8oLT9cXGQrKD86XFwuXFxkKyk/KShbYS16QS1aJV0rKT8vLCBIYiA9IHtcbiAgY206IDk2IC8gMi41NCxcbiAgbW06IDk2IC8gMjUuNCxcbiAgcHQ6IDk2IC8gNzIsXG4gIHBjOiA5NiAvIDYsXG4gIGluOiA5NixcbiAgUTogOTYgLyAoMi41NCAqIDQwKSxcbiAgcHg6IDFcbn0sIGpGID0gT2JqZWN0LmtleXMoSGIpLCBDciA9IFwiTmFOXCI7XG5mdW5jdGlvbiBrRihlLCB0KSB7XG4gIHJldHVybiBlICogSGJbdF07XG59XG52YXIgcGEgPSAvKiBAX19QVVJFX18gKi8gZnVuY3Rpb24oKSB7XG4gIGZ1bmN0aW9uIGUodCwgbikge1xuICAgIENGKHRoaXMsIGUpLCB0aGlzLm51bSA9IHQsIHRoaXMudW5pdCA9IG4sIHRoaXMubnVtID0gdCwgdGhpcy51bml0ID0gbiwgTnVtYmVyLmlzTmFOKHQpICYmICh0aGlzLnVuaXQgPSBcIlwiKSwgbiAhPT0gXCJcIiAmJiAhUkYudGVzdChuKSAmJiAodGhpcy5udW0gPSBOYU4sIHRoaXMudW5pdCA9IFwiXCIpLCBqRi5pbmNsdWRlcyhuKSAmJiAodGhpcy5udW0gPSBrRih0LCBuKSwgdGhpcy51bml0ID0gXCJweFwiKTtcbiAgfVxuICByZXR1cm4gRUYoZSwgW3tcbiAgICBrZXk6IFwiYWRkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uKG4pIHtcbiAgICAgIHJldHVybiB0aGlzLnVuaXQgIT09IG4udW5pdCA/IG5ldyBlKE5hTiwgXCJcIikgOiBuZXcgZSh0aGlzLm51bSArIG4ubnVtLCB0aGlzLnVuaXQpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzdWJ0cmFjdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbihuKSB7XG4gICAgICByZXR1cm4gdGhpcy51bml0ICE9PSBuLnVuaXQgPyBuZXcgZShOYU4sIFwiXCIpIDogbmV3IGUodGhpcy5udW0gLSBuLm51bSwgdGhpcy51bml0KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibXVsdGlwbHlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24obikge1xuICAgICAgcmV0dXJuIHRoaXMudW5pdCAhPT0gXCJcIiAmJiBuLnVuaXQgIT09IFwiXCIgJiYgdGhpcy51bml0ICE9PSBuLnVuaXQgPyBuZXcgZShOYU4sIFwiXCIpIDogbmV3IGUodGhpcy5udW0gKiBuLm51bSwgdGhpcy51bml0IHx8IG4udW5pdCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRpdmlkZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbihuKSB7XG4gICAgICByZXR1cm4gdGhpcy51bml0ICE9PSBcIlwiICYmIG4udW5pdCAhPT0gXCJcIiAmJiB0aGlzLnVuaXQgIT09IG4udW5pdCA/IG5ldyBlKE5hTiwgXCJcIikgOiBuZXcgZSh0aGlzLm51bSAvIG4ubnVtLCB0aGlzLnVuaXQgfHwgbi51bml0KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidG9TdHJpbmdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gXCJcIi5jb25jYXQodGhpcy5udW0pLmNvbmNhdCh0aGlzLnVuaXQpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJpc05hTlwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBOdW1iZXIuaXNOYU4odGhpcy5udW0pO1xuICAgIH1cbiAgfV0sIFt7XG4gICAga2V5OiBcInBhcnNlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uKG4pIHtcbiAgICAgIHZhciByLCBpID0gKHIgPSBJRi5leGVjKG4pKSAhPT0gbnVsbCAmJiByICE9PSB2b2lkIDAgPyByIDogW10sIG8gPSBaYShpLCAzKSwgYSA9IG9bMV0sIHMgPSBvWzJdO1xuICAgICAgcmV0dXJuIG5ldyBlKHBhcnNlRmxvYXQoYSksIHMgPz8gXCJcIik7XG4gICAgfVxuICB9XSksIGU7XG59KCk7XG5mdW5jdGlvbiBxYihlKSB7XG4gIGlmIChlLmluY2x1ZGVzKENyKSlcbiAgICByZXR1cm4gQ3I7XG4gIGZvciAodmFyIHQgPSBlOyB0LmluY2x1ZGVzKFwiKlwiKSB8fCB0LmluY2x1ZGVzKFwiL1wiKTsgKSB7XG4gICAgdmFyIG4sIHIgPSAobiA9IF9oLmV4ZWModCkpICE9PSBudWxsICYmIG4gIT09IHZvaWQgMCA/IG4gOiBbXSwgaSA9IFphKHIsIDQpLCBvID0gaVsxXSwgYSA9IGlbMl0sIHMgPSBpWzNdLCB1ID0gcGEucGFyc2UobyA/PyBcIlwiKSwgYyA9IHBhLnBhcnNlKHMgPz8gXCJcIiksIGYgPSBhID09PSBcIipcIiA/IHUubXVsdGlwbHkoYykgOiB1LmRpdmlkZShjKTtcbiAgICBpZiAoZi5pc05hTigpKVxuICAgICAgcmV0dXJuIENyO1xuICAgIHQgPSB0LnJlcGxhY2UoX2gsIGYudG9TdHJpbmcoKSk7XG4gIH1cbiAgZm9yICg7IHQuaW5jbHVkZXMoXCIrXCIpIHx8IC8uLVxcZCsoPzpcXC5cXGQrKT8vLnRlc3QodCk7ICkge1xuICAgIHZhciBsLCBkID0gKGwgPSBBaC5leGVjKHQpKSAhPT0gbnVsbCAmJiBsICE9PSB2b2lkIDAgPyBsIDogW10sIHAgPSBaYShkLCA0KSwgZyA9IHBbMV0sIGggPSBwWzJdLCB2ID0gcFszXSwgdyA9IHBhLnBhcnNlKGcgPz8gXCJcIiksIGIgPSBwYS5wYXJzZSh2ID8/IFwiXCIpLCB4ID0gaCA9PT0gXCIrXCIgPyB3LmFkZChiKSA6IHcuc3VidHJhY3QoYik7XG4gICAgaWYgKHguaXNOYU4oKSlcbiAgICAgIHJldHVybiBDcjtcbiAgICB0ID0gdC5yZXBsYWNlKEFoLCB4LnRvU3RyaW5nKCkpO1xuICB9XG4gIHJldHVybiB0O1xufVxudmFyIFBoID0gL1xcKChbXigpXSopXFwpLztcbmZ1bmN0aW9uIERGKGUpIHtcbiAgZm9yICh2YXIgdCA9IGU7IHQuaW5jbHVkZXMoXCIoXCIpOyApIHtcbiAgICB2YXIgbiA9IFBoLmV4ZWModCksIHIgPSBaYShuLCAyKSwgaSA9IHJbMV07XG4gICAgdCA9IHQucmVwbGFjZShQaCwgcWIoaSkpO1xuICB9XG4gIHJldHVybiB0O1xufVxuZnVuY3Rpb24gTkYoZSkge1xuICB2YXIgdCA9IGUucmVwbGFjZSgvXFxzKy9nLCBcIlwiKTtcbiAgcmV0dXJuIHQgPSBERih0KSwgdCA9IHFiKHQpLCB0O1xufVxuZnVuY3Rpb24gRkYoZSkge1xuICB0cnkge1xuICAgIHJldHVybiBORihlKTtcbiAgfSBjYXRjaCB7XG4gICAgcmV0dXJuIENyO1xuICB9XG59XG5mdW5jdGlvbiBEdShlKSB7XG4gIHZhciB0ID0gRkYoZS5zbGljZSg1LCAtMSkpO1xuICByZXR1cm4gdCA9PT0gQ3IgPyBcIlwiIDogdDtcbn1cbnZhciBMRiA9IFtcInhcIiwgXCJ5XCIsIFwibGluZUhlaWdodFwiLCBcImNhcEhlaWdodFwiLCBcInNjYWxlVG9GaXRcIiwgXCJ0ZXh0QW5jaG9yXCIsIFwidmVydGljYWxBbmNob3JcIiwgXCJmaWxsXCJdLCBCRiA9IFtcImR4XCIsIFwiZHlcIiwgXCJhbmdsZVwiLCBcImNsYXNzTmFtZVwiLCBcImJyZWFrQWxsXCJdO1xuZnVuY3Rpb24gZWwoKSB7XG4gIHJldHVybiBlbCA9IE9iamVjdC5hc3NpZ24gPyBPYmplY3QuYXNzaWduLmJpbmQoKSA6IGZ1bmN0aW9uKGUpIHtcbiAgICBmb3IgKHZhciB0ID0gMTsgdCA8IGFyZ3VtZW50cy5sZW5ndGg7IHQrKykge1xuICAgICAgdmFyIG4gPSBhcmd1bWVudHNbdF07XG4gICAgICBmb3IgKHZhciByIGluIG4pXG4gICAgICAgIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChuLCByKSAmJiAoZVtyXSA9IG5bcl0pO1xuICAgIH1cbiAgICByZXR1cm4gZTtcbiAgfSwgZWwuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cbmZ1bmN0aW9uIENoKGUsIHQpIHtcbiAgaWYgKGUgPT0gbnVsbClcbiAgICByZXR1cm4ge307XG4gIHZhciBuID0gekYoZSwgdCksIHIsIGk7XG4gIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gICAgdmFyIG8gPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGUpO1xuICAgIGZvciAoaSA9IDA7IGkgPCBvLmxlbmd0aDsgaSsrKVxuICAgICAgciA9IG9baV0sICEodC5pbmRleE9mKHIpID49IDApICYmIE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChlLCByKSAmJiAobltyXSA9IGVbcl0pO1xuICB9XG4gIHJldHVybiBuO1xufVxuZnVuY3Rpb24gekYoZSwgdCkge1xuICBpZiAoZSA9PSBudWxsKVxuICAgIHJldHVybiB7fTtcbiAgdmFyIG4gPSB7fSwgciA9IE9iamVjdC5rZXlzKGUpLCBpLCBvO1xuICBmb3IgKG8gPSAwOyBvIDwgci5sZW5ndGg7IG8rKylcbiAgICBpID0gcltvXSwgISh0LmluZGV4T2YoaSkgPj0gMCkgJiYgKG5baV0gPSBlW2ldKTtcbiAgcmV0dXJuIG47XG59XG5mdW5jdGlvbiBFaChlLCB0KSB7XG4gIHJldHVybiBVRihlKSB8fCBXRihlLCB0KSB8fCBHRihlLCB0KSB8fCBWRigpO1xufVxuZnVuY3Rpb24gVkYoKSB7XG4gIHRocm93IG5ldyBUeXBlRXJyb3IoYEludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2UuXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuYCk7XG59XG5mdW5jdGlvbiBHRihlLCB0KSB7XG4gIGlmIChlKSB7XG4gICAgaWYgKHR5cGVvZiBlID09IFwic3RyaW5nXCIpXG4gICAgICByZXR1cm4gVGgoZSwgdCk7XG4gICAgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoZSkuc2xpY2UoOCwgLTEpO1xuICAgIGlmIChuID09PSBcIk9iamVjdFwiICYmIGUuY29uc3RydWN0b3IgJiYgKG4gPSBlLmNvbnN0cnVjdG9yLm5hbWUpLCBuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpXG4gICAgICByZXR1cm4gQXJyYXkuZnJvbShlKTtcbiAgICBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSlcbiAgICAgIHJldHVybiBUaChlLCB0KTtcbiAgfVxufVxuZnVuY3Rpb24gVGgoZSwgdCkge1xuICAodCA9PSBudWxsIHx8IHQgPiBlLmxlbmd0aCkgJiYgKHQgPSBlLmxlbmd0aCk7XG4gIGZvciAodmFyIG4gPSAwLCByID0gbmV3IEFycmF5KHQpOyBuIDwgdDsgbisrKVxuICAgIHJbbl0gPSBlW25dO1xuICByZXR1cm4gcjtcbn1cbmZ1bmN0aW9uIFdGKGUsIHQpIHtcbiAgdmFyIG4gPSBlID09IG51bGwgPyBudWxsIDogdHlwZW9mIFN5bWJvbCA8IFwidVwiICYmIGVbU3ltYm9sLml0ZXJhdG9yXSB8fCBlW1wiQEBpdGVyYXRvclwiXTtcbiAgaWYgKG4gIT0gbnVsbCkge1xuICAgIHZhciByLCBpLCBvLCBhLCBzID0gW10sIHUgPSAhMCwgYyA9ICExO1xuICAgIHRyeSB7XG4gICAgICBpZiAobyA9IChuID0gbi5jYWxsKGUpKS5uZXh0LCB0ID09PSAwKSB7XG4gICAgICAgIGlmIChPYmplY3QobikgIT09IG4pXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB1ID0gITE7XG4gICAgICB9IGVsc2VcbiAgICAgICAgZm9yICg7ICEodSA9IChyID0gby5jYWxsKG4pKS5kb25lKSAmJiAocy5wdXNoKHIudmFsdWUpLCBzLmxlbmd0aCAhPT0gdCk7IHUgPSAhMClcbiAgICAgICAgICA7XG4gICAgfSBjYXRjaCAoZikge1xuICAgICAgYyA9ICEwLCBpID0gZjtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKCF1ICYmIG4ucmV0dXJuICE9IG51bGwgJiYgKGEgPSBuLnJldHVybigpLCBPYmplY3QoYSkgIT09IGEpKVxuICAgICAgICAgIHJldHVybjtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGlmIChjKVxuICAgICAgICAgIHRocm93IGk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzO1xuICB9XG59XG5mdW5jdGlvbiBVRihlKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGUpKVxuICAgIHJldHVybiBlO1xufVxudmFyIEtiID0gL1sgXFxmXFxuXFxyXFx0XFx2XFx1MjAyOFxcdTIwMjldKy8sIFliID0gZnVuY3Rpb24odCkge1xuICB2YXIgbiA9IHQuY2hpbGRyZW4sIHIgPSB0LmJyZWFrQWxsLCBpID0gdC5zdHlsZTtcbiAgdHJ5IHtcbiAgICB2YXIgbyA9IFtdO1xuICAgIG1lKG4pIHx8IChyID8gbyA9IG4udG9TdHJpbmcoKS5zcGxpdChcIlwiKSA6IG8gPSBuLnRvU3RyaW5nKCkuc3BsaXQoS2IpKTtcbiAgICB2YXIgYSA9IG8ubWFwKGZ1bmN0aW9uKHUpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHdvcmQ6IHUsXG4gICAgICAgIHdpZHRoOiBHaSh1LCBpKS53aWR0aFxuICAgICAgfTtcbiAgICB9KSwgcyA9IHIgPyAwIDogR2koXCLCoFwiLCBpKS53aWR0aDtcbiAgICByZXR1cm4ge1xuICAgICAgd29yZHNXaXRoQ29tcHV0ZWRXaWR0aDogYSxcbiAgICAgIHNwYWNlV2lkdGg6IHNcbiAgICB9O1xuICB9IGNhdGNoIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufSwgSEYgPSBmdW5jdGlvbih0LCBuLCByLCBpLCBvKSB7XG4gIHZhciBhID0gdC5tYXhMaW5lcywgcyA9IHQuY2hpbGRyZW4sIHUgPSB0LnN0eWxlLCBjID0gdC5icmVha0FsbCwgZiA9IEsoYSksIGwgPSBzLCBkID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIE4gPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHZvaWQgMCA/IGFyZ3VtZW50c1swXSA6IFtdO1xuICAgIHJldHVybiBOLnJlZHVjZShmdW5jdGlvbihrLCBGKSB7XG4gICAgICB2YXIgViA9IEYud29yZCwgTCA9IEYud2lkdGgsIEkgPSBrW2subGVuZ3RoIC0gMV07XG4gICAgICBpZiAoSSAmJiAoaSA9PSBudWxsIHx8IG8gfHwgSS53aWR0aCArIEwgKyByIDwgTnVtYmVyKGkpKSlcbiAgICAgICAgSS53b3Jkcy5wdXNoKFYpLCBJLndpZHRoICs9IEwgKyByO1xuICAgICAgZWxzZSB7XG4gICAgICAgIHZhciBEID0ge1xuICAgICAgICAgIHdvcmRzOiBbVl0sXG4gICAgICAgICAgd2lkdGg6IExcbiAgICAgICAgfTtcbiAgICAgICAgay5wdXNoKEQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGs7XG4gICAgfSwgW10pO1xuICB9LCBwID0gZChuKSwgZyA9IGZ1bmN0aW9uKE4pIHtcbiAgICByZXR1cm4gTi5yZWR1Y2UoZnVuY3Rpb24oaywgRikge1xuICAgICAgcmV0dXJuIGsud2lkdGggPiBGLndpZHRoID8gayA6IEY7XG4gICAgfSk7XG4gIH07XG4gIGlmICghZilcbiAgICByZXR1cm4gcDtcbiAgZm9yICh2YXIgaCA9IFwi4oCmXCIsIHYgPSBmdW5jdGlvbihOKSB7XG4gICAgdmFyIGsgPSBsLnNsaWNlKDAsIE4pLCBGID0gWWIoe1xuICAgICAgYnJlYWtBbGw6IGMsXG4gICAgICBzdHlsZTogdSxcbiAgICAgIGNoaWxkcmVuOiBrICsgaFxuICAgIH0pLndvcmRzV2l0aENvbXB1dGVkV2lkdGgsIFYgPSBkKEYpLCBMID0gVi5sZW5ndGggPiBhIHx8IGcoVikud2lkdGggPiBOdW1iZXIoaSk7XG4gICAgcmV0dXJuIFtMLCBWXTtcbiAgfSwgdyA9IDAsIGIgPSBsLmxlbmd0aCAtIDEsIHggPSAwLCBtOyB3IDw9IGIgJiYgeCA8PSBsLmxlbmd0aCAtIDE7ICkge1xuICAgIHZhciB5ID0gTWF0aC5mbG9vcigodyArIGIpIC8gMiksIFMgPSB5IC0gMSwgJCA9IHYoUyksIE8gPSBFaCgkLCAyKSwgVCA9IE9bMF0sIE0gPSBPWzFdLCBFID0gdih5KSwgQSA9IEVoKEUsIDEpLCBqID0gQVswXTtcbiAgICBpZiAoIVQgJiYgIWogJiYgKHcgPSB5ICsgMSksIFQgJiYgaiAmJiAoYiA9IHkgLSAxKSwgIVQgJiYgaikge1xuICAgICAgbSA9IE07XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgeCsrO1xuICB9XG4gIHJldHVybiBtIHx8IHA7XG59LCBNaCA9IGZ1bmN0aW9uKHQpIHtcbiAgdmFyIG4gPSBtZSh0KSA/IFtdIDogdC50b1N0cmluZygpLnNwbGl0KEtiKTtcbiAgcmV0dXJuIFt7XG4gICAgd29yZHM6IG5cbiAgfV07XG59LCBxRiA9IGZ1bmN0aW9uKHQpIHtcbiAgdmFyIG4gPSB0LndpZHRoLCByID0gdC5zY2FsZVRvRml0LCBpID0gdC5jaGlsZHJlbiwgbyA9IHQuc3R5bGUsIGEgPSB0LmJyZWFrQWxsLCBzID0gdC5tYXhMaW5lcztcbiAgaWYgKChuIHx8IHIpICYmICF5bi5pc1Nzcikge1xuICAgIHZhciB1LCBjLCBmID0gWWIoe1xuICAgICAgYnJlYWtBbGw6IGEsXG4gICAgICBjaGlsZHJlbjogaSxcbiAgICAgIHN0eWxlOiBvXG4gICAgfSk7XG4gICAgaWYgKGYpIHtcbiAgICAgIHZhciBsID0gZi53b3Jkc1dpdGhDb21wdXRlZFdpZHRoLCBkID0gZi5zcGFjZVdpZHRoO1xuICAgICAgdSA9IGwsIGMgPSBkO1xuICAgIH0gZWxzZVxuICAgICAgcmV0dXJuIE1oKGkpO1xuICAgIHJldHVybiBIRih7XG4gICAgICBicmVha0FsbDogYSxcbiAgICAgIGNoaWxkcmVuOiBpLFxuICAgICAgbWF4TGluZXM6IHMsXG4gICAgICBzdHlsZTogb1xuICAgIH0sIHUsIGMsIG4sIHIpO1xuICB9XG4gIHJldHVybiBNaChpKTtcbn0sIFJoID0gXCIjODA4MDgwXCIsIEphID0gZnVuY3Rpb24odCkge1xuICB2YXIgbiA9IHQueCwgciA9IG4gPT09IHZvaWQgMCA/IDAgOiBuLCBpID0gdC55LCBvID0gaSA9PT0gdm9pZCAwID8gMCA6IGksIGEgPSB0LmxpbmVIZWlnaHQsIHMgPSBhID09PSB2b2lkIDAgPyBcIjFlbVwiIDogYSwgdSA9IHQuY2FwSGVpZ2h0LCBjID0gdSA9PT0gdm9pZCAwID8gXCIwLjcxZW1cIiA6IHUsIGYgPSB0LnNjYWxlVG9GaXQsIGwgPSBmID09PSB2b2lkIDAgPyAhMSA6IGYsIGQgPSB0LnRleHRBbmNob3IsIHAgPSBkID09PSB2b2lkIDAgPyBcInN0YXJ0XCIgOiBkLCBnID0gdC52ZXJ0aWNhbEFuY2hvciwgaCA9IGcgPT09IHZvaWQgMCA/IFwiZW5kXCIgOiBnLCB2ID0gdC5maWxsLCB3ID0gdiA9PT0gdm9pZCAwID8gUmggOiB2LCBiID0gQ2godCwgTEYpLCB4ID0gWGkoZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHFGKHtcbiAgICAgIGJyZWFrQWxsOiBiLmJyZWFrQWxsLFxuICAgICAgY2hpbGRyZW46IGIuY2hpbGRyZW4sXG4gICAgICBtYXhMaW5lczogYi5tYXhMaW5lcyxcbiAgICAgIHNjYWxlVG9GaXQ6IGwsXG4gICAgICBzdHlsZTogYi5zdHlsZSxcbiAgICAgIHdpZHRoOiBiLndpZHRoXG4gICAgfSk7XG4gIH0sIFtiLmJyZWFrQWxsLCBiLmNoaWxkcmVuLCBiLm1heExpbmVzLCBsLCBiLnN0eWxlLCBiLndpZHRoXSksIG0gPSBiLmR4LCB5ID0gYi5keSwgUyA9IGIuYW5nbGUsICQgPSBiLmNsYXNzTmFtZSwgTyA9IGIuYnJlYWtBbGwsIFQgPSBDaChiLCBCRik7XG4gIGlmICghS2UocikgfHwgIUtlKG8pKVxuICAgIHJldHVybiBudWxsO1xuICB2YXIgTSA9IHIgKyAoSyhtKSA/IG0gOiAwKSwgRSA9IG8gKyAoSyh5KSA/IHkgOiAwKSwgQTtcbiAgc3dpdGNoIChoKSB7XG4gICAgY2FzZSBcInN0YXJ0XCI6XG4gICAgICBBID0gRHUoXCJjYWxjKFwiLmNvbmNhdChjLCBcIilcIikpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcIm1pZGRsZVwiOlxuICAgICAgQSA9IER1KFwiY2FsYyhcIi5jb25jYXQoKHgubGVuZ3RoIC0gMSkgLyAyLCBcIiAqIC1cIikuY29uY2F0KHMsIFwiICsgKFwiKS5jb25jYXQoYywgXCIgLyAyKSlcIikpO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIEEgPSBEdShcImNhbGMoXCIuY29uY2F0KHgubGVuZ3RoIC0gMSwgXCIgKiAtXCIpLmNvbmNhdChzLCBcIilcIikpO1xuICAgICAgYnJlYWs7XG4gIH1cbiAgdmFyIGogPSBbXTtcbiAgaWYgKGwpIHtcbiAgICB2YXIgUiA9IHhbMF0ud2lkdGgsIE4gPSBiLndpZHRoO1xuICAgIGoucHVzaChcInNjYWxlKFwiLmNvbmNhdCgoSyhOKSA/IE4gLyBSIDogMSkgLyBSLCBcIilcIikpO1xuICB9XG4gIHJldHVybiBTICYmIGoucHVzaChcInJvdGF0ZShcIi5jb25jYXQoUywgXCIsIFwiKS5jb25jYXQoTSwgXCIsIFwiKS5jb25jYXQoRSwgXCIpXCIpKSwgai5sZW5ndGggJiYgKFQudHJhbnNmb3JtID0gai5qb2luKFwiIFwiKSksIC8qIEBfX1BVUkVfXyAqLyBQLmNyZWF0ZUVsZW1lbnQoXCJ0ZXh0XCIsIGVsKHt9LCB5ZShULCAhMCksIHtcbiAgICB4OiBNLFxuICAgIHk6IEUsXG4gICAgY2xhc3NOYW1lOiAkZShcInJlY2hhcnRzLXRleHRcIiwgJCksXG4gICAgdGV4dEFuY2hvcjogcCxcbiAgICBmaWxsOiB3LmluY2x1ZGVzKFwidXJsXCIpID8gUmggOiB3XG4gIH0pLCB4Lm1hcChmdW5jdGlvbihrLCBGKSB7XG4gICAgdmFyIFYgPSBrLndvcmRzLmpvaW4oTyA/IFwiXCIgOiBcIiBcIik7XG4gICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBQLmNyZWF0ZUVsZW1lbnQoXCJ0c3BhblwiLCB7XG4gICAgICB4OiBNLFxuICAgICAgZHk6IEYgPT09IDAgPyBBIDogcyxcbiAgICAgIGtleTogVlxuICAgIH0sIFYpO1xuICB9KSk7XG59O1xuZnVuY3Rpb24gTG4oZSwgdCkge1xuICByZXR1cm4gZSA9PSBudWxsIHx8IHQgPT0gbnVsbCA/IE5hTiA6IGUgPCB0ID8gLTEgOiBlID4gdCA/IDEgOiBlID49IHQgPyAwIDogTmFOO1xufVxuZnVuY3Rpb24gS0YoZSwgdCkge1xuICByZXR1cm4gZSA9PSBudWxsIHx8IHQgPT0gbnVsbCA/IE5hTiA6IHQgPCBlID8gLTEgOiB0ID4gZSA/IDEgOiB0ID49IGUgPyAwIDogTmFOO1xufVxuZnVuY3Rpb24gQmYoZSkge1xuICBsZXQgdCwgbiwgcjtcbiAgZS5sZW5ndGggIT09IDIgPyAodCA9IExuLCBuID0gKHMsIHUpID0+IExuKGUocyksIHUpLCByID0gKHMsIHUpID0+IGUocykgLSB1KSA6ICh0ID0gZSA9PT0gTG4gfHwgZSA9PT0gS0YgPyBlIDogWUYsIG4gPSBlLCByID0gZSk7XG4gIGZ1bmN0aW9uIGkocywgdSwgYyA9IDAsIGYgPSBzLmxlbmd0aCkge1xuICAgIGlmIChjIDwgZikge1xuICAgICAgaWYgKHQodSwgdSkgIT09IDApXG4gICAgICAgIHJldHVybiBmO1xuICAgICAgZG8ge1xuICAgICAgICBjb25zdCBsID0gYyArIGYgPj4+IDE7XG4gICAgICAgIG4oc1tsXSwgdSkgPCAwID8gYyA9IGwgKyAxIDogZiA9IGw7XG4gICAgICB9IHdoaWxlIChjIDwgZik7XG4gICAgfVxuICAgIHJldHVybiBjO1xuICB9XG4gIGZ1bmN0aW9uIG8ocywgdSwgYyA9IDAsIGYgPSBzLmxlbmd0aCkge1xuICAgIGlmIChjIDwgZikge1xuICAgICAgaWYgKHQodSwgdSkgIT09IDApXG4gICAgICAgIHJldHVybiBmO1xuICAgICAgZG8ge1xuICAgICAgICBjb25zdCBsID0gYyArIGYgPj4+IDE7XG4gICAgICAgIG4oc1tsXSwgdSkgPD0gMCA/IGMgPSBsICsgMSA6IGYgPSBsO1xuICAgICAgfSB3aGlsZSAoYyA8IGYpO1xuICAgIH1cbiAgICByZXR1cm4gYztcbiAgfVxuICBmdW5jdGlvbiBhKHMsIHUsIGMgPSAwLCBmID0gcy5sZW5ndGgpIHtcbiAgICBjb25zdCBsID0gaShzLCB1LCBjLCBmIC0gMSk7XG4gICAgcmV0dXJuIGwgPiBjICYmIHIoc1tsIC0gMV0sIHUpID4gLXIoc1tsXSwgdSkgPyBsIC0gMSA6IGw7XG4gIH1cbiAgcmV0dXJuIHsgbGVmdDogaSwgY2VudGVyOiBhLCByaWdodDogbyB9O1xufVxuZnVuY3Rpb24gWUYoKSB7XG4gIHJldHVybiAwO1xufVxuZnVuY3Rpb24gWGIoZSkge1xuICByZXR1cm4gZSA9PT0gbnVsbCA/IE5hTiA6ICtlO1xufVxuZnVuY3Rpb24qIFhGKGUsIHQpIHtcbiAgZm9yIChsZXQgbiBvZiBlKVxuICAgIG4gIT0gbnVsbCAmJiAobiA9ICtuKSA+PSBuICYmICh5aWVsZCBuKTtcbn1cbmNvbnN0IFpGID0gQmYoTG4pLCBxbyA9IFpGLnJpZ2h0O1xuQmYoWGIpLmNlbnRlcjtcbmNsYXNzIEloIGV4dGVuZHMgTWFwIHtcbiAgY29uc3RydWN0b3IodCwgbiA9IGVMKSB7XG4gICAgaWYgKHN1cGVyKCksIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHsgX2ludGVybjogeyB2YWx1ZTogLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSB9LCBfa2V5OiB7IHZhbHVlOiBuIH0gfSksIHQgIT0gbnVsbClcbiAgICAgIGZvciAoY29uc3QgW3IsIGldIG9mIHQpXG4gICAgICAgIHRoaXMuc2V0KHIsIGkpO1xuICB9XG4gIGdldCh0KSB7XG4gICAgcmV0dXJuIHN1cGVyLmdldChqaCh0aGlzLCB0KSk7XG4gIH1cbiAgaGFzKHQpIHtcbiAgICByZXR1cm4gc3VwZXIuaGFzKGpoKHRoaXMsIHQpKTtcbiAgfVxuICBzZXQodCwgbikge1xuICAgIHJldHVybiBzdXBlci5zZXQoSkYodGhpcywgdCksIG4pO1xuICB9XG4gIGRlbGV0ZSh0KSB7XG4gICAgcmV0dXJuIHN1cGVyLmRlbGV0ZShRRih0aGlzLCB0KSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGpoKHsgX2ludGVybjogZSwgX2tleTogdCB9LCBuKSB7XG4gIGNvbnN0IHIgPSB0KG4pO1xuICByZXR1cm4gZS5oYXMocikgPyBlLmdldChyKSA6IG47XG59XG5mdW5jdGlvbiBKRih7IF9pbnRlcm46IGUsIF9rZXk6IHQgfSwgbikge1xuICBjb25zdCByID0gdChuKTtcbiAgcmV0dXJuIGUuaGFzKHIpID8gZS5nZXQocikgOiAoZS5zZXQociwgbiksIG4pO1xufVxuZnVuY3Rpb24gUUYoeyBfaW50ZXJuOiBlLCBfa2V5OiB0IH0sIG4pIHtcbiAgY29uc3QgciA9IHQobik7XG4gIHJldHVybiBlLmhhcyhyKSAmJiAobiA9IGUuZ2V0KHIpLCBlLmRlbGV0ZShyKSksIG47XG59XG5mdW5jdGlvbiBlTChlKSB7XG4gIHJldHVybiBlICE9PSBudWxsICYmIHR5cGVvZiBlID09IFwib2JqZWN0XCIgPyBlLnZhbHVlT2YoKSA6IGU7XG59XG5mdW5jdGlvbiB0TChlID0gTG4pIHtcbiAgaWYgKGUgPT09IExuKVxuICAgIHJldHVybiBaYjtcbiAgaWYgKHR5cGVvZiBlICE9IFwiZnVuY3Rpb25cIilcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiY29tcGFyZSBpcyBub3QgYSBmdW5jdGlvblwiKTtcbiAgcmV0dXJuICh0LCBuKSA9PiB7XG4gICAgY29uc3QgciA9IGUodCwgbik7XG4gICAgcmV0dXJuIHIgfHwgciA9PT0gMCA/IHIgOiAoZShuLCBuKSA9PT0gMCkgLSAoZSh0LCB0KSA9PT0gMCk7XG4gIH07XG59XG5mdW5jdGlvbiBaYihlLCB0KSB7XG4gIHJldHVybiAoZSA9PSBudWxsIHx8ICEoZSA+PSBlKSkgLSAodCA9PSBudWxsIHx8ICEodCA+PSB0KSkgfHwgKGUgPCB0ID8gLTEgOiBlID4gdCA/IDEgOiAwKTtcbn1cbmNvbnN0IG5MID0gTWF0aC5zcXJ0KDUwKSwgckwgPSBNYXRoLnNxcnQoMTApLCBpTCA9IE1hdGguc3FydCgyKTtcbmZ1bmN0aW9uIFFhKGUsIHQsIG4pIHtcbiAgY29uc3QgciA9ICh0IC0gZSkgLyBNYXRoLm1heCgwLCBuKSwgaSA9IE1hdGguZmxvb3IoTWF0aC5sb2cxMChyKSksIG8gPSByIC8gTWF0aC5wb3coMTAsIGkpLCBhID0gbyA+PSBuTCA/IDEwIDogbyA+PSByTCA/IDUgOiBvID49IGlMID8gMiA6IDE7XG4gIGxldCBzLCB1LCBjO1xuICByZXR1cm4gaSA8IDAgPyAoYyA9IE1hdGgucG93KDEwLCAtaSkgLyBhLCBzID0gTWF0aC5yb3VuZChlICogYyksIHUgPSBNYXRoLnJvdW5kKHQgKiBjKSwgcyAvIGMgPCBlICYmICsrcywgdSAvIGMgPiB0ICYmIC0tdSwgYyA9IC1jKSA6IChjID0gTWF0aC5wb3coMTAsIGkpICogYSwgcyA9IE1hdGgucm91bmQoZSAvIGMpLCB1ID0gTWF0aC5yb3VuZCh0IC8gYyksIHMgKiBjIDwgZSAmJiArK3MsIHUgKiBjID4gdCAmJiAtLXUpLCB1IDwgcyAmJiAwLjUgPD0gbiAmJiBuIDwgMiA/IFFhKGUsIHQsIG4gKiAyKSA6IFtzLCB1LCBjXTtcbn1cbmZ1bmN0aW9uIHRsKGUsIHQsIG4pIHtcbiAgaWYgKHQgPSArdCwgZSA9ICtlLCBuID0gK24sICEobiA+IDApKVxuICAgIHJldHVybiBbXTtcbiAgaWYgKGUgPT09IHQpXG4gICAgcmV0dXJuIFtlXTtcbiAgY29uc3QgciA9IHQgPCBlLCBbaSwgbywgYV0gPSByID8gUWEodCwgZSwgbikgOiBRYShlLCB0LCBuKTtcbiAgaWYgKCEobyA+PSBpKSlcbiAgICByZXR1cm4gW107XG4gIGNvbnN0IHMgPSBvIC0gaSArIDEsIHUgPSBuZXcgQXJyYXkocyk7XG4gIGlmIChyKVxuICAgIGlmIChhIDwgMClcbiAgICAgIGZvciAobGV0IGMgPSAwOyBjIDwgczsgKytjKVxuICAgICAgICB1W2NdID0gKG8gLSBjKSAvIC1hO1xuICAgIGVsc2VcbiAgICAgIGZvciAobGV0IGMgPSAwOyBjIDwgczsgKytjKVxuICAgICAgICB1W2NdID0gKG8gLSBjKSAqIGE7XG4gIGVsc2UgaWYgKGEgPCAwKVxuICAgIGZvciAobGV0IGMgPSAwOyBjIDwgczsgKytjKVxuICAgICAgdVtjXSA9IChpICsgYykgLyAtYTtcbiAgZWxzZVxuICAgIGZvciAobGV0IGMgPSAwOyBjIDwgczsgKytjKVxuICAgICAgdVtjXSA9IChpICsgYykgKiBhO1xuICByZXR1cm4gdTtcbn1cbmZ1bmN0aW9uIG5sKGUsIHQsIG4pIHtcbiAgcmV0dXJuIHQgPSArdCwgZSA9ICtlLCBuID0gK24sIFFhKGUsIHQsIG4pWzJdO1xufVxuZnVuY3Rpb24gcmwoZSwgdCwgbikge1xuICB0ID0gK3QsIGUgPSArZSwgbiA9ICtuO1xuICBjb25zdCByID0gdCA8IGUsIGkgPSByID8gbmwodCwgZSwgbikgOiBubChlLCB0LCBuKTtcbiAgcmV0dXJuIChyID8gLTEgOiAxKSAqIChpIDwgMCA/IDEgLyAtaSA6IGkpO1xufVxuZnVuY3Rpb24ga2goZSwgdCkge1xuICBsZXQgbjtcbiAgZm9yIChjb25zdCByIG9mIGUpXG4gICAgciAhPSBudWxsICYmIChuIDwgciB8fCBuID09PSB2b2lkIDAgJiYgciA+PSByKSAmJiAobiA9IHIpO1xuICByZXR1cm4gbjtcbn1cbmZ1bmN0aW9uIERoKGUsIHQpIHtcbiAgbGV0IG47XG4gIGZvciAoY29uc3QgciBvZiBlKVxuICAgIHIgIT0gbnVsbCAmJiAobiA+IHIgfHwgbiA9PT0gdm9pZCAwICYmIHIgPj0gcikgJiYgKG4gPSByKTtcbiAgcmV0dXJuIG47XG59XG5mdW5jdGlvbiBKYihlLCB0LCBuID0gMCwgciA9IDEgLyAwLCBpKSB7XG4gIGlmICh0ID0gTWF0aC5mbG9vcih0KSwgbiA9IE1hdGguZmxvb3IoTWF0aC5tYXgoMCwgbikpLCByID0gTWF0aC5mbG9vcihNYXRoLm1pbihlLmxlbmd0aCAtIDEsIHIpKSwgIShuIDw9IHQgJiYgdCA8PSByKSlcbiAgICByZXR1cm4gZTtcbiAgZm9yIChpID0gaSA9PT0gdm9pZCAwID8gWmIgOiB0TChpKTsgciA+IG47ICkge1xuICAgIGlmIChyIC0gbiA+IDYwMCkge1xuICAgICAgY29uc3QgdSA9IHIgLSBuICsgMSwgYyA9IHQgLSBuICsgMSwgZiA9IE1hdGgubG9nKHUpLCBsID0gMC41ICogTWF0aC5leHAoMiAqIGYgLyAzKSwgZCA9IDAuNSAqIE1hdGguc3FydChmICogbCAqICh1IC0gbCkgLyB1KSAqIChjIC0gdSAvIDIgPCAwID8gLTEgOiAxKSwgcCA9IE1hdGgubWF4KG4sIE1hdGguZmxvb3IodCAtIGMgKiBsIC8gdSArIGQpKSwgZyA9IE1hdGgubWluKHIsIE1hdGguZmxvb3IodCArICh1IC0gYykgKiBsIC8gdSArIGQpKTtcbiAgICAgIEpiKGUsIHQsIHAsIGcsIGkpO1xuICAgIH1cbiAgICBjb25zdCBvID0gZVt0XTtcbiAgICBsZXQgYSA9IG4sIHMgPSByO1xuICAgIGZvciAoUmkoZSwgbiwgdCksIGkoZVtyXSwgbykgPiAwICYmIFJpKGUsIG4sIHIpOyBhIDwgczsgKSB7XG4gICAgICBmb3IgKFJpKGUsIGEsIHMpLCArK2EsIC0tczsgaShlW2FdLCBvKSA8IDA7IClcbiAgICAgICAgKythO1xuICAgICAgZm9yICg7IGkoZVtzXSwgbykgPiAwOyApXG4gICAgICAgIC0tcztcbiAgICB9XG4gICAgaShlW25dLCBvKSA9PT0gMCA/IFJpKGUsIG4sIHMpIDogKCsrcywgUmkoZSwgcywgcikpLCBzIDw9IHQgJiYgKG4gPSBzICsgMSksIHQgPD0gcyAmJiAociA9IHMgLSAxKTtcbiAgfVxuICByZXR1cm4gZTtcbn1cbmZ1bmN0aW9uIFJpKGUsIHQsIG4pIHtcbiAgY29uc3QgciA9IGVbdF07XG4gIGVbdF0gPSBlW25dLCBlW25dID0gcjtcbn1cbmZ1bmN0aW9uIG9MKGUsIHQsIG4pIHtcbiAgaWYgKGUgPSBGbG9hdDY0QXJyYXkuZnJvbShYRihlKSksICEoIShyID0gZS5sZW5ndGgpIHx8IGlzTmFOKHQgPSArdCkpKSB7XG4gICAgaWYgKHQgPD0gMCB8fCByIDwgMilcbiAgICAgIHJldHVybiBEaChlKTtcbiAgICBpZiAodCA+PSAxKVxuICAgICAgcmV0dXJuIGtoKGUpO1xuICAgIHZhciByLCBpID0gKHIgLSAxKSAqIHQsIG8gPSBNYXRoLmZsb29yKGkpLCBhID0ga2goSmIoZSwgbykuc3ViYXJyYXkoMCwgbyArIDEpKSwgcyA9IERoKGUuc3ViYXJyYXkobyArIDEpKTtcbiAgICByZXR1cm4gYSArIChzIC0gYSkgKiAoaSAtIG8pO1xuICB9XG59XG5mdW5jdGlvbiBhTChlLCB0LCBuID0gWGIpIHtcbiAgaWYgKCEoIShyID0gZS5sZW5ndGgpIHx8IGlzTmFOKHQgPSArdCkpKSB7XG4gICAgaWYgKHQgPD0gMCB8fCByIDwgMilcbiAgICAgIHJldHVybiArbihlWzBdLCAwLCBlKTtcbiAgICBpZiAodCA+PSAxKVxuICAgICAgcmV0dXJuICtuKGVbciAtIDFdLCByIC0gMSwgZSk7XG4gICAgdmFyIHIsIGkgPSAociAtIDEpICogdCwgbyA9IE1hdGguZmxvb3IoaSksIGEgPSArbihlW29dLCBvLCBlKSwgcyA9ICtuKGVbbyArIDFdLCBvICsgMSwgZSk7XG4gICAgcmV0dXJuIGEgKyAocyAtIGEpICogKGkgLSBvKTtcbiAgfVxufVxuZnVuY3Rpb24gc0woZSwgdCwgbikge1xuICBlID0gK2UsIHQgPSArdCwgbiA9IChpID0gYXJndW1lbnRzLmxlbmd0aCkgPCAyID8gKHQgPSBlLCBlID0gMCwgMSkgOiBpIDwgMyA/IDEgOiArbjtcbiAgZm9yICh2YXIgciA9IC0xLCBpID0gTWF0aC5tYXgoMCwgTWF0aC5jZWlsKCh0IC0gZSkgLyBuKSkgfCAwLCBvID0gbmV3IEFycmF5KGkpOyArK3IgPCBpOyApXG4gICAgb1tyXSA9IGUgKyByICogbjtcbiAgcmV0dXJuIG87XG59XG5mdW5jdGlvbiBCdChlLCB0KSB7XG4gIHN3aXRjaCAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgIGNhc2UgMDpcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMTpcbiAgICAgIHRoaXMucmFuZ2UoZSk7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgdGhpcy5yYW5nZSh0KS5kb21haW4oZSk7XG4gICAgICBicmVhaztcbiAgfVxuICByZXR1cm4gdGhpcztcbn1cbmZ1bmN0aW9uIEVuKGUsIHQpIHtcbiAgc3dpdGNoIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgY2FzZSAwOlxuICAgICAgYnJlYWs7XG4gICAgY2FzZSAxOiB7XG4gICAgICB0eXBlb2YgZSA9PSBcImZ1bmN0aW9uXCIgPyB0aGlzLmludGVycG9sYXRvcihlKSA6IHRoaXMucmFuZ2UoZSk7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgZGVmYXVsdDoge1xuICAgICAgdGhpcy5kb21haW4oZSksIHR5cGVvZiB0ID09IFwiZnVuY3Rpb25cIiA/IHRoaXMuaW50ZXJwb2xhdG9yKHQpIDogdGhpcy5yYW5nZSh0KTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdGhpcztcbn1cbmNvbnN0IGlsID0gU3ltYm9sKFwiaW1wbGljaXRcIik7XG5mdW5jdGlvbiB6ZigpIHtcbiAgdmFyIGUgPSBuZXcgSWgoKSwgdCA9IFtdLCBuID0gW10sIHIgPSBpbDtcbiAgZnVuY3Rpb24gaShvKSB7XG4gICAgbGV0IGEgPSBlLmdldChvKTtcbiAgICBpZiAoYSA9PT0gdm9pZCAwKSB7XG4gICAgICBpZiAociAhPT0gaWwpXG4gICAgICAgIHJldHVybiByO1xuICAgICAgZS5zZXQobywgYSA9IHQucHVzaChvKSAtIDEpO1xuICAgIH1cbiAgICByZXR1cm4gblthICUgbi5sZW5ndGhdO1xuICB9XG4gIHJldHVybiBpLmRvbWFpbiA9IGZ1bmN0aW9uKG8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpXG4gICAgICByZXR1cm4gdC5zbGljZSgpO1xuICAgIHQgPSBbXSwgZSA9IG5ldyBJaCgpO1xuICAgIGZvciAoY29uc3QgYSBvZiBvKVxuICAgICAgZS5oYXMoYSkgfHwgZS5zZXQoYSwgdC5wdXNoKGEpIC0gMSk7XG4gICAgcmV0dXJuIGk7XG4gIH0sIGkucmFuZ2UgPSBmdW5jdGlvbihvKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAobiA9IEFycmF5LmZyb20obyksIGkpIDogbi5zbGljZSgpO1xuICB9LCBpLnVua25vd24gPSBmdW5jdGlvbihvKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAociA9IG8sIGkpIDogcjtcbiAgfSwgaS5jb3B5ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHpmKHQsIG4pLnVua25vd24ocik7XG4gIH0sIEJ0LmFwcGx5KGksIGFyZ3VtZW50cyksIGk7XG59XG5mdW5jdGlvbiBzbygpIHtcbiAgdmFyIGUgPSB6ZigpLnVua25vd24odm9pZCAwKSwgdCA9IGUuZG9tYWluLCBuID0gZS5yYW5nZSwgciA9IDAsIGkgPSAxLCBvLCBhLCBzID0gITEsIHUgPSAwLCBjID0gMCwgZiA9IDAuNTtcbiAgZGVsZXRlIGUudW5rbm93bjtcbiAgZnVuY3Rpb24gbCgpIHtcbiAgICB2YXIgZCA9IHQoKS5sZW5ndGgsIHAgPSBpIDwgciwgZyA9IHAgPyBpIDogciwgaCA9IHAgPyByIDogaTtcbiAgICBvID0gKGggLSBnKSAvIE1hdGgubWF4KDEsIGQgLSB1ICsgYyAqIDIpLCBzICYmIChvID0gTWF0aC5mbG9vcihvKSksIGcgKz0gKGggLSBnIC0gbyAqIChkIC0gdSkpICogZiwgYSA9IG8gKiAoMSAtIHUpLCBzICYmIChnID0gTWF0aC5yb3VuZChnKSwgYSA9IE1hdGgucm91bmQoYSkpO1xuICAgIHZhciB2ID0gc0woZCkubWFwKGZ1bmN0aW9uKHcpIHtcbiAgICAgIHJldHVybiBnICsgbyAqIHc7XG4gICAgfSk7XG4gICAgcmV0dXJuIG4ocCA/IHYucmV2ZXJzZSgpIDogdik7XG4gIH1cbiAgcmV0dXJuIGUuZG9tYWluID0gZnVuY3Rpb24oZCkge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHQoZCksIGwoKSkgOiB0KCk7XG4gIH0sIGUucmFuZ2UgPSBmdW5jdGlvbihkKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoW3IsIGldID0gZCwgciA9ICtyLCBpID0gK2ksIGwoKSkgOiBbciwgaV07XG4gIH0sIGUucmFuZ2VSb3VuZCA9IGZ1bmN0aW9uKGQpIHtcbiAgICByZXR1cm4gW3IsIGldID0gZCwgciA9ICtyLCBpID0gK2ksIHMgPSAhMCwgbCgpO1xuICB9LCBlLmJhbmR3aWR0aCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBhO1xuICB9LCBlLnN0ZXAgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gbztcbiAgfSwgZS5yb3VuZCA9IGZ1bmN0aW9uKGQpIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChzID0gISFkLCBsKCkpIDogcztcbiAgfSwgZS5wYWRkaW5nID0gZnVuY3Rpb24oZCkge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHUgPSBNYXRoLm1pbigxLCBjID0gK2QpLCBsKCkpIDogdTtcbiAgfSwgZS5wYWRkaW5nSW5uZXIgPSBmdW5jdGlvbihkKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAodSA9IE1hdGgubWluKDEsIGQpLCBsKCkpIDogdTtcbiAgfSwgZS5wYWRkaW5nT3V0ZXIgPSBmdW5jdGlvbihkKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoYyA9ICtkLCBsKCkpIDogYztcbiAgfSwgZS5hbGlnbiA9IGZ1bmN0aW9uKGQpIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChmID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oMSwgZCkpLCBsKCkpIDogZjtcbiAgfSwgZS5jb3B5ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHNvKHQoKSwgW3IsIGldKS5yb3VuZChzKS5wYWRkaW5nSW5uZXIodSkucGFkZGluZ091dGVyKGMpLmFsaWduKGYpO1xuICB9LCBCdC5hcHBseShsKCksIGFyZ3VtZW50cyk7XG59XG5mdW5jdGlvbiBRYihlKSB7XG4gIHZhciB0ID0gZS5jb3B5O1xuICByZXR1cm4gZS5wYWRkaW5nID0gZS5wYWRkaW5nT3V0ZXIsIGRlbGV0ZSBlLnBhZGRpbmdJbm5lciwgZGVsZXRlIGUucGFkZGluZ091dGVyLCBlLmNvcHkgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gUWIodCgpKTtcbiAgfSwgZTtcbn1cbmZ1bmN0aW9uIFdpKCkge1xuICByZXR1cm4gUWIoc28uYXBwbHkobnVsbCwgYXJndW1lbnRzKS5wYWRkaW5nSW5uZXIoMSkpO1xufVxuZnVuY3Rpb24gVmYoZSwgdCwgbikge1xuICBlLnByb3RvdHlwZSA9IHQucHJvdG90eXBlID0gbiwgbi5jb25zdHJ1Y3RvciA9IGU7XG59XG5mdW5jdGlvbiBlMChlLCB0KSB7XG4gIHZhciBuID0gT2JqZWN0LmNyZWF0ZShlLnByb3RvdHlwZSk7XG4gIGZvciAodmFyIHIgaW4gdClcbiAgICBuW3JdID0gdFtyXTtcbiAgcmV0dXJuIG47XG59XG5mdW5jdGlvbiBLbygpIHtcbn1cbnZhciB1byA9IDAuNywgZXMgPSAxIC8gdW8sIElyID0gXCJcXFxccyooWystXT9cXFxcZCspXFxcXHMqXCIsIGNvID0gXCJcXFxccyooWystXT8oPzpcXFxcZCpcXFxcLik/XFxcXGQrKD86W2VFXVsrLV0/XFxcXGQrKT8pXFxcXHMqXCIsIGFuID0gXCJcXFxccyooWystXT8oPzpcXFxcZCpcXFxcLik/XFxcXGQrKD86W2VFXVsrLV0/XFxcXGQrKT8pJVxcXFxzKlwiLCB1TCA9IC9eIyhbMC05YS1mXXszLDh9KSQvLCBjTCA9IG5ldyBSZWdFeHAoYF5yZ2JcXFxcKCR7SXJ9LCR7SXJ9LCR7SXJ9XFxcXCkkYCksIGxMID0gbmV3IFJlZ0V4cChgXnJnYlxcXFwoJHthbn0sJHthbn0sJHthbn1cXFxcKSRgKSwgZkwgPSBuZXcgUmVnRXhwKGBecmdiYVxcXFwoJHtJcn0sJHtJcn0sJHtJcn0sJHtjb31cXFxcKSRgKSwgZEwgPSBuZXcgUmVnRXhwKGBecmdiYVxcXFwoJHthbn0sJHthbn0sJHthbn0sJHtjb31cXFxcKSRgKSwgcEwgPSBuZXcgUmVnRXhwKGBeaHNsXFxcXCgke2NvfSwke2FufSwke2FufVxcXFwpJGApLCBoTCA9IG5ldyBSZWdFeHAoYF5oc2xhXFxcXCgke2NvfSwke2FufSwke2FufSwke2NvfVxcXFwpJGApLCBOaCA9IHtcbiAgYWxpY2VibHVlOiAxNTc5MjM4MyxcbiAgYW50aXF1ZXdoaXRlOiAxNjQ0NDM3NSxcbiAgYXF1YTogNjU1MzUsXG4gIGFxdWFtYXJpbmU6IDgzODg1NjQsXG4gIGF6dXJlOiAxNTc5NDE3NSxcbiAgYmVpZ2U6IDE2MTE5MjYwLFxuICBiaXNxdWU6IDE2NzcwMjQ0LFxuICBibGFjazogMCxcbiAgYmxhbmNoZWRhbG1vbmQ6IDE2NzcyMDQ1LFxuICBibHVlOiAyNTUsXG4gIGJsdWV2aW9sZXQ6IDkwNTUyMDIsXG4gIGJyb3duOiAxMDgyNDIzNCxcbiAgYnVybHl3b29kOiAxNDU5NjIzMSxcbiAgY2FkZXRibHVlOiA2MjY2NTI4LFxuICBjaGFydHJldXNlOiA4Mzg4MzUyLFxuICBjaG9jb2xhdGU6IDEzNzg5NDcwLFxuICBjb3JhbDogMTY3NDQyNzIsXG4gIGNvcm5mbG93ZXJibHVlOiA2NTkxOTgxLFxuICBjb3Juc2lsazogMTY3NzUzODgsXG4gIGNyaW1zb246IDE0NDIzMTAwLFxuICBjeWFuOiA2NTUzNSxcbiAgZGFya2JsdWU6IDEzOSxcbiAgZGFya2N5YW46IDM1NzIzLFxuICBkYXJrZ29sZGVucm9kOiAxMjA5MjkzOSxcbiAgZGFya2dyYXk6IDExMTE5MDE3LFxuICBkYXJrZ3JlZW46IDI1NjAwLFxuICBkYXJrZ3JleTogMTExMTkwMTcsXG4gIGRhcmtraGFraTogMTI0MzMyNTksXG4gIGRhcmttYWdlbnRhOiA5MTA5NjQzLFxuICBkYXJrb2xpdmVncmVlbjogNTU5Nzk5OSxcbiAgZGFya29yYW5nZTogMTY3NDc1MjAsXG4gIGRhcmtvcmNoaWQ6IDEwMDQwMDEyLFxuICBkYXJrcmVkOiA5MTA5NTA0LFxuICBkYXJrc2FsbW9uOiAxNTMwODQxMCxcbiAgZGFya3NlYWdyZWVuOiA5NDE5OTE5LFxuICBkYXJrc2xhdGVibHVlOiA0NzM0MzQ3LFxuICBkYXJrc2xhdGVncmF5OiAzMTAwNDk1LFxuICBkYXJrc2xhdGVncmV5OiAzMTAwNDk1LFxuICBkYXJrdHVycXVvaXNlOiA1Mjk0NSxcbiAgZGFya3Zpb2xldDogOTY5OTUzOSxcbiAgZGVlcHBpbms6IDE2NzE2OTQ3LFxuICBkZWVwc2t5Ymx1ZTogNDkxNTEsXG4gIGRpbWdyYXk6IDY5MDgyNjUsXG4gIGRpbWdyZXk6IDY5MDgyNjUsXG4gIGRvZGdlcmJsdWU6IDIwMDMxOTksXG4gIGZpcmVicmljazogMTE2NzQxNDYsXG4gIGZsb3JhbHdoaXRlOiAxNjc3NTkyMCxcbiAgZm9yZXN0Z3JlZW46IDIyNjM4NDIsXG4gIGZ1Y2hzaWE6IDE2NzExOTM1LFxuICBnYWluc2Jvcm86IDE0NDc0NDYwLFxuICBnaG9zdHdoaXRlOiAxNjMxNjY3MSxcbiAgZ29sZDogMTY3NjY3MjAsXG4gIGdvbGRlbnJvZDogMTQzMjkxMjAsXG4gIGdyYXk6IDg0MjE1MDQsXG4gIGdyZWVuOiAzMjc2OCxcbiAgZ3JlZW55ZWxsb3c6IDExNDAzMDU1LFxuICBncmV5OiA4NDIxNTA0LFxuICBob25leWRldzogMTU3OTQxNjAsXG4gIGhvdHBpbms6IDE2NzM4NzQwLFxuICBpbmRpYW5yZWQ6IDEzNDU4NTI0LFxuICBpbmRpZ286IDQ5MTUzMzAsXG4gIGl2b3J5OiAxNjc3NzIwMCxcbiAga2hha2k6IDE1Nzg3NjYwLFxuICBsYXZlbmRlcjogMTUxMzI0MTAsXG4gIGxhdmVuZGVyYmx1c2g6IDE2NzczMzY1LFxuICBsYXduZ3JlZW46IDgxOTA5NzYsXG4gIGxlbW9uY2hpZmZvbjogMTY3NzU4ODUsXG4gIGxpZ2h0Ymx1ZTogMTEzOTMyNTQsXG4gIGxpZ2h0Y29yYWw6IDE1NzYxNTM2LFxuICBsaWdodGN5YW46IDE0NzQ1NTk5LFxuICBsaWdodGdvbGRlbnJvZHllbGxvdzogMTY0NDgyMTAsXG4gIGxpZ2h0Z3JheTogMTM4ODIzMjMsXG4gIGxpZ2h0Z3JlZW46IDk0OTgyNTYsXG4gIGxpZ2h0Z3JleTogMTM4ODIzMjMsXG4gIGxpZ2h0cGluazogMTY3NTg0NjUsXG4gIGxpZ2h0c2FsbW9uOiAxNjc1Mjc2MixcbiAgbGlnaHRzZWFncmVlbjogMjE0Mjg5MCxcbiAgbGlnaHRza3libHVlOiA4OTAwMzQ2LFxuICBsaWdodHNsYXRlZ3JheTogNzgzMzc1MyxcbiAgbGlnaHRzbGF0ZWdyZXk6IDc4MzM3NTMsXG4gIGxpZ2h0c3RlZWxibHVlOiAxMTU4NDczNCxcbiAgbGlnaHR5ZWxsb3c6IDE2Nzc3MTg0LFxuICBsaW1lOiA2NTI4MCxcbiAgbGltZWdyZWVuOiAzMzI5MzMwLFxuICBsaW5lbjogMTY0NDU2NzAsXG4gIG1hZ2VudGE6IDE2NzExOTM1LFxuICBtYXJvb246IDgzODg2MDgsXG4gIG1lZGl1bWFxdWFtYXJpbmU6IDY3MzczMjIsXG4gIG1lZGl1bWJsdWU6IDIwNSxcbiAgbWVkaXVtb3JjaGlkOiAxMjIxMTY2NyxcbiAgbWVkaXVtcHVycGxlOiA5NjYyNjgzLFxuICBtZWRpdW1zZWFncmVlbjogMzk3ODA5NyxcbiAgbWVkaXVtc2xhdGVibHVlOiA4MDg3NzkwLFxuICBtZWRpdW1zcHJpbmdncmVlbjogNjQxNTQsXG4gIG1lZGl1bXR1cnF1b2lzZTogNDc3MjMwMCxcbiAgbWVkaXVtdmlvbGV0cmVkOiAxMzA0NzE3MyxcbiAgbWlkbmlnaHRibHVlOiAxNjQ0OTEyLFxuICBtaW50Y3JlYW06IDE2MTIxODUwLFxuICBtaXN0eXJvc2U6IDE2NzcwMjczLFxuICBtb2NjYXNpbjogMTY3NzAyMjksXG4gIG5hdmFqb3doaXRlOiAxNjc2ODY4NSxcbiAgbmF2eTogMTI4LFxuICBvbGRsYWNlOiAxNjY0MzU1OCxcbiAgb2xpdmU6IDg0MjEzNzYsXG4gIG9saXZlZHJhYjogNzA0ODczOSxcbiAgb3JhbmdlOiAxNjc1MzkyMCxcbiAgb3JhbmdlcmVkOiAxNjcyOTM0NCxcbiAgb3JjaGlkOiAxNDMxNTczNCxcbiAgcGFsZWdvbGRlbnJvZDogMTU2NTcxMzAsXG4gIHBhbGVncmVlbjogMTAwMjU4ODAsXG4gIHBhbGV0dXJxdW9pc2U6IDExNTI5OTY2LFxuICBwYWxldmlvbGV0cmVkOiAxNDM4MTIwMyxcbiAgcGFwYXlhd2hpcDogMTY3NzMwNzcsXG4gIHBlYWNocHVmZjogMTY3Njc2NzMsXG4gIHBlcnU6IDEzNDY4OTkxLFxuICBwaW5rOiAxNjc2MTAzNSxcbiAgcGx1bTogMTQ1MjQ2MzcsXG4gIHBvd2RlcmJsdWU6IDExNTkxOTEwLFxuICBwdXJwbGU6IDgzODg3MzYsXG4gIHJlYmVjY2FwdXJwbGU6IDY2OTc4ODEsXG4gIHJlZDogMTY3MTE2ODAsXG4gIHJvc3licm93bjogMTIzNTc1MTksXG4gIHJveWFsYmx1ZTogNDI4Njk0NSxcbiAgc2FkZGxlYnJvd246IDkxMjcxODcsXG4gIHNhbG1vbjogMTY0MTY4ODIsXG4gIHNhbmR5YnJvd246IDE2MDMyODY0LFxuICBzZWFncmVlbjogMzA1MDMyNyxcbiAgc2Vhc2hlbGw6IDE2Nzc0NjM4LFxuICBzaWVubmE6IDEwNTA2Nzk3LFxuICBzaWx2ZXI6IDEyNjMyMjU2LFxuICBza3libHVlOiA4OTAwMzMxLFxuICBzbGF0ZWJsdWU6IDY5NzAwNjEsXG4gIHNsYXRlZ3JheTogNzM3Mjk0NCxcbiAgc2xhdGVncmV5OiA3MzcyOTQ0LFxuICBzbm93OiAxNjc3NTkzMCxcbiAgc3ByaW5nZ3JlZW46IDY1NDA3LFxuICBzdGVlbGJsdWU6IDQ2MjA5ODAsXG4gIHRhbjogMTM4MDg3ODAsXG4gIHRlYWw6IDMyODk2LFxuICB0aGlzdGxlOiAxNDIwNDg4OCxcbiAgdG9tYXRvOiAxNjczNzA5NSxcbiAgdHVycXVvaXNlOiA0MjUxODU2LFxuICB2aW9sZXQ6IDE1NjMxMDg2LFxuICB3aGVhdDogMTYxMTMzMzEsXG4gIHdoaXRlOiAxNjc3NzIxNSxcbiAgd2hpdGVzbW9rZTogMTYxMTkyODUsXG4gIHllbGxvdzogMTY3NzY5NjAsXG4gIHllbGxvd2dyZWVuOiAxMDE0NTA3NFxufTtcblZmKEtvLCBsbywge1xuICBjb3B5KGUpIHtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihuZXcgdGhpcy5jb25zdHJ1Y3RvcigpLCB0aGlzLCBlKTtcbiAgfSxcbiAgZGlzcGxheWFibGUoKSB7XG4gICAgcmV0dXJuIHRoaXMucmdiKCkuZGlzcGxheWFibGUoKTtcbiAgfSxcbiAgaGV4OiBGaCxcbiAgLy8gRGVwcmVjYXRlZCEgVXNlIGNvbG9yLmZvcm1hdEhleC5cbiAgZm9ybWF0SGV4OiBGaCxcbiAgZm9ybWF0SGV4ODogZ0wsXG4gIGZvcm1hdEhzbDogdkwsXG4gIGZvcm1hdFJnYjogTGgsXG4gIHRvU3RyaW5nOiBMaFxufSk7XG5mdW5jdGlvbiBGaCgpIHtcbiAgcmV0dXJuIHRoaXMucmdiKCkuZm9ybWF0SGV4KCk7XG59XG5mdW5jdGlvbiBnTCgpIHtcbiAgcmV0dXJuIHRoaXMucmdiKCkuZm9ybWF0SGV4OCgpO1xufVxuZnVuY3Rpb24gdkwoKSB7XG4gIHJldHVybiB0MCh0aGlzKS5mb3JtYXRIc2woKTtcbn1cbmZ1bmN0aW9uIExoKCkge1xuICByZXR1cm4gdGhpcy5yZ2IoKS5mb3JtYXRSZ2IoKTtcbn1cbmZ1bmN0aW9uIGxvKGUpIHtcbiAgdmFyIHQsIG47XG4gIHJldHVybiBlID0gKGUgKyBcIlwiKS50cmltKCkudG9Mb3dlckNhc2UoKSwgKHQgPSB1TC5leGVjKGUpKSA/IChuID0gdFsxXS5sZW5ndGgsIHQgPSBwYXJzZUludCh0WzFdLCAxNiksIG4gPT09IDYgPyBCaCh0KSA6IG4gPT09IDMgPyBuZXcgaHQodCA+PiA4ICYgMTUgfCB0ID4+IDQgJiAyNDAsIHQgPj4gNCAmIDE1IHwgdCAmIDI0MCwgKHQgJiAxNSkgPDwgNCB8IHQgJiAxNSwgMSkgOiBuID09PSA4ID8gaGEodCA+PiAyNCAmIDI1NSwgdCA+PiAxNiAmIDI1NSwgdCA+PiA4ICYgMjU1LCAodCAmIDI1NSkgLyAyNTUpIDogbiA9PT0gNCA/IGhhKHQgPj4gMTIgJiAxNSB8IHQgPj4gOCAmIDI0MCwgdCA+PiA4ICYgMTUgfCB0ID4+IDQgJiAyNDAsIHQgPj4gNCAmIDE1IHwgdCAmIDI0MCwgKCh0ICYgMTUpIDw8IDQgfCB0ICYgMTUpIC8gMjU1KSA6IG51bGwpIDogKHQgPSBjTC5leGVjKGUpKSA/IG5ldyBodCh0WzFdLCB0WzJdLCB0WzNdLCAxKSA6ICh0ID0gbEwuZXhlYyhlKSkgPyBuZXcgaHQodFsxXSAqIDI1NSAvIDEwMCwgdFsyXSAqIDI1NSAvIDEwMCwgdFszXSAqIDI1NSAvIDEwMCwgMSkgOiAodCA9IGZMLmV4ZWMoZSkpID8gaGEodFsxXSwgdFsyXSwgdFszXSwgdFs0XSkgOiAodCA9IGRMLmV4ZWMoZSkpID8gaGEodFsxXSAqIDI1NSAvIDEwMCwgdFsyXSAqIDI1NSAvIDEwMCwgdFszXSAqIDI1NSAvIDEwMCwgdFs0XSkgOiAodCA9IHBMLmV4ZWMoZSkpID8gR2godFsxXSwgdFsyXSAvIDEwMCwgdFszXSAvIDEwMCwgMSkgOiAodCA9IGhMLmV4ZWMoZSkpID8gR2godFsxXSwgdFsyXSAvIDEwMCwgdFszXSAvIDEwMCwgdFs0XSkgOiBOaC5oYXNPd25Qcm9wZXJ0eShlKSA/IEJoKE5oW2VdKSA6IGUgPT09IFwidHJhbnNwYXJlbnRcIiA/IG5ldyBodChOYU4sIE5hTiwgTmFOLCAwKSA6IG51bGw7XG59XG5mdW5jdGlvbiBCaChlKSB7XG4gIHJldHVybiBuZXcgaHQoZSA+PiAxNiAmIDI1NSwgZSA+PiA4ICYgMjU1LCBlICYgMjU1LCAxKTtcbn1cbmZ1bmN0aW9uIGhhKGUsIHQsIG4sIHIpIHtcbiAgcmV0dXJuIHIgPD0gMCAmJiAoZSA9IHQgPSBuID0gTmFOKSwgbmV3IGh0KGUsIHQsIG4sIHIpO1xufVxuZnVuY3Rpb24gbUwoZSkge1xuICByZXR1cm4gZSBpbnN0YW5jZW9mIEtvIHx8IChlID0gbG8oZSkpLCBlID8gKGUgPSBlLnJnYigpLCBuZXcgaHQoZS5yLCBlLmcsIGUuYiwgZS5vcGFjaXR5KSkgOiBuZXcgaHQoKTtcbn1cbmZ1bmN0aW9uIG9sKGUsIHQsIG4sIHIpIHtcbiAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPT09IDEgPyBtTChlKSA6IG5ldyBodChlLCB0LCBuLCByID8/IDEpO1xufVxuZnVuY3Rpb24gaHQoZSwgdCwgbiwgcikge1xuICB0aGlzLnIgPSArZSwgdGhpcy5nID0gK3QsIHRoaXMuYiA9ICtuLCB0aGlzLm9wYWNpdHkgPSArcjtcbn1cblZmKGh0LCBvbCwgZTAoS28sIHtcbiAgYnJpZ2h0ZXIoZSkge1xuICAgIHJldHVybiBlID0gZSA9PSBudWxsID8gZXMgOiBNYXRoLnBvdyhlcywgZSksIG5ldyBodCh0aGlzLnIgKiBlLCB0aGlzLmcgKiBlLCB0aGlzLmIgKiBlLCB0aGlzLm9wYWNpdHkpO1xuICB9LFxuICBkYXJrZXIoZSkge1xuICAgIHJldHVybiBlID0gZSA9PSBudWxsID8gdW8gOiBNYXRoLnBvdyh1bywgZSksIG5ldyBodCh0aGlzLnIgKiBlLCB0aGlzLmcgKiBlLCB0aGlzLmIgKiBlLCB0aGlzLm9wYWNpdHkpO1xuICB9LFxuICByZ2IoKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIGNsYW1wKCkge1xuICAgIHJldHVybiBuZXcgaHQoc3IodGhpcy5yKSwgc3IodGhpcy5nKSwgc3IodGhpcy5iKSwgdHModGhpcy5vcGFjaXR5KSk7XG4gIH0sXG4gIGRpc3BsYXlhYmxlKCkge1xuICAgIHJldHVybiAtMC41IDw9IHRoaXMuciAmJiB0aGlzLnIgPCAyNTUuNSAmJiAtMC41IDw9IHRoaXMuZyAmJiB0aGlzLmcgPCAyNTUuNSAmJiAtMC41IDw9IHRoaXMuYiAmJiB0aGlzLmIgPCAyNTUuNSAmJiAwIDw9IHRoaXMub3BhY2l0eSAmJiB0aGlzLm9wYWNpdHkgPD0gMTtcbiAgfSxcbiAgaGV4OiB6aCxcbiAgLy8gRGVwcmVjYXRlZCEgVXNlIGNvbG9yLmZvcm1hdEhleC5cbiAgZm9ybWF0SGV4OiB6aCxcbiAgZm9ybWF0SGV4ODogeUwsXG4gIGZvcm1hdFJnYjogVmgsXG4gIHRvU3RyaW5nOiBWaFxufSkpO1xuZnVuY3Rpb24gemgoKSB7XG4gIHJldHVybiBgIyR7cnIodGhpcy5yKX0ke3JyKHRoaXMuZyl9JHtycih0aGlzLmIpfWA7XG59XG5mdW5jdGlvbiB5TCgpIHtcbiAgcmV0dXJuIGAjJHtycih0aGlzLnIpfSR7cnIodGhpcy5nKX0ke3JyKHRoaXMuYil9JHtycigoaXNOYU4odGhpcy5vcGFjaXR5KSA/IDEgOiB0aGlzLm9wYWNpdHkpICogMjU1KX1gO1xufVxuZnVuY3Rpb24gVmgoKSB7XG4gIGNvbnN0IGUgPSB0cyh0aGlzLm9wYWNpdHkpO1xuICByZXR1cm4gYCR7ZSA9PT0gMSA/IFwicmdiKFwiIDogXCJyZ2JhKFwifSR7c3IodGhpcy5yKX0sICR7c3IodGhpcy5nKX0sICR7c3IodGhpcy5iKX0ke2UgPT09IDEgPyBcIilcIiA6IGAsICR7ZX0pYH1gO1xufVxuZnVuY3Rpb24gdHMoZSkge1xuICByZXR1cm4gaXNOYU4oZSkgPyAxIDogTWF0aC5tYXgoMCwgTWF0aC5taW4oMSwgZSkpO1xufVxuZnVuY3Rpb24gc3IoZSkge1xuICByZXR1cm4gTWF0aC5tYXgoMCwgTWF0aC5taW4oMjU1LCBNYXRoLnJvdW5kKGUpIHx8IDApKTtcbn1cbmZ1bmN0aW9uIHJyKGUpIHtcbiAgcmV0dXJuIGUgPSBzcihlKSwgKGUgPCAxNiA/IFwiMFwiIDogXCJcIikgKyBlLnRvU3RyaW5nKDE2KTtcbn1cbmZ1bmN0aW9uIEdoKGUsIHQsIG4sIHIpIHtcbiAgcmV0dXJuIHIgPD0gMCA/IGUgPSB0ID0gbiA9IE5hTiA6IG4gPD0gMCB8fCBuID49IDEgPyBlID0gdCA9IE5hTiA6IHQgPD0gMCAmJiAoZSA9IE5hTiksIG5ldyBxdChlLCB0LCBuLCByKTtcbn1cbmZ1bmN0aW9uIHQwKGUpIHtcbiAgaWYgKGUgaW5zdGFuY2VvZiBxdClcbiAgICByZXR1cm4gbmV3IHF0KGUuaCwgZS5zLCBlLmwsIGUub3BhY2l0eSk7XG4gIGlmIChlIGluc3RhbmNlb2YgS28gfHwgKGUgPSBsbyhlKSksICFlKVxuICAgIHJldHVybiBuZXcgcXQoKTtcbiAgaWYgKGUgaW5zdGFuY2VvZiBxdClcbiAgICByZXR1cm4gZTtcbiAgZSA9IGUucmdiKCk7XG4gIHZhciB0ID0gZS5yIC8gMjU1LCBuID0gZS5nIC8gMjU1LCByID0gZS5iIC8gMjU1LCBpID0gTWF0aC5taW4odCwgbiwgciksIG8gPSBNYXRoLm1heCh0LCBuLCByKSwgYSA9IE5hTiwgcyA9IG8gLSBpLCB1ID0gKG8gKyBpKSAvIDI7XG4gIHJldHVybiBzID8gKHQgPT09IG8gPyBhID0gKG4gLSByKSAvIHMgKyAobiA8IHIpICogNiA6IG4gPT09IG8gPyBhID0gKHIgLSB0KSAvIHMgKyAyIDogYSA9ICh0IC0gbikgLyBzICsgNCwgcyAvPSB1IDwgMC41ID8gbyArIGkgOiAyIC0gbyAtIGksIGEgKj0gNjApIDogcyA9IHUgPiAwICYmIHUgPCAxID8gMCA6IGEsIG5ldyBxdChhLCBzLCB1LCBlLm9wYWNpdHkpO1xufVxuZnVuY3Rpb24gYkwoZSwgdCwgbiwgcikge1xuICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA9PT0gMSA/IHQwKGUpIDogbmV3IHF0KGUsIHQsIG4sIHIgPz8gMSk7XG59XG5mdW5jdGlvbiBxdChlLCB0LCBuLCByKSB7XG4gIHRoaXMuaCA9ICtlLCB0aGlzLnMgPSArdCwgdGhpcy5sID0gK24sIHRoaXMub3BhY2l0eSA9ICtyO1xufVxuVmYocXQsIGJMLCBlMChLbywge1xuICBicmlnaHRlcihlKSB7XG4gICAgcmV0dXJuIGUgPSBlID09IG51bGwgPyBlcyA6IE1hdGgucG93KGVzLCBlKSwgbmV3IHF0KHRoaXMuaCwgdGhpcy5zLCB0aGlzLmwgKiBlLCB0aGlzLm9wYWNpdHkpO1xuICB9LFxuICBkYXJrZXIoZSkge1xuICAgIHJldHVybiBlID0gZSA9PSBudWxsID8gdW8gOiBNYXRoLnBvdyh1bywgZSksIG5ldyBxdCh0aGlzLmgsIHRoaXMucywgdGhpcy5sICogZSwgdGhpcy5vcGFjaXR5KTtcbiAgfSxcbiAgcmdiKCkge1xuICAgIHZhciBlID0gdGhpcy5oICUgMzYwICsgKHRoaXMuaCA8IDApICogMzYwLCB0ID0gaXNOYU4oZSkgfHwgaXNOYU4odGhpcy5zKSA/IDAgOiB0aGlzLnMsIG4gPSB0aGlzLmwsIHIgPSBuICsgKG4gPCAwLjUgPyBuIDogMSAtIG4pICogdCwgaSA9IDIgKiBuIC0gcjtcbiAgICByZXR1cm4gbmV3IGh0KFxuICAgICAgTnUoZSA+PSAyNDAgPyBlIC0gMjQwIDogZSArIDEyMCwgaSwgciksXG4gICAgICBOdShlLCBpLCByKSxcbiAgICAgIE51KGUgPCAxMjAgPyBlICsgMjQwIDogZSAtIDEyMCwgaSwgciksXG4gICAgICB0aGlzLm9wYWNpdHlcbiAgICApO1xuICB9LFxuICBjbGFtcCgpIHtcbiAgICByZXR1cm4gbmV3IHF0KFdoKHRoaXMuaCksIGdhKHRoaXMucyksIGdhKHRoaXMubCksIHRzKHRoaXMub3BhY2l0eSkpO1xuICB9LFxuICBkaXNwbGF5YWJsZSgpIHtcbiAgICByZXR1cm4gKDAgPD0gdGhpcy5zICYmIHRoaXMucyA8PSAxIHx8IGlzTmFOKHRoaXMucykpICYmIDAgPD0gdGhpcy5sICYmIHRoaXMubCA8PSAxICYmIDAgPD0gdGhpcy5vcGFjaXR5ICYmIHRoaXMub3BhY2l0eSA8PSAxO1xuICB9LFxuICBmb3JtYXRIc2woKSB7XG4gICAgY29uc3QgZSA9IHRzKHRoaXMub3BhY2l0eSk7XG4gICAgcmV0dXJuIGAke2UgPT09IDEgPyBcImhzbChcIiA6IFwiaHNsYShcIn0ke1doKHRoaXMuaCl9LCAke2dhKHRoaXMucykgKiAxMDB9JSwgJHtnYSh0aGlzLmwpICogMTAwfSUke2UgPT09IDEgPyBcIilcIiA6IGAsICR7ZX0pYH1gO1xuICB9XG59KSk7XG5mdW5jdGlvbiBXaChlKSB7XG4gIHJldHVybiBlID0gKGUgfHwgMCkgJSAzNjAsIGUgPCAwID8gZSArIDM2MCA6IGU7XG59XG5mdW5jdGlvbiBnYShlKSB7XG4gIHJldHVybiBNYXRoLm1heCgwLCBNYXRoLm1pbigxLCBlIHx8IDApKTtcbn1cbmZ1bmN0aW9uIE51KGUsIHQsIG4pIHtcbiAgcmV0dXJuIChlIDwgNjAgPyB0ICsgKG4gLSB0KSAqIGUgLyA2MCA6IGUgPCAxODAgPyBuIDogZSA8IDI0MCA/IHQgKyAobiAtIHQpICogKDI0MCAtIGUpIC8gNjAgOiB0KSAqIDI1NTtcbn1cbmNvbnN0IEdmID0gKGUpID0+ICgpID0+IGU7XG5mdW5jdGlvbiB3TChlLCB0KSB7XG4gIHJldHVybiBmdW5jdGlvbihuKSB7XG4gICAgcmV0dXJuIGUgKyBuICogdDtcbiAgfTtcbn1cbmZ1bmN0aW9uIHhMKGUsIHQsIG4pIHtcbiAgcmV0dXJuIGUgPSBNYXRoLnBvdyhlLCBuKSwgdCA9IE1hdGgucG93KHQsIG4pIC0gZSwgbiA9IDEgLyBuLCBmdW5jdGlvbihyKSB7XG4gICAgcmV0dXJuIE1hdGgucG93KGUgKyByICogdCwgbik7XG4gIH07XG59XG5mdW5jdGlvbiBTTChlKSB7XG4gIHJldHVybiAoZSA9ICtlKSA9PSAxID8gbjAgOiBmdW5jdGlvbih0LCBuKSB7XG4gICAgcmV0dXJuIG4gLSB0ID8geEwodCwgbiwgZSkgOiBHZihpc05hTih0KSA/IG4gOiB0KTtcbiAgfTtcbn1cbmZ1bmN0aW9uIG4wKGUsIHQpIHtcbiAgdmFyIG4gPSB0IC0gZTtcbiAgcmV0dXJuIG4gPyB3TChlLCBuKSA6IEdmKGlzTmFOKGUpID8gdCA6IGUpO1xufVxuY29uc3QgVWggPSBmdW5jdGlvbiBlKHQpIHtcbiAgdmFyIG4gPSBTTCh0KTtcbiAgZnVuY3Rpb24gcihpLCBvKSB7XG4gICAgdmFyIGEgPSBuKChpID0gb2woaSkpLnIsIChvID0gb2wobykpLnIpLCBzID0gbihpLmcsIG8uZyksIHUgPSBuKGkuYiwgby5iKSwgYyA9IG4wKGkub3BhY2l0eSwgby5vcGFjaXR5KTtcbiAgICByZXR1cm4gZnVuY3Rpb24oZikge1xuICAgICAgcmV0dXJuIGkuciA9IGEoZiksIGkuZyA9IHMoZiksIGkuYiA9IHUoZiksIGkub3BhY2l0eSA9IGMoZiksIGkgKyBcIlwiO1xuICAgIH07XG4gIH1cbiAgcmV0dXJuIHIuZ2FtbWEgPSBlLCByO1xufSgxKTtcbmZ1bmN0aW9uICRMKGUsIHQpIHtcbiAgdCB8fCAodCA9IFtdKTtcbiAgdmFyIG4gPSBlID8gTWF0aC5taW4odC5sZW5ndGgsIGUubGVuZ3RoKSA6IDAsIHIgPSB0LnNsaWNlKCksIGk7XG4gIHJldHVybiBmdW5jdGlvbihvKSB7XG4gICAgZm9yIChpID0gMDsgaSA8IG47ICsraSlcbiAgICAgIHJbaV0gPSBlW2ldICogKDEgLSBvKSArIHRbaV0gKiBvO1xuICAgIHJldHVybiByO1xuICB9O1xufVxuZnVuY3Rpb24gT0woZSkge1xuICByZXR1cm4gQXJyYXlCdWZmZXIuaXNWaWV3KGUpICYmICEoZSBpbnN0YW5jZW9mIERhdGFWaWV3KTtcbn1cbmZ1bmN0aW9uIF9MKGUsIHQpIHtcbiAgdmFyIG4gPSB0ID8gdC5sZW5ndGggOiAwLCByID0gZSA/IE1hdGgubWluKG4sIGUubGVuZ3RoKSA6IDAsIGkgPSBuZXcgQXJyYXkociksIG8gPSBuZXcgQXJyYXkobiksIGE7XG4gIGZvciAoYSA9IDA7IGEgPCByOyArK2EpXG4gICAgaVthXSA9IHZpKGVbYV0sIHRbYV0pO1xuICBmb3IgKDsgYSA8IG47ICsrYSlcbiAgICBvW2FdID0gdFthXTtcbiAgcmV0dXJuIGZ1bmN0aW9uKHMpIHtcbiAgICBmb3IgKGEgPSAwOyBhIDwgcjsgKythKVxuICAgICAgb1thXSA9IGlbYV0ocyk7XG4gICAgcmV0dXJuIG87XG4gIH07XG59XG5mdW5jdGlvbiBBTChlLCB0KSB7XG4gIHZhciBuID0gLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKCk7XG4gIHJldHVybiBlID0gK2UsIHQgPSArdCwgZnVuY3Rpb24ocikge1xuICAgIHJldHVybiBuLnNldFRpbWUoZSAqICgxIC0gcikgKyB0ICogciksIG47XG4gIH07XG59XG5mdW5jdGlvbiBucyhlLCB0KSB7XG4gIHJldHVybiBlID0gK2UsIHQgPSArdCwgZnVuY3Rpb24obikge1xuICAgIHJldHVybiBlICogKDEgLSBuKSArIHQgKiBuO1xuICB9O1xufVxuZnVuY3Rpb24gUEwoZSwgdCkge1xuICB2YXIgbiA9IHt9LCByID0ge30sIGk7XG4gIChlID09PSBudWxsIHx8IHR5cGVvZiBlICE9IFwib2JqZWN0XCIpICYmIChlID0ge30pLCAodCA9PT0gbnVsbCB8fCB0eXBlb2YgdCAhPSBcIm9iamVjdFwiKSAmJiAodCA9IHt9KTtcbiAgZm9yIChpIGluIHQpXG4gICAgaSBpbiBlID8gbltpXSA9IHZpKGVbaV0sIHRbaV0pIDogcltpXSA9IHRbaV07XG4gIHJldHVybiBmdW5jdGlvbihvKSB7XG4gICAgZm9yIChpIGluIG4pXG4gICAgICByW2ldID0gbltpXShvKTtcbiAgICByZXR1cm4gcjtcbiAgfTtcbn1cbnZhciBhbCA9IC9bLStdPyg/OlxcZCtcXC4/XFxkKnxcXC4/XFxkKykoPzpbZUVdWy0rXT9cXGQrKT8vZywgRnUgPSBuZXcgUmVnRXhwKGFsLnNvdXJjZSwgXCJnXCIpO1xuZnVuY3Rpb24gQ0woZSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGU7XG4gIH07XG59XG5mdW5jdGlvbiBFTChlKSB7XG4gIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgcmV0dXJuIGUodCkgKyBcIlwiO1xuICB9O1xufVxuZnVuY3Rpb24gVEwoZSwgdCkge1xuICB2YXIgbiA9IGFsLmxhc3RJbmRleCA9IEZ1Lmxhc3RJbmRleCA9IDAsIHIsIGksIG8sIGEgPSAtMSwgcyA9IFtdLCB1ID0gW107XG4gIGZvciAoZSA9IGUgKyBcIlwiLCB0ID0gdCArIFwiXCI7IChyID0gYWwuZXhlYyhlKSkgJiYgKGkgPSBGdS5leGVjKHQpKTsgKVxuICAgIChvID0gaS5pbmRleCkgPiBuICYmIChvID0gdC5zbGljZShuLCBvKSwgc1thXSA/IHNbYV0gKz0gbyA6IHNbKythXSA9IG8pLCAociA9IHJbMF0pID09PSAoaSA9IGlbMF0pID8gc1thXSA/IHNbYV0gKz0gaSA6IHNbKythXSA9IGkgOiAoc1srK2FdID0gbnVsbCwgdS5wdXNoKHsgaTogYSwgeDogbnMociwgaSkgfSkpLCBuID0gRnUubGFzdEluZGV4O1xuICByZXR1cm4gbiA8IHQubGVuZ3RoICYmIChvID0gdC5zbGljZShuKSwgc1thXSA/IHNbYV0gKz0gbyA6IHNbKythXSA9IG8pLCBzLmxlbmd0aCA8IDIgPyB1WzBdID8gRUwodVswXS54KSA6IENMKHQpIDogKHQgPSB1Lmxlbmd0aCwgZnVuY3Rpb24oYykge1xuICAgIGZvciAodmFyIGYgPSAwLCBsOyBmIDwgdDsgKytmKVxuICAgICAgc1sobCA9IHVbZl0pLmldID0gbC54KGMpO1xuICAgIHJldHVybiBzLmpvaW4oXCJcIik7XG4gIH0pO1xufVxuZnVuY3Rpb24gdmkoZSwgdCkge1xuICB2YXIgbiA9IHR5cGVvZiB0LCByO1xuICByZXR1cm4gdCA9PSBudWxsIHx8IG4gPT09IFwiYm9vbGVhblwiID8gR2YodCkgOiAobiA9PT0gXCJudW1iZXJcIiA/IG5zIDogbiA9PT0gXCJzdHJpbmdcIiA/IChyID0gbG8odCkpID8gKHQgPSByLCBVaCkgOiBUTCA6IHQgaW5zdGFuY2VvZiBsbyA/IFVoIDogdCBpbnN0YW5jZW9mIERhdGUgPyBBTCA6IE9MKHQpID8gJEwgOiBBcnJheS5pc0FycmF5KHQpID8gX0wgOiB0eXBlb2YgdC52YWx1ZU9mICE9IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgdC50b1N0cmluZyAhPSBcImZ1bmN0aW9uXCIgfHwgaXNOYU4odCkgPyBQTCA6IG5zKShlLCB0KTtcbn1cbmZ1bmN0aW9uIFdmKGUsIHQpIHtcbiAgcmV0dXJuIGUgPSArZSwgdCA9ICt0LCBmdW5jdGlvbihuKSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQoZSAqICgxIC0gbikgKyB0ICogbik7XG4gIH07XG59XG5mdW5jdGlvbiBNTChlLCB0KSB7XG4gIHQgPT09IHZvaWQgMCAmJiAodCA9IGUsIGUgPSB2aSk7XG4gIGZvciAodmFyIG4gPSAwLCByID0gdC5sZW5ndGggLSAxLCBpID0gdFswXSwgbyA9IG5ldyBBcnJheShyIDwgMCA/IDAgOiByKTsgbiA8IHI7IClcbiAgICBvW25dID0gZShpLCBpID0gdFsrK25dKTtcbiAgcmV0dXJuIGZ1bmN0aW9uKGEpIHtcbiAgICB2YXIgcyA9IE1hdGgubWF4KDAsIE1hdGgubWluKHIgLSAxLCBNYXRoLmZsb29yKGEgKj0gcikpKTtcbiAgICByZXR1cm4gb1tzXShhIC0gcyk7XG4gIH07XG59XG5mdW5jdGlvbiBSTChlKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZTtcbiAgfTtcbn1cbmZ1bmN0aW9uIHJzKGUpIHtcbiAgcmV0dXJuICtlO1xufVxudmFyIEhoID0gWzAsIDFdO1xuZnVuY3Rpb24gZnQoZSkge1xuICByZXR1cm4gZTtcbn1cbmZ1bmN0aW9uIHNsKGUsIHQpIHtcbiAgcmV0dXJuICh0IC09IGUgPSArZSkgPyBmdW5jdGlvbihuKSB7XG4gICAgcmV0dXJuIChuIC0gZSkgLyB0O1xuICB9IDogUkwoaXNOYU4odCkgPyBOYU4gOiAwLjUpO1xufVxuZnVuY3Rpb24gSUwoZSwgdCkge1xuICB2YXIgbjtcbiAgcmV0dXJuIGUgPiB0ICYmIChuID0gZSwgZSA9IHQsIHQgPSBuKSwgZnVuY3Rpb24ocikge1xuICAgIHJldHVybiBNYXRoLm1heChlLCBNYXRoLm1pbih0LCByKSk7XG4gIH07XG59XG5mdW5jdGlvbiBqTChlLCB0LCBuKSB7XG4gIHZhciByID0gZVswXSwgaSA9IGVbMV0sIG8gPSB0WzBdLCBhID0gdFsxXTtcbiAgcmV0dXJuIGkgPCByID8gKHIgPSBzbChpLCByKSwgbyA9IG4oYSwgbykpIDogKHIgPSBzbChyLCBpKSwgbyA9IG4obywgYSkpLCBmdW5jdGlvbihzKSB7XG4gICAgcmV0dXJuIG8ocihzKSk7XG4gIH07XG59XG5mdW5jdGlvbiBrTChlLCB0LCBuKSB7XG4gIHZhciByID0gTWF0aC5taW4oZS5sZW5ndGgsIHQubGVuZ3RoKSAtIDEsIGkgPSBuZXcgQXJyYXkociksIG8gPSBuZXcgQXJyYXkociksIGEgPSAtMTtcbiAgZm9yIChlW3JdIDwgZVswXSAmJiAoZSA9IGUuc2xpY2UoKS5yZXZlcnNlKCksIHQgPSB0LnNsaWNlKCkucmV2ZXJzZSgpKTsgKythIDwgcjsgKVxuICAgIGlbYV0gPSBzbChlW2FdLCBlW2EgKyAxXSksIG9bYV0gPSBuKHRbYV0sIHRbYSArIDFdKTtcbiAgcmV0dXJuIGZ1bmN0aW9uKHMpIHtcbiAgICB2YXIgdSA9IHFvKGUsIHMsIDEsIHIpIC0gMTtcbiAgICByZXR1cm4gb1t1XShpW3VdKHMpKTtcbiAgfTtcbn1cbmZ1bmN0aW9uIFlvKGUsIHQpIHtcbiAgcmV0dXJuIHQuZG9tYWluKGUuZG9tYWluKCkpLnJhbmdlKGUucmFuZ2UoKSkuaW50ZXJwb2xhdGUoZS5pbnRlcnBvbGF0ZSgpKS5jbGFtcChlLmNsYW1wKCkpLnVua25vd24oZS51bmtub3duKCkpO1xufVxuZnVuY3Rpb24gcXMoKSB7XG4gIHZhciBlID0gSGgsIHQgPSBIaCwgbiA9IHZpLCByLCBpLCBvLCBhID0gZnQsIHMsIHUsIGM7XG4gIGZ1bmN0aW9uIGYoKSB7XG4gICAgdmFyIGQgPSBNYXRoLm1pbihlLmxlbmd0aCwgdC5sZW5ndGgpO1xuICAgIHJldHVybiBhICE9PSBmdCAmJiAoYSA9IElMKGVbMF0sIGVbZCAtIDFdKSksIHMgPSBkID4gMiA/IGtMIDogakwsIHUgPSBjID0gbnVsbCwgbDtcbiAgfVxuICBmdW5jdGlvbiBsKGQpIHtcbiAgICByZXR1cm4gZCA9PSBudWxsIHx8IGlzTmFOKGQgPSArZCkgPyBvIDogKHUgfHwgKHUgPSBzKGUubWFwKHIpLCB0LCBuKSkpKHIoYShkKSkpO1xuICB9XG4gIHJldHVybiBsLmludmVydCA9IGZ1bmN0aW9uKGQpIHtcbiAgICByZXR1cm4gYShpKChjIHx8IChjID0gcyh0LCBlLm1hcChyKSwgbnMpKSkoZCkpKTtcbiAgfSwgbC5kb21haW4gPSBmdW5jdGlvbihkKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoZSA9IEFycmF5LmZyb20oZCwgcnMpLCBmKCkpIDogZS5zbGljZSgpO1xuICB9LCBsLnJhbmdlID0gZnVuY3Rpb24oZCkge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHQgPSBBcnJheS5mcm9tKGQpLCBmKCkpIDogdC5zbGljZSgpO1xuICB9LCBsLnJhbmdlUm91bmQgPSBmdW5jdGlvbihkKSB7XG4gICAgcmV0dXJuIHQgPSBBcnJheS5mcm9tKGQpLCBuID0gV2YsIGYoKTtcbiAgfSwgbC5jbGFtcCA9IGZ1bmN0aW9uKGQpIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChhID0gZCA/ICEwIDogZnQsIGYoKSkgOiBhICE9PSBmdDtcbiAgfSwgbC5pbnRlcnBvbGF0ZSA9IGZ1bmN0aW9uKGQpIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChuID0gZCwgZigpKSA6IG47XG4gIH0sIGwudW5rbm93biA9IGZ1bmN0aW9uKGQpIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChvID0gZCwgbCkgOiBvO1xuICB9LCBmdW5jdGlvbihkLCBwKSB7XG4gICAgcmV0dXJuIHIgPSBkLCBpID0gcCwgZigpO1xuICB9O1xufVxuZnVuY3Rpb24gVWYoKSB7XG4gIHJldHVybiBxcygpKGZ0LCBmdCk7XG59XG5mdW5jdGlvbiBETChlKSB7XG4gIHJldHVybiBNYXRoLmFicyhlID0gTWF0aC5yb3VuZChlKSkgPj0gMWUyMSA/IGUudG9Mb2NhbGVTdHJpbmcoXCJlblwiKS5yZXBsYWNlKC8sL2csIFwiXCIpIDogZS50b1N0cmluZygxMCk7XG59XG5mdW5jdGlvbiBpcyhlLCB0KSB7XG4gIGlmICgobiA9IChlID0gdCA/IGUudG9FeHBvbmVudGlhbCh0IC0gMSkgOiBlLnRvRXhwb25lbnRpYWwoKSkuaW5kZXhPZihcImVcIikpIDwgMClcbiAgICByZXR1cm4gbnVsbDtcbiAgdmFyIG4sIHIgPSBlLnNsaWNlKDAsIG4pO1xuICByZXR1cm4gW1xuICAgIHIubGVuZ3RoID4gMSA/IHJbMF0gKyByLnNsaWNlKDIpIDogcixcbiAgICArZS5zbGljZShuICsgMSlcbiAgXTtcbn1cbmZ1bmN0aW9uIFVyKGUpIHtcbiAgcmV0dXJuIGUgPSBpcyhNYXRoLmFicyhlKSksIGUgPyBlWzFdIDogTmFOO1xufVxuZnVuY3Rpb24gTkwoZSwgdCkge1xuICByZXR1cm4gZnVuY3Rpb24obiwgcikge1xuICAgIGZvciAodmFyIGkgPSBuLmxlbmd0aCwgbyA9IFtdLCBhID0gMCwgcyA9IGVbMF0sIHUgPSAwOyBpID4gMCAmJiBzID4gMCAmJiAodSArIHMgKyAxID4gciAmJiAocyA9IE1hdGgubWF4KDEsIHIgLSB1KSksIG8ucHVzaChuLnN1YnN0cmluZyhpIC09IHMsIGkgKyBzKSksICEoKHUgKz0gcyArIDEpID4gcikpOyApXG4gICAgICBzID0gZVthID0gKGEgKyAxKSAlIGUubGVuZ3RoXTtcbiAgICByZXR1cm4gby5yZXZlcnNlKCkuam9pbih0KTtcbiAgfTtcbn1cbmZ1bmN0aW9uIEZMKGUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcbiAgICByZXR1cm4gdC5yZXBsYWNlKC9bMC05XS9nLCBmdW5jdGlvbihuKSB7XG4gICAgICByZXR1cm4gZVsrbl07XG4gICAgfSk7XG4gIH07XG59XG52YXIgTEwgPSAvXig/OiguKT8oWzw+PV5dKSk/KFsrXFwtKCBdKT8oWyQjXSk/KDApPyhcXGQrKT8oLCk/KFxcLlxcZCspPyh+KT8oW2EteiVdKT8kL2k7XG5mdW5jdGlvbiBmbyhlKSB7XG4gIGlmICghKHQgPSBMTC5leGVjKGUpKSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGZvcm1hdDogXCIgKyBlKTtcbiAgdmFyIHQ7XG4gIHJldHVybiBuZXcgSGYoe1xuICAgIGZpbGw6IHRbMV0sXG4gICAgYWxpZ246IHRbMl0sXG4gICAgc2lnbjogdFszXSxcbiAgICBzeW1ib2w6IHRbNF0sXG4gICAgemVybzogdFs1XSxcbiAgICB3aWR0aDogdFs2XSxcbiAgICBjb21tYTogdFs3XSxcbiAgICBwcmVjaXNpb246IHRbOF0gJiYgdFs4XS5zbGljZSgxKSxcbiAgICB0cmltOiB0WzldLFxuICAgIHR5cGU6IHRbMTBdXG4gIH0pO1xufVxuZm8ucHJvdG90eXBlID0gSGYucHJvdG90eXBlO1xuZnVuY3Rpb24gSGYoZSkge1xuICB0aGlzLmZpbGwgPSBlLmZpbGwgPT09IHZvaWQgMCA/IFwiIFwiIDogZS5maWxsICsgXCJcIiwgdGhpcy5hbGlnbiA9IGUuYWxpZ24gPT09IHZvaWQgMCA/IFwiPlwiIDogZS5hbGlnbiArIFwiXCIsIHRoaXMuc2lnbiA9IGUuc2lnbiA9PT0gdm9pZCAwID8gXCItXCIgOiBlLnNpZ24gKyBcIlwiLCB0aGlzLnN5bWJvbCA9IGUuc3ltYm9sID09PSB2b2lkIDAgPyBcIlwiIDogZS5zeW1ib2wgKyBcIlwiLCB0aGlzLnplcm8gPSAhIWUuemVybywgdGhpcy53aWR0aCA9IGUud2lkdGggPT09IHZvaWQgMCA/IHZvaWQgMCA6ICtlLndpZHRoLCB0aGlzLmNvbW1hID0gISFlLmNvbW1hLCB0aGlzLnByZWNpc2lvbiA9IGUucHJlY2lzaW9uID09PSB2b2lkIDAgPyB2b2lkIDAgOiArZS5wcmVjaXNpb24sIHRoaXMudHJpbSA9ICEhZS50cmltLCB0aGlzLnR5cGUgPSBlLnR5cGUgPT09IHZvaWQgMCA/IFwiXCIgOiBlLnR5cGUgKyBcIlwiO1xufVxuSGYucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLmZpbGwgKyB0aGlzLmFsaWduICsgdGhpcy5zaWduICsgdGhpcy5zeW1ib2wgKyAodGhpcy56ZXJvID8gXCIwXCIgOiBcIlwiKSArICh0aGlzLndpZHRoID09PSB2b2lkIDAgPyBcIlwiIDogTWF0aC5tYXgoMSwgdGhpcy53aWR0aCB8IDApKSArICh0aGlzLmNvbW1hID8gXCIsXCIgOiBcIlwiKSArICh0aGlzLnByZWNpc2lvbiA9PT0gdm9pZCAwID8gXCJcIiA6IFwiLlwiICsgTWF0aC5tYXgoMCwgdGhpcy5wcmVjaXNpb24gfCAwKSkgKyAodGhpcy50cmltID8gXCJ+XCIgOiBcIlwiKSArIHRoaXMudHlwZTtcbn07XG5mdW5jdGlvbiBCTChlKSB7XG4gIGU6XG4gICAgZm9yICh2YXIgdCA9IGUubGVuZ3RoLCBuID0gMSwgciA9IC0xLCBpOyBuIDwgdDsgKytuKVxuICAgICAgc3dpdGNoIChlW25dKSB7XG4gICAgICAgIGNhc2UgXCIuXCI6XG4gICAgICAgICAgciA9IGkgPSBuO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiMFwiOlxuICAgICAgICAgIHIgPT09IDAgJiYgKHIgPSBuKSwgaSA9IG47XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgaWYgKCErZVtuXSlcbiAgICAgICAgICAgIGJyZWFrIGU7XG4gICAgICAgICAgciA+IDAgJiYgKHIgPSAwKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgcmV0dXJuIHIgPiAwID8gZS5zbGljZSgwLCByKSArIGUuc2xpY2UoaSArIDEpIDogZTtcbn1cbnZhciByMDtcbmZ1bmN0aW9uIHpMKGUsIHQpIHtcbiAgdmFyIG4gPSBpcyhlLCB0KTtcbiAgaWYgKCFuKVxuICAgIHJldHVybiBlICsgXCJcIjtcbiAgdmFyIHIgPSBuWzBdLCBpID0gblsxXSwgbyA9IGkgLSAocjAgPSBNYXRoLm1heCgtOCwgTWF0aC5taW4oOCwgTWF0aC5mbG9vcihpIC8gMykpKSAqIDMpICsgMSwgYSA9IHIubGVuZ3RoO1xuICByZXR1cm4gbyA9PT0gYSA/IHIgOiBvID4gYSA/IHIgKyBuZXcgQXJyYXkobyAtIGEgKyAxKS5qb2luKFwiMFwiKSA6IG8gPiAwID8gci5zbGljZSgwLCBvKSArIFwiLlwiICsgci5zbGljZShvKSA6IFwiMC5cIiArIG5ldyBBcnJheSgxIC0gbykuam9pbihcIjBcIikgKyBpcyhlLCBNYXRoLm1heCgwLCB0ICsgbyAtIDEpKVswXTtcbn1cbmZ1bmN0aW9uIHFoKGUsIHQpIHtcbiAgdmFyIG4gPSBpcyhlLCB0KTtcbiAgaWYgKCFuKVxuICAgIHJldHVybiBlICsgXCJcIjtcbiAgdmFyIHIgPSBuWzBdLCBpID0gblsxXTtcbiAgcmV0dXJuIGkgPCAwID8gXCIwLlwiICsgbmV3IEFycmF5KC1pKS5qb2luKFwiMFwiKSArIHIgOiByLmxlbmd0aCA+IGkgKyAxID8gci5zbGljZSgwLCBpICsgMSkgKyBcIi5cIiArIHIuc2xpY2UoaSArIDEpIDogciArIG5ldyBBcnJheShpIC0gci5sZW5ndGggKyAyKS5qb2luKFwiMFwiKTtcbn1cbmNvbnN0IEtoID0ge1xuICBcIiVcIjogKGUsIHQpID0+IChlICogMTAwKS50b0ZpeGVkKHQpLFxuICBiOiAoZSkgPT4gTWF0aC5yb3VuZChlKS50b1N0cmluZygyKSxcbiAgYzogKGUpID0+IGUgKyBcIlwiLFxuICBkOiBETCxcbiAgZTogKGUsIHQpID0+IGUudG9FeHBvbmVudGlhbCh0KSxcbiAgZjogKGUsIHQpID0+IGUudG9GaXhlZCh0KSxcbiAgZzogKGUsIHQpID0+IGUudG9QcmVjaXNpb24odCksXG4gIG86IChlKSA9PiBNYXRoLnJvdW5kKGUpLnRvU3RyaW5nKDgpLFxuICBwOiAoZSwgdCkgPT4gcWgoZSAqIDEwMCwgdCksXG4gIHI6IHFoLFxuICBzOiB6TCxcbiAgWDogKGUpID0+IE1hdGgucm91bmQoZSkudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCksXG4gIHg6IChlKSA9PiBNYXRoLnJvdW5kKGUpLnRvU3RyaW5nKDE2KVxufTtcbmZ1bmN0aW9uIFloKGUpIHtcbiAgcmV0dXJuIGU7XG59XG52YXIgWGggPSBBcnJheS5wcm90b3R5cGUubWFwLCBaaCA9IFtcInlcIiwgXCJ6XCIsIFwiYVwiLCBcImZcIiwgXCJwXCIsIFwiblwiLCBcIsK1XCIsIFwibVwiLCBcIlwiLCBcImtcIiwgXCJNXCIsIFwiR1wiLCBcIlRcIiwgXCJQXCIsIFwiRVwiLCBcIlpcIiwgXCJZXCJdO1xuZnVuY3Rpb24gVkwoZSkge1xuICB2YXIgdCA9IGUuZ3JvdXBpbmcgPT09IHZvaWQgMCB8fCBlLnRob3VzYW5kcyA9PT0gdm9pZCAwID8gWWggOiBOTChYaC5jYWxsKGUuZ3JvdXBpbmcsIE51bWJlciksIGUudGhvdXNhbmRzICsgXCJcIiksIG4gPSBlLmN1cnJlbmN5ID09PSB2b2lkIDAgPyBcIlwiIDogZS5jdXJyZW5jeVswXSArIFwiXCIsIHIgPSBlLmN1cnJlbmN5ID09PSB2b2lkIDAgPyBcIlwiIDogZS5jdXJyZW5jeVsxXSArIFwiXCIsIGkgPSBlLmRlY2ltYWwgPT09IHZvaWQgMCA/IFwiLlwiIDogZS5kZWNpbWFsICsgXCJcIiwgbyA9IGUubnVtZXJhbHMgPT09IHZvaWQgMCA/IFloIDogRkwoWGguY2FsbChlLm51bWVyYWxzLCBTdHJpbmcpKSwgYSA9IGUucGVyY2VudCA9PT0gdm9pZCAwID8gXCIlXCIgOiBlLnBlcmNlbnQgKyBcIlwiLCBzID0gZS5taW51cyA9PT0gdm9pZCAwID8gXCLiiJJcIiA6IGUubWludXMgKyBcIlwiLCB1ID0gZS5uYW4gPT09IHZvaWQgMCA/IFwiTmFOXCIgOiBlLm5hbiArIFwiXCI7XG4gIGZ1bmN0aW9uIGMobCkge1xuICAgIGwgPSBmbyhsKTtcbiAgICB2YXIgZCA9IGwuZmlsbCwgcCA9IGwuYWxpZ24sIGcgPSBsLnNpZ24sIGggPSBsLnN5bWJvbCwgdiA9IGwuemVybywgdyA9IGwud2lkdGgsIGIgPSBsLmNvbW1hLCB4ID0gbC5wcmVjaXNpb24sIG0gPSBsLnRyaW0sIHkgPSBsLnR5cGU7XG4gICAgeSA9PT0gXCJuXCIgPyAoYiA9ICEwLCB5ID0gXCJnXCIpIDogS2hbeV0gfHwgKHggPT09IHZvaWQgMCAmJiAoeCA9IDEyKSwgbSA9ICEwLCB5ID0gXCJnXCIpLCAodiB8fCBkID09PSBcIjBcIiAmJiBwID09PSBcIj1cIikgJiYgKHYgPSAhMCwgZCA9IFwiMFwiLCBwID0gXCI9XCIpO1xuICAgIHZhciBTID0gaCA9PT0gXCIkXCIgPyBuIDogaCA9PT0gXCIjXCIgJiYgL1tib3hYXS8udGVzdCh5KSA/IFwiMFwiICsgeS50b0xvd2VyQ2FzZSgpIDogXCJcIiwgJCA9IGggPT09IFwiJFwiID8gciA6IC9bJXBdLy50ZXN0KHkpID8gYSA6IFwiXCIsIE8gPSBLaFt5XSwgVCA9IC9bZGVmZ3BycyVdLy50ZXN0KHkpO1xuICAgIHggPSB4ID09PSB2b2lkIDAgPyA2IDogL1tncHJzXS8udGVzdCh5KSA/IE1hdGgubWF4KDEsIE1hdGgubWluKDIxLCB4KSkgOiBNYXRoLm1heCgwLCBNYXRoLm1pbigyMCwgeCkpO1xuICAgIGZ1bmN0aW9uIE0oRSkge1xuICAgICAgdmFyIEEgPSBTLCBqID0gJCwgUiwgTiwgaztcbiAgICAgIGlmICh5ID09PSBcImNcIilcbiAgICAgICAgaiA9IE8oRSkgKyBqLCBFID0gXCJcIjtcbiAgICAgIGVsc2Uge1xuICAgICAgICBFID0gK0U7XG4gICAgICAgIHZhciBGID0gRSA8IDAgfHwgMSAvIEUgPCAwO1xuICAgICAgICBpZiAoRSA9IGlzTmFOKEUpID8gdSA6IE8oTWF0aC5hYnMoRSksIHgpLCBtICYmIChFID0gQkwoRSkpLCBGICYmICtFID09IDAgJiYgZyAhPT0gXCIrXCIgJiYgKEYgPSAhMSksIEEgPSAoRiA/IGcgPT09IFwiKFwiID8gZyA6IHMgOiBnID09PSBcIi1cIiB8fCBnID09PSBcIihcIiA/IFwiXCIgOiBnKSArIEEsIGogPSAoeSA9PT0gXCJzXCIgPyBaaFs4ICsgcjAgLyAzXSA6IFwiXCIpICsgaiArIChGICYmIGcgPT09IFwiKFwiID8gXCIpXCIgOiBcIlwiKSwgVCkge1xuICAgICAgICAgIGZvciAoUiA9IC0xLCBOID0gRS5sZW5ndGg7ICsrUiA8IE47IClcbiAgICAgICAgICAgIGlmIChrID0gRS5jaGFyQ29kZUF0KFIpLCA0OCA+IGsgfHwgayA+IDU3KSB7XG4gICAgICAgICAgICAgIGogPSAoayA9PT0gNDYgPyBpICsgRS5zbGljZShSICsgMSkgOiBFLnNsaWNlKFIpKSArIGosIEUgPSBFLnNsaWNlKDAsIFIpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYiAmJiAhdiAmJiAoRSA9IHQoRSwgMSAvIDApKTtcbiAgICAgIHZhciBWID0gQS5sZW5ndGggKyBFLmxlbmd0aCArIGoubGVuZ3RoLCBMID0gViA8IHcgPyBuZXcgQXJyYXkodyAtIFYgKyAxKS5qb2luKGQpIDogXCJcIjtcbiAgICAgIHN3aXRjaCAoYiAmJiB2ICYmIChFID0gdChMICsgRSwgTC5sZW5ndGggPyB3IC0gai5sZW5ndGggOiAxIC8gMCksIEwgPSBcIlwiKSwgcCkge1xuICAgICAgICBjYXNlIFwiPFwiOlxuICAgICAgICAgIEUgPSBBICsgRSArIGogKyBMO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiPVwiOlxuICAgICAgICAgIEUgPSBBICsgTCArIEUgKyBqO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiXlwiOlxuICAgICAgICAgIEUgPSBMLnNsaWNlKDAsIFYgPSBMLmxlbmd0aCA+PiAxKSArIEEgKyBFICsgaiArIEwuc2xpY2UoVik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgRSA9IEwgKyBBICsgRSArIGo7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICByZXR1cm4gbyhFKTtcbiAgICB9XG4gICAgcmV0dXJuIE0udG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBsICsgXCJcIjtcbiAgICB9LCBNO1xuICB9XG4gIGZ1bmN0aW9uIGYobCwgZCkge1xuICAgIHZhciBwID0gYygobCA9IGZvKGwpLCBsLnR5cGUgPSBcImZcIiwgbCkpLCBnID0gTWF0aC5tYXgoLTgsIE1hdGgubWluKDgsIE1hdGguZmxvb3IoVXIoZCkgLyAzKSkpICogMywgaCA9IE1hdGgucG93KDEwLCAtZyksIHYgPSBaaFs4ICsgZyAvIDNdO1xuICAgIHJldHVybiBmdW5jdGlvbih3KSB7XG4gICAgICByZXR1cm4gcChoICogdykgKyB2O1xuICAgIH07XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBmb3JtYXQ6IGMsXG4gICAgZm9ybWF0UHJlZml4OiBmXG4gIH07XG59XG52YXIgdmEsIHFmLCBpMDtcbkdMKHtcbiAgdGhvdXNhbmRzOiBcIixcIixcbiAgZ3JvdXBpbmc6IFszXSxcbiAgY3VycmVuY3k6IFtcIiRcIiwgXCJcIl1cbn0pO1xuZnVuY3Rpb24gR0woZSkge1xuICByZXR1cm4gdmEgPSBWTChlKSwgcWYgPSB2YS5mb3JtYXQsIGkwID0gdmEuZm9ybWF0UHJlZml4LCB2YTtcbn1cbmZ1bmN0aW9uIFdMKGUpIHtcbiAgcmV0dXJuIE1hdGgubWF4KDAsIC1VcihNYXRoLmFicyhlKSkpO1xufVxuZnVuY3Rpb24gVUwoZSwgdCkge1xuICByZXR1cm4gTWF0aC5tYXgoMCwgTWF0aC5tYXgoLTgsIE1hdGgubWluKDgsIE1hdGguZmxvb3IoVXIodCkgLyAzKSkpICogMyAtIFVyKE1hdGguYWJzKGUpKSk7XG59XG5mdW5jdGlvbiBITChlLCB0KSB7XG4gIHJldHVybiBlID0gTWF0aC5hYnMoZSksIHQgPSBNYXRoLmFicyh0KSAtIGUsIE1hdGgubWF4KDAsIFVyKHQpIC0gVXIoZSkpICsgMTtcbn1cbmZ1bmN0aW9uIG8wKGUsIHQsIG4sIHIpIHtcbiAgdmFyIGkgPSBybChlLCB0LCBuKSwgbztcbiAgc3dpdGNoIChyID0gZm8ociA/PyBcIixmXCIpLCByLnR5cGUpIHtcbiAgICBjYXNlIFwic1wiOiB7XG4gICAgICB2YXIgYSA9IE1hdGgubWF4KE1hdGguYWJzKGUpLCBNYXRoLmFicyh0KSk7XG4gICAgICByZXR1cm4gci5wcmVjaXNpb24gPT0gbnVsbCAmJiAhaXNOYU4obyA9IFVMKGksIGEpKSAmJiAoci5wcmVjaXNpb24gPSBvKSwgaTAociwgYSk7XG4gICAgfVxuICAgIGNhc2UgXCJcIjpcbiAgICBjYXNlIFwiZVwiOlxuICAgIGNhc2UgXCJnXCI6XG4gICAgY2FzZSBcInBcIjpcbiAgICBjYXNlIFwiclwiOiB7XG4gICAgICByLnByZWNpc2lvbiA9PSBudWxsICYmICFpc05hTihvID0gSEwoaSwgTWF0aC5tYXgoTWF0aC5hYnMoZSksIE1hdGguYWJzKHQpKSkpICYmIChyLnByZWNpc2lvbiA9IG8gLSAoci50eXBlID09PSBcImVcIikpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNhc2UgXCJmXCI6XG4gICAgY2FzZSBcIiVcIjoge1xuICAgICAgci5wcmVjaXNpb24gPT0gbnVsbCAmJiAhaXNOYU4obyA9IFdMKGkpKSAmJiAoci5wcmVjaXNpb24gPSBvIC0gKHIudHlwZSA9PT0gXCIlXCIpICogMik7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHFmKHIpO1xufVxuZnVuY3Rpb24gcW4oZSkge1xuICB2YXIgdCA9IGUuZG9tYWluO1xuICByZXR1cm4gZS50aWNrcyA9IGZ1bmN0aW9uKG4pIHtcbiAgICB2YXIgciA9IHQoKTtcbiAgICByZXR1cm4gdGwoclswXSwgcltyLmxlbmd0aCAtIDFdLCBuID8/IDEwKTtcbiAgfSwgZS50aWNrRm9ybWF0ID0gZnVuY3Rpb24obiwgcikge1xuICAgIHZhciBpID0gdCgpO1xuICAgIHJldHVybiBvMChpWzBdLCBpW2kubGVuZ3RoIC0gMV0sIG4gPz8gMTAsIHIpO1xuICB9LCBlLm5pY2UgPSBmdW5jdGlvbihuKSB7XG4gICAgbiA9PSBudWxsICYmIChuID0gMTApO1xuICAgIHZhciByID0gdCgpLCBpID0gMCwgbyA9IHIubGVuZ3RoIC0gMSwgYSA9IHJbaV0sIHMgPSByW29dLCB1LCBjLCBmID0gMTA7XG4gICAgZm9yIChzIDwgYSAmJiAoYyA9IGEsIGEgPSBzLCBzID0gYywgYyA9IGksIGkgPSBvLCBvID0gYyk7IGYtLSA+IDA7ICkge1xuICAgICAgaWYgKGMgPSBubChhLCBzLCBuKSwgYyA9PT0gdSlcbiAgICAgICAgcmV0dXJuIHJbaV0gPSBhLCByW29dID0gcywgdChyKTtcbiAgICAgIGlmIChjID4gMClcbiAgICAgICAgYSA9IE1hdGguZmxvb3IoYSAvIGMpICogYywgcyA9IE1hdGguY2VpbChzIC8gYykgKiBjO1xuICAgICAgZWxzZSBpZiAoYyA8IDApXG4gICAgICAgIGEgPSBNYXRoLmNlaWwoYSAqIGMpIC8gYywgcyA9IE1hdGguZmxvb3IocyAqIGMpIC8gYztcbiAgICAgIGVsc2VcbiAgICAgICAgYnJlYWs7XG4gICAgICB1ID0gYztcbiAgICB9XG4gICAgcmV0dXJuIGU7XG4gIH0sIGU7XG59XG5mdW5jdGlvbiBvcygpIHtcbiAgdmFyIGUgPSBVZigpO1xuICByZXR1cm4gZS5jb3B5ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIFlvKGUsIG9zKCkpO1xuICB9LCBCdC5hcHBseShlLCBhcmd1bWVudHMpLCBxbihlKTtcbn1cbmZ1bmN0aW9uIGEwKGUpIHtcbiAgdmFyIHQ7XG4gIGZ1bmN0aW9uIG4ocikge1xuICAgIHJldHVybiByID09IG51bGwgfHwgaXNOYU4ociA9ICtyKSA/IHQgOiByO1xuICB9XG4gIHJldHVybiBuLmludmVydCA9IG4sIG4uZG9tYWluID0gbi5yYW5nZSA9IGZ1bmN0aW9uKHIpIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChlID0gQXJyYXkuZnJvbShyLCBycyksIG4pIDogZS5zbGljZSgpO1xuICB9LCBuLnVua25vd24gPSBmdW5jdGlvbihyKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAodCA9IHIsIG4pIDogdDtcbiAgfSwgbi5jb3B5ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGEwKGUpLnVua25vd24odCk7XG4gIH0sIGUgPSBhcmd1bWVudHMubGVuZ3RoID8gQXJyYXkuZnJvbShlLCBycykgOiBbMCwgMV0sIHFuKG4pO1xufVxuZnVuY3Rpb24gczAoZSwgdCkge1xuICBlID0gZS5zbGljZSgpO1xuICB2YXIgbiA9IDAsIHIgPSBlLmxlbmd0aCAtIDEsIGkgPSBlW25dLCBvID0gZVtyXSwgYTtcbiAgcmV0dXJuIG8gPCBpICYmIChhID0gbiwgbiA9IHIsIHIgPSBhLCBhID0gaSwgaSA9IG8sIG8gPSBhKSwgZVtuXSA9IHQuZmxvb3IoaSksIGVbcl0gPSB0LmNlaWwobyksIGU7XG59XG5mdW5jdGlvbiBKaChlKSB7XG4gIHJldHVybiBNYXRoLmxvZyhlKTtcbn1cbmZ1bmN0aW9uIFFoKGUpIHtcbiAgcmV0dXJuIE1hdGguZXhwKGUpO1xufVxuZnVuY3Rpb24gcUwoZSkge1xuICByZXR1cm4gLU1hdGgubG9nKC1lKTtcbn1cbmZ1bmN0aW9uIEtMKGUpIHtcbiAgcmV0dXJuIC1NYXRoLmV4cCgtZSk7XG59XG5mdW5jdGlvbiBZTChlKSB7XG4gIHJldHVybiBpc0Zpbml0ZShlKSA/ICsoXCIxZVwiICsgZSkgOiBlIDwgMCA/IDAgOiBlO1xufVxuZnVuY3Rpb24gWEwoZSkge1xuICByZXR1cm4gZSA9PT0gMTAgPyBZTCA6IGUgPT09IE1hdGguRSA/IE1hdGguZXhwIDogKHQpID0+IE1hdGgucG93KGUsIHQpO1xufVxuZnVuY3Rpb24gWkwoZSkge1xuICByZXR1cm4gZSA9PT0gTWF0aC5FID8gTWF0aC5sb2cgOiBlID09PSAxMCAmJiBNYXRoLmxvZzEwIHx8IGUgPT09IDIgJiYgTWF0aC5sb2cyIHx8IChlID0gTWF0aC5sb2coZSksICh0KSA9PiBNYXRoLmxvZyh0KSAvIGUpO1xufVxuZnVuY3Rpb24gZWcoZSkge1xuICByZXR1cm4gKHQsIG4pID0+IC1lKC10LCBuKTtcbn1cbmZ1bmN0aW9uIEtmKGUpIHtcbiAgY29uc3QgdCA9IGUoSmgsIFFoKSwgbiA9IHQuZG9tYWluO1xuICBsZXQgciA9IDEwLCBpLCBvO1xuICBmdW5jdGlvbiBhKCkge1xuICAgIHJldHVybiBpID0gWkwociksIG8gPSBYTChyKSwgbigpWzBdIDwgMCA/IChpID0gZWcoaSksIG8gPSBlZyhvKSwgZShxTCwgS0wpKSA6IGUoSmgsIFFoKSwgdDtcbiAgfVxuICByZXR1cm4gdC5iYXNlID0gZnVuY3Rpb24ocykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHIgPSArcywgYSgpKSA6IHI7XG4gIH0sIHQuZG9tYWluID0gZnVuY3Rpb24ocykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKG4ocyksIGEoKSkgOiBuKCk7XG4gIH0sIHQudGlja3MgPSAocykgPT4ge1xuICAgIGNvbnN0IHUgPSBuKCk7XG4gICAgbGV0IGMgPSB1WzBdLCBmID0gdVt1Lmxlbmd0aCAtIDFdO1xuICAgIGNvbnN0IGwgPSBmIDwgYztcbiAgICBsICYmIChbYywgZl0gPSBbZiwgY10pO1xuICAgIGxldCBkID0gaShjKSwgcCA9IGkoZiksIGcsIGg7XG4gICAgY29uc3QgdiA9IHMgPT0gbnVsbCA/IDEwIDogK3M7XG4gICAgbGV0IHcgPSBbXTtcbiAgICBpZiAoIShyICUgMSkgJiYgcCAtIGQgPCB2KSB7XG4gICAgICBpZiAoZCA9IE1hdGguZmxvb3IoZCksIHAgPSBNYXRoLmNlaWwocCksIGMgPiAwKSB7XG4gICAgICAgIGZvciAoOyBkIDw9IHA7ICsrZClcbiAgICAgICAgICBmb3IgKGcgPSAxOyBnIDwgcjsgKytnKVxuICAgICAgICAgICAgaWYgKGggPSBkIDwgMCA/IGcgLyBvKC1kKSA6IGcgKiBvKGQpLCAhKGggPCBjKSkge1xuICAgICAgICAgICAgICBpZiAoaCA+IGYpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIHcucHVzaChoKTtcbiAgICAgICAgICAgIH1cbiAgICAgIH0gZWxzZVxuICAgICAgICBmb3IgKDsgZCA8PSBwOyArK2QpXG4gICAgICAgICAgZm9yIChnID0gciAtIDE7IGcgPj0gMTsgLS1nKVxuICAgICAgICAgICAgaWYgKGggPSBkID4gMCA/IGcgLyBvKC1kKSA6IGcgKiBvKGQpLCAhKGggPCBjKSkge1xuICAgICAgICAgICAgICBpZiAoaCA+IGYpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIHcucHVzaChoKTtcbiAgICAgICAgICAgIH1cbiAgICAgIHcubGVuZ3RoICogMiA8IHYgJiYgKHcgPSB0bChjLCBmLCB2KSk7XG4gICAgfSBlbHNlXG4gICAgICB3ID0gdGwoZCwgcCwgTWF0aC5taW4ocCAtIGQsIHYpKS5tYXAobyk7XG4gICAgcmV0dXJuIGwgPyB3LnJldmVyc2UoKSA6IHc7XG4gIH0sIHQudGlja0Zvcm1hdCA9IChzLCB1KSA9PiB7XG4gICAgaWYgKHMgPT0gbnVsbCAmJiAocyA9IDEwKSwgdSA9PSBudWxsICYmICh1ID0gciA9PT0gMTAgPyBcInNcIiA6IFwiLFwiKSwgdHlwZW9mIHUgIT0gXCJmdW5jdGlvblwiICYmICghKHIgJSAxKSAmJiAodSA9IGZvKHUpKS5wcmVjaXNpb24gPT0gbnVsbCAmJiAodS50cmltID0gITApLCB1ID0gcWYodSkpLCBzID09PSAxIC8gMClcbiAgICAgIHJldHVybiB1O1xuICAgIGNvbnN0IGMgPSBNYXRoLm1heCgxLCByICogcyAvIHQudGlja3MoKS5sZW5ndGgpO1xuICAgIHJldHVybiAoZikgPT4ge1xuICAgICAgbGV0IGwgPSBmIC8gbyhNYXRoLnJvdW5kKGkoZikpKTtcbiAgICAgIHJldHVybiBsICogciA8IHIgLSAwLjUgJiYgKGwgKj0gciksIGwgPD0gYyA/IHUoZikgOiBcIlwiO1xuICAgIH07XG4gIH0sIHQubmljZSA9ICgpID0+IG4oczAobigpLCB7XG4gICAgZmxvb3I6IChzKSA9PiBvKE1hdGguZmxvb3IoaShzKSkpLFxuICAgIGNlaWw6IChzKSA9PiBvKE1hdGguY2VpbChpKHMpKSlcbiAgfSkpLCB0O1xufVxuZnVuY3Rpb24gdTAoKSB7XG4gIGNvbnN0IGUgPSBLZihxcygpKS5kb21haW4oWzEsIDEwXSk7XG4gIHJldHVybiBlLmNvcHkgPSAoKSA9PiBZbyhlLCB1MCgpKS5iYXNlKGUuYmFzZSgpKSwgQnQuYXBwbHkoZSwgYXJndW1lbnRzKSwgZTtcbn1cbmZ1bmN0aW9uIHRnKGUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcbiAgICByZXR1cm4gTWF0aC5zaWduKHQpICogTWF0aC5sb2cxcChNYXRoLmFicyh0IC8gZSkpO1xuICB9O1xufVxuZnVuY3Rpb24gbmcoZSkge1xuICByZXR1cm4gZnVuY3Rpb24odCkge1xuICAgIHJldHVybiBNYXRoLnNpZ24odCkgKiBNYXRoLmV4cG0xKE1hdGguYWJzKHQpKSAqIGU7XG4gIH07XG59XG5mdW5jdGlvbiBZZihlKSB7XG4gIHZhciB0ID0gMSwgbiA9IGUodGcodCksIG5nKHQpKTtcbiAgcmV0dXJuIG4uY29uc3RhbnQgPSBmdW5jdGlvbihyKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyBlKHRnKHQgPSArciksIG5nKHQpKSA6IHQ7XG4gIH0sIHFuKG4pO1xufVxuZnVuY3Rpb24gYzAoKSB7XG4gIHZhciBlID0gWWYocXMoKSk7XG4gIHJldHVybiBlLmNvcHkgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gWW8oZSwgYzAoKSkuY29uc3RhbnQoZS5jb25zdGFudCgpKTtcbiAgfSwgQnQuYXBwbHkoZSwgYXJndW1lbnRzKTtcbn1cbmZ1bmN0aW9uIHJnKGUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcbiAgICByZXR1cm4gdCA8IDAgPyAtTWF0aC5wb3coLXQsIGUpIDogTWF0aC5wb3codCwgZSk7XG4gIH07XG59XG5mdW5jdGlvbiBKTChlKSB7XG4gIHJldHVybiBlIDwgMCA/IC1NYXRoLnNxcnQoLWUpIDogTWF0aC5zcXJ0KGUpO1xufVxuZnVuY3Rpb24gUUwoZSkge1xuICByZXR1cm4gZSA8IDAgPyAtZSAqIGUgOiBlICogZTtcbn1cbmZ1bmN0aW9uIFhmKGUpIHtcbiAgdmFyIHQgPSBlKGZ0LCBmdCksIG4gPSAxO1xuICBmdW5jdGlvbiByKCkge1xuICAgIHJldHVybiBuID09PSAxID8gZShmdCwgZnQpIDogbiA9PT0gMC41ID8gZShKTCwgUUwpIDogZShyZyhuKSwgcmcoMSAvIG4pKTtcbiAgfVxuICByZXR1cm4gdC5leHBvbmVudCA9IGZ1bmN0aW9uKGkpIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChuID0gK2ksIHIoKSkgOiBuO1xuICB9LCBxbih0KTtcbn1cbmZ1bmN0aW9uIFpmKCkge1xuICB2YXIgZSA9IFhmKHFzKCkpO1xuICByZXR1cm4gZS5jb3B5ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIFlvKGUsIFpmKCkpLmV4cG9uZW50KGUuZXhwb25lbnQoKSk7XG4gIH0sIEJ0LmFwcGx5KGUsIGFyZ3VtZW50cyksIGU7XG59XG5mdW5jdGlvbiBlMygpIHtcbiAgcmV0dXJuIFpmLmFwcGx5KG51bGwsIGFyZ3VtZW50cykuZXhwb25lbnQoMC41KTtcbn1cbmZ1bmN0aW9uIGlnKGUpIHtcbiAgcmV0dXJuIE1hdGguc2lnbihlKSAqIGUgKiBlO1xufVxuZnVuY3Rpb24gdDMoZSkge1xuICByZXR1cm4gTWF0aC5zaWduKGUpICogTWF0aC5zcXJ0KE1hdGguYWJzKGUpKTtcbn1cbmZ1bmN0aW9uIGwwKCkge1xuICB2YXIgZSA9IFVmKCksIHQgPSBbMCwgMV0sIG4gPSAhMSwgcjtcbiAgZnVuY3Rpb24gaShvKSB7XG4gICAgdmFyIGEgPSB0MyhlKG8pKTtcbiAgICByZXR1cm4gaXNOYU4oYSkgPyByIDogbiA/IE1hdGgucm91bmQoYSkgOiBhO1xuICB9XG4gIHJldHVybiBpLmludmVydCA9IGZ1bmN0aW9uKG8pIHtcbiAgICByZXR1cm4gZS5pbnZlcnQoaWcobykpO1xuICB9LCBpLmRvbWFpbiA9IGZ1bmN0aW9uKG8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChlLmRvbWFpbihvKSwgaSkgOiBlLmRvbWFpbigpO1xuICB9LCBpLnJhbmdlID0gZnVuY3Rpb24obykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGUucmFuZ2UoKHQgPSBBcnJheS5mcm9tKG8sIHJzKSkubWFwKGlnKSksIGkpIDogdC5zbGljZSgpO1xuICB9LCBpLnJhbmdlUm91bmQgPSBmdW5jdGlvbihvKSB7XG4gICAgcmV0dXJuIGkucmFuZ2Uobykucm91bmQoITApO1xuICB9LCBpLnJvdW5kID0gZnVuY3Rpb24obykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKG4gPSAhIW8sIGkpIDogbjtcbiAgfSwgaS5jbGFtcCA9IGZ1bmN0aW9uKG8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChlLmNsYW1wKG8pLCBpKSA6IGUuY2xhbXAoKTtcbiAgfSwgaS51bmtub3duID0gZnVuY3Rpb24obykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHIgPSBvLCBpKSA6IHI7XG4gIH0sIGkuY29weSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBsMChlLmRvbWFpbigpLCB0KS5yb3VuZChuKS5jbGFtcChlLmNsYW1wKCkpLnVua25vd24ocik7XG4gIH0sIEJ0LmFwcGx5KGksIGFyZ3VtZW50cyksIHFuKGkpO1xufVxuZnVuY3Rpb24gZjAoKSB7XG4gIHZhciBlID0gW10sIHQgPSBbXSwgbiA9IFtdLCByO1xuICBmdW5jdGlvbiBpKCkge1xuICAgIHZhciBhID0gMCwgcyA9IE1hdGgubWF4KDEsIHQubGVuZ3RoKTtcbiAgICBmb3IgKG4gPSBuZXcgQXJyYXkocyAtIDEpOyArK2EgPCBzOyApXG4gICAgICBuW2EgLSAxXSA9IGFMKGUsIGEgLyBzKTtcbiAgICByZXR1cm4gbztcbiAgfVxuICBmdW5jdGlvbiBvKGEpIHtcbiAgICByZXR1cm4gYSA9PSBudWxsIHx8IGlzTmFOKGEgPSArYSkgPyByIDogdFtxbyhuLCBhKV07XG4gIH1cbiAgcmV0dXJuIG8uaW52ZXJ0RXh0ZW50ID0gZnVuY3Rpb24oYSkge1xuICAgIHZhciBzID0gdC5pbmRleE9mKGEpO1xuICAgIHJldHVybiBzIDwgMCA/IFtOYU4sIE5hTl0gOiBbXG4gICAgICBzID4gMCA/IG5bcyAtIDFdIDogZVswXSxcbiAgICAgIHMgPCBuLmxlbmd0aCA/IG5bc10gOiBlW2UubGVuZ3RoIC0gMV1cbiAgICBdO1xuICB9LCBvLmRvbWFpbiA9IGZ1bmN0aW9uKGEpIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpXG4gICAgICByZXR1cm4gZS5zbGljZSgpO1xuICAgIGUgPSBbXTtcbiAgICBmb3IgKGxldCBzIG9mIGEpXG4gICAgICBzICE9IG51bGwgJiYgIWlzTmFOKHMgPSArcykgJiYgZS5wdXNoKHMpO1xuICAgIHJldHVybiBlLnNvcnQoTG4pLCBpKCk7XG4gIH0sIG8ucmFuZ2UgPSBmdW5jdGlvbihhKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAodCA9IEFycmF5LmZyb20oYSksIGkoKSkgOiB0LnNsaWNlKCk7XG4gIH0sIG8udW5rbm93biA9IGZ1bmN0aW9uKGEpIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChyID0gYSwgbykgOiByO1xuICB9LCBvLnF1YW50aWxlcyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBuLnNsaWNlKCk7XG4gIH0sIG8uY29weSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBmMCgpLmRvbWFpbihlKS5yYW5nZSh0KS51bmtub3duKHIpO1xuICB9LCBCdC5hcHBseShvLCBhcmd1bWVudHMpO1xufVxuZnVuY3Rpb24gZDAoKSB7XG4gIHZhciBlID0gMCwgdCA9IDEsIG4gPSAxLCByID0gWzAuNV0sIGkgPSBbMCwgMV0sIG87XG4gIGZ1bmN0aW9uIGEodSkge1xuICAgIHJldHVybiB1ICE9IG51bGwgJiYgdSA8PSB1ID8gaVtxbyhyLCB1LCAwLCBuKV0gOiBvO1xuICB9XG4gIGZ1bmN0aW9uIHMoKSB7XG4gICAgdmFyIHUgPSAtMTtcbiAgICBmb3IgKHIgPSBuZXcgQXJyYXkobik7ICsrdSA8IG47IClcbiAgICAgIHJbdV0gPSAoKHUgKyAxKSAqIHQgLSAodSAtIG4pICogZSkgLyAobiArIDEpO1xuICAgIHJldHVybiBhO1xuICB9XG4gIHJldHVybiBhLmRvbWFpbiA9IGZ1bmN0aW9uKHUpIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChbZSwgdF0gPSB1LCBlID0gK2UsIHQgPSArdCwgcygpKSA6IFtlLCB0XTtcbiAgfSwgYS5yYW5nZSA9IGZ1bmN0aW9uKHUpIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChuID0gKGkgPSBBcnJheS5mcm9tKHUpKS5sZW5ndGggLSAxLCBzKCkpIDogaS5zbGljZSgpO1xuICB9LCBhLmludmVydEV4dGVudCA9IGZ1bmN0aW9uKHUpIHtcbiAgICB2YXIgYyA9IGkuaW5kZXhPZih1KTtcbiAgICByZXR1cm4gYyA8IDAgPyBbTmFOLCBOYU5dIDogYyA8IDEgPyBbZSwgclswXV0gOiBjID49IG4gPyBbcltuIC0gMV0sIHRdIDogW3JbYyAtIDFdLCByW2NdXTtcbiAgfSwgYS51bmtub3duID0gZnVuY3Rpb24odSkge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoICYmIChvID0gdSksIGE7XG4gIH0sIGEudGhyZXNob2xkcyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiByLnNsaWNlKCk7XG4gIH0sIGEuY29weSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBkMCgpLmRvbWFpbihbZSwgdF0pLnJhbmdlKGkpLnVua25vd24obyk7XG4gIH0sIEJ0LmFwcGx5KHFuKGEpLCBhcmd1bWVudHMpO1xufVxuZnVuY3Rpb24gcDAoKSB7XG4gIHZhciBlID0gWzAuNV0sIHQgPSBbMCwgMV0sIG4sIHIgPSAxO1xuICBmdW5jdGlvbiBpKG8pIHtcbiAgICByZXR1cm4gbyAhPSBudWxsICYmIG8gPD0gbyA/IHRbcW8oZSwgbywgMCwgcildIDogbjtcbiAgfVxuICByZXR1cm4gaS5kb21haW4gPSBmdW5jdGlvbihvKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoZSA9IEFycmF5LmZyb20obyksIHIgPSBNYXRoLm1pbihlLmxlbmd0aCwgdC5sZW5ndGggLSAxKSwgaSkgOiBlLnNsaWNlKCk7XG4gIH0sIGkucmFuZ2UgPSBmdW5jdGlvbihvKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAodCA9IEFycmF5LmZyb20obyksIHIgPSBNYXRoLm1pbihlLmxlbmd0aCwgdC5sZW5ndGggLSAxKSwgaSkgOiB0LnNsaWNlKCk7XG4gIH0sIGkuaW52ZXJ0RXh0ZW50ID0gZnVuY3Rpb24obykge1xuICAgIHZhciBhID0gdC5pbmRleE9mKG8pO1xuICAgIHJldHVybiBbZVthIC0gMV0sIGVbYV1dO1xuICB9LCBpLnVua25vd24gPSBmdW5jdGlvbihvKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAobiA9IG8sIGkpIDogbjtcbiAgfSwgaS5jb3B5ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHAwKCkuZG9tYWluKGUpLnJhbmdlKHQpLnVua25vd24obik7XG4gIH0sIEJ0LmFwcGx5KGksIGFyZ3VtZW50cyk7XG59XG5jb25zdCBMdSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpLCBCdSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpO1xuZnVuY3Rpb24gWGUoZSwgdCwgbiwgcikge1xuICBmdW5jdGlvbiBpKG8pIHtcbiAgICByZXR1cm4gZShvID0gYXJndW1lbnRzLmxlbmd0aCA9PT0gMCA/IC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpIDogLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKCtvKSksIG87XG4gIH1cbiAgcmV0dXJuIGkuZmxvb3IgPSAobykgPT4gKGUobyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgrbykpLCBvKSwgaS5jZWlsID0gKG8pID0+IChlKG8gPSBuZXcgRGF0ZShvIC0gMSkpLCB0KG8sIDEpLCBlKG8pLCBvKSwgaS5yb3VuZCA9IChvKSA9PiB7XG4gICAgY29uc3QgYSA9IGkobyksIHMgPSBpLmNlaWwobyk7XG4gICAgcmV0dXJuIG8gLSBhIDwgcyAtIG8gPyBhIDogcztcbiAgfSwgaS5vZmZzZXQgPSAobywgYSkgPT4gKHQobyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgrbyksIGEgPT0gbnVsbCA/IDEgOiBNYXRoLmZsb29yKGEpKSwgbyksIGkucmFuZ2UgPSAobywgYSwgcykgPT4ge1xuICAgIGNvbnN0IHUgPSBbXTtcbiAgICBpZiAobyA9IGkuY2VpbChvKSwgcyA9IHMgPT0gbnVsbCA/IDEgOiBNYXRoLmZsb29yKHMpLCAhKG8gPCBhKSB8fCAhKHMgPiAwKSlcbiAgICAgIHJldHVybiB1O1xuICAgIGxldCBjO1xuICAgIGRvXG4gICAgICB1LnB1c2goYyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgrbykpLCB0KG8sIHMpLCBlKG8pO1xuICAgIHdoaWxlIChjIDwgbyAmJiBvIDwgYSk7XG4gICAgcmV0dXJuIHU7XG4gIH0sIGkuZmlsdGVyID0gKG8pID0+IFhlKChhKSA9PiB7XG4gICAgaWYgKGEgPj0gYSlcbiAgICAgIGZvciAoOyBlKGEpLCAhbyhhKTsgKVxuICAgICAgICBhLnNldFRpbWUoYSAtIDEpO1xuICB9LCAoYSwgcykgPT4ge1xuICAgIGlmIChhID49IGEpXG4gICAgICBpZiAocyA8IDApXG4gICAgICAgIGZvciAoOyArK3MgPD0gMDsgKVxuICAgICAgICAgIGZvciAoOyB0KGEsIC0xKSwgIW8oYSk7IClcbiAgICAgICAgICAgIDtcbiAgICAgIGVsc2VcbiAgICAgICAgZm9yICg7IC0tcyA+PSAwOyApXG4gICAgICAgICAgZm9yICg7IHQoYSwgMSksICFvKGEpOyApXG4gICAgICAgICAgICA7XG4gIH0pLCBuICYmIChpLmNvdW50ID0gKG8sIGEpID0+IChMdS5zZXRUaW1lKCtvKSwgQnUuc2V0VGltZSgrYSksIGUoTHUpLCBlKEJ1KSwgTWF0aC5mbG9vcihuKEx1LCBCdSkpKSwgaS5ldmVyeSA9IChvKSA9PiAobyA9IE1hdGguZmxvb3IobyksICFpc0Zpbml0ZShvKSB8fCAhKG8gPiAwKSA/IG51bGwgOiBvID4gMSA/IGkuZmlsdGVyKHIgPyAoYSkgPT4gcihhKSAlIG8gPT09IDAgOiAoYSkgPT4gaS5jb3VudCgwLCBhKSAlIG8gPT09IDApIDogaSkpLCBpO1xufVxuY29uc3QgYXMgPSBYZSgoKSA9PiB7XG59LCAoZSwgdCkgPT4ge1xuICBlLnNldFRpbWUoK2UgKyB0KTtcbn0sIChlLCB0KSA9PiB0IC0gZSk7XG5hcy5ldmVyeSA9IChlKSA9PiAoZSA9IE1hdGguZmxvb3IoZSksICFpc0Zpbml0ZShlKSB8fCAhKGUgPiAwKSA/IG51bGwgOiBlID4gMSA/IFhlKCh0KSA9PiB7XG4gIHQuc2V0VGltZShNYXRoLmZsb29yKHQgLyBlKSAqIGUpO1xufSwgKHQsIG4pID0+IHtcbiAgdC5zZXRUaW1lKCt0ICsgbiAqIGUpO1xufSwgKHQsIG4pID0+IChuIC0gdCkgLyBlKSA6IGFzKTtcbmFzLnJhbmdlO1xuY29uc3QgZ24gPSAxZTMsIEl0ID0gZ24gKiA2MCwgdm4gPSBJdCAqIDYwLCBTbiA9IHZuICogMjQsIEpmID0gU24gKiA3LCBvZyA9IFNuICogMzAsIHp1ID0gU24gKiAzNjUsIGlyID0gWGUoKGUpID0+IHtcbiAgZS5zZXRUaW1lKGUgLSBlLmdldE1pbGxpc2Vjb25kcygpKTtcbn0sIChlLCB0KSA9PiB7XG4gIGUuc2V0VGltZSgrZSArIHQgKiBnbik7XG59LCAoZSwgdCkgPT4gKHQgLSBlKSAvIGduLCAoZSkgPT4gZS5nZXRVVENTZWNvbmRzKCkpO1xuaXIucmFuZ2U7XG5jb25zdCBRZiA9IFhlKChlKSA9PiB7XG4gIGUuc2V0VGltZShlIC0gZS5nZXRNaWxsaXNlY29uZHMoKSAtIGUuZ2V0U2Vjb25kcygpICogZ24pO1xufSwgKGUsIHQpID0+IHtcbiAgZS5zZXRUaW1lKCtlICsgdCAqIEl0KTtcbn0sIChlLCB0KSA9PiAodCAtIGUpIC8gSXQsIChlKSA9PiBlLmdldE1pbnV0ZXMoKSk7XG5RZi5yYW5nZTtcbmNvbnN0IGVkID0gWGUoKGUpID0+IHtcbiAgZS5zZXRVVENTZWNvbmRzKDAsIDApO1xufSwgKGUsIHQpID0+IHtcbiAgZS5zZXRUaW1lKCtlICsgdCAqIEl0KTtcbn0sIChlLCB0KSA9PiAodCAtIGUpIC8gSXQsIChlKSA9PiBlLmdldFVUQ01pbnV0ZXMoKSk7XG5lZC5yYW5nZTtcbmNvbnN0IHRkID0gWGUoKGUpID0+IHtcbiAgZS5zZXRUaW1lKGUgLSBlLmdldE1pbGxpc2Vjb25kcygpIC0gZS5nZXRTZWNvbmRzKCkgKiBnbiAtIGUuZ2V0TWludXRlcygpICogSXQpO1xufSwgKGUsIHQpID0+IHtcbiAgZS5zZXRUaW1lKCtlICsgdCAqIHZuKTtcbn0sIChlLCB0KSA9PiAodCAtIGUpIC8gdm4sIChlKSA9PiBlLmdldEhvdXJzKCkpO1xudGQucmFuZ2U7XG5jb25zdCBuZCA9IFhlKChlKSA9PiB7XG4gIGUuc2V0VVRDTWludXRlcygwLCAwLCAwKTtcbn0sIChlLCB0KSA9PiB7XG4gIGUuc2V0VGltZSgrZSArIHQgKiB2bik7XG59LCAoZSwgdCkgPT4gKHQgLSBlKSAvIHZuLCAoZSkgPT4gZS5nZXRVVENIb3VycygpKTtcbm5kLnJhbmdlO1xuY29uc3QgWG8gPSBYZShcbiAgKGUpID0+IGUuc2V0SG91cnMoMCwgMCwgMCwgMCksXG4gIChlLCB0KSA9PiBlLnNldERhdGUoZS5nZXREYXRlKCkgKyB0KSxcbiAgKGUsIHQpID0+ICh0IC0gZSAtICh0LmdldFRpbWV6b25lT2Zmc2V0KCkgLSBlLmdldFRpbWV6b25lT2Zmc2V0KCkpICogSXQpIC8gU24sXG4gIChlKSA9PiBlLmdldERhdGUoKSAtIDFcbik7XG5Yby5yYW5nZTtcbmNvbnN0IEtzID0gWGUoKGUpID0+IHtcbiAgZS5zZXRVVENIb3VycygwLCAwLCAwLCAwKTtcbn0sIChlLCB0KSA9PiB7XG4gIGUuc2V0VVRDRGF0ZShlLmdldFVUQ0RhdGUoKSArIHQpO1xufSwgKGUsIHQpID0+ICh0IC0gZSkgLyBTbiwgKGUpID0+IGUuZ2V0VVRDRGF0ZSgpIC0gMSk7XG5Lcy5yYW5nZTtcbmNvbnN0IGgwID0gWGUoKGUpID0+IHtcbiAgZS5zZXRVVENIb3VycygwLCAwLCAwLCAwKTtcbn0sIChlLCB0KSA9PiB7XG4gIGUuc2V0VVRDRGF0ZShlLmdldFVUQ0RhdGUoKSArIHQpO1xufSwgKGUsIHQpID0+ICh0IC0gZSkgLyBTbiwgKGUpID0+IE1hdGguZmxvb3IoZSAvIFNuKSk7XG5oMC5yYW5nZTtcbmZ1bmN0aW9uIG1yKGUpIHtcbiAgcmV0dXJuIFhlKCh0KSA9PiB7XG4gICAgdC5zZXREYXRlKHQuZ2V0RGF0ZSgpIC0gKHQuZ2V0RGF5KCkgKyA3IC0gZSkgJSA3KSwgdC5zZXRIb3VycygwLCAwLCAwLCAwKTtcbiAgfSwgKHQsIG4pID0+IHtcbiAgICB0LnNldERhdGUodC5nZXREYXRlKCkgKyBuICogNyk7XG4gIH0sICh0LCBuKSA9PiAobiAtIHQgLSAobi5nZXRUaW1lem9uZU9mZnNldCgpIC0gdC5nZXRUaW1lem9uZU9mZnNldCgpKSAqIEl0KSAvIEpmKTtcbn1cbmNvbnN0IFlzID0gbXIoMCksIHNzID0gbXIoMSksIG4zID0gbXIoMiksIHIzID0gbXIoMyksIEhyID0gbXIoNCksIGkzID0gbXIoNSksIG8zID0gbXIoNik7XG5Zcy5yYW5nZTtcbnNzLnJhbmdlO1xubjMucmFuZ2U7XG5yMy5yYW5nZTtcbkhyLnJhbmdlO1xuaTMucmFuZ2U7XG5vMy5yYW5nZTtcbmZ1bmN0aW9uIHlyKGUpIHtcbiAgcmV0dXJuIFhlKCh0KSA9PiB7XG4gICAgdC5zZXRVVENEYXRlKHQuZ2V0VVRDRGF0ZSgpIC0gKHQuZ2V0VVRDRGF5KCkgKyA3IC0gZSkgJSA3KSwgdC5zZXRVVENIb3VycygwLCAwLCAwLCAwKTtcbiAgfSwgKHQsIG4pID0+IHtcbiAgICB0LnNldFVUQ0RhdGUodC5nZXRVVENEYXRlKCkgKyBuICogNyk7XG4gIH0sICh0LCBuKSA9PiAobiAtIHQpIC8gSmYpO1xufVxuY29uc3QgWHMgPSB5cigwKSwgdXMgPSB5cigxKSwgYTMgPSB5cigyKSwgczMgPSB5cigzKSwgcXIgPSB5cig0KSwgdTMgPSB5cig1KSwgYzMgPSB5cig2KTtcblhzLnJhbmdlO1xudXMucmFuZ2U7XG5hMy5yYW5nZTtcbnMzLnJhbmdlO1xucXIucmFuZ2U7XG51My5yYW5nZTtcbmMzLnJhbmdlO1xuY29uc3QgcmQgPSBYZSgoZSkgPT4ge1xuICBlLnNldERhdGUoMSksIGUuc2V0SG91cnMoMCwgMCwgMCwgMCk7XG59LCAoZSwgdCkgPT4ge1xuICBlLnNldE1vbnRoKGUuZ2V0TW9udGgoKSArIHQpO1xufSwgKGUsIHQpID0+IHQuZ2V0TW9udGgoKSAtIGUuZ2V0TW9udGgoKSArICh0LmdldEZ1bGxZZWFyKCkgLSBlLmdldEZ1bGxZZWFyKCkpICogMTIsIChlKSA9PiBlLmdldE1vbnRoKCkpO1xucmQucmFuZ2U7XG5jb25zdCBpZCA9IFhlKChlKSA9PiB7XG4gIGUuc2V0VVRDRGF0ZSgxKSwgZS5zZXRVVENIb3VycygwLCAwLCAwLCAwKTtcbn0sIChlLCB0KSA9PiB7XG4gIGUuc2V0VVRDTW9udGgoZS5nZXRVVENNb250aCgpICsgdCk7XG59LCAoZSwgdCkgPT4gdC5nZXRVVENNb250aCgpIC0gZS5nZXRVVENNb250aCgpICsgKHQuZ2V0VVRDRnVsbFllYXIoKSAtIGUuZ2V0VVRDRnVsbFllYXIoKSkgKiAxMiwgKGUpID0+IGUuZ2V0VVRDTW9udGgoKSk7XG5pZC5yYW5nZTtcbmNvbnN0ICRuID0gWGUoKGUpID0+IHtcbiAgZS5zZXRNb250aCgwLCAxKSwgZS5zZXRIb3VycygwLCAwLCAwLCAwKTtcbn0sIChlLCB0KSA9PiB7XG4gIGUuc2V0RnVsbFllYXIoZS5nZXRGdWxsWWVhcigpICsgdCk7XG59LCAoZSwgdCkgPT4gdC5nZXRGdWxsWWVhcigpIC0gZS5nZXRGdWxsWWVhcigpLCAoZSkgPT4gZS5nZXRGdWxsWWVhcigpKTtcbiRuLmV2ZXJ5ID0gKGUpID0+ICFpc0Zpbml0ZShlID0gTWF0aC5mbG9vcihlKSkgfHwgIShlID4gMCkgPyBudWxsIDogWGUoKHQpID0+IHtcbiAgdC5zZXRGdWxsWWVhcihNYXRoLmZsb29yKHQuZ2V0RnVsbFllYXIoKSAvIGUpICogZSksIHQuc2V0TW9udGgoMCwgMSksIHQuc2V0SG91cnMoMCwgMCwgMCwgMCk7XG59LCAodCwgbikgPT4ge1xuICB0LnNldEZ1bGxZZWFyKHQuZ2V0RnVsbFllYXIoKSArIG4gKiBlKTtcbn0pO1xuJG4ucmFuZ2U7XG5jb25zdCBPbiA9IFhlKChlKSA9PiB7XG4gIGUuc2V0VVRDTW9udGgoMCwgMSksIGUuc2V0VVRDSG91cnMoMCwgMCwgMCwgMCk7XG59LCAoZSwgdCkgPT4ge1xuICBlLnNldFVUQ0Z1bGxZZWFyKGUuZ2V0VVRDRnVsbFllYXIoKSArIHQpO1xufSwgKGUsIHQpID0+IHQuZ2V0VVRDRnVsbFllYXIoKSAtIGUuZ2V0VVRDRnVsbFllYXIoKSwgKGUpID0+IGUuZ2V0VVRDRnVsbFllYXIoKSk7XG5Pbi5ldmVyeSA9IChlKSA9PiAhaXNGaW5pdGUoZSA9IE1hdGguZmxvb3IoZSkpIHx8ICEoZSA+IDApID8gbnVsbCA6IFhlKCh0KSA9PiB7XG4gIHQuc2V0VVRDRnVsbFllYXIoTWF0aC5mbG9vcih0LmdldFVUQ0Z1bGxZZWFyKCkgLyBlKSAqIGUpLCB0LnNldFVUQ01vbnRoKDAsIDEpLCB0LnNldFVUQ0hvdXJzKDAsIDAsIDAsIDApO1xufSwgKHQsIG4pID0+IHtcbiAgdC5zZXRVVENGdWxsWWVhcih0LmdldFVUQ0Z1bGxZZWFyKCkgKyBuICogZSk7XG59KTtcbk9uLnJhbmdlO1xuZnVuY3Rpb24gZzAoZSwgdCwgbiwgciwgaSwgbykge1xuICBjb25zdCBhID0gW1xuICAgIFtpciwgMSwgZ25dLFxuICAgIFtpciwgNSwgNSAqIGduXSxcbiAgICBbaXIsIDE1LCAxNSAqIGduXSxcbiAgICBbaXIsIDMwLCAzMCAqIGduXSxcbiAgICBbbywgMSwgSXRdLFxuICAgIFtvLCA1LCA1ICogSXRdLFxuICAgIFtvLCAxNSwgMTUgKiBJdF0sXG4gICAgW28sIDMwLCAzMCAqIEl0XSxcbiAgICBbaSwgMSwgdm5dLFxuICAgIFtpLCAzLCAzICogdm5dLFxuICAgIFtpLCA2LCA2ICogdm5dLFxuICAgIFtpLCAxMiwgMTIgKiB2bl0sXG4gICAgW3IsIDEsIFNuXSxcbiAgICBbciwgMiwgMiAqIFNuXSxcbiAgICBbbiwgMSwgSmZdLFxuICAgIFt0LCAxLCBvZ10sXG4gICAgW3QsIDMsIDMgKiBvZ10sXG4gICAgW2UsIDEsIHp1XVxuICBdO1xuICBmdW5jdGlvbiBzKGMsIGYsIGwpIHtcbiAgICBjb25zdCBkID0gZiA8IGM7XG4gICAgZCAmJiAoW2MsIGZdID0gW2YsIGNdKTtcbiAgICBjb25zdCBwID0gbCAmJiB0eXBlb2YgbC5yYW5nZSA9PSBcImZ1bmN0aW9uXCIgPyBsIDogdShjLCBmLCBsKSwgZyA9IHAgPyBwLnJhbmdlKGMsICtmICsgMSkgOiBbXTtcbiAgICByZXR1cm4gZCA/IGcucmV2ZXJzZSgpIDogZztcbiAgfVxuICBmdW5jdGlvbiB1KGMsIGYsIGwpIHtcbiAgICBjb25zdCBkID0gTWF0aC5hYnMoZiAtIGMpIC8gbCwgcCA9IEJmKChbLCAsIHZdKSA9PiB2KS5yaWdodChhLCBkKTtcbiAgICBpZiAocCA9PT0gYS5sZW5ndGgpXG4gICAgICByZXR1cm4gZS5ldmVyeShybChjIC8genUsIGYgLyB6dSwgbCkpO1xuICAgIGlmIChwID09PSAwKVxuICAgICAgcmV0dXJuIGFzLmV2ZXJ5KE1hdGgubWF4KHJsKGMsIGYsIGwpLCAxKSk7XG4gICAgY29uc3QgW2csIGhdID0gYVtkIC8gYVtwIC0gMV1bMl0gPCBhW3BdWzJdIC8gZCA/IHAgLSAxIDogcF07XG4gICAgcmV0dXJuIGcuZXZlcnkoaCk7XG4gIH1cbiAgcmV0dXJuIFtzLCB1XTtcbn1cbmNvbnN0IFtsMywgZjNdID0gZzAoT24sIGlkLCBYcywgaDAsIG5kLCBlZCksIFtkMywgcDNdID0gZzAoJG4sIHJkLCBZcywgWG8sIHRkLCBRZik7XG5mdW5jdGlvbiBWdShlKSB7XG4gIGlmICgwIDw9IGUueSAmJiBlLnkgPCAxMDApIHtcbiAgICB2YXIgdCA9IG5ldyBEYXRlKC0xLCBlLm0sIGUuZCwgZS5ILCBlLk0sIGUuUywgZS5MKTtcbiAgICByZXR1cm4gdC5zZXRGdWxsWWVhcihlLnkpLCB0O1xuICB9XG4gIHJldHVybiBuZXcgRGF0ZShlLnksIGUubSwgZS5kLCBlLkgsIGUuTSwgZS5TLCBlLkwpO1xufVxuZnVuY3Rpb24gR3UoZSkge1xuICBpZiAoMCA8PSBlLnkgJiYgZS55IDwgMTAwKSB7XG4gICAgdmFyIHQgPSBuZXcgRGF0ZShEYXRlLlVUQygtMSwgZS5tLCBlLmQsIGUuSCwgZS5NLCBlLlMsIGUuTCkpO1xuICAgIHJldHVybiB0LnNldFVUQ0Z1bGxZZWFyKGUueSksIHQ7XG4gIH1cbiAgcmV0dXJuIG5ldyBEYXRlKERhdGUuVVRDKGUueSwgZS5tLCBlLmQsIGUuSCwgZS5NLCBlLlMsIGUuTCkpO1xufVxuZnVuY3Rpb24gSWkoZSwgdCwgbikge1xuICByZXR1cm4geyB5OiBlLCBtOiB0LCBkOiBuLCBIOiAwLCBNOiAwLCBTOiAwLCBMOiAwIH07XG59XG5mdW5jdGlvbiBoMyhlKSB7XG4gIHZhciB0ID0gZS5kYXRlVGltZSwgbiA9IGUuZGF0ZSwgciA9IGUudGltZSwgaSA9IGUucGVyaW9kcywgbyA9IGUuZGF5cywgYSA9IGUuc2hvcnREYXlzLCBzID0gZS5tb250aHMsIHUgPSBlLnNob3J0TW9udGhzLCBjID0gamkoaSksIGYgPSBraShpKSwgbCA9IGppKG8pLCBkID0ga2kobyksIHAgPSBqaShhKSwgZyA9IGtpKGEpLCBoID0gamkocyksIHYgPSBraShzKSwgdyA9IGppKHUpLCBiID0ga2kodSksIHggPSB7XG4gICAgYTogRixcbiAgICBBOiBWLFxuICAgIGI6IEwsXG4gICAgQjogSSxcbiAgICBjOiBudWxsLFxuICAgIGQ6IGZnLFxuICAgIGU6IGZnLFxuICAgIGY6IE4zLFxuICAgIGc6IHEzLFxuICAgIEc6IFkzLFxuICAgIEg6IGozLFxuICAgIEk6IGszLFxuICAgIGo6IEQzLFxuICAgIEw6IHYwLFxuICAgIG06IEYzLFxuICAgIE06IEwzLFxuICAgIHA6IEQsXG4gICAgcTogRyxcbiAgICBROiBoZyxcbiAgICBzOiBnZyxcbiAgICBTOiBCMyxcbiAgICB1OiB6MyxcbiAgICBVOiBWMyxcbiAgICBWOiBHMyxcbiAgICB3OiBXMyxcbiAgICBXOiBVMyxcbiAgICB4OiBudWxsLFxuICAgIFg6IG51bGwsXG4gICAgeTogSDMsXG4gICAgWTogSzMsXG4gICAgWjogWDMsXG4gICAgXCIlXCI6IHBnXG4gIH0sIG0gPSB7XG4gICAgYTogcSxcbiAgICBBOiBKLFxuICAgIGI6IG5lLFxuICAgIEI6IHRlLFxuICAgIGM6IG51bGwsXG4gICAgZDogZGcsXG4gICAgZTogZGcsXG4gICAgZjogZUIsXG4gICAgZzogbEIsXG4gICAgRzogZEIsXG4gICAgSDogWjMsXG4gICAgSTogSjMsXG4gICAgajogUTMsXG4gICAgTDogeTAsXG4gICAgbTogdEIsXG4gICAgTTogbkIsXG4gICAgcDogZWUsXG4gICAgcTogaWUsXG4gICAgUTogaGcsXG4gICAgczogZ2csXG4gICAgUzogckIsXG4gICAgdTogaUIsXG4gICAgVTogb0IsXG4gICAgVjogYUIsXG4gICAgdzogc0IsXG4gICAgVzogdUIsXG4gICAgeDogbnVsbCxcbiAgICBYOiBudWxsLFxuICAgIHk6IGNCLFxuICAgIFk6IGZCLFxuICAgIFo6IHBCLFxuICAgIFwiJVwiOiBwZ1xuICB9LCB5ID0ge1xuICAgIGE6IE0sXG4gICAgQTogRSxcbiAgICBiOiBBLFxuICAgIEI6IGosXG4gICAgYzogUixcbiAgICBkOiBjZyxcbiAgICBlOiBjZyxcbiAgICBmOiBUMyxcbiAgICBnOiB1ZyxcbiAgICBHOiBzZyxcbiAgICBIOiBsZyxcbiAgICBJOiBsZyxcbiAgICBqOiBBMyxcbiAgICBMOiBFMyxcbiAgICBtOiBfMyxcbiAgICBNOiBQMyxcbiAgICBwOiBULFxuICAgIHE6IE8zLFxuICAgIFE6IFIzLFxuICAgIHM6IEkzLFxuICAgIFM6IEMzLFxuICAgIHU6IGIzLFxuICAgIFU6IHczLFxuICAgIFY6IHgzLFxuICAgIHc6IHkzLFxuICAgIFc6IFMzLFxuICAgIHg6IE4sXG4gICAgWDogayxcbiAgICB5OiB1ZyxcbiAgICBZOiBzZyxcbiAgICBaOiAkMyxcbiAgICBcIiVcIjogTTNcbiAgfTtcbiAgeC54ID0gUyhuLCB4KSwgeC5YID0gUyhyLCB4KSwgeC5jID0gUyh0LCB4KSwgbS54ID0gUyhuLCBtKSwgbS5YID0gUyhyLCBtKSwgbS5jID0gUyh0LCBtKTtcbiAgZnVuY3Rpb24gUyhCLCBVKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHJlKSB7XG4gICAgICB2YXIgQyA9IFtdLCBnZSA9IC0xLCBsZSA9IDAsIHhlID0gQi5sZW5ndGgsIEVlLCBaZSwgZHQ7XG4gICAgICBmb3IgKHJlIGluc3RhbmNlb2YgRGF0ZSB8fCAocmUgPSAvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoK3JlKSk7ICsrZ2UgPCB4ZTsgKVxuICAgICAgICBCLmNoYXJDb2RlQXQoZ2UpID09PSAzNyAmJiAoQy5wdXNoKEIuc2xpY2UobGUsIGdlKSksIChaZSA9IGFnW0VlID0gQi5jaGFyQXQoKytnZSldKSAhPSBudWxsID8gRWUgPSBCLmNoYXJBdCgrK2dlKSA6IFplID0gRWUgPT09IFwiZVwiID8gXCIgXCIgOiBcIjBcIiwgKGR0ID0gVVtFZV0pICYmIChFZSA9IGR0KHJlLCBaZSkpLCBDLnB1c2goRWUpLCBsZSA9IGdlICsgMSk7XG4gICAgICByZXR1cm4gQy5wdXNoKEIuc2xpY2UobGUsIGdlKSksIEMuam9pbihcIlwiKTtcbiAgICB9O1xuICB9XG4gIGZ1bmN0aW9uICQoQiwgVSkge1xuICAgIHJldHVybiBmdW5jdGlvbihyZSkge1xuICAgICAgdmFyIEMgPSBJaSgxOTAwLCB2b2lkIDAsIDEpLCBnZSA9IE8oQywgQiwgcmUgKz0gXCJcIiwgMCksIGxlLCB4ZTtcbiAgICAgIGlmIChnZSAhPSByZS5sZW5ndGgpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgaWYgKFwiUVwiIGluIEMpXG4gICAgICAgIHJldHVybiBuZXcgRGF0ZShDLlEpO1xuICAgICAgaWYgKFwic1wiIGluIEMpXG4gICAgICAgIHJldHVybiBuZXcgRGF0ZShDLnMgKiAxZTMgKyAoXCJMXCIgaW4gQyA/IEMuTCA6IDApKTtcbiAgICAgIGlmIChVICYmICEoXCJaXCIgaW4gQykgJiYgKEMuWiA9IDApLCBcInBcIiBpbiBDICYmIChDLkggPSBDLkggJSAxMiArIEMucCAqIDEyKSwgQy5tID09PSB2b2lkIDAgJiYgKEMubSA9IFwicVwiIGluIEMgPyBDLnEgOiAwKSwgXCJWXCIgaW4gQykge1xuICAgICAgICBpZiAoQy5WIDwgMSB8fCBDLlYgPiA1MylcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgXCJ3XCIgaW4gQyB8fCAoQy53ID0gMSksIFwiWlwiIGluIEMgPyAobGUgPSBHdShJaShDLnksIDAsIDEpKSwgeGUgPSBsZS5nZXRVVENEYXkoKSwgbGUgPSB4ZSA+IDQgfHwgeGUgPT09IDAgPyB1cy5jZWlsKGxlKSA6IHVzKGxlKSwgbGUgPSBLcy5vZmZzZXQobGUsIChDLlYgLSAxKSAqIDcpLCBDLnkgPSBsZS5nZXRVVENGdWxsWWVhcigpLCBDLm0gPSBsZS5nZXRVVENNb250aCgpLCBDLmQgPSBsZS5nZXRVVENEYXRlKCkgKyAoQy53ICsgNikgJSA3KSA6IChsZSA9IFZ1KElpKEMueSwgMCwgMSkpLCB4ZSA9IGxlLmdldERheSgpLCBsZSA9IHhlID4gNCB8fCB4ZSA9PT0gMCA/IHNzLmNlaWwobGUpIDogc3MobGUpLCBsZSA9IFhvLm9mZnNldChsZSwgKEMuViAtIDEpICogNyksIEMueSA9IGxlLmdldEZ1bGxZZWFyKCksIEMubSA9IGxlLmdldE1vbnRoKCksIEMuZCA9IGxlLmdldERhdGUoKSArIChDLncgKyA2KSAlIDcpO1xuICAgICAgfSBlbHNlXG4gICAgICAgIChcIldcIiBpbiBDIHx8IFwiVVwiIGluIEMpICYmIChcIndcIiBpbiBDIHx8IChDLncgPSBcInVcIiBpbiBDID8gQy51ICUgNyA6IFwiV1wiIGluIEMgPyAxIDogMCksIHhlID0gXCJaXCIgaW4gQyA/IEd1KElpKEMueSwgMCwgMSkpLmdldFVUQ0RheSgpIDogVnUoSWkoQy55LCAwLCAxKSkuZ2V0RGF5KCksIEMubSA9IDAsIEMuZCA9IFwiV1wiIGluIEMgPyAoQy53ICsgNikgJSA3ICsgQy5XICogNyAtICh4ZSArIDUpICUgNyA6IEMudyArIEMuVSAqIDcgLSAoeGUgKyA2KSAlIDcpO1xuICAgICAgcmV0dXJuIFwiWlwiIGluIEMgPyAoQy5IICs9IEMuWiAvIDEwMCB8IDAsIEMuTSArPSBDLlogJSAxMDAsIEd1KEMpKSA6IFZ1KEMpO1xuICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gTyhCLCBVLCByZSwgQykge1xuICAgIGZvciAodmFyIGdlID0gMCwgbGUgPSBVLmxlbmd0aCwgeGUgPSByZS5sZW5ndGgsIEVlLCBaZTsgZ2UgPCBsZTsgKSB7XG4gICAgICBpZiAoQyA+PSB4ZSlcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgaWYgKEVlID0gVS5jaGFyQ29kZUF0KGdlKyspLCBFZSA9PT0gMzcpIHtcbiAgICAgICAgaWYgKEVlID0gVS5jaGFyQXQoZ2UrKyksIFplID0geVtFZSBpbiBhZyA/IFUuY2hhckF0KGdlKyspIDogRWVdLCAhWmUgfHwgKEMgPSBaZShCLCByZSwgQykpIDwgMClcbiAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICB9IGVsc2UgaWYgKEVlICE9IHJlLmNoYXJDb2RlQXQoQysrKSlcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIH1cbiAgICByZXR1cm4gQztcbiAgfVxuICBmdW5jdGlvbiBUKEIsIFUsIHJlKSB7XG4gICAgdmFyIEMgPSBjLmV4ZWMoVS5zbGljZShyZSkpO1xuICAgIHJldHVybiBDID8gKEIucCA9IGYuZ2V0KENbMF0udG9Mb3dlckNhc2UoKSksIHJlICsgQ1swXS5sZW5ndGgpIDogLTE7XG4gIH1cbiAgZnVuY3Rpb24gTShCLCBVLCByZSkge1xuICAgIHZhciBDID0gcC5leGVjKFUuc2xpY2UocmUpKTtcbiAgICByZXR1cm4gQyA/IChCLncgPSBnLmdldChDWzBdLnRvTG93ZXJDYXNlKCkpLCByZSArIENbMF0ubGVuZ3RoKSA6IC0xO1xuICB9XG4gIGZ1bmN0aW9uIEUoQiwgVSwgcmUpIHtcbiAgICB2YXIgQyA9IGwuZXhlYyhVLnNsaWNlKHJlKSk7XG4gICAgcmV0dXJuIEMgPyAoQi53ID0gZC5nZXQoQ1swXS50b0xvd2VyQ2FzZSgpKSwgcmUgKyBDWzBdLmxlbmd0aCkgOiAtMTtcbiAgfVxuICBmdW5jdGlvbiBBKEIsIFUsIHJlKSB7XG4gICAgdmFyIEMgPSB3LmV4ZWMoVS5zbGljZShyZSkpO1xuICAgIHJldHVybiBDID8gKEIubSA9IGIuZ2V0KENbMF0udG9Mb3dlckNhc2UoKSksIHJlICsgQ1swXS5sZW5ndGgpIDogLTE7XG4gIH1cbiAgZnVuY3Rpb24gaihCLCBVLCByZSkge1xuICAgIHZhciBDID0gaC5leGVjKFUuc2xpY2UocmUpKTtcbiAgICByZXR1cm4gQyA/IChCLm0gPSB2LmdldChDWzBdLnRvTG93ZXJDYXNlKCkpLCByZSArIENbMF0ubGVuZ3RoKSA6IC0xO1xuICB9XG4gIGZ1bmN0aW9uIFIoQiwgVSwgcmUpIHtcbiAgICByZXR1cm4gTyhCLCB0LCBVLCByZSk7XG4gIH1cbiAgZnVuY3Rpb24gTihCLCBVLCByZSkge1xuICAgIHJldHVybiBPKEIsIG4sIFUsIHJlKTtcbiAgfVxuICBmdW5jdGlvbiBrKEIsIFUsIHJlKSB7XG4gICAgcmV0dXJuIE8oQiwgciwgVSwgcmUpO1xuICB9XG4gIGZ1bmN0aW9uIEYoQikge1xuICAgIHJldHVybiBhW0IuZ2V0RGF5KCldO1xuICB9XG4gIGZ1bmN0aW9uIFYoQikge1xuICAgIHJldHVybiBvW0IuZ2V0RGF5KCldO1xuICB9XG4gIGZ1bmN0aW9uIEwoQikge1xuICAgIHJldHVybiB1W0IuZ2V0TW9udGgoKV07XG4gIH1cbiAgZnVuY3Rpb24gSShCKSB7XG4gICAgcmV0dXJuIHNbQi5nZXRNb250aCgpXTtcbiAgfVxuICBmdW5jdGlvbiBEKEIpIHtcbiAgICByZXR1cm4gaVsrKEIuZ2V0SG91cnMoKSA+PSAxMildO1xuICB9XG4gIGZ1bmN0aW9uIEcoQikge1xuICAgIHJldHVybiAxICsgfn4oQi5nZXRNb250aCgpIC8gMyk7XG4gIH1cbiAgZnVuY3Rpb24gcShCKSB7XG4gICAgcmV0dXJuIGFbQi5nZXRVVENEYXkoKV07XG4gIH1cbiAgZnVuY3Rpb24gSihCKSB7XG4gICAgcmV0dXJuIG9bQi5nZXRVVENEYXkoKV07XG4gIH1cbiAgZnVuY3Rpb24gbmUoQikge1xuICAgIHJldHVybiB1W0IuZ2V0VVRDTW9udGgoKV07XG4gIH1cbiAgZnVuY3Rpb24gdGUoQikge1xuICAgIHJldHVybiBzW0IuZ2V0VVRDTW9udGgoKV07XG4gIH1cbiAgZnVuY3Rpb24gZWUoQikge1xuICAgIHJldHVybiBpWysoQi5nZXRVVENIb3VycygpID49IDEyKV07XG4gIH1cbiAgZnVuY3Rpb24gaWUoQikge1xuICAgIHJldHVybiAxICsgfn4oQi5nZXRVVENNb250aCgpIC8gMyk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBmb3JtYXQ6IGZ1bmN0aW9uKEIpIHtcbiAgICAgIHZhciBVID0gUyhCICs9IFwiXCIsIHgpO1xuICAgICAgcmV0dXJuIFUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIEI7XG4gICAgICB9LCBVO1xuICAgIH0sXG4gICAgcGFyc2U6IGZ1bmN0aW9uKEIpIHtcbiAgICAgIHZhciBVID0gJChCICs9IFwiXCIsICExKTtcbiAgICAgIHJldHVybiBVLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBCO1xuICAgICAgfSwgVTtcbiAgICB9LFxuICAgIHV0Y0Zvcm1hdDogZnVuY3Rpb24oQikge1xuICAgICAgdmFyIFUgPSBTKEIgKz0gXCJcIiwgbSk7XG4gICAgICByZXR1cm4gVS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gQjtcbiAgICAgIH0sIFU7XG4gICAgfSxcbiAgICB1dGNQYXJzZTogZnVuY3Rpb24oQikge1xuICAgICAgdmFyIFUgPSAkKEIgKz0gXCJcIiwgITApO1xuICAgICAgcmV0dXJuIFUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIEI7XG4gICAgICB9LCBVO1xuICAgIH1cbiAgfTtcbn1cbnZhciBhZyA9IHsgXCItXCI6IFwiXCIsIF86IFwiIFwiLCAwOiBcIjBcIiB9LCBldCA9IC9eXFxzKlxcZCsvLCBnMyA9IC9eJS8sIHYzID0gL1tcXFxcXiQqKz98W1xcXSgpLnt9XS9nO1xuZnVuY3Rpb24gT2UoZSwgdCwgbikge1xuICB2YXIgciA9IGUgPCAwID8gXCItXCIgOiBcIlwiLCBpID0gKHIgPyAtZSA6IGUpICsgXCJcIiwgbyA9IGkubGVuZ3RoO1xuICByZXR1cm4gciArIChvIDwgbiA/IG5ldyBBcnJheShuIC0gbyArIDEpLmpvaW4odCkgKyBpIDogaSk7XG59XG5mdW5jdGlvbiBtMyhlKSB7XG4gIHJldHVybiBlLnJlcGxhY2UodjMsIFwiXFxcXCQmXCIpO1xufVxuZnVuY3Rpb24gamkoZSkge1xuICByZXR1cm4gbmV3IFJlZ0V4cChcIl4oPzpcIiArIGUubWFwKG0zKS5qb2luKFwifFwiKSArIFwiKVwiLCBcImlcIik7XG59XG5mdW5jdGlvbiBraShlKSB7XG4gIHJldHVybiBuZXcgTWFwKGUubWFwKCh0LCBuKSA9PiBbdC50b0xvd2VyQ2FzZSgpLCBuXSkpO1xufVxuZnVuY3Rpb24geTMoZSwgdCwgbikge1xuICB2YXIgciA9IGV0LmV4ZWModC5zbGljZShuLCBuICsgMSkpO1xuICByZXR1cm4gciA/IChlLncgPSArclswXSwgbiArIHJbMF0ubGVuZ3RoKSA6IC0xO1xufVxuZnVuY3Rpb24gYjMoZSwgdCwgbikge1xuICB2YXIgciA9IGV0LmV4ZWModC5zbGljZShuLCBuICsgMSkpO1xuICByZXR1cm4gciA/IChlLnUgPSArclswXSwgbiArIHJbMF0ubGVuZ3RoKSA6IC0xO1xufVxuZnVuY3Rpb24gdzMoZSwgdCwgbikge1xuICB2YXIgciA9IGV0LmV4ZWModC5zbGljZShuLCBuICsgMikpO1xuICByZXR1cm4gciA/IChlLlUgPSArclswXSwgbiArIHJbMF0ubGVuZ3RoKSA6IC0xO1xufVxuZnVuY3Rpb24geDMoZSwgdCwgbikge1xuICB2YXIgciA9IGV0LmV4ZWModC5zbGljZShuLCBuICsgMikpO1xuICByZXR1cm4gciA/IChlLlYgPSArclswXSwgbiArIHJbMF0ubGVuZ3RoKSA6IC0xO1xufVxuZnVuY3Rpb24gUzMoZSwgdCwgbikge1xuICB2YXIgciA9IGV0LmV4ZWModC5zbGljZShuLCBuICsgMikpO1xuICByZXR1cm4gciA/IChlLlcgPSArclswXSwgbiArIHJbMF0ubGVuZ3RoKSA6IC0xO1xufVxuZnVuY3Rpb24gc2coZSwgdCwgbikge1xuICB2YXIgciA9IGV0LmV4ZWModC5zbGljZShuLCBuICsgNCkpO1xuICByZXR1cm4gciA/IChlLnkgPSArclswXSwgbiArIHJbMF0ubGVuZ3RoKSA6IC0xO1xufVxuZnVuY3Rpb24gdWcoZSwgdCwgbikge1xuICB2YXIgciA9IGV0LmV4ZWModC5zbGljZShuLCBuICsgMikpO1xuICByZXR1cm4gciA/IChlLnkgPSArclswXSArICgrclswXSA+IDY4ID8gMTkwMCA6IDJlMyksIG4gKyByWzBdLmxlbmd0aCkgOiAtMTtcbn1cbmZ1bmN0aW9uICQzKGUsIHQsIG4pIHtcbiAgdmFyIHIgPSAvXihaKXwoWystXVxcZFxcZCkoPzo6PyhcXGRcXGQpKT8vLmV4ZWModC5zbGljZShuLCBuICsgNikpO1xuICByZXR1cm4gciA/IChlLlogPSByWzFdID8gMCA6IC0oclsyXSArIChyWzNdIHx8IFwiMDBcIikpLCBuICsgclswXS5sZW5ndGgpIDogLTE7XG59XG5mdW5jdGlvbiBPMyhlLCB0LCBuKSB7XG4gIHZhciByID0gZXQuZXhlYyh0LnNsaWNlKG4sIG4gKyAxKSk7XG4gIHJldHVybiByID8gKGUucSA9IHJbMF0gKiAzIC0gMywgbiArIHJbMF0ubGVuZ3RoKSA6IC0xO1xufVxuZnVuY3Rpb24gXzMoZSwgdCwgbikge1xuICB2YXIgciA9IGV0LmV4ZWModC5zbGljZShuLCBuICsgMikpO1xuICByZXR1cm4gciA/IChlLm0gPSByWzBdIC0gMSwgbiArIHJbMF0ubGVuZ3RoKSA6IC0xO1xufVxuZnVuY3Rpb24gY2coZSwgdCwgbikge1xuICB2YXIgciA9IGV0LmV4ZWModC5zbGljZShuLCBuICsgMikpO1xuICByZXR1cm4gciA/IChlLmQgPSArclswXSwgbiArIHJbMF0ubGVuZ3RoKSA6IC0xO1xufVxuZnVuY3Rpb24gQTMoZSwgdCwgbikge1xuICB2YXIgciA9IGV0LmV4ZWModC5zbGljZShuLCBuICsgMykpO1xuICByZXR1cm4gciA/IChlLm0gPSAwLCBlLmQgPSArclswXSwgbiArIHJbMF0ubGVuZ3RoKSA6IC0xO1xufVxuZnVuY3Rpb24gbGcoZSwgdCwgbikge1xuICB2YXIgciA9IGV0LmV4ZWModC5zbGljZShuLCBuICsgMikpO1xuICByZXR1cm4gciA/IChlLkggPSArclswXSwgbiArIHJbMF0ubGVuZ3RoKSA6IC0xO1xufVxuZnVuY3Rpb24gUDMoZSwgdCwgbikge1xuICB2YXIgciA9IGV0LmV4ZWModC5zbGljZShuLCBuICsgMikpO1xuICByZXR1cm4gciA/IChlLk0gPSArclswXSwgbiArIHJbMF0ubGVuZ3RoKSA6IC0xO1xufVxuZnVuY3Rpb24gQzMoZSwgdCwgbikge1xuICB2YXIgciA9IGV0LmV4ZWModC5zbGljZShuLCBuICsgMikpO1xuICByZXR1cm4gciA/IChlLlMgPSArclswXSwgbiArIHJbMF0ubGVuZ3RoKSA6IC0xO1xufVxuZnVuY3Rpb24gRTMoZSwgdCwgbikge1xuICB2YXIgciA9IGV0LmV4ZWModC5zbGljZShuLCBuICsgMykpO1xuICByZXR1cm4gciA/IChlLkwgPSArclswXSwgbiArIHJbMF0ubGVuZ3RoKSA6IC0xO1xufVxuZnVuY3Rpb24gVDMoZSwgdCwgbikge1xuICB2YXIgciA9IGV0LmV4ZWModC5zbGljZShuLCBuICsgNikpO1xuICByZXR1cm4gciA/IChlLkwgPSBNYXRoLmZsb29yKHJbMF0gLyAxZTMpLCBuICsgclswXS5sZW5ndGgpIDogLTE7XG59XG5mdW5jdGlvbiBNMyhlLCB0LCBuKSB7XG4gIHZhciByID0gZzMuZXhlYyh0LnNsaWNlKG4sIG4gKyAxKSk7XG4gIHJldHVybiByID8gbiArIHJbMF0ubGVuZ3RoIDogLTE7XG59XG5mdW5jdGlvbiBSMyhlLCB0LCBuKSB7XG4gIHZhciByID0gZXQuZXhlYyh0LnNsaWNlKG4pKTtcbiAgcmV0dXJuIHIgPyAoZS5RID0gK3JbMF0sIG4gKyByWzBdLmxlbmd0aCkgOiAtMTtcbn1cbmZ1bmN0aW9uIEkzKGUsIHQsIG4pIHtcbiAgdmFyIHIgPSBldC5leGVjKHQuc2xpY2UobikpO1xuICByZXR1cm4gciA/IChlLnMgPSArclswXSwgbiArIHJbMF0ubGVuZ3RoKSA6IC0xO1xufVxuZnVuY3Rpb24gZmcoZSwgdCkge1xuICByZXR1cm4gT2UoZS5nZXREYXRlKCksIHQsIDIpO1xufVxuZnVuY3Rpb24gajMoZSwgdCkge1xuICByZXR1cm4gT2UoZS5nZXRIb3VycygpLCB0LCAyKTtcbn1cbmZ1bmN0aW9uIGszKGUsIHQpIHtcbiAgcmV0dXJuIE9lKGUuZ2V0SG91cnMoKSAlIDEyIHx8IDEyLCB0LCAyKTtcbn1cbmZ1bmN0aW9uIEQzKGUsIHQpIHtcbiAgcmV0dXJuIE9lKDEgKyBYby5jb3VudCgkbihlKSwgZSksIHQsIDMpO1xufVxuZnVuY3Rpb24gdjAoZSwgdCkge1xuICByZXR1cm4gT2UoZS5nZXRNaWxsaXNlY29uZHMoKSwgdCwgMyk7XG59XG5mdW5jdGlvbiBOMyhlLCB0KSB7XG4gIHJldHVybiB2MChlLCB0KSArIFwiMDAwXCI7XG59XG5mdW5jdGlvbiBGMyhlLCB0KSB7XG4gIHJldHVybiBPZShlLmdldE1vbnRoKCkgKyAxLCB0LCAyKTtcbn1cbmZ1bmN0aW9uIEwzKGUsIHQpIHtcbiAgcmV0dXJuIE9lKGUuZ2V0TWludXRlcygpLCB0LCAyKTtcbn1cbmZ1bmN0aW9uIEIzKGUsIHQpIHtcbiAgcmV0dXJuIE9lKGUuZ2V0U2Vjb25kcygpLCB0LCAyKTtcbn1cbmZ1bmN0aW9uIHozKGUpIHtcbiAgdmFyIHQgPSBlLmdldERheSgpO1xuICByZXR1cm4gdCA9PT0gMCA/IDcgOiB0O1xufVxuZnVuY3Rpb24gVjMoZSwgdCkge1xuICByZXR1cm4gT2UoWXMuY291bnQoJG4oZSkgLSAxLCBlKSwgdCwgMik7XG59XG5mdW5jdGlvbiBtMChlKSB7XG4gIHZhciB0ID0gZS5nZXREYXkoKTtcbiAgcmV0dXJuIHQgPj0gNCB8fCB0ID09PSAwID8gSHIoZSkgOiBIci5jZWlsKGUpO1xufVxuZnVuY3Rpb24gRzMoZSwgdCkge1xuICByZXR1cm4gZSA9IG0wKGUpLCBPZShIci5jb3VudCgkbihlKSwgZSkgKyAoJG4oZSkuZ2V0RGF5KCkgPT09IDQpLCB0LCAyKTtcbn1cbmZ1bmN0aW9uIFczKGUpIHtcbiAgcmV0dXJuIGUuZ2V0RGF5KCk7XG59XG5mdW5jdGlvbiBVMyhlLCB0KSB7XG4gIHJldHVybiBPZShzcy5jb3VudCgkbihlKSAtIDEsIGUpLCB0LCAyKTtcbn1cbmZ1bmN0aW9uIEgzKGUsIHQpIHtcbiAgcmV0dXJuIE9lKGUuZ2V0RnVsbFllYXIoKSAlIDEwMCwgdCwgMik7XG59XG5mdW5jdGlvbiBxMyhlLCB0KSB7XG4gIHJldHVybiBlID0gbTAoZSksIE9lKGUuZ2V0RnVsbFllYXIoKSAlIDEwMCwgdCwgMik7XG59XG5mdW5jdGlvbiBLMyhlLCB0KSB7XG4gIHJldHVybiBPZShlLmdldEZ1bGxZZWFyKCkgJSAxZTQsIHQsIDQpO1xufVxuZnVuY3Rpb24gWTMoZSwgdCkge1xuICB2YXIgbiA9IGUuZ2V0RGF5KCk7XG4gIHJldHVybiBlID0gbiA+PSA0IHx8IG4gPT09IDAgPyBIcihlKSA6IEhyLmNlaWwoZSksIE9lKGUuZ2V0RnVsbFllYXIoKSAlIDFlNCwgdCwgNCk7XG59XG5mdW5jdGlvbiBYMyhlKSB7XG4gIHZhciB0ID0gZS5nZXRUaW1lem9uZU9mZnNldCgpO1xuICByZXR1cm4gKHQgPiAwID8gXCItXCIgOiAodCAqPSAtMSwgXCIrXCIpKSArIE9lKHQgLyA2MCB8IDAsIFwiMFwiLCAyKSArIE9lKHQgJSA2MCwgXCIwXCIsIDIpO1xufVxuZnVuY3Rpb24gZGcoZSwgdCkge1xuICByZXR1cm4gT2UoZS5nZXRVVENEYXRlKCksIHQsIDIpO1xufVxuZnVuY3Rpb24gWjMoZSwgdCkge1xuICByZXR1cm4gT2UoZS5nZXRVVENIb3VycygpLCB0LCAyKTtcbn1cbmZ1bmN0aW9uIEozKGUsIHQpIHtcbiAgcmV0dXJuIE9lKGUuZ2V0VVRDSG91cnMoKSAlIDEyIHx8IDEyLCB0LCAyKTtcbn1cbmZ1bmN0aW9uIFEzKGUsIHQpIHtcbiAgcmV0dXJuIE9lKDEgKyBLcy5jb3VudChPbihlKSwgZSksIHQsIDMpO1xufVxuZnVuY3Rpb24geTAoZSwgdCkge1xuICByZXR1cm4gT2UoZS5nZXRVVENNaWxsaXNlY29uZHMoKSwgdCwgMyk7XG59XG5mdW5jdGlvbiBlQihlLCB0KSB7XG4gIHJldHVybiB5MChlLCB0KSArIFwiMDAwXCI7XG59XG5mdW5jdGlvbiB0QihlLCB0KSB7XG4gIHJldHVybiBPZShlLmdldFVUQ01vbnRoKCkgKyAxLCB0LCAyKTtcbn1cbmZ1bmN0aW9uIG5CKGUsIHQpIHtcbiAgcmV0dXJuIE9lKGUuZ2V0VVRDTWludXRlcygpLCB0LCAyKTtcbn1cbmZ1bmN0aW9uIHJCKGUsIHQpIHtcbiAgcmV0dXJuIE9lKGUuZ2V0VVRDU2Vjb25kcygpLCB0LCAyKTtcbn1cbmZ1bmN0aW9uIGlCKGUpIHtcbiAgdmFyIHQgPSBlLmdldFVUQ0RheSgpO1xuICByZXR1cm4gdCA9PT0gMCA/IDcgOiB0O1xufVxuZnVuY3Rpb24gb0IoZSwgdCkge1xuICByZXR1cm4gT2UoWHMuY291bnQoT24oZSkgLSAxLCBlKSwgdCwgMik7XG59XG5mdW5jdGlvbiBiMChlKSB7XG4gIHZhciB0ID0gZS5nZXRVVENEYXkoKTtcbiAgcmV0dXJuIHQgPj0gNCB8fCB0ID09PSAwID8gcXIoZSkgOiBxci5jZWlsKGUpO1xufVxuZnVuY3Rpb24gYUIoZSwgdCkge1xuICByZXR1cm4gZSA9IGIwKGUpLCBPZShxci5jb3VudChPbihlKSwgZSkgKyAoT24oZSkuZ2V0VVRDRGF5KCkgPT09IDQpLCB0LCAyKTtcbn1cbmZ1bmN0aW9uIHNCKGUpIHtcbiAgcmV0dXJuIGUuZ2V0VVRDRGF5KCk7XG59XG5mdW5jdGlvbiB1QihlLCB0KSB7XG4gIHJldHVybiBPZSh1cy5jb3VudChPbihlKSAtIDEsIGUpLCB0LCAyKTtcbn1cbmZ1bmN0aW9uIGNCKGUsIHQpIHtcbiAgcmV0dXJuIE9lKGUuZ2V0VVRDRnVsbFllYXIoKSAlIDEwMCwgdCwgMik7XG59XG5mdW5jdGlvbiBsQihlLCB0KSB7XG4gIHJldHVybiBlID0gYjAoZSksIE9lKGUuZ2V0VVRDRnVsbFllYXIoKSAlIDEwMCwgdCwgMik7XG59XG5mdW5jdGlvbiBmQihlLCB0KSB7XG4gIHJldHVybiBPZShlLmdldFVUQ0Z1bGxZZWFyKCkgJSAxZTQsIHQsIDQpO1xufVxuZnVuY3Rpb24gZEIoZSwgdCkge1xuICB2YXIgbiA9IGUuZ2V0VVRDRGF5KCk7XG4gIHJldHVybiBlID0gbiA+PSA0IHx8IG4gPT09IDAgPyBxcihlKSA6IHFyLmNlaWwoZSksIE9lKGUuZ2V0VVRDRnVsbFllYXIoKSAlIDFlNCwgdCwgNCk7XG59XG5mdW5jdGlvbiBwQigpIHtcbiAgcmV0dXJuIFwiKzAwMDBcIjtcbn1cbmZ1bmN0aW9uIHBnKCkge1xuICByZXR1cm4gXCIlXCI7XG59XG5mdW5jdGlvbiBoZyhlKSB7XG4gIHJldHVybiArZTtcbn1cbmZ1bmN0aW9uIGdnKGUpIHtcbiAgcmV0dXJuIE1hdGguZmxvb3IoK2UgLyAxZTMpO1xufVxudmFyIF9yLCB3MCwgeDA7XG5oQih7XG4gIGRhdGVUaW1lOiBcIiV4LCAlWFwiLFxuICBkYXRlOiBcIiUtbS8lLWQvJVlcIixcbiAgdGltZTogXCIlLUk6JU06JVMgJXBcIixcbiAgcGVyaW9kczogW1wiQU1cIiwgXCJQTVwiXSxcbiAgZGF5czogW1wiU3VuZGF5XCIsIFwiTW9uZGF5XCIsIFwiVHVlc2RheVwiLCBcIldlZG5lc2RheVwiLCBcIlRodXJzZGF5XCIsIFwiRnJpZGF5XCIsIFwiU2F0dXJkYXlcIl0sXG4gIHNob3J0RGF5czogW1wiU3VuXCIsIFwiTW9uXCIsIFwiVHVlXCIsIFwiV2VkXCIsIFwiVGh1XCIsIFwiRnJpXCIsIFwiU2F0XCJdLFxuICBtb250aHM6IFtcIkphbnVhcnlcIiwgXCJGZWJydWFyeVwiLCBcIk1hcmNoXCIsIFwiQXByaWxcIiwgXCJNYXlcIiwgXCJKdW5lXCIsIFwiSnVseVwiLCBcIkF1Z3VzdFwiLCBcIlNlcHRlbWJlclwiLCBcIk9jdG9iZXJcIiwgXCJOb3ZlbWJlclwiLCBcIkRlY2VtYmVyXCJdLFxuICBzaG9ydE1vbnRoczogW1wiSmFuXCIsIFwiRmViXCIsIFwiTWFyXCIsIFwiQXByXCIsIFwiTWF5XCIsIFwiSnVuXCIsIFwiSnVsXCIsIFwiQXVnXCIsIFwiU2VwXCIsIFwiT2N0XCIsIFwiTm92XCIsIFwiRGVjXCJdXG59KTtcbmZ1bmN0aW9uIGhCKGUpIHtcbiAgcmV0dXJuIF9yID0gaDMoZSksIHcwID0gX3IuZm9ybWF0LCBfci5wYXJzZSwgeDAgPSBfci51dGNGb3JtYXQsIF9yLnV0Y1BhcnNlLCBfcjtcbn1cbmZ1bmN0aW9uIGdCKGUpIHtcbiAgcmV0dXJuIG5ldyBEYXRlKGUpO1xufVxuZnVuY3Rpb24gdkIoZSkge1xuICByZXR1cm4gZSBpbnN0YW5jZW9mIERhdGUgPyArZSA6ICsvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoK2UpO1xufVxuZnVuY3Rpb24gb2QoZSwgdCwgbiwgciwgaSwgbywgYSwgcywgdSwgYykge1xuICB2YXIgZiA9IFVmKCksIGwgPSBmLmludmVydCwgZCA9IGYuZG9tYWluLCBwID0gYyhcIi4lTFwiKSwgZyA9IGMoXCI6JVNcIiksIGggPSBjKFwiJUk6JU1cIiksIHYgPSBjKFwiJUkgJXBcIiksIHcgPSBjKFwiJWEgJWRcIiksIGIgPSBjKFwiJWIgJWRcIiksIHggPSBjKFwiJUJcIiksIG0gPSBjKFwiJVlcIik7XG4gIGZ1bmN0aW9uIHkoUykge1xuICAgIHJldHVybiAodShTKSA8IFMgPyBwIDogcyhTKSA8IFMgPyBnIDogYShTKSA8IFMgPyBoIDogbyhTKSA8IFMgPyB2IDogcihTKSA8IFMgPyBpKFMpIDwgUyA/IHcgOiBiIDogbihTKSA8IFMgPyB4IDogbSkoUyk7XG4gIH1cbiAgcmV0dXJuIGYuaW52ZXJ0ID0gZnVuY3Rpb24oUykge1xuICAgIHJldHVybiBuZXcgRGF0ZShsKFMpKTtcbiAgfSwgZi5kb21haW4gPSBmdW5jdGlvbihTKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyBkKEFycmF5LmZyb20oUywgdkIpKSA6IGQoKS5tYXAoZ0IpO1xuICB9LCBmLnRpY2tzID0gZnVuY3Rpb24oUykge1xuICAgIHZhciAkID0gZCgpO1xuICAgIHJldHVybiBlKCRbMF0sICRbJC5sZW5ndGggLSAxXSwgUyA/PyAxMCk7XG4gIH0sIGYudGlja0Zvcm1hdCA9IGZ1bmN0aW9uKFMsICQpIHtcbiAgICByZXR1cm4gJCA9PSBudWxsID8geSA6IGMoJCk7XG4gIH0sIGYubmljZSA9IGZ1bmN0aW9uKFMpIHtcbiAgICB2YXIgJCA9IGQoKTtcbiAgICByZXR1cm4gKCFTIHx8IHR5cGVvZiBTLnJhbmdlICE9IFwiZnVuY3Rpb25cIikgJiYgKFMgPSB0KCRbMF0sICRbJC5sZW5ndGggLSAxXSwgUyA/PyAxMCkpLCBTID8gZChzMCgkLCBTKSkgOiBmO1xuICB9LCBmLmNvcHkgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gWW8oZiwgb2QoZSwgdCwgbiwgciwgaSwgbywgYSwgcywgdSwgYykpO1xuICB9LCBmO1xufVxuZnVuY3Rpb24gbUIoKSB7XG4gIHJldHVybiBCdC5hcHBseShvZChkMywgcDMsICRuLCByZCwgWXMsIFhvLCB0ZCwgUWYsIGlyLCB3MCkuZG9tYWluKFtuZXcgRGF0ZSgyZTMsIDAsIDEpLCBuZXcgRGF0ZSgyZTMsIDAsIDIpXSksIGFyZ3VtZW50cyk7XG59XG5mdW5jdGlvbiB5QigpIHtcbiAgcmV0dXJuIEJ0LmFwcGx5KG9kKGwzLCBmMywgT24sIGlkLCBYcywgS3MsIG5kLCBlZCwgaXIsIHgwKS5kb21haW4oW0RhdGUuVVRDKDJlMywgMCwgMSksIERhdGUuVVRDKDJlMywgMCwgMildKSwgYXJndW1lbnRzKTtcbn1cbmZ1bmN0aW9uIFpzKCkge1xuICB2YXIgZSA9IDAsIHQgPSAxLCBuLCByLCBpLCBvLCBhID0gZnQsIHMgPSAhMSwgdTtcbiAgZnVuY3Rpb24gYyhsKSB7XG4gICAgcmV0dXJuIGwgPT0gbnVsbCB8fCBpc05hTihsID0gK2wpID8gdSA6IGEoaSA9PT0gMCA/IDAuNSA6IChsID0gKG8obCkgLSBuKSAqIGksIHMgPyBNYXRoLm1heCgwLCBNYXRoLm1pbigxLCBsKSkgOiBsKSk7XG4gIH1cbiAgYy5kb21haW4gPSBmdW5jdGlvbihsKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoW2UsIHRdID0gbCwgbiA9IG8oZSA9ICtlKSwgciA9IG8odCA9ICt0KSwgaSA9IG4gPT09IHIgPyAwIDogMSAvIChyIC0gbiksIGMpIDogW2UsIHRdO1xuICB9LCBjLmNsYW1wID0gZnVuY3Rpb24obCkge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHMgPSAhIWwsIGMpIDogcztcbiAgfSwgYy5pbnRlcnBvbGF0b3IgPSBmdW5jdGlvbihsKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoYSA9IGwsIGMpIDogYTtcbiAgfTtcbiAgZnVuY3Rpb24gZihsKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGQpIHtcbiAgICAgIHZhciBwLCBnO1xuICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoW3AsIGddID0gZCwgYSA9IGwocCwgZyksIGMpIDogW2EoMCksIGEoMSldO1xuICAgIH07XG4gIH1cbiAgcmV0dXJuIGMucmFuZ2UgPSBmKHZpKSwgYy5yYW5nZVJvdW5kID0gZihXZiksIGMudW5rbm93biA9IGZ1bmN0aW9uKGwpIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh1ID0gbCwgYykgOiB1O1xuICB9LCBmdW5jdGlvbihsKSB7XG4gICAgcmV0dXJuIG8gPSBsLCBuID0gbChlKSwgciA9IGwodCksIGkgPSBuID09PSByID8gMCA6IDEgLyAociAtIG4pLCBjO1xuICB9O1xufVxuZnVuY3Rpb24gS24oZSwgdCkge1xuICByZXR1cm4gdC5kb21haW4oZS5kb21haW4oKSkuaW50ZXJwb2xhdG9yKGUuaW50ZXJwb2xhdG9yKCkpLmNsYW1wKGUuY2xhbXAoKSkudW5rbm93bihlLnVua25vd24oKSk7XG59XG5mdW5jdGlvbiBTMCgpIHtcbiAgdmFyIGUgPSBxbihacygpKGZ0KSk7XG4gIHJldHVybiBlLmNvcHkgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gS24oZSwgUzAoKSk7XG4gIH0sIEVuLmFwcGx5KGUsIGFyZ3VtZW50cyk7XG59XG5mdW5jdGlvbiAkMCgpIHtcbiAgdmFyIGUgPSBLZihacygpKS5kb21haW4oWzEsIDEwXSk7XG4gIHJldHVybiBlLmNvcHkgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gS24oZSwgJDAoKSkuYmFzZShlLmJhc2UoKSk7XG4gIH0sIEVuLmFwcGx5KGUsIGFyZ3VtZW50cyk7XG59XG5mdW5jdGlvbiBPMCgpIHtcbiAgdmFyIGUgPSBZZihacygpKTtcbiAgcmV0dXJuIGUuY29weSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBLbihlLCBPMCgpKS5jb25zdGFudChlLmNvbnN0YW50KCkpO1xuICB9LCBFbi5hcHBseShlLCBhcmd1bWVudHMpO1xufVxuZnVuY3Rpb24gYWQoKSB7XG4gIHZhciBlID0gWGYoWnMoKSk7XG4gIHJldHVybiBlLmNvcHkgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gS24oZSwgYWQoKSkuZXhwb25lbnQoZS5leHBvbmVudCgpKTtcbiAgfSwgRW4uYXBwbHkoZSwgYXJndW1lbnRzKTtcbn1cbmZ1bmN0aW9uIGJCKCkge1xuICByZXR1cm4gYWQuYXBwbHkobnVsbCwgYXJndW1lbnRzKS5leHBvbmVudCgwLjUpO1xufVxuZnVuY3Rpb24gXzAoKSB7XG4gIHZhciBlID0gW10sIHQgPSBmdDtcbiAgZnVuY3Rpb24gbihyKSB7XG4gICAgaWYgKHIgIT0gbnVsbCAmJiAhaXNOYU4ociA9ICtyKSlcbiAgICAgIHJldHVybiB0KChxbyhlLCByLCAxKSAtIDEpIC8gKGUubGVuZ3RoIC0gMSkpO1xuICB9XG4gIHJldHVybiBuLmRvbWFpbiA9IGZ1bmN0aW9uKHIpIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpXG4gICAgICByZXR1cm4gZS5zbGljZSgpO1xuICAgIGUgPSBbXTtcbiAgICBmb3IgKGxldCBpIG9mIHIpXG4gICAgICBpICE9IG51bGwgJiYgIWlzTmFOKGkgPSAraSkgJiYgZS5wdXNoKGkpO1xuICAgIHJldHVybiBlLnNvcnQoTG4pLCBuO1xuICB9LCBuLmludGVycG9sYXRvciA9IGZ1bmN0aW9uKHIpIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh0ID0gciwgbikgOiB0O1xuICB9LCBuLnJhbmdlID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGUubWFwKChyLCBpKSA9PiB0KGkgLyAoZS5sZW5ndGggLSAxKSkpO1xuICB9LCBuLnF1YW50aWxlcyA9IGZ1bmN0aW9uKHIpIHtcbiAgICByZXR1cm4gQXJyYXkuZnJvbSh7IGxlbmd0aDogciArIDEgfSwgKGksIG8pID0+IG9MKGUsIG8gLyByKSk7XG4gIH0sIG4uY29weSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBfMCh0KS5kb21haW4oZSk7XG4gIH0sIEVuLmFwcGx5KG4sIGFyZ3VtZW50cyk7XG59XG5mdW5jdGlvbiBKcygpIHtcbiAgdmFyIGUgPSAwLCB0ID0gMC41LCBuID0gMSwgciA9IDEsIGksIG8sIGEsIHMsIHUsIGMgPSBmdCwgZiwgbCA9ICExLCBkO1xuICBmdW5jdGlvbiBwKGgpIHtcbiAgICByZXR1cm4gaXNOYU4oaCA9ICtoKSA/IGQgOiAoaCA9IDAuNSArICgoaCA9ICtmKGgpKSAtIG8pICogKHIgKiBoIDwgciAqIG8gPyBzIDogdSksIGMobCA/IE1hdGgubWF4KDAsIE1hdGgubWluKDEsIGgpKSA6IGgpKTtcbiAgfVxuICBwLmRvbWFpbiA9IGZ1bmN0aW9uKGgpIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChbZSwgdCwgbl0gPSBoLCBpID0gZihlID0gK2UpLCBvID0gZih0ID0gK3QpLCBhID0gZihuID0gK24pLCBzID0gaSA9PT0gbyA/IDAgOiAwLjUgLyAobyAtIGkpLCB1ID0gbyA9PT0gYSA/IDAgOiAwLjUgLyAoYSAtIG8pLCByID0gbyA8IGkgPyAtMSA6IDEsIHApIDogW2UsIHQsIG5dO1xuICB9LCBwLmNsYW1wID0gZnVuY3Rpb24oaCkge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGwgPSAhIWgsIHApIDogbDtcbiAgfSwgcC5pbnRlcnBvbGF0b3IgPSBmdW5jdGlvbihoKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoYyA9IGgsIHApIDogYztcbiAgfTtcbiAgZnVuY3Rpb24gZyhoKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHYpIHtcbiAgICAgIHZhciB3LCBiLCB4O1xuICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoW3csIGIsIHhdID0gdiwgYyA9IE1MKGgsIFt3LCBiLCB4XSksIHApIDogW2MoMCksIGMoMC41KSwgYygxKV07XG4gICAgfTtcbiAgfVxuICByZXR1cm4gcC5yYW5nZSA9IGcodmkpLCBwLnJhbmdlUm91bmQgPSBnKFdmKSwgcC51bmtub3duID0gZnVuY3Rpb24oaCkge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGQgPSBoLCBwKSA6IGQ7XG4gIH0sIGZ1bmN0aW9uKGgpIHtcbiAgICByZXR1cm4gZiA9IGgsIGkgPSBoKGUpLCBvID0gaCh0KSwgYSA9IGgobiksIHMgPSBpID09PSBvID8gMCA6IDAuNSAvIChvIC0gaSksIHUgPSBvID09PSBhID8gMCA6IDAuNSAvIChhIC0gbyksIHIgPSBvIDwgaSA/IC0xIDogMSwgcDtcbiAgfTtcbn1cbmZ1bmN0aW9uIEEwKCkge1xuICB2YXIgZSA9IHFuKEpzKCkoZnQpKTtcbiAgcmV0dXJuIGUuY29weSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBLbihlLCBBMCgpKTtcbiAgfSwgRW4uYXBwbHkoZSwgYXJndW1lbnRzKTtcbn1cbmZ1bmN0aW9uIFAwKCkge1xuICB2YXIgZSA9IEtmKEpzKCkpLmRvbWFpbihbMC4xLCAxLCAxMF0pO1xuICByZXR1cm4gZS5jb3B5ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIEtuKGUsIFAwKCkpLmJhc2UoZS5iYXNlKCkpO1xuICB9LCBFbi5hcHBseShlLCBhcmd1bWVudHMpO1xufVxuZnVuY3Rpb24gQzAoKSB7XG4gIHZhciBlID0gWWYoSnMoKSk7XG4gIHJldHVybiBlLmNvcHkgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gS24oZSwgQzAoKSkuY29uc3RhbnQoZS5jb25zdGFudCgpKTtcbiAgfSwgRW4uYXBwbHkoZSwgYXJndW1lbnRzKTtcbn1cbmZ1bmN0aW9uIHNkKCkge1xuICB2YXIgZSA9IFhmKEpzKCkpO1xuICByZXR1cm4gZS5jb3B5ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIEtuKGUsIHNkKCkpLmV4cG9uZW50KGUuZXhwb25lbnQoKSk7XG4gIH0sIEVuLmFwcGx5KGUsIGFyZ3VtZW50cyk7XG59XG5mdW5jdGlvbiB3QigpIHtcbiAgcmV0dXJuIHNkLmFwcGx5KG51bGwsIGFyZ3VtZW50cykuZXhwb25lbnQoMC41KTtcbn1cbmNvbnN0IHZnID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5mcmVlemUoLyogQF9fUFVSRV9fICovIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7XG4gIF9fcHJvdG9fXzogbnVsbCxcbiAgc2NhbGVCYW5kOiBzbyxcbiAgc2NhbGVEaXZlcmdpbmc6IEEwLFxuICBzY2FsZURpdmVyZ2luZ0xvZzogUDAsXG4gIHNjYWxlRGl2ZXJnaW5nUG93OiBzZCxcbiAgc2NhbGVEaXZlcmdpbmdTcXJ0OiB3QixcbiAgc2NhbGVEaXZlcmdpbmdTeW1sb2c6IEMwLFxuICBzY2FsZUlkZW50aXR5OiBhMCxcbiAgc2NhbGVJbXBsaWNpdDogaWwsXG4gIHNjYWxlTGluZWFyOiBvcyxcbiAgc2NhbGVMb2c6IHUwLFxuICBzY2FsZU9yZGluYWw6IHpmLFxuICBzY2FsZVBvaW50OiBXaSxcbiAgc2NhbGVQb3c6IFpmLFxuICBzY2FsZVF1YW50aWxlOiBmMCxcbiAgc2NhbGVRdWFudGl6ZTogZDAsXG4gIHNjYWxlUmFkaWFsOiBsMCxcbiAgc2NhbGVTZXF1ZW50aWFsOiBTMCxcbiAgc2NhbGVTZXF1ZW50aWFsTG9nOiAkMCxcbiAgc2NhbGVTZXF1ZW50aWFsUG93OiBhZCxcbiAgc2NhbGVTZXF1ZW50aWFsUXVhbnRpbGU6IF8wLFxuICBzY2FsZVNlcXVlbnRpYWxTcXJ0OiBiQixcbiAgc2NhbGVTZXF1ZW50aWFsU3ltbG9nOiBPMCxcbiAgc2NhbGVTcXJ0OiBlMyxcbiAgc2NhbGVTeW1sb2c6IGMwLFxuICBzY2FsZVRocmVzaG9sZDogcDAsXG4gIHNjYWxlVGltZTogbUIsXG4gIHNjYWxlVXRjOiB5QixcbiAgdGlja0Zvcm1hdDogbzBcbn0sIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogXCJNb2R1bGVcIiB9KSk7XG52YXIgeEIgPSB1aTtcbmZ1bmN0aW9uIFNCKGUsIHQsIG4pIHtcbiAgZm9yICh2YXIgciA9IC0xLCBpID0gZS5sZW5ndGg7ICsrciA8IGk7ICkge1xuICAgIHZhciBvID0gZVtyXSwgYSA9IHQobyk7XG4gICAgaWYgKGEgIT0gbnVsbCAmJiAocyA9PT0gdm9pZCAwID8gYSA9PT0gYSAmJiAheEIoYSkgOiBuKGEsIHMpKSlcbiAgICAgIHZhciBzID0gYSwgdSA9IG87XG4gIH1cbiAgcmV0dXJuIHU7XG59XG52YXIgRTAgPSBTQjtcbmZ1bmN0aW9uICRCKGUsIHQpIHtcbiAgcmV0dXJuIGUgPiB0O1xufVxudmFyIE9CID0gJEIsIF9CID0gRTAsIEFCID0gT0IsIFBCID0gZ2k7XG5mdW5jdGlvbiBDQihlKSB7XG4gIHJldHVybiBlICYmIGUubGVuZ3RoID8gX0IoZSwgUEIsIEFCKSA6IHZvaWQgMDtcbn1cbnZhciBFQiA9IENCO1xuY29uc3QgUXMgPSAvKiBAX19QVVJFX18gKi8gamUoRUIpO1xuZnVuY3Rpb24gVEIoZSwgdCkge1xuICByZXR1cm4gZSA8IHQ7XG59XG52YXIgTUIgPSBUQiwgUkIgPSBFMCwgSUIgPSBNQiwgakIgPSBnaTtcbmZ1bmN0aW9uIGtCKGUpIHtcbiAgcmV0dXJuIGUgJiYgZS5sZW5ndGggPyBSQihlLCBqQiwgSUIpIDogdm9pZCAwO1xufVxudmFyIERCID0ga0I7XG5jb25zdCBldSA9IC8qIEBfX1BVUkVfXyAqLyBqZShEQik7XG52YXIgTkIgPSBTZiwgRkIgPSBIbiwgTEIgPSBGYiwgQkIgPSBtdDtcbmZ1bmN0aW9uIHpCKGUsIHQpIHtcbiAgdmFyIG4gPSBCQihlKSA/IE5CIDogTEI7XG4gIHJldHVybiBuKGUsIEZCKHQpKTtcbn1cbnZhciBWQiA9IHpCLCBHQiA9IERiLCBXQiA9IFZCO1xuZnVuY3Rpb24gVUIoZSwgdCkge1xuICByZXR1cm4gR0IoV0IoZSwgdCksIDEpO1xufVxudmFyIEhCID0gVUI7XG5jb25zdCBxQiA9IC8qIEBfX1BVUkVfXyAqLyBqZShIQik7XG52YXIgS0IgPSBEZjtcbmZ1bmN0aW9uIFlCKGUsIHQpIHtcbiAgcmV0dXJuIEtCKGUsIHQpO1xufVxudmFyIFhCID0gWUI7XG5jb25zdCB0dSA9IC8qIEBfX1BVUkVfXyAqLyBqZShYQik7XG52YXIgbWkgPSAxZTksIFpCID0ge1xuICAvLyBUaGVzZSB2YWx1ZXMgbXVzdCBiZSBpbnRlZ2VycyB3aXRoaW4gdGhlIHN0YXRlZCByYW5nZXMgKGluY2x1c2l2ZSkuXG4gIC8vIE1vc3Qgb2YgdGhlc2UgdmFsdWVzIGNhbiBiZSBjaGFuZ2VkIGR1cmluZyBydW4tdGltZSB1c2luZyBgRGVjaW1hbC5jb25maWdgLlxuICAvLyBUaGUgbWF4aW11bSBudW1iZXIgb2Ygc2lnbmlmaWNhbnQgZGlnaXRzIG9mIHRoZSByZXN1bHQgb2YgYSBjYWxjdWxhdGlvbiBvciBiYXNlIGNvbnZlcnNpb24uXG4gIC8vIEUuZy4gYERlY2ltYWwuY29uZmlnKHsgcHJlY2lzaW9uOiAyMCB9KTtgXG4gIHByZWNpc2lvbjogMjAsXG4gIC8vIDEgdG8gTUFYX0RJR0lUU1xuICAvLyBUaGUgcm91bmRpbmcgbW9kZSB1c2VkIGJ5IGRlZmF1bHQgYnkgYHRvSW50ZWdlcmAsIGB0b0RlY2ltYWxQbGFjZXNgLCBgdG9FeHBvbmVudGlhbGAsXG4gIC8vIGB0b0ZpeGVkYCwgYHRvUHJlY2lzaW9uYCBhbmQgYHRvU2lnbmlmaWNhbnREaWdpdHNgLlxuICAvL1xuICAvLyBST1VORF9VUCAgICAgICAgIDAgQXdheSBmcm9tIHplcm8uXG4gIC8vIFJPVU5EX0RPV04gICAgICAgMSBUb3dhcmRzIHplcm8uXG4gIC8vIFJPVU5EX0NFSUwgICAgICAgMiBUb3dhcmRzICtJbmZpbml0eS5cbiAgLy8gUk9VTkRfRkxPT1IgICAgICAzIFRvd2FyZHMgLUluZmluaXR5LlxuICAvLyBST1VORF9IQUxGX1VQICAgIDQgVG93YXJkcyBuZWFyZXN0IG5laWdoYm91ci4gSWYgZXF1aWRpc3RhbnQsIHVwLlxuICAvLyBST1VORF9IQUxGX0RPV04gIDUgVG93YXJkcyBuZWFyZXN0IG5laWdoYm91ci4gSWYgZXF1aWRpc3RhbnQsIGRvd24uXG4gIC8vIFJPVU5EX0hBTEZfRVZFTiAgNiBUb3dhcmRzIG5lYXJlc3QgbmVpZ2hib3VyLiBJZiBlcXVpZGlzdGFudCwgdG93YXJkcyBldmVuIG5laWdoYm91ci5cbiAgLy8gUk9VTkRfSEFMRl9DRUlMICA3IFRvd2FyZHMgbmVhcmVzdCBuZWlnaGJvdXIuIElmIGVxdWlkaXN0YW50LCB0b3dhcmRzICtJbmZpbml0eS5cbiAgLy8gUk9VTkRfSEFMRl9GTE9PUiA4IFRvd2FyZHMgbmVhcmVzdCBuZWlnaGJvdXIuIElmIGVxdWlkaXN0YW50LCB0b3dhcmRzIC1JbmZpbml0eS5cbiAgLy9cbiAgLy8gRS5nLlxuICAvLyBgRGVjaW1hbC5yb3VuZGluZyA9IDQ7YFxuICAvLyBgRGVjaW1hbC5yb3VuZGluZyA9IERlY2ltYWwuUk9VTkRfSEFMRl9VUDtgXG4gIHJvdW5kaW5nOiA0LFxuICAvLyAwIHRvIDhcbiAgLy8gVGhlIGV4cG9uZW50IHZhbHVlIGF0IGFuZCBiZW5lYXRoIHdoaWNoIGB0b1N0cmluZ2AgcmV0dXJucyBleHBvbmVudGlhbCBub3RhdGlvbi5cbiAgLy8gSmF2YVNjcmlwdCBudW1iZXJzOiAtN1xuICB0b0V4cE5lZzogLTcsXG4gIC8vIDAgdG8gLU1BWF9FXG4gIC8vIFRoZSBleHBvbmVudCB2YWx1ZSBhdCBhbmQgYWJvdmUgd2hpY2ggYHRvU3RyaW5nYCByZXR1cm5zIGV4cG9uZW50aWFsIG5vdGF0aW9uLlxuICAvLyBKYXZhU2NyaXB0IG51bWJlcnM6IDIxXG4gIHRvRXhwUG9zOiAyMSxcbiAgLy8gMCB0byBNQVhfRVxuICAvLyBUaGUgbmF0dXJhbCBsb2dhcml0aG0gb2YgMTAuXG4gIC8vIDExNSBkaWdpdHNcbiAgTE4xMDogXCIyLjMwMjU4NTA5Mjk5NDA0NTY4NDAxNzk5MTQ1NDY4NDM2NDIwNzYwMTEwMTQ4ODYyODc3Mjk3NjAzMzMyNzkwMDk2NzU3MjYwOTY3NzM1MjQ4MDIzNTk5NzIwNTA4OTU5ODI5ODM0MTk2Nzc4NDA0MjI4NlwiXG59LCBjZCwgQmUgPSAhMCwgRHQgPSBcIltEZWNpbWFsRXJyb3JdIFwiLCB1ciA9IER0ICsgXCJJbnZhbGlkIGFyZ3VtZW50OiBcIiwgdWQgPSBEdCArIFwiRXhwb25lbnQgb3V0IG9mIHJhbmdlOiBcIiwgeWkgPSBNYXRoLmZsb29yLCB0ciA9IE1hdGgucG93LCBKQiA9IC9eKFxcZCsoXFwuXFxkKik/fFxcLlxcZCspKGVbKy1dP1xcZCspPyQvaSwgU3QsIFFlID0gMWU3LCBOZSA9IDcsIFQwID0gOTAwNzE5OTI1NDc0MDk5MSwgY3MgPSB5aShUMCAvIE5lKSwgUSA9IHt9O1xuUS5hYnNvbHV0ZVZhbHVlID0gUS5hYnMgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGUgPSBuZXcgdGhpcy5jb25zdHJ1Y3Rvcih0aGlzKTtcbiAgcmV0dXJuIGUucyAmJiAoZS5zID0gMSksIGU7XG59O1xuUS5jb21wYXJlZFRvID0gUS5jbXAgPSBmdW5jdGlvbihlKSB7XG4gIHZhciB0LCBuLCByLCBpLCBvID0gdGhpcztcbiAgaWYgKGUgPSBuZXcgby5jb25zdHJ1Y3RvcihlKSwgby5zICE9PSBlLnMpXG4gICAgcmV0dXJuIG8ucyB8fCAtZS5zO1xuICBpZiAoby5lICE9PSBlLmUpXG4gICAgcmV0dXJuIG8uZSA+IGUuZSBeIG8ucyA8IDAgPyAxIDogLTE7XG4gIGZvciAociA9IG8uZC5sZW5ndGgsIGkgPSBlLmQubGVuZ3RoLCB0ID0gMCwgbiA9IHIgPCBpID8gciA6IGk7IHQgPCBuOyArK3QpXG4gICAgaWYgKG8uZFt0XSAhPT0gZS5kW3RdKVxuICAgICAgcmV0dXJuIG8uZFt0XSA+IGUuZFt0XSBeIG8ucyA8IDAgPyAxIDogLTE7XG4gIHJldHVybiByID09PSBpID8gMCA6IHIgPiBpIF4gby5zIDwgMCA/IDEgOiAtMTtcbn07XG5RLmRlY2ltYWxQbGFjZXMgPSBRLmRwID0gZnVuY3Rpb24oKSB7XG4gIHZhciBlID0gdGhpcywgdCA9IGUuZC5sZW5ndGggLSAxLCBuID0gKHQgLSBlLmUpICogTmU7XG4gIGlmICh0ID0gZS5kW3RdLCB0KVxuICAgIGZvciAoOyB0ICUgMTAgPT0gMDsgdCAvPSAxMClcbiAgICAgIG4tLTtcbiAgcmV0dXJuIG4gPCAwID8gMCA6IG47XG59O1xuUS5kaXZpZGVkQnkgPSBRLmRpdiA9IGZ1bmN0aW9uKGUpIHtcbiAgcmV0dXJuIGJuKHRoaXMsIG5ldyB0aGlzLmNvbnN0cnVjdG9yKGUpKTtcbn07XG5RLmRpdmlkZWRUb0ludGVnZXJCeSA9IFEuaWRpdiA9IGZ1bmN0aW9uKGUpIHtcbiAgdmFyIHQgPSB0aGlzLCBuID0gdC5jb25zdHJ1Y3RvcjtcbiAgcmV0dXJuIFJlKGJuKHQsIG5ldyBuKGUpLCAwLCAxKSwgbi5wcmVjaXNpb24pO1xufTtcblEuZXF1YWxzID0gUS5lcSA9IGZ1bmN0aW9uKGUpIHtcbiAgcmV0dXJuICF0aGlzLmNtcChlKTtcbn07XG5RLmV4cG9uZW50ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBIZSh0aGlzKTtcbn07XG5RLmdyZWF0ZXJUaGFuID0gUS5ndCA9IGZ1bmN0aW9uKGUpIHtcbiAgcmV0dXJuIHRoaXMuY21wKGUpID4gMDtcbn07XG5RLmdyZWF0ZXJUaGFuT3JFcXVhbFRvID0gUS5ndGUgPSBmdW5jdGlvbihlKSB7XG4gIHJldHVybiB0aGlzLmNtcChlKSA+PSAwO1xufTtcblEuaXNJbnRlZ2VyID0gUS5pc2ludCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5lID4gdGhpcy5kLmxlbmd0aCAtIDI7XG59O1xuUS5pc05lZ2F0aXZlID0gUS5pc25lZyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5zIDwgMDtcbn07XG5RLmlzUG9zaXRpdmUgPSBRLmlzcG9zID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLnMgPiAwO1xufTtcblEuaXNaZXJvID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLnMgPT09IDA7XG59O1xuUS5sZXNzVGhhbiA9IFEubHQgPSBmdW5jdGlvbihlKSB7XG4gIHJldHVybiB0aGlzLmNtcChlKSA8IDA7XG59O1xuUS5sZXNzVGhhbk9yRXF1YWxUbyA9IFEubHRlID0gZnVuY3Rpb24oZSkge1xuICByZXR1cm4gdGhpcy5jbXAoZSkgPCAxO1xufTtcblEubG9nYXJpdGhtID0gUS5sb2cgPSBmdW5jdGlvbihlKSB7XG4gIHZhciB0LCBuID0gdGhpcywgciA9IG4uY29uc3RydWN0b3IsIGkgPSByLnByZWNpc2lvbiwgbyA9IGkgKyA1O1xuICBpZiAoZSA9PT0gdm9pZCAwKVxuICAgIGUgPSBuZXcgcigxMCk7XG4gIGVsc2UgaWYgKGUgPSBuZXcgcihlKSwgZS5zIDwgMSB8fCBlLmVxKFN0KSlcbiAgICB0aHJvdyBFcnJvcihEdCArIFwiTmFOXCIpO1xuICBpZiAobi5zIDwgMSlcbiAgICB0aHJvdyBFcnJvcihEdCArIChuLnMgPyBcIk5hTlwiIDogXCItSW5maW5pdHlcIikpO1xuICByZXR1cm4gbi5lcShTdCkgPyBuZXcgcigwKSA6IChCZSA9ICExLCB0ID0gYm4ocG8obiwgbyksIHBvKGUsIG8pLCBvKSwgQmUgPSAhMCwgUmUodCwgaSkpO1xufTtcblEubWludXMgPSBRLnN1YiA9IGZ1bmN0aW9uKGUpIHtcbiAgdmFyIHQgPSB0aGlzO1xuICByZXR1cm4gZSA9IG5ldyB0LmNvbnN0cnVjdG9yKGUpLCB0LnMgPT0gZS5zID8gSTAodCwgZSkgOiBNMCh0LCAoZS5zID0gLWUucywgZSkpO1xufTtcblEubW9kdWxvID0gUS5tb2QgPSBmdW5jdGlvbihlKSB7XG4gIHZhciB0LCBuID0gdGhpcywgciA9IG4uY29uc3RydWN0b3IsIGkgPSByLnByZWNpc2lvbjtcbiAgaWYgKGUgPSBuZXcgcihlKSwgIWUucylcbiAgICB0aHJvdyBFcnJvcihEdCArIFwiTmFOXCIpO1xuICByZXR1cm4gbi5zID8gKEJlID0gITEsIHQgPSBibihuLCBlLCAwLCAxKS50aW1lcyhlKSwgQmUgPSAhMCwgbi5taW51cyh0KSkgOiBSZShuZXcgcihuKSwgaSk7XG59O1xuUS5uYXR1cmFsRXhwb25lbnRpYWwgPSBRLmV4cCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gUjAodGhpcyk7XG59O1xuUS5uYXR1cmFsTG9nYXJpdGhtID0gUS5sbiA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gcG8odGhpcyk7XG59O1xuUS5uZWdhdGVkID0gUS5uZWcgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGUgPSBuZXcgdGhpcy5jb25zdHJ1Y3Rvcih0aGlzKTtcbiAgcmV0dXJuIGUucyA9IC1lLnMgfHwgMCwgZTtcbn07XG5RLnBsdXMgPSBRLmFkZCA9IGZ1bmN0aW9uKGUpIHtcbiAgdmFyIHQgPSB0aGlzO1xuICByZXR1cm4gZSA9IG5ldyB0LmNvbnN0cnVjdG9yKGUpLCB0LnMgPT0gZS5zID8gTTAodCwgZSkgOiBJMCh0LCAoZS5zID0gLWUucywgZSkpO1xufTtcblEucHJlY2lzaW9uID0gUS5zZCA9IGZ1bmN0aW9uKGUpIHtcbiAgdmFyIHQsIG4sIHIsIGkgPSB0aGlzO1xuICBpZiAoZSAhPT0gdm9pZCAwICYmIGUgIT09ICEhZSAmJiBlICE9PSAxICYmIGUgIT09IDApXG4gICAgdGhyb3cgRXJyb3IodXIgKyBlKTtcbiAgaWYgKHQgPSBIZShpKSArIDEsIHIgPSBpLmQubGVuZ3RoIC0gMSwgbiA9IHIgKiBOZSArIDEsIHIgPSBpLmRbcl0sIHIpIHtcbiAgICBmb3IgKDsgciAlIDEwID09IDA7IHIgLz0gMTApXG4gICAgICBuLS07XG4gICAgZm9yIChyID0gaS5kWzBdOyByID49IDEwOyByIC89IDEwKVxuICAgICAgbisrO1xuICB9XG4gIHJldHVybiBlICYmIHQgPiBuID8gdCA6IG47XG59O1xuUS5zcXVhcmVSb290ID0gUS5zcXJ0ID0gZnVuY3Rpb24oKSB7XG4gIHZhciBlLCB0LCBuLCByLCBpLCBvLCBhLCBzID0gdGhpcywgdSA9IHMuY29uc3RydWN0b3I7XG4gIGlmIChzLnMgPCAxKSB7XG4gICAgaWYgKCFzLnMpXG4gICAgICByZXR1cm4gbmV3IHUoMCk7XG4gICAgdGhyb3cgRXJyb3IoRHQgKyBcIk5hTlwiKTtcbiAgfVxuICBmb3IgKGUgPSBIZShzKSwgQmUgPSAhMSwgaSA9IE1hdGguc3FydCgrcyksIGkgPT0gMCB8fCBpID09IDEgLyAwID8gKHQgPSBvbihzLmQpLCAodC5sZW5ndGggKyBlKSAlIDIgPT0gMCAmJiAodCArPSBcIjBcIiksIGkgPSBNYXRoLnNxcnQodCksIGUgPSB5aSgoZSArIDEpIC8gMikgLSAoZSA8IDAgfHwgZSAlIDIpLCBpID09IDEgLyAwID8gdCA9IFwiNWVcIiArIGUgOiAodCA9IGkudG9FeHBvbmVudGlhbCgpLCB0ID0gdC5zbGljZSgwLCB0LmluZGV4T2YoXCJlXCIpICsgMSkgKyBlKSwgciA9IG5ldyB1KHQpKSA6IHIgPSBuZXcgdShpLnRvU3RyaW5nKCkpLCBuID0gdS5wcmVjaXNpb24sIGkgPSBhID0gbiArIDM7IDsgKVxuICAgIGlmIChvID0gciwgciA9IG8ucGx1cyhibihzLCBvLCBhICsgMikpLnRpbWVzKDAuNSksIG9uKG8uZCkuc2xpY2UoMCwgYSkgPT09ICh0ID0gb24oci5kKSkuc2xpY2UoMCwgYSkpIHtcbiAgICAgIGlmICh0ID0gdC5zbGljZShhIC0gMywgYSArIDEpLCBpID09IGEgJiYgdCA9PSBcIjQ5OTlcIikge1xuICAgICAgICBpZiAoUmUobywgbiArIDEsIDApLCBvLnRpbWVzKG8pLmVxKHMpKSB7XG4gICAgICAgICAgciA9IG87XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodCAhPSBcIjk5OTlcIilcbiAgICAgICAgYnJlYWs7XG4gICAgICBhICs9IDQ7XG4gICAgfVxuICByZXR1cm4gQmUgPSAhMCwgUmUociwgbik7XG59O1xuUS50aW1lcyA9IFEubXVsID0gZnVuY3Rpb24oZSkge1xuICB2YXIgdCwgbiwgciwgaSwgbywgYSwgcywgdSwgYywgZiA9IHRoaXMsIGwgPSBmLmNvbnN0cnVjdG9yLCBkID0gZi5kLCBwID0gKGUgPSBuZXcgbChlKSkuZDtcbiAgaWYgKCFmLnMgfHwgIWUucylcbiAgICByZXR1cm4gbmV3IGwoMCk7XG4gIGZvciAoZS5zICo9IGYucywgbiA9IGYuZSArIGUuZSwgdSA9IGQubGVuZ3RoLCBjID0gcC5sZW5ndGgsIHUgPCBjICYmIChvID0gZCwgZCA9IHAsIHAgPSBvLCBhID0gdSwgdSA9IGMsIGMgPSBhKSwgbyA9IFtdLCBhID0gdSArIGMsIHIgPSBhOyByLS07IClcbiAgICBvLnB1c2goMCk7XG4gIGZvciAociA9IGM7IC0tciA+PSAwOyApIHtcbiAgICBmb3IgKHQgPSAwLCBpID0gdSArIHI7IGkgPiByOyApXG4gICAgICBzID0gb1tpXSArIHBbcl0gKiBkW2kgLSByIC0gMV0gKyB0LCBvW2ktLV0gPSBzICUgUWUgfCAwLCB0ID0gcyAvIFFlIHwgMDtcbiAgICBvW2ldID0gKG9baV0gKyB0KSAlIFFlIHwgMDtcbiAgfVxuICBmb3IgKDsgIW9bLS1hXTsgKVxuICAgIG8ucG9wKCk7XG4gIHJldHVybiB0ID8gKytuIDogby5zaGlmdCgpLCBlLmQgPSBvLCBlLmUgPSBuLCBCZSA/IFJlKGUsIGwucHJlY2lzaW9uKSA6IGU7XG59O1xuUS50b0RlY2ltYWxQbGFjZXMgPSBRLnRvZHAgPSBmdW5jdGlvbihlLCB0KSB7XG4gIHZhciBuID0gdGhpcywgciA9IG4uY29uc3RydWN0b3I7XG4gIHJldHVybiBuID0gbmV3IHIobiksIGUgPT09IHZvaWQgMCA/IG4gOiAoZm4oZSwgMCwgbWkpLCB0ID09PSB2b2lkIDAgPyB0ID0gci5yb3VuZGluZyA6IGZuKHQsIDAsIDgpLCBSZShuLCBlICsgSGUobikgKyAxLCB0KSk7XG59O1xuUS50b0V4cG9uZW50aWFsID0gZnVuY3Rpb24oZSwgdCkge1xuICB2YXIgbiwgciA9IHRoaXMsIGkgPSByLmNvbnN0cnVjdG9yO1xuICByZXR1cm4gZSA9PT0gdm9pZCAwID8gbiA9IGZyKHIsICEwKSA6IChmbihlLCAwLCBtaSksIHQgPT09IHZvaWQgMCA/IHQgPSBpLnJvdW5kaW5nIDogZm4odCwgMCwgOCksIHIgPSBSZShuZXcgaShyKSwgZSArIDEsIHQpLCBuID0gZnIociwgITAsIGUgKyAxKSksIG47XG59O1xuUS50b0ZpeGVkID0gZnVuY3Rpb24oZSwgdCkge1xuICB2YXIgbiwgciwgaSA9IHRoaXMsIG8gPSBpLmNvbnN0cnVjdG9yO1xuICByZXR1cm4gZSA9PT0gdm9pZCAwID8gZnIoaSkgOiAoZm4oZSwgMCwgbWkpLCB0ID09PSB2b2lkIDAgPyB0ID0gby5yb3VuZGluZyA6IGZuKHQsIDAsIDgpLCByID0gUmUobmV3IG8oaSksIGUgKyBIZShpKSArIDEsIHQpLCBuID0gZnIoci5hYnMoKSwgITEsIGUgKyBIZShyKSArIDEpLCBpLmlzbmVnKCkgJiYgIWkuaXNaZXJvKCkgPyBcIi1cIiArIG4gOiBuKTtcbn07XG5RLnRvSW50ZWdlciA9IFEudG9pbnQgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGUgPSB0aGlzLCB0ID0gZS5jb25zdHJ1Y3RvcjtcbiAgcmV0dXJuIFJlKG5ldyB0KGUpLCBIZShlKSArIDEsIHQucm91bmRpbmcpO1xufTtcblEudG9OdW1iZXIgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuICt0aGlzO1xufTtcblEudG9Qb3dlciA9IFEucG93ID0gZnVuY3Rpb24oZSkge1xuICB2YXIgdCwgbiwgciwgaSwgbywgYSwgcyA9IHRoaXMsIHUgPSBzLmNvbnN0cnVjdG9yLCBjID0gMTIsIGYgPSArKGUgPSBuZXcgdShlKSk7XG4gIGlmICghZS5zKVxuICAgIHJldHVybiBuZXcgdShTdCk7XG4gIGlmIChzID0gbmV3IHUocyksICFzLnMpIHtcbiAgICBpZiAoZS5zIDwgMSlcbiAgICAgIHRocm93IEVycm9yKER0ICsgXCJJbmZpbml0eVwiKTtcbiAgICByZXR1cm4gcztcbiAgfVxuICBpZiAocy5lcShTdCkpXG4gICAgcmV0dXJuIHM7XG4gIGlmIChyID0gdS5wcmVjaXNpb24sIGUuZXEoU3QpKVxuICAgIHJldHVybiBSZShzLCByKTtcbiAgaWYgKHQgPSBlLmUsIG4gPSBlLmQubGVuZ3RoIC0gMSwgYSA9IHQgPj0gbiwgbyA9IHMucywgYSkge1xuICAgIGlmICgobiA9IGYgPCAwID8gLWYgOiBmKSA8PSBUMCkge1xuICAgICAgZm9yIChpID0gbmV3IHUoU3QpLCB0ID0gTWF0aC5jZWlsKHIgLyBOZSArIDQpLCBCZSA9ICExOyBuICUgMiAmJiAoaSA9IGkudGltZXMocyksIHlnKGkuZCwgdCkpLCBuID0geWkobiAvIDIpLCBuICE9PSAwOyApXG4gICAgICAgIHMgPSBzLnRpbWVzKHMpLCB5ZyhzLmQsIHQpO1xuICAgICAgcmV0dXJuIEJlID0gITAsIGUucyA8IDAgPyBuZXcgdShTdCkuZGl2KGkpIDogUmUoaSwgcik7XG4gICAgfVxuICB9IGVsc2UgaWYgKG8gPCAwKVxuICAgIHRocm93IEVycm9yKER0ICsgXCJOYU5cIik7XG4gIHJldHVybiBvID0gbyA8IDAgJiYgZS5kW01hdGgubWF4KHQsIG4pXSAmIDEgPyAtMSA6IDEsIHMucyA9IDEsIEJlID0gITEsIGkgPSBlLnRpbWVzKHBvKHMsIHIgKyBjKSksIEJlID0gITAsIGkgPSBSMChpKSwgaS5zID0gbywgaTtcbn07XG5RLnRvUHJlY2lzaW9uID0gZnVuY3Rpb24oZSwgdCkge1xuICB2YXIgbiwgciwgaSA9IHRoaXMsIG8gPSBpLmNvbnN0cnVjdG9yO1xuICByZXR1cm4gZSA9PT0gdm9pZCAwID8gKG4gPSBIZShpKSwgciA9IGZyKGksIG4gPD0gby50b0V4cE5lZyB8fCBuID49IG8udG9FeHBQb3MpKSA6IChmbihlLCAxLCBtaSksIHQgPT09IHZvaWQgMCA/IHQgPSBvLnJvdW5kaW5nIDogZm4odCwgMCwgOCksIGkgPSBSZShuZXcgbyhpKSwgZSwgdCksIG4gPSBIZShpKSwgciA9IGZyKGksIGUgPD0gbiB8fCBuIDw9IG8udG9FeHBOZWcsIGUpKSwgcjtcbn07XG5RLnRvU2lnbmlmaWNhbnREaWdpdHMgPSBRLnRvc2QgPSBmdW5jdGlvbihlLCB0KSB7XG4gIHZhciBuID0gdGhpcywgciA9IG4uY29uc3RydWN0b3I7XG4gIHJldHVybiBlID09PSB2b2lkIDAgPyAoZSA9IHIucHJlY2lzaW9uLCB0ID0gci5yb3VuZGluZykgOiAoZm4oZSwgMSwgbWkpLCB0ID09PSB2b2lkIDAgPyB0ID0gci5yb3VuZGluZyA6IGZuKHQsIDAsIDgpKSwgUmUobmV3IHIobiksIGUsIHQpO1xufTtcblEudG9TdHJpbmcgPSBRLnZhbHVlT2YgPSBRLnZhbCA9IFEudG9KU09OID0gUVtTeW1ib2wuZm9yKFwibm9kZWpzLnV0aWwuaW5zcGVjdC5jdXN0b21cIildID0gZnVuY3Rpb24oKSB7XG4gIHZhciBlID0gdGhpcywgdCA9IEhlKGUpLCBuID0gZS5jb25zdHJ1Y3RvcjtcbiAgcmV0dXJuIGZyKGUsIHQgPD0gbi50b0V4cE5lZyB8fCB0ID49IG4udG9FeHBQb3MpO1xufTtcbmZ1bmN0aW9uIE0wKGUsIHQpIHtcbiAgdmFyIG4sIHIsIGksIG8sIGEsIHMsIHUsIGMsIGYgPSBlLmNvbnN0cnVjdG9yLCBsID0gZi5wcmVjaXNpb247XG4gIGlmICghZS5zIHx8ICF0LnMpXG4gICAgcmV0dXJuIHQucyB8fCAodCA9IG5ldyBmKGUpKSwgQmUgPyBSZSh0LCBsKSA6IHQ7XG4gIGlmICh1ID0gZS5kLCBjID0gdC5kLCBhID0gZS5lLCBpID0gdC5lLCB1ID0gdS5zbGljZSgpLCBvID0gYSAtIGksIG8pIHtcbiAgICBmb3IgKG8gPCAwID8gKHIgPSB1LCBvID0gLW8sIHMgPSBjLmxlbmd0aCkgOiAociA9IGMsIGkgPSBhLCBzID0gdS5sZW5ndGgpLCBhID0gTWF0aC5jZWlsKGwgLyBOZSksIHMgPSBhID4gcyA/IGEgKyAxIDogcyArIDEsIG8gPiBzICYmIChvID0gcywgci5sZW5ndGggPSAxKSwgci5yZXZlcnNlKCk7IG8tLTsgKVxuICAgICAgci5wdXNoKDApO1xuICAgIHIucmV2ZXJzZSgpO1xuICB9XG4gIGZvciAocyA9IHUubGVuZ3RoLCBvID0gYy5sZW5ndGgsIHMgLSBvIDwgMCAmJiAobyA9IHMsIHIgPSBjLCBjID0gdSwgdSA9IHIpLCBuID0gMDsgbzsgKVxuICAgIG4gPSAodVstLW9dID0gdVtvXSArIGNbb10gKyBuKSAvIFFlIHwgMCwgdVtvXSAlPSBRZTtcbiAgZm9yIChuICYmICh1LnVuc2hpZnQobiksICsraSksIHMgPSB1Lmxlbmd0aDsgdVstLXNdID09IDA7IClcbiAgICB1LnBvcCgpO1xuICByZXR1cm4gdC5kID0gdSwgdC5lID0gaSwgQmUgPyBSZSh0LCBsKSA6IHQ7XG59XG5mdW5jdGlvbiBmbihlLCB0LCBuKSB7XG4gIGlmIChlICE9PSB+fmUgfHwgZSA8IHQgfHwgZSA+IG4pXG4gICAgdGhyb3cgRXJyb3IodXIgKyBlKTtcbn1cbmZ1bmN0aW9uIG9uKGUpIHtcbiAgdmFyIHQsIG4sIHIsIGkgPSBlLmxlbmd0aCAtIDEsIG8gPSBcIlwiLCBhID0gZVswXTtcbiAgaWYgKGkgPiAwKSB7XG4gICAgZm9yIChvICs9IGEsIHQgPSAxOyB0IDwgaTsgdCsrKVxuICAgICAgciA9IGVbdF0gKyBcIlwiLCBuID0gTmUgLSByLmxlbmd0aCwgbiAmJiAobyArPSBqbihuKSksIG8gKz0gcjtcbiAgICBhID0gZVt0XSwgciA9IGEgKyBcIlwiLCBuID0gTmUgLSByLmxlbmd0aCwgbiAmJiAobyArPSBqbihuKSk7XG4gIH0gZWxzZSBpZiAoYSA9PT0gMClcbiAgICByZXR1cm4gXCIwXCI7XG4gIGZvciAoOyBhICUgMTAgPT09IDA7IClcbiAgICBhIC89IDEwO1xuICByZXR1cm4gbyArIGE7XG59XG52YXIgYm4gPSAvKiBAX19QVVJFX18gKi8gZnVuY3Rpb24oKSB7XG4gIGZ1bmN0aW9uIGUociwgaSkge1xuICAgIHZhciBvLCBhID0gMCwgcyA9IHIubGVuZ3RoO1xuICAgIGZvciAociA9IHIuc2xpY2UoKTsgcy0tOyApXG4gICAgICBvID0gcltzXSAqIGkgKyBhLCByW3NdID0gbyAlIFFlIHwgMCwgYSA9IG8gLyBRZSB8IDA7XG4gICAgcmV0dXJuIGEgJiYgci51bnNoaWZ0KGEpLCByO1xuICB9XG4gIGZ1bmN0aW9uIHQociwgaSwgbywgYSkge1xuICAgIHZhciBzLCB1O1xuICAgIGlmIChvICE9IGEpXG4gICAgICB1ID0gbyA+IGEgPyAxIDogLTE7XG4gICAgZWxzZVxuICAgICAgZm9yIChzID0gdSA9IDA7IHMgPCBvOyBzKyspXG4gICAgICAgIGlmIChyW3NdICE9IGlbc10pIHtcbiAgICAgICAgICB1ID0gcltzXSA+IGlbc10gPyAxIDogLTE7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICByZXR1cm4gdTtcbiAgfVxuICBmdW5jdGlvbiBuKHIsIGksIG8pIHtcbiAgICBmb3IgKHZhciBhID0gMDsgby0tOyApXG4gICAgICByW29dIC09IGEsIGEgPSByW29dIDwgaVtvXSA/IDEgOiAwLCByW29dID0gYSAqIFFlICsgcltvXSAtIGlbb107XG4gICAgZm9yICg7ICFyWzBdICYmIHIubGVuZ3RoID4gMTsgKVxuICAgICAgci5zaGlmdCgpO1xuICB9XG4gIHJldHVybiBmdW5jdGlvbihyLCBpLCBvLCBhKSB7XG4gICAgdmFyIHMsIHUsIGMsIGYsIGwsIGQsIHAsIGcsIGgsIHYsIHcsIGIsIHgsIG0sIHksIFMsICQsIE8sIFQgPSByLmNvbnN0cnVjdG9yLCBNID0gci5zID09IGkucyA/IDEgOiAtMSwgRSA9IHIuZCwgQSA9IGkuZDtcbiAgICBpZiAoIXIucylcbiAgICAgIHJldHVybiBuZXcgVChyKTtcbiAgICBpZiAoIWkucylcbiAgICAgIHRocm93IEVycm9yKER0ICsgXCJEaXZpc2lvbiBieSB6ZXJvXCIpO1xuICAgIGZvciAodSA9IHIuZSAtIGkuZSwgJCA9IEEubGVuZ3RoLCB5ID0gRS5sZW5ndGgsIHAgPSBuZXcgVChNKSwgZyA9IHAuZCA9IFtdLCBjID0gMDsgQVtjXSA9PSAoRVtjXSB8fCAwKTsgKVxuICAgICAgKytjO1xuICAgIGlmIChBW2NdID4gKEVbY10gfHwgMCkgJiYgLS11LCBvID09IG51bGwgPyBiID0gbyA9IFQucHJlY2lzaW9uIDogYSA/IGIgPSBvICsgKEhlKHIpIC0gSGUoaSkpICsgMSA6IGIgPSBvLCBiIDwgMClcbiAgICAgIHJldHVybiBuZXcgVCgwKTtcbiAgICBpZiAoYiA9IGIgLyBOZSArIDIgfCAwLCBjID0gMCwgJCA9PSAxKVxuICAgICAgZm9yIChmID0gMCwgQSA9IEFbMF0sIGIrKzsgKGMgPCB5IHx8IGYpICYmIGItLTsgYysrKVxuICAgICAgICB4ID0gZiAqIFFlICsgKEVbY10gfHwgMCksIGdbY10gPSB4IC8gQSB8IDAsIGYgPSB4ICUgQSB8IDA7XG4gICAgZWxzZSB7XG4gICAgICBmb3IgKGYgPSBRZSAvIChBWzBdICsgMSkgfCAwLCBmID4gMSAmJiAoQSA9IGUoQSwgZiksIEUgPSBlKEUsIGYpLCAkID0gQS5sZW5ndGgsIHkgPSBFLmxlbmd0aCksIG0gPSAkLCBoID0gRS5zbGljZSgwLCAkKSwgdiA9IGgubGVuZ3RoOyB2IDwgJDsgKVxuICAgICAgICBoW3YrK10gPSAwO1xuICAgICAgTyA9IEEuc2xpY2UoKSwgTy51bnNoaWZ0KDApLCBTID0gQVswXSwgQVsxXSA+PSBRZSAvIDIgJiYgKytTO1xuICAgICAgZG9cbiAgICAgICAgZiA9IDAsIHMgPSB0KEEsIGgsICQsIHYpLCBzIDwgMCA/ICh3ID0gaFswXSwgJCAhPSB2ICYmICh3ID0gdyAqIFFlICsgKGhbMV0gfHwgMCkpLCBmID0gdyAvIFMgfCAwLCBmID4gMSA/IChmID49IFFlICYmIChmID0gUWUgLSAxKSwgbCA9IGUoQSwgZiksIGQgPSBsLmxlbmd0aCwgdiA9IGgubGVuZ3RoLCBzID0gdChsLCBoLCBkLCB2KSwgcyA9PSAxICYmIChmLS0sIG4obCwgJCA8IGQgPyBPIDogQSwgZCkpKSA6IChmID09IDAgJiYgKHMgPSBmID0gMSksIGwgPSBBLnNsaWNlKCkpLCBkID0gbC5sZW5ndGgsIGQgPCB2ICYmIGwudW5zaGlmdCgwKSwgbihoLCBsLCB2KSwgcyA9PSAtMSAmJiAodiA9IGgubGVuZ3RoLCBzID0gdChBLCBoLCAkLCB2KSwgcyA8IDEgJiYgKGYrKywgbihoLCAkIDwgdiA/IE8gOiBBLCB2KSkpLCB2ID0gaC5sZW5ndGgpIDogcyA9PT0gMCAmJiAoZisrLCBoID0gWzBdKSwgZ1tjKytdID0gZiwgcyAmJiBoWzBdID8gaFt2KytdID0gRVttXSB8fCAwIDogKGggPSBbRVttXV0sIHYgPSAxKTtcbiAgICAgIHdoaWxlICgobSsrIDwgeSB8fCBoWzBdICE9PSB2b2lkIDApICYmIGItLSk7XG4gICAgfVxuICAgIHJldHVybiBnWzBdIHx8IGcuc2hpZnQoKSwgcC5lID0gdSwgUmUocCwgYSA/IG8gKyBIZShwKSArIDEgOiBvKTtcbiAgfTtcbn0oKTtcbmZ1bmN0aW9uIFIwKGUsIHQpIHtcbiAgdmFyIG4sIHIsIGksIG8sIGEsIHMsIHUgPSAwLCBjID0gMCwgZiA9IGUuY29uc3RydWN0b3IsIGwgPSBmLnByZWNpc2lvbjtcbiAgaWYgKEhlKGUpID4gMTYpXG4gICAgdGhyb3cgRXJyb3IodWQgKyBIZShlKSk7XG4gIGlmICghZS5zKVxuICAgIHJldHVybiBuZXcgZihTdCk7XG4gIGZvciAodCA9PSBudWxsID8gKEJlID0gITEsIHMgPSBsKSA6IHMgPSB0LCBhID0gbmV3IGYoMC4wMzEyNSk7IGUuYWJzKCkuZ3RlKDAuMSk7IClcbiAgICBlID0gZS50aW1lcyhhKSwgYyArPSA1O1xuICBmb3IgKHIgPSBNYXRoLmxvZyh0cigyLCBjKSkgLyBNYXRoLkxOMTAgKiAyICsgNSB8IDAsIHMgKz0gciwgbiA9IGkgPSBvID0gbmV3IGYoU3QpLCBmLnByZWNpc2lvbiA9IHM7IDsgKSB7XG4gICAgaWYgKGkgPSBSZShpLnRpbWVzKGUpLCBzKSwgbiA9IG4udGltZXMoKyt1KSwgYSA9IG8ucGx1cyhibihpLCBuLCBzKSksIG9uKGEuZCkuc2xpY2UoMCwgcykgPT09IG9uKG8uZCkuc2xpY2UoMCwgcykpIHtcbiAgICAgIGZvciAoOyBjLS07IClcbiAgICAgICAgbyA9IFJlKG8udGltZXMobyksIHMpO1xuICAgICAgcmV0dXJuIGYucHJlY2lzaW9uID0gbCwgdCA9PSBudWxsID8gKEJlID0gITAsIFJlKG8sIGwpKSA6IG87XG4gICAgfVxuICAgIG8gPSBhO1xuICB9XG59XG5mdW5jdGlvbiBIZShlKSB7XG4gIGZvciAodmFyIHQgPSBlLmUgKiBOZSwgbiA9IGUuZFswXTsgbiA+PSAxMDsgbiAvPSAxMClcbiAgICB0Kys7XG4gIHJldHVybiB0O1xufVxuZnVuY3Rpb24gV3UoZSwgdCwgbikge1xuICBpZiAodCA+IGUuTE4xMC5zZCgpKVxuICAgIHRocm93IEJlID0gITAsIG4gJiYgKGUucHJlY2lzaW9uID0gbiksIEVycm9yKER0ICsgXCJMTjEwIHByZWNpc2lvbiBsaW1pdCBleGNlZWRlZFwiKTtcbiAgcmV0dXJuIFJlKG5ldyBlKGUuTE4xMCksIHQpO1xufVxuZnVuY3Rpb24gam4oZSkge1xuICBmb3IgKHZhciB0ID0gXCJcIjsgZS0tOyApXG4gICAgdCArPSBcIjBcIjtcbiAgcmV0dXJuIHQ7XG59XG5mdW5jdGlvbiBwbyhlLCB0KSB7XG4gIHZhciBuLCByLCBpLCBvLCBhLCBzLCB1LCBjLCBmLCBsID0gMSwgZCA9IDEwLCBwID0gZSwgZyA9IHAuZCwgaCA9IHAuY29uc3RydWN0b3IsIHYgPSBoLnByZWNpc2lvbjtcbiAgaWYgKHAucyA8IDEpXG4gICAgdGhyb3cgRXJyb3IoRHQgKyAocC5zID8gXCJOYU5cIiA6IFwiLUluZmluaXR5XCIpKTtcbiAgaWYgKHAuZXEoU3QpKVxuICAgIHJldHVybiBuZXcgaCgwKTtcbiAgaWYgKHQgPT0gbnVsbCA/IChCZSA9ICExLCBjID0gdikgOiBjID0gdCwgcC5lcSgxMCkpXG4gICAgcmV0dXJuIHQgPT0gbnVsbCAmJiAoQmUgPSAhMCksIFd1KGgsIGMpO1xuICBpZiAoYyArPSBkLCBoLnByZWNpc2lvbiA9IGMsIG4gPSBvbihnKSwgciA9IG4uY2hhckF0KDApLCBvID0gSGUocCksIE1hdGguYWJzKG8pIDwgMTVlMTQpIHtcbiAgICBmb3IgKDsgciA8IDcgJiYgciAhPSAxIHx8IHIgPT0gMSAmJiBuLmNoYXJBdCgxKSA+IDM7IClcbiAgICAgIHAgPSBwLnRpbWVzKGUpLCBuID0gb24ocC5kKSwgciA9IG4uY2hhckF0KDApLCBsKys7XG4gICAgbyA9IEhlKHApLCByID4gMSA/IChwID0gbmV3IGgoXCIwLlwiICsgbiksIG8rKykgOiBwID0gbmV3IGgociArIFwiLlwiICsgbi5zbGljZSgxKSk7XG4gIH0gZWxzZVxuICAgIHJldHVybiB1ID0gV3UoaCwgYyArIDIsIHYpLnRpbWVzKG8gKyBcIlwiKSwgcCA9IHBvKG5ldyBoKHIgKyBcIi5cIiArIG4uc2xpY2UoMSkpLCBjIC0gZCkucGx1cyh1KSwgaC5wcmVjaXNpb24gPSB2LCB0ID09IG51bGwgPyAoQmUgPSAhMCwgUmUocCwgdikpIDogcDtcbiAgZm9yIChzID0gYSA9IHAgPSBibihwLm1pbnVzKFN0KSwgcC5wbHVzKFN0KSwgYyksIGYgPSBSZShwLnRpbWVzKHApLCBjKSwgaSA9IDM7IDsgKSB7XG4gICAgaWYgKGEgPSBSZShhLnRpbWVzKGYpLCBjKSwgdSA9IHMucGx1cyhibihhLCBuZXcgaChpKSwgYykpLCBvbih1LmQpLnNsaWNlKDAsIGMpID09PSBvbihzLmQpLnNsaWNlKDAsIGMpKVxuICAgICAgcmV0dXJuIHMgPSBzLnRpbWVzKDIpLCBvICE9PSAwICYmIChzID0gcy5wbHVzKFd1KGgsIGMgKyAyLCB2KS50aW1lcyhvICsgXCJcIikpKSwgcyA9IGJuKHMsIG5ldyBoKGwpLCBjKSwgaC5wcmVjaXNpb24gPSB2LCB0ID09IG51bGwgPyAoQmUgPSAhMCwgUmUocywgdikpIDogcztcbiAgICBzID0gdSwgaSArPSAyO1xuICB9XG59XG5mdW5jdGlvbiBtZyhlLCB0KSB7XG4gIHZhciBuLCByLCBpO1xuICBmb3IgKChuID0gdC5pbmRleE9mKFwiLlwiKSkgPiAtMSAmJiAodCA9IHQucmVwbGFjZShcIi5cIiwgXCJcIikpLCAociA9IHQuc2VhcmNoKC9lL2kpKSA+IDAgPyAobiA8IDAgJiYgKG4gPSByKSwgbiArPSArdC5zbGljZShyICsgMSksIHQgPSB0LnN1YnN0cmluZygwLCByKSkgOiBuIDwgMCAmJiAobiA9IHQubGVuZ3RoKSwgciA9IDA7IHQuY2hhckNvZGVBdChyKSA9PT0gNDg7IClcbiAgICArK3I7XG4gIGZvciAoaSA9IHQubGVuZ3RoOyB0LmNoYXJDb2RlQXQoaSAtIDEpID09PSA0ODsgKVxuICAgIC0taTtcbiAgaWYgKHQgPSB0LnNsaWNlKHIsIGkpLCB0KSB7XG4gICAgaWYgKGkgLT0gciwgbiA9IG4gLSByIC0gMSwgZS5lID0geWkobiAvIE5lKSwgZS5kID0gW10sIHIgPSAobiArIDEpICUgTmUsIG4gPCAwICYmIChyICs9IE5lKSwgciA8IGkpIHtcbiAgICAgIGZvciAociAmJiBlLmQucHVzaCgrdC5zbGljZSgwLCByKSksIGkgLT0gTmU7IHIgPCBpOyApXG4gICAgICAgIGUuZC5wdXNoKCt0LnNsaWNlKHIsIHIgKz0gTmUpKTtcbiAgICAgIHQgPSB0LnNsaWNlKHIpLCByID0gTmUgLSB0Lmxlbmd0aDtcbiAgICB9IGVsc2VcbiAgICAgIHIgLT0gaTtcbiAgICBmb3IgKDsgci0tOyApXG4gICAgICB0ICs9IFwiMFwiO1xuICAgIGlmIChlLmQucHVzaCgrdCksIEJlICYmIChlLmUgPiBjcyB8fCBlLmUgPCAtY3MpKVxuICAgICAgdGhyb3cgRXJyb3IodWQgKyBuKTtcbiAgfSBlbHNlXG4gICAgZS5zID0gMCwgZS5lID0gMCwgZS5kID0gWzBdO1xuICByZXR1cm4gZTtcbn1cbmZ1bmN0aW9uIFJlKGUsIHQsIG4pIHtcbiAgdmFyIHIsIGksIG8sIGEsIHMsIHUsIGMsIGYsIGwgPSBlLmQ7XG4gIGZvciAoYSA9IDEsIG8gPSBsWzBdOyBvID49IDEwOyBvIC89IDEwKVxuICAgIGErKztcbiAgaWYgKHIgPSB0IC0gYSwgciA8IDApXG4gICAgciArPSBOZSwgaSA9IHQsIGMgPSBsW2YgPSAwXTtcbiAgZWxzZSB7XG4gICAgaWYgKGYgPSBNYXRoLmNlaWwoKHIgKyAxKSAvIE5lKSwgbyA9IGwubGVuZ3RoLCBmID49IG8pXG4gICAgICByZXR1cm4gZTtcbiAgICBmb3IgKGMgPSBvID0gbFtmXSwgYSA9IDE7IG8gPj0gMTA7IG8gLz0gMTApXG4gICAgICBhKys7XG4gICAgciAlPSBOZSwgaSA9IHIgLSBOZSArIGE7XG4gIH1cbiAgaWYgKG4gIT09IHZvaWQgMCAmJiAobyA9IHRyKDEwLCBhIC0gaSAtIDEpLCBzID0gYyAvIG8gJSAxMCB8IDAsIHUgPSB0IDwgMCB8fCBsW2YgKyAxXSAhPT0gdm9pZCAwIHx8IGMgJSBvLCB1ID0gbiA8IDQgPyAocyB8fCB1KSAmJiAobiA9PSAwIHx8IG4gPT0gKGUucyA8IDAgPyAzIDogMikpIDogcyA+IDUgfHwgcyA9PSA1ICYmIChuID09IDQgfHwgdSB8fCBuID09IDYgJiYgLy8gQ2hlY2sgd2hldGhlciB0aGUgZGlnaXQgdG8gdGhlIGxlZnQgb2YgdGhlIHJvdW5kaW5nIGRpZ2l0IGlzIG9kZC5cbiAgKHIgPiAwID8gaSA+IDAgPyBjIC8gdHIoMTAsIGEgLSBpKSA6IDAgOiBsW2YgLSAxXSkgJSAxMCAmIDEgfHwgbiA9PSAoZS5zIDwgMCA/IDggOiA3KSkpLCB0IDwgMSB8fCAhbFswXSlcbiAgICByZXR1cm4gdSA/IChvID0gSGUoZSksIGwubGVuZ3RoID0gMSwgdCA9IHQgLSBvIC0gMSwgbFswXSA9IHRyKDEwLCAoTmUgLSB0ICUgTmUpICUgTmUpLCBlLmUgPSB5aSgtdCAvIE5lKSB8fCAwKSA6IChsLmxlbmd0aCA9IDEsIGxbMF0gPSBlLmUgPSBlLnMgPSAwKSwgZTtcbiAgaWYgKHIgPT0gMCA/IChsLmxlbmd0aCA9IGYsIG8gPSAxLCBmLS0pIDogKGwubGVuZ3RoID0gZiArIDEsIG8gPSB0cigxMCwgTmUgLSByKSwgbFtmXSA9IGkgPiAwID8gKGMgLyB0cigxMCwgYSAtIGkpICUgdHIoMTAsIGkpIHwgMCkgKiBvIDogMCksIHUpXG4gICAgZm9yICg7IDsgKVxuICAgICAgaWYgKGYgPT0gMCkge1xuICAgICAgICAobFswXSArPSBvKSA9PSBRZSAmJiAobFswXSA9IDEsICsrZS5lKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAobFtmXSArPSBvLCBsW2ZdICE9IFFlKVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBsW2YtLV0gPSAwLCBvID0gMTtcbiAgICAgIH1cbiAgZm9yIChyID0gbC5sZW5ndGg7IGxbLS1yXSA9PT0gMDsgKVxuICAgIGwucG9wKCk7XG4gIGlmIChCZSAmJiAoZS5lID4gY3MgfHwgZS5lIDwgLWNzKSlcbiAgICB0aHJvdyBFcnJvcih1ZCArIEhlKGUpKTtcbiAgcmV0dXJuIGU7XG59XG5mdW5jdGlvbiBJMChlLCB0KSB7XG4gIHZhciBuLCByLCBpLCBvLCBhLCBzLCB1LCBjLCBmLCBsLCBkID0gZS5jb25zdHJ1Y3RvciwgcCA9IGQucHJlY2lzaW9uO1xuICBpZiAoIWUucyB8fCAhdC5zKVxuICAgIHJldHVybiB0LnMgPyB0LnMgPSAtdC5zIDogdCA9IG5ldyBkKGUpLCBCZSA/IFJlKHQsIHApIDogdDtcbiAgaWYgKHUgPSBlLmQsIGwgPSB0LmQsIHIgPSB0LmUsIGMgPSBlLmUsIHUgPSB1LnNsaWNlKCksIGEgPSBjIC0gciwgYSkge1xuICAgIGZvciAoZiA9IGEgPCAwLCBmID8gKG4gPSB1LCBhID0gLWEsIHMgPSBsLmxlbmd0aCkgOiAobiA9IGwsIHIgPSBjLCBzID0gdS5sZW5ndGgpLCBpID0gTWF0aC5tYXgoTWF0aC5jZWlsKHAgLyBOZSksIHMpICsgMiwgYSA+IGkgJiYgKGEgPSBpLCBuLmxlbmd0aCA9IDEpLCBuLnJldmVyc2UoKSwgaSA9IGE7IGktLTsgKVxuICAgICAgbi5wdXNoKDApO1xuICAgIG4ucmV2ZXJzZSgpO1xuICB9IGVsc2Uge1xuICAgIGZvciAoaSA9IHUubGVuZ3RoLCBzID0gbC5sZW5ndGgsIGYgPSBpIDwgcywgZiAmJiAocyA9IGkpLCBpID0gMDsgaSA8IHM7IGkrKylcbiAgICAgIGlmICh1W2ldICE9IGxbaV0pIHtcbiAgICAgICAgZiA9IHVbaV0gPCBsW2ldO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICBhID0gMDtcbiAgfVxuICBmb3IgKGYgJiYgKG4gPSB1LCB1ID0gbCwgbCA9IG4sIHQucyA9IC10LnMpLCBzID0gdS5sZW5ndGgsIGkgPSBsLmxlbmd0aCAtIHM7IGkgPiAwOyAtLWkpXG4gICAgdVtzKytdID0gMDtcbiAgZm9yIChpID0gbC5sZW5ndGg7IGkgPiBhOyApIHtcbiAgICBpZiAodVstLWldIDwgbFtpXSkge1xuICAgICAgZm9yIChvID0gaTsgbyAmJiB1Wy0tb10gPT09IDA7IClcbiAgICAgICAgdVtvXSA9IFFlIC0gMTtcbiAgICAgIC0tdVtvXSwgdVtpXSArPSBRZTtcbiAgICB9XG4gICAgdVtpXSAtPSBsW2ldO1xuICB9XG4gIGZvciAoOyB1Wy0tc10gPT09IDA7IClcbiAgICB1LnBvcCgpO1xuICBmb3IgKDsgdVswXSA9PT0gMDsgdS5zaGlmdCgpKVxuICAgIC0tcjtcbiAgcmV0dXJuIHVbMF0gPyAodC5kID0gdSwgdC5lID0gciwgQmUgPyBSZSh0LCBwKSA6IHQpIDogbmV3IGQoMCk7XG59XG5mdW5jdGlvbiBmcihlLCB0LCBuKSB7XG4gIHZhciByLCBpID0gSGUoZSksIG8gPSBvbihlLmQpLCBhID0gby5sZW5ndGg7XG4gIHJldHVybiB0ID8gKG4gJiYgKHIgPSBuIC0gYSkgPiAwID8gbyA9IG8uY2hhckF0KDApICsgXCIuXCIgKyBvLnNsaWNlKDEpICsgam4ocikgOiBhID4gMSAmJiAobyA9IG8uY2hhckF0KDApICsgXCIuXCIgKyBvLnNsaWNlKDEpKSwgbyA9IG8gKyAoaSA8IDAgPyBcImVcIiA6IFwiZStcIikgKyBpKSA6IGkgPCAwID8gKG8gPSBcIjAuXCIgKyBqbigtaSAtIDEpICsgbywgbiAmJiAociA9IG4gLSBhKSA+IDAgJiYgKG8gKz0gam4ocikpKSA6IGkgPj0gYSA/IChvICs9IGpuKGkgKyAxIC0gYSksIG4gJiYgKHIgPSBuIC0gaSAtIDEpID4gMCAmJiAobyA9IG8gKyBcIi5cIiArIGpuKHIpKSkgOiAoKHIgPSBpICsgMSkgPCBhICYmIChvID0gby5zbGljZSgwLCByKSArIFwiLlwiICsgby5zbGljZShyKSksIG4gJiYgKHIgPSBuIC0gYSkgPiAwICYmIChpICsgMSA9PT0gYSAmJiAobyArPSBcIi5cIiksIG8gKz0gam4ocikpKSwgZS5zIDwgMCA/IFwiLVwiICsgbyA6IG87XG59XG5mdW5jdGlvbiB5ZyhlLCB0KSB7XG4gIGlmIChlLmxlbmd0aCA+IHQpXG4gICAgcmV0dXJuIGUubGVuZ3RoID0gdCwgITA7XG59XG5mdW5jdGlvbiBqMChlKSB7XG4gIHZhciB0LCBuLCByO1xuICBmdW5jdGlvbiBpKG8pIHtcbiAgICB2YXIgYSA9IHRoaXM7XG4gICAgaWYgKCEoYSBpbnN0YW5jZW9mIGkpKVxuICAgICAgcmV0dXJuIG5ldyBpKG8pO1xuICAgIGlmIChhLmNvbnN0cnVjdG9yID0gaSwgbyBpbnN0YW5jZW9mIGkpIHtcbiAgICAgIGEucyA9IG8ucywgYS5lID0gby5lLCBhLmQgPSAobyA9IG8uZCkgPyBvLnNsaWNlKCkgOiBvO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG8gPT0gXCJudW1iZXJcIikge1xuICAgICAgaWYgKG8gKiAwICE9PSAwKVxuICAgICAgICB0aHJvdyBFcnJvcih1ciArIG8pO1xuICAgICAgaWYgKG8gPiAwKVxuICAgICAgICBhLnMgPSAxO1xuICAgICAgZWxzZSBpZiAobyA8IDApXG4gICAgICAgIG8gPSAtbywgYS5zID0gLTE7XG4gICAgICBlbHNlIHtcbiAgICAgICAgYS5zID0gMCwgYS5lID0gMCwgYS5kID0gWzBdO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAobyA9PT0gfn5vICYmIG8gPCAxZTcpIHtcbiAgICAgICAgYS5lID0gMCwgYS5kID0gW29dO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICByZXR1cm4gbWcoYSwgby50b1N0cmluZygpKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBvICE9IFwic3RyaW5nXCIpXG4gICAgICB0aHJvdyBFcnJvcih1ciArIG8pO1xuICAgIGlmIChvLmNoYXJDb2RlQXQoMCkgPT09IDQ1ID8gKG8gPSBvLnNsaWNlKDEpLCBhLnMgPSAtMSkgOiBhLnMgPSAxLCBKQi50ZXN0KG8pKVxuICAgICAgbWcoYSwgbyk7XG4gICAgZWxzZVxuICAgICAgdGhyb3cgRXJyb3IodXIgKyBvKTtcbiAgfVxuICBpZiAoaS5wcm90b3R5cGUgPSBRLCBpLlJPVU5EX1VQID0gMCwgaS5ST1VORF9ET1dOID0gMSwgaS5ST1VORF9DRUlMID0gMiwgaS5ST1VORF9GTE9PUiA9IDMsIGkuUk9VTkRfSEFMRl9VUCA9IDQsIGkuUk9VTkRfSEFMRl9ET1dOID0gNSwgaS5ST1VORF9IQUxGX0VWRU4gPSA2LCBpLlJPVU5EX0hBTEZfQ0VJTCA9IDcsIGkuUk9VTkRfSEFMRl9GTE9PUiA9IDgsIGkuY2xvbmUgPSBqMCwgaS5jb25maWcgPSBpLnNldCA9IFFCLCBlID09PSB2b2lkIDAgJiYgKGUgPSB7fSksIGUpXG4gICAgZm9yIChyID0gW1wicHJlY2lzaW9uXCIsIFwicm91bmRpbmdcIiwgXCJ0b0V4cE5lZ1wiLCBcInRvRXhwUG9zXCIsIFwiTE4xMFwiXSwgdCA9IDA7IHQgPCByLmxlbmd0aDsgKVxuICAgICAgZS5oYXNPd25Qcm9wZXJ0eShuID0gclt0KytdKSB8fCAoZVtuXSA9IHRoaXNbbl0pO1xuICByZXR1cm4gaS5jb25maWcoZSksIGk7XG59XG5mdW5jdGlvbiBRQihlKSB7XG4gIGlmICghZSB8fCB0eXBlb2YgZSAhPSBcIm9iamVjdFwiKVxuICAgIHRocm93IEVycm9yKER0ICsgXCJPYmplY3QgZXhwZWN0ZWRcIik7XG4gIHZhciB0LCBuLCByLCBpID0gW1xuICAgIFwicHJlY2lzaW9uXCIsXG4gICAgMSxcbiAgICBtaSxcbiAgICBcInJvdW5kaW5nXCIsXG4gICAgMCxcbiAgICA4LFxuICAgIFwidG9FeHBOZWdcIixcbiAgICAtMSAvIDAsXG4gICAgMCxcbiAgICBcInRvRXhwUG9zXCIsXG4gICAgMCxcbiAgICAxIC8gMFxuICBdO1xuICBmb3IgKHQgPSAwOyB0IDwgaS5sZW5ndGg7IHQgKz0gMylcbiAgICBpZiAoKHIgPSBlW24gPSBpW3RdXSkgIT09IHZvaWQgMClcbiAgICAgIGlmICh5aShyKSA9PT0gciAmJiByID49IGlbdCArIDFdICYmIHIgPD0gaVt0ICsgMl0pXG4gICAgICAgIHRoaXNbbl0gPSByO1xuICAgICAgZWxzZVxuICAgICAgICB0aHJvdyBFcnJvcih1ciArIG4gKyBcIjogXCIgKyByKTtcbiAgaWYgKChyID0gZVtuID0gXCJMTjEwXCJdKSAhPT0gdm9pZCAwKVxuICAgIGlmIChyID09IE1hdGguTE4xMClcbiAgICAgIHRoaXNbbl0gPSBuZXcgdGhpcyhyKTtcbiAgICBlbHNlXG4gICAgICB0aHJvdyBFcnJvcih1ciArIG4gKyBcIjogXCIgKyByKTtcbiAgcmV0dXJuIHRoaXM7XG59XG52YXIgY2QgPSBqMChaQik7XG5TdCA9IG5ldyBjZCgxKTtcbmNvbnN0IFRlID0gY2Q7XG5mdW5jdGlvbiBlNihlKSB7XG4gIHJldHVybiBpNihlKSB8fCByNihlKSB8fCBuNihlKSB8fCB0NigpO1xufVxuZnVuY3Rpb24gdDYoKSB7XG4gIHRocm93IG5ldyBUeXBlRXJyb3IoYEludmFsaWQgYXR0ZW1wdCB0byBzcHJlYWQgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLmApO1xufVxuZnVuY3Rpb24gbjYoZSwgdCkge1xuICBpZiAoZSkge1xuICAgIGlmICh0eXBlb2YgZSA9PSBcInN0cmluZ1wiKVxuICAgICAgcmV0dXJuIHVsKGUsIHQpO1xuICAgIHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGUpLnNsaWNlKDgsIC0xKTtcbiAgICBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBlLmNvbnN0cnVjdG9yICYmIChuID0gZS5jb25zdHJ1Y3Rvci5uYW1lKSwgbiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKVxuICAgICAgcmV0dXJuIEFycmF5LmZyb20oZSk7XG4gICAgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpXG4gICAgICByZXR1cm4gdWwoZSwgdCk7XG4gIH1cbn1cbmZ1bmN0aW9uIHI2KGUpIHtcbiAgaWYgKHR5cGVvZiBTeW1ib2wgPCBcInVcIiAmJiBTeW1ib2wuaXRlcmF0b3IgaW4gT2JqZWN0KGUpKVxuICAgIHJldHVybiBBcnJheS5mcm9tKGUpO1xufVxuZnVuY3Rpb24gaTYoZSkge1xuICBpZiAoQXJyYXkuaXNBcnJheShlKSlcbiAgICByZXR1cm4gdWwoZSk7XG59XG5mdW5jdGlvbiB1bChlLCB0KSB7XG4gICh0ID09IG51bGwgfHwgdCA+IGUubGVuZ3RoKSAmJiAodCA9IGUubGVuZ3RoKTtcbiAgZm9yICh2YXIgbiA9IDAsIHIgPSBuZXcgQXJyYXkodCk7IG4gPCB0OyBuKyspXG4gICAgcltuXSA9IGVbbl07XG4gIHJldHVybiByO1xufVxudmFyIG82ID0gZnVuY3Rpb24odCkge1xuICByZXR1cm4gdDtcbn0sIGswID0ge1xuICBcIkBAZnVuY3Rpb25hbC9wbGFjZWhvbGRlclwiOiAhMFxufSwgRDAgPSBmdW5jdGlvbih0KSB7XG4gIHJldHVybiB0ID09PSBrMDtcbn0sIGJnID0gZnVuY3Rpb24odCkge1xuICByZXR1cm4gZnVuY3Rpb24gbigpIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA9PT0gMCB8fCBhcmd1bWVudHMubGVuZ3RoID09PSAxICYmIEQwKGFyZ3VtZW50cy5sZW5ndGggPD0gMCA/IHZvaWQgMCA6IGFyZ3VtZW50c1swXSkgPyBuIDogdC5hcHBseSh2b2lkIDAsIGFyZ3VtZW50cyk7XG4gIH07XG59LCBhNiA9IGZ1bmN0aW9uIGUodCwgbikge1xuICByZXR1cm4gdCA9PT0gMSA/IG4gOiBiZyhmdW5jdGlvbigpIHtcbiAgICBmb3IgKHZhciByID0gYXJndW1lbnRzLmxlbmd0aCwgaSA9IG5ldyBBcnJheShyKSwgbyA9IDA7IG8gPCByOyBvKyspXG4gICAgICBpW29dID0gYXJndW1lbnRzW29dO1xuICAgIHZhciBhID0gaS5maWx0ZXIoZnVuY3Rpb24ocykge1xuICAgICAgcmV0dXJuIHMgIT09IGswO1xuICAgIH0pLmxlbmd0aDtcbiAgICByZXR1cm4gYSA+PSB0ID8gbi5hcHBseSh2b2lkIDAsIGkpIDogZSh0IC0gYSwgYmcoZnVuY3Rpb24oKSB7XG4gICAgICBmb3IgKHZhciBzID0gYXJndW1lbnRzLmxlbmd0aCwgdSA9IG5ldyBBcnJheShzKSwgYyA9IDA7IGMgPCBzOyBjKyspXG4gICAgICAgIHVbY10gPSBhcmd1bWVudHNbY107XG4gICAgICB2YXIgZiA9IGkubWFwKGZ1bmN0aW9uKGwpIHtcbiAgICAgICAgcmV0dXJuIEQwKGwpID8gdS5zaGlmdCgpIDogbDtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIG4uYXBwbHkodm9pZCAwLCBlNihmKS5jb25jYXQodSkpO1xuICAgIH0pKTtcbiAgfSk7XG59LCBudSA9IGZ1bmN0aW9uKHQpIHtcbiAgcmV0dXJuIGE2KHQubGVuZ3RoLCB0KTtcbn0sIGNsID0gZnVuY3Rpb24odCwgbikge1xuICBmb3IgKHZhciByID0gW10sIGkgPSB0OyBpIDwgbjsgKytpKVxuICAgIHJbaSAtIHRdID0gaTtcbiAgcmV0dXJuIHI7XG59LCBzNiA9IG51KGZ1bmN0aW9uKGUsIHQpIHtcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkodCkgPyB0Lm1hcChlKSA6IE9iamVjdC5rZXlzKHQpLm1hcChmdW5jdGlvbihuKSB7XG4gICAgcmV0dXJuIHRbbl07XG4gIH0pLm1hcChlKTtcbn0pLCB1NiA9IGZ1bmN0aW9uKCkge1xuICBmb3IgKHZhciB0ID0gYXJndW1lbnRzLmxlbmd0aCwgbiA9IG5ldyBBcnJheSh0KSwgciA9IDA7IHIgPCB0OyByKyspXG4gICAgbltyXSA9IGFyZ3VtZW50c1tyXTtcbiAgaWYgKCFuLmxlbmd0aClcbiAgICByZXR1cm4gbzY7XG4gIHZhciBpID0gbi5yZXZlcnNlKCksIG8gPSBpWzBdLCBhID0gaS5zbGljZSgxKTtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBhLnJlZHVjZShmdW5jdGlvbihzLCB1KSB7XG4gICAgICByZXR1cm4gdShzKTtcbiAgICB9LCBvLmFwcGx5KHZvaWQgMCwgYXJndW1lbnRzKSk7XG4gIH07XG59LCBsbCA9IGZ1bmN0aW9uKHQpIHtcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkodCkgPyB0LnJldmVyc2UoKSA6IHQuc3BsaXQoXCJcIikucmV2ZXJzZS5qb2luKFwiXCIpO1xufSwgTjAgPSBmdW5jdGlvbih0KSB7XG4gIHZhciBuID0gbnVsbCwgciA9IG51bGw7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICBmb3IgKHZhciBpID0gYXJndW1lbnRzLmxlbmd0aCwgbyA9IG5ldyBBcnJheShpKSwgYSA9IDA7IGEgPCBpOyBhKyspXG4gICAgICBvW2FdID0gYXJndW1lbnRzW2FdO1xuICAgIHJldHVybiBuICYmIG8uZXZlcnkoZnVuY3Rpb24ocywgdSkge1xuICAgICAgcmV0dXJuIHMgPT09IG5bdV07XG4gICAgfSkgfHwgKG4gPSBvLCByID0gdC5hcHBseSh2b2lkIDAsIG8pKSwgcjtcbiAgfTtcbn07XG5mdW5jdGlvbiBjNihlKSB7XG4gIHZhciB0O1xuICByZXR1cm4gZSA9PT0gMCA/IHQgPSAxIDogdCA9IE1hdGguZmxvb3IobmV3IFRlKGUpLmFicygpLmxvZygxMCkudG9OdW1iZXIoKSkgKyAxLCB0O1xufVxuZnVuY3Rpb24gbDYoZSwgdCwgbikge1xuICBmb3IgKHZhciByID0gbmV3IFRlKGUpLCBpID0gMCwgbyA9IFtdOyByLmx0KHQpICYmIGkgPCAxZTU7IClcbiAgICBvLnB1c2goci50b051bWJlcigpKSwgciA9IHIuYWRkKG4pLCBpKys7XG4gIHJldHVybiBvO1xufVxudmFyIGY2ID0gbnUoZnVuY3Rpb24oZSwgdCwgbikge1xuICB2YXIgciA9ICtlLCBpID0gK3Q7XG4gIHJldHVybiByICsgbiAqIChpIC0gcik7XG59KSwgZDYgPSBudShmdW5jdGlvbihlLCB0LCBuKSB7XG4gIHZhciByID0gdCAtICtlO1xuICByZXR1cm4gciA9IHIgfHwgMSAvIDAsIChuIC0gZSkgLyByO1xufSksIHA2ID0gbnUoZnVuY3Rpb24oZSwgdCwgbikge1xuICB2YXIgciA9IHQgLSArZTtcbiAgcmV0dXJuIHIgPSByIHx8IDEgLyAwLCBNYXRoLm1heCgwLCBNYXRoLm1pbigxLCAobiAtIGUpIC8gcikpO1xufSk7XG5jb25zdCBydSA9IHtcbiAgcmFuZ2VTdGVwOiBsNixcbiAgZ2V0RGlnaXRDb3VudDogYzYsXG4gIGludGVycG9sYXRlTnVtYmVyOiBmNixcbiAgdW5pbnRlcnBvbGF0ZU51bWJlcjogZDYsXG4gIHVuaW50ZXJwb2xhdGVUcnVuY2F0aW9uOiBwNlxufTtcbmZ1bmN0aW9uIGZsKGUpIHtcbiAgcmV0dXJuIHY2KGUpIHx8IGc2KGUpIHx8IEYwKGUpIHx8IGg2KCk7XG59XG5mdW5jdGlvbiBoNigpIHtcbiAgdGhyb3cgbmV3IFR5cGVFcnJvcihgSW52YWxpZCBhdHRlbXB0IHRvIHNwcmVhZCBub24taXRlcmFibGUgaW5zdGFuY2UuXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuYCk7XG59XG5mdW5jdGlvbiBnNihlKSB7XG4gIGlmICh0eXBlb2YgU3ltYm9sIDwgXCJ1XCIgJiYgU3ltYm9sLml0ZXJhdG9yIGluIE9iamVjdChlKSlcbiAgICByZXR1cm4gQXJyYXkuZnJvbShlKTtcbn1cbmZ1bmN0aW9uIHY2KGUpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoZSkpXG4gICAgcmV0dXJuIGRsKGUpO1xufVxuZnVuY3Rpb24gaG8oZSwgdCkge1xuICByZXR1cm4gYjYoZSkgfHwgeTYoZSwgdCkgfHwgRjAoZSwgdCkgfHwgbTYoKTtcbn1cbmZ1bmN0aW9uIG02KCkge1xuICB0aHJvdyBuZXcgVHlwZUVycm9yKGBJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLmApO1xufVxuZnVuY3Rpb24gRjAoZSwgdCkge1xuICBpZiAoZSkge1xuICAgIGlmICh0eXBlb2YgZSA9PSBcInN0cmluZ1wiKVxuICAgICAgcmV0dXJuIGRsKGUsIHQpO1xuICAgIHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGUpLnNsaWNlKDgsIC0xKTtcbiAgICBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBlLmNvbnN0cnVjdG9yICYmIChuID0gZS5jb25zdHJ1Y3Rvci5uYW1lKSwgbiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKVxuICAgICAgcmV0dXJuIEFycmF5LmZyb20oZSk7XG4gICAgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpXG4gICAgICByZXR1cm4gZGwoZSwgdCk7XG4gIH1cbn1cbmZ1bmN0aW9uIGRsKGUsIHQpIHtcbiAgKHQgPT0gbnVsbCB8fCB0ID4gZS5sZW5ndGgpICYmICh0ID0gZS5sZW5ndGgpO1xuICBmb3IgKHZhciBuID0gMCwgciA9IG5ldyBBcnJheSh0KTsgbiA8IHQ7IG4rKylcbiAgICByW25dID0gZVtuXTtcbiAgcmV0dXJuIHI7XG59XG5mdW5jdGlvbiB5NihlLCB0KSB7XG4gIGlmICghKHR5cGVvZiBTeW1ib2wgPiBcInVcIiB8fCAhKFN5bWJvbC5pdGVyYXRvciBpbiBPYmplY3QoZSkpKSkge1xuICAgIHZhciBuID0gW10sIHIgPSAhMCwgaSA9ICExLCBvID0gdm9pZCAwO1xuICAgIHRyeSB7XG4gICAgICBmb3IgKHZhciBhID0gZVtTeW1ib2wuaXRlcmF0b3JdKCksIHM7ICEociA9IChzID0gYS5uZXh0KCkpLmRvbmUpICYmIChuLnB1c2gocy52YWx1ZSksICEodCAmJiBuLmxlbmd0aCA9PT0gdCkpOyByID0gITApXG4gICAgICAgIDtcbiAgICB9IGNhdGNoICh1KSB7XG4gICAgICBpID0gITAsIG8gPSB1O1xuICAgIH0gZmluYWxseSB7XG4gICAgICB0cnkge1xuICAgICAgICAhciAmJiBhLnJldHVybiAhPSBudWxsICYmIGEucmV0dXJuKCk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBpZiAoaSlcbiAgICAgICAgICB0aHJvdyBvO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbjtcbiAgfVxufVxuZnVuY3Rpb24gYjYoZSkge1xuICBpZiAoQXJyYXkuaXNBcnJheShlKSlcbiAgICByZXR1cm4gZTtcbn1cbmZ1bmN0aW9uIEwwKGUpIHtcbiAgdmFyIHQgPSBobyhlLCAyKSwgbiA9IHRbMF0sIHIgPSB0WzFdLCBpID0gbiwgbyA9IHI7XG4gIHJldHVybiBuID4gciAmJiAoaSA9IHIsIG8gPSBuKSwgW2ksIG9dO1xufVxuZnVuY3Rpb24gQjAoZSwgdCwgbikge1xuICBpZiAoZS5sdGUoMCkpXG4gICAgcmV0dXJuIG5ldyBUZSgwKTtcbiAgdmFyIHIgPSBydS5nZXREaWdpdENvdW50KGUudG9OdW1iZXIoKSksIGkgPSBuZXcgVGUoMTApLnBvdyhyKSwgbyA9IGUuZGl2KGkpLCBhID0gciAhPT0gMSA/IDAuMDUgOiAwLjEsIHMgPSBuZXcgVGUoTWF0aC5jZWlsKG8uZGl2KGEpLnRvTnVtYmVyKCkpKS5hZGQobikubXVsKGEpLCB1ID0gcy5tdWwoaSk7XG4gIHJldHVybiB0ID8gdSA6IG5ldyBUZShNYXRoLmNlaWwodSkpO1xufVxuZnVuY3Rpb24gdzYoZSwgdCwgbikge1xuICB2YXIgciA9IDEsIGkgPSBuZXcgVGUoZSk7XG4gIGlmICghaS5pc2ludCgpICYmIG4pIHtcbiAgICB2YXIgbyA9IE1hdGguYWJzKGUpO1xuICAgIG8gPCAxID8gKHIgPSBuZXcgVGUoMTApLnBvdyhydS5nZXREaWdpdENvdW50KGUpIC0gMSksIGkgPSBuZXcgVGUoTWF0aC5mbG9vcihpLmRpdihyKS50b051bWJlcigpKSkubXVsKHIpKSA6IG8gPiAxICYmIChpID0gbmV3IFRlKE1hdGguZmxvb3IoZSkpKTtcbiAgfSBlbHNlXG4gICAgZSA9PT0gMCA/IGkgPSBuZXcgVGUoTWF0aC5mbG9vcigodCAtIDEpIC8gMikpIDogbiB8fCAoaSA9IG5ldyBUZShNYXRoLmZsb29yKGUpKSk7XG4gIHZhciBhID0gTWF0aC5mbG9vcigodCAtIDEpIC8gMiksIHMgPSB1NihzNihmdW5jdGlvbih1KSB7XG4gICAgcmV0dXJuIGkuYWRkKG5ldyBUZSh1IC0gYSkubXVsKHIpKS50b051bWJlcigpO1xuICB9KSwgY2wpO1xuICByZXR1cm4gcygwLCB0KTtcbn1cbmZ1bmN0aW9uIHowKGUsIHQsIG4sIHIpIHtcbiAgdmFyIGkgPSBhcmd1bWVudHMubGVuZ3RoID4gNCAmJiBhcmd1bWVudHNbNF0gIT09IHZvaWQgMCA/IGFyZ3VtZW50c1s0XSA6IDA7XG4gIGlmICghTnVtYmVyLmlzRmluaXRlKCh0IC0gZSkgLyAobiAtIDEpKSlcbiAgICByZXR1cm4ge1xuICAgICAgc3RlcDogbmV3IFRlKDApLFxuICAgICAgdGlja01pbjogbmV3IFRlKDApLFxuICAgICAgdGlja01heDogbmV3IFRlKDApXG4gICAgfTtcbiAgdmFyIG8gPSBCMChuZXcgVGUodCkuc3ViKGUpLmRpdihuIC0gMSksIHIsIGkpLCBhO1xuICBlIDw9IDAgJiYgdCA+PSAwID8gYSA9IG5ldyBUZSgwKSA6IChhID0gbmV3IFRlKGUpLmFkZCh0KS5kaXYoMiksIGEgPSBhLnN1YihuZXcgVGUoYSkubW9kKG8pKSk7XG4gIHZhciBzID0gTWF0aC5jZWlsKGEuc3ViKGUpLmRpdihvKS50b051bWJlcigpKSwgdSA9IE1hdGguY2VpbChuZXcgVGUodCkuc3ViKGEpLmRpdihvKS50b051bWJlcigpKSwgYyA9IHMgKyB1ICsgMTtcbiAgcmV0dXJuIGMgPiBuID8gejAoZSwgdCwgbiwgciwgaSArIDEpIDogKGMgPCBuICYmICh1ID0gdCA+IDAgPyB1ICsgKG4gLSBjKSA6IHUsIHMgPSB0ID4gMCA/IHMgOiBzICsgKG4gLSBjKSksIHtcbiAgICBzdGVwOiBvLFxuICAgIHRpY2tNaW46IGEuc3ViKG5ldyBUZShzKS5tdWwobykpLFxuICAgIHRpY2tNYXg6IGEuYWRkKG5ldyBUZSh1KS5tdWwobykpXG4gIH0pO1xufVxuZnVuY3Rpb24geDYoZSkge1xuICB2YXIgdCA9IGhvKGUsIDIpLCBuID0gdFswXSwgciA9IHRbMV0sIGkgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHZvaWQgMCA/IGFyZ3VtZW50c1sxXSA6IDYsIG8gPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHZvaWQgMCA/IGFyZ3VtZW50c1syXSA6ICEwLCBhID0gTWF0aC5tYXgoaSwgMiksIHMgPSBMMChbbiwgcl0pLCB1ID0gaG8ocywgMiksIGMgPSB1WzBdLCBmID0gdVsxXTtcbiAgaWYgKGMgPT09IC0xIC8gMCB8fCBmID09PSAxIC8gMCkge1xuICAgIHZhciBsID0gZiA9PT0gMSAvIDAgPyBbY10uY29uY2F0KGZsKGNsKDAsIGkgLSAxKS5tYXAoZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gMSAvIDA7XG4gICAgfSkpKSA6IFtdLmNvbmNhdChmbChjbCgwLCBpIC0gMSkubWFwKGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIC0xIC8gMDtcbiAgICB9KSksIFtmXSk7XG4gICAgcmV0dXJuIG4gPiByID8gbGwobCkgOiBsO1xuICB9XG4gIGlmIChjID09PSBmKVxuICAgIHJldHVybiB3NihjLCBpLCBvKTtcbiAgdmFyIGQgPSB6MChjLCBmLCBhLCBvKSwgcCA9IGQuc3RlcCwgZyA9IGQudGlja01pbiwgaCA9IGQudGlja01heCwgdiA9IHJ1LnJhbmdlU3RlcChnLCBoLmFkZChuZXcgVGUoMC4xKS5tdWwocCkpLCBwKTtcbiAgcmV0dXJuIG4gPiByID8gbGwodikgOiB2O1xufVxuZnVuY3Rpb24gUzYoZSwgdCkge1xuICB2YXIgbiA9IGhvKGUsIDIpLCByID0gblswXSwgaSA9IG5bMV0sIG8gPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHZvaWQgMCA/IGFyZ3VtZW50c1syXSA6ICEwLCBhID0gTDAoW3IsIGldKSwgcyA9IGhvKGEsIDIpLCB1ID0gc1swXSwgYyA9IHNbMV07XG4gIGlmICh1ID09PSAtMSAvIDAgfHwgYyA9PT0gMSAvIDApXG4gICAgcmV0dXJuIFtyLCBpXTtcbiAgaWYgKHUgPT09IGMpXG4gICAgcmV0dXJuIFt1XTtcbiAgdmFyIGYgPSBNYXRoLm1heCh0LCAyKSwgbCA9IEIwKG5ldyBUZShjKS5zdWIodSkuZGl2KGYgLSAxKSwgbywgMCksIGQgPSBbXS5jb25jYXQoZmwocnUucmFuZ2VTdGVwKG5ldyBUZSh1KSwgbmV3IFRlKGMpLnN1YihuZXcgVGUoMC45OSkubXVsKGwpKSwgbCkpLCBbY10pO1xuICByZXR1cm4gciA+IGkgPyBsbChkKSA6IGQ7XG59XG52YXIgJDYgPSBOMCh4NiksIE82ID0gTjAoUzYpLCBfNiA9IHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiwgVXUgPSBcIkludmFyaWFudCBmYWlsZWRcIjtcbmZ1bmN0aW9uIGd0KGUsIHQpIHtcbiAgaWYgKF82KVxuICAgIHRocm93IG5ldyBFcnJvcihVdSk7XG4gIHZhciBuID0gdHlwZW9mIHQgPT0gXCJmdW5jdGlvblwiID8gdCgpIDogdCwgciA9IG4gPyBcIlwiLmNvbmNhdChVdSwgXCI6IFwiKS5jb25jYXQobikgOiBVdTtcbiAgdGhyb3cgbmV3IEVycm9yKHIpO1xufVxudmFyIEE2ID0gW1wib2Zmc2V0XCIsIFwibGF5b3V0XCIsIFwid2lkdGhcIiwgXCJkYXRhS2V5XCIsIFwiZGF0YVwiLCBcImRhdGFQb2ludEZvcm1hdHRlclwiLCBcInhBeGlzXCIsIFwieUF4aXNcIl07XG5mdW5jdGlvbiBscygpIHtcbiAgcmV0dXJuIGxzID0gT2JqZWN0LmFzc2lnbiA/IE9iamVjdC5hc3NpZ24uYmluZCgpIDogZnVuY3Rpb24oZSkge1xuICAgIGZvciAodmFyIHQgPSAxOyB0IDwgYXJndW1lbnRzLmxlbmd0aDsgdCsrKSB7XG4gICAgICB2YXIgbiA9IGFyZ3VtZW50c1t0XTtcbiAgICAgIGZvciAodmFyIHIgaW4gbilcbiAgICAgICAgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG4sIHIpICYmIChlW3JdID0gbltyXSk7XG4gICAgfVxuICAgIHJldHVybiBlO1xuICB9LCBscy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuZnVuY3Rpb24gUDYoZSwgdCkge1xuICByZXR1cm4gTTYoZSkgfHwgVDYoZSwgdCkgfHwgRTYoZSwgdCkgfHwgQzYoKTtcbn1cbmZ1bmN0aW9uIEM2KCkge1xuICB0aHJvdyBuZXcgVHlwZUVycm9yKGBJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLmApO1xufVxuZnVuY3Rpb24gRTYoZSwgdCkge1xuICBpZiAoZSkge1xuICAgIGlmICh0eXBlb2YgZSA9PSBcInN0cmluZ1wiKVxuICAgICAgcmV0dXJuIHdnKGUsIHQpO1xuICAgIHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGUpLnNsaWNlKDgsIC0xKTtcbiAgICBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBlLmNvbnN0cnVjdG9yICYmIChuID0gZS5jb25zdHJ1Y3Rvci5uYW1lKSwgbiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKVxuICAgICAgcmV0dXJuIEFycmF5LmZyb20oZSk7XG4gICAgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpXG4gICAgICByZXR1cm4gd2coZSwgdCk7XG4gIH1cbn1cbmZ1bmN0aW9uIHdnKGUsIHQpIHtcbiAgKHQgPT0gbnVsbCB8fCB0ID4gZS5sZW5ndGgpICYmICh0ID0gZS5sZW5ndGgpO1xuICBmb3IgKHZhciBuID0gMCwgciA9IG5ldyBBcnJheSh0KTsgbiA8IHQ7IG4rKylcbiAgICByW25dID0gZVtuXTtcbiAgcmV0dXJuIHI7XG59XG5mdW5jdGlvbiBUNihlLCB0KSB7XG4gIHZhciBuID0gZSA9PSBudWxsID8gbnVsbCA6IHR5cGVvZiBTeW1ib2wgPCBcInVcIiAmJiBlW1N5bWJvbC5pdGVyYXRvcl0gfHwgZVtcIkBAaXRlcmF0b3JcIl07XG4gIGlmIChuICE9IG51bGwpIHtcbiAgICB2YXIgciwgaSwgbywgYSwgcyA9IFtdLCB1ID0gITAsIGMgPSAhMTtcbiAgICB0cnkge1xuICAgICAgaWYgKG8gPSAobiA9IG4uY2FsbChlKSkubmV4dCwgdCAhPT0gMClcbiAgICAgICAgZm9yICg7ICEodSA9IChyID0gby5jYWxsKG4pKS5kb25lKSAmJiAocy5wdXNoKHIudmFsdWUpLCBzLmxlbmd0aCAhPT0gdCk7IHUgPSAhMClcbiAgICAgICAgICA7XG4gICAgfSBjYXRjaCAoZikge1xuICAgICAgYyA9ICEwLCBpID0gZjtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKCF1ICYmIG4ucmV0dXJuICE9IG51bGwgJiYgKGEgPSBuLnJldHVybigpLCBPYmplY3QoYSkgIT09IGEpKVxuICAgICAgICAgIHJldHVybjtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGlmIChjKVxuICAgICAgICAgIHRocm93IGk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzO1xuICB9XG59XG5mdW5jdGlvbiBNNihlKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGUpKVxuICAgIHJldHVybiBlO1xufVxuZnVuY3Rpb24gUjYoZSwgdCkge1xuICBpZiAoZSA9PSBudWxsKVxuICAgIHJldHVybiB7fTtcbiAgdmFyIG4gPSBJNihlLCB0KSwgciwgaTtcbiAgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcbiAgICB2YXIgbyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZSk7XG4gICAgZm9yIChpID0gMDsgaSA8IG8ubGVuZ3RoOyBpKyspXG4gICAgICByID0gb1tpXSwgISh0LmluZGV4T2YocikgPj0gMCkgJiYgT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKGUsIHIpICYmIChuW3JdID0gZVtyXSk7XG4gIH1cbiAgcmV0dXJuIG47XG59XG5mdW5jdGlvbiBJNihlLCB0KSB7XG4gIGlmIChlID09IG51bGwpXG4gICAgcmV0dXJuIHt9O1xuICB2YXIgbiA9IHt9LCByID0gT2JqZWN0LmtleXMoZSksIGksIG87XG4gIGZvciAobyA9IDA7IG8gPCByLmxlbmd0aDsgbysrKVxuICAgIGkgPSByW29dLCAhKHQuaW5kZXhPZihpKSA+PSAwKSAmJiAobltpXSA9IGVbaV0pO1xuICByZXR1cm4gbjtcbn1cbmZ1bmN0aW9uIFpvKGUpIHtcbiAgdmFyIHQgPSBlLm9mZnNldCwgbiA9IGUubGF5b3V0LCByID0gZS53aWR0aCwgaSA9IGUuZGF0YUtleSwgbyA9IGUuZGF0YSwgYSA9IGUuZGF0YVBvaW50Rm9ybWF0dGVyLCBzID0gZS54QXhpcywgdSA9IGUueUF4aXMsIGMgPSBSNihlLCBBNiksIGYgPSB5ZShjLCAhMSk7XG4gIGUuZGlyZWN0aW9uID09PSBcInhcIiAmJiBzLnR5cGUgIT09IFwibnVtYmVyXCIgJiYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGd0KCExLCAnRXJyb3JCYXIgcmVxdWlyZXMgQXhpcyB0eXBlIHByb3BlcnR5IHRvIGJlIFwibnVtYmVyXCIuJykgOiBndCgpKTtcbiAgdmFyIGwgPSBvLm1hcChmdW5jdGlvbihkKSB7XG4gICAgdmFyIHAgPSBhKGQsIGkpLCBnID0gcC54LCBoID0gcC55LCB2ID0gcC52YWx1ZSwgdyA9IHAuZXJyb3JWYWw7XG4gICAgaWYgKCF3KVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgdmFyIGIgPSBbXSwgeCwgbTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh3KSkge1xuICAgICAgdmFyIHkgPSBQNih3LCAyKTtcbiAgICAgIHggPSB5WzBdLCBtID0geVsxXTtcbiAgICB9IGVsc2VcbiAgICAgIHggPSBtID0gdztcbiAgICBpZiAobiA9PT0gXCJ2ZXJ0aWNhbFwiKSB7XG4gICAgICB2YXIgUyA9IHMuc2NhbGUsICQgPSBoICsgdCwgTyA9ICQgKyByLCBUID0gJCAtIHIsIE0gPSBTKHYgLSB4KSwgRSA9IFModiArIG0pO1xuICAgICAgYi5wdXNoKHtcbiAgICAgICAgeDE6IEUsXG4gICAgICAgIHkxOiBPLFxuICAgICAgICB4MjogRSxcbiAgICAgICAgeTI6IFRcbiAgICAgIH0pLCBiLnB1c2goe1xuICAgICAgICB4MTogTSxcbiAgICAgICAgeTE6ICQsXG4gICAgICAgIHgyOiBFLFxuICAgICAgICB5MjogJFxuICAgICAgfSksIGIucHVzaCh7XG4gICAgICAgIHgxOiBNLFxuICAgICAgICB5MTogTyxcbiAgICAgICAgeDI6IE0sXG4gICAgICAgIHkyOiBUXG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKG4gPT09IFwiaG9yaXpvbnRhbFwiKSB7XG4gICAgICB2YXIgQSA9IHUuc2NhbGUsIGogPSBnICsgdCwgUiA9IGogLSByLCBOID0gaiArIHIsIGsgPSBBKHYgLSB4KSwgRiA9IEEodiArIG0pO1xuICAgICAgYi5wdXNoKHtcbiAgICAgICAgeDE6IFIsXG4gICAgICAgIHkxOiBGLFxuICAgICAgICB4MjogTixcbiAgICAgICAgeTI6IEZcbiAgICAgIH0pLCBiLnB1c2goe1xuICAgICAgICB4MTogaixcbiAgICAgICAgeTE6IGssXG4gICAgICAgIHgyOiBqLFxuICAgICAgICB5MjogRlxuICAgICAgfSksIGIucHVzaCh7XG4gICAgICAgIHgxOiBSLFxuICAgICAgICB5MTogayxcbiAgICAgICAgeDI6IE4sXG4gICAgICAgIHkyOiBrXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBQLmNyZWF0ZUVsZW1lbnQoV2UsIGxzKHtcbiAgICAgIGNsYXNzTmFtZTogXCJyZWNoYXJ0cy1lcnJvckJhclwiLFxuICAgICAga2V5OiBcImJhci1cIi5jb25jYXQoYi5tYXAoZnVuY3Rpb24oVikge1xuICAgICAgICByZXR1cm4gXCJcIi5jb25jYXQoVi54MSwgXCItXCIpLmNvbmNhdChWLngyLCBcIi1cIikuY29uY2F0KFYueTEsIFwiLVwiKS5jb25jYXQoVi55Mik7XG4gICAgICB9KSlcbiAgICB9LCBmKSwgYi5tYXAoZnVuY3Rpb24oVikge1xuICAgICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBQLmNyZWF0ZUVsZW1lbnQoXCJsaW5lXCIsIGxzKHt9LCBWLCB7XG4gICAgICAgIGtleTogXCJsaW5lLVwiLmNvbmNhdChWLngxLCBcIi1cIikuY29uY2F0KFYueDIsIFwiLVwiKS5jb25jYXQoVi55MSwgXCItXCIpLmNvbmNhdChWLnkyKVxuICAgICAgfSkpO1xuICAgIH0pKTtcbiAgfSk7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gUC5jcmVhdGVFbGVtZW50KFdlLCB7XG4gICAgY2xhc3NOYW1lOiBcInJlY2hhcnRzLWVycm9yQmFyc1wiXG4gIH0sIGwpO1xufVxuWm8uZGVmYXVsdFByb3BzID0ge1xuICBzdHJva2U6IFwiYmxhY2tcIixcbiAgc3Ryb2tlV2lkdGg6IDEuNSxcbiAgd2lkdGg6IDUsXG4gIG9mZnNldDogMCxcbiAgbGF5b3V0OiBcImhvcml6b250YWxcIlxufTtcblpvLmRpc3BsYXlOYW1lID0gXCJFcnJvckJhclwiO1xuZnVuY3Rpb24gZ28oZSkge1xuICBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7XG4gIHJldHVybiBnbyA9IHR5cGVvZiBTeW1ib2wgPT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uKHQpIHtcbiAgICByZXR1cm4gdHlwZW9mIHQ7XG4gIH0gOiBmdW5jdGlvbih0KSB7XG4gICAgcmV0dXJuIHQgJiYgdHlwZW9mIFN5bWJvbCA9PSBcImZ1bmN0aW9uXCIgJiYgdC5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIHQgIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIHQ7XG4gIH0sIGdvKGUpO1xufVxuZnVuY3Rpb24geGcoZSwgdCkge1xuICB2YXIgbiA9IE9iamVjdC5rZXlzKGUpO1xuICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykge1xuICAgIHZhciByID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhlKTtcbiAgICB0ICYmIChyID0gci5maWx0ZXIoZnVuY3Rpb24oaSkge1xuICAgICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSwgaSkuZW51bWVyYWJsZTtcbiAgICB9KSksIG4ucHVzaC5hcHBseShuLCByKTtcbiAgfVxuICByZXR1cm4gbjtcbn1cbmZ1bmN0aW9uIEh1KGUpIHtcbiAgZm9yICh2YXIgdCA9IDE7IHQgPCBhcmd1bWVudHMubGVuZ3RoOyB0KyspIHtcbiAgICB2YXIgbiA9IGFyZ3VtZW50c1t0XSAhPSBudWxsID8gYXJndW1lbnRzW3RdIDoge307XG4gICAgdCAlIDIgPyB4ZyhPYmplY3QobiksICEwKS5mb3JFYWNoKGZ1bmN0aW9uKHIpIHtcbiAgICAgIGo2KGUsIHIsIG5bcl0pO1xuICAgIH0pIDogT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhlLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhuKSkgOiB4ZyhPYmplY3QobikpLmZvckVhY2goZnVuY3Rpb24ocikge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIHIsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobiwgcikpO1xuICAgIH0pO1xuICB9XG4gIHJldHVybiBlO1xufVxuZnVuY3Rpb24gajYoZSwgdCwgbikge1xuICByZXR1cm4gdCA9IGs2KHQpLCB0IGluIGUgPyBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgdCwgeyB2YWx1ZTogbiwgZW51bWVyYWJsZTogITAsIGNvbmZpZ3VyYWJsZTogITAsIHdyaXRhYmxlOiAhMCB9KSA6IGVbdF0gPSBuLCBlO1xufVxuZnVuY3Rpb24gazYoZSkge1xuICB2YXIgdCA9IEQ2KGUsIFwic3RyaW5nXCIpO1xuICByZXR1cm4gZ28odCkgPT0gXCJzeW1ib2xcIiA/IHQgOiBTdHJpbmcodCk7XG59XG5mdW5jdGlvbiBENihlLCB0KSB7XG4gIGlmIChnbyhlKSAhPSBcIm9iamVjdFwiIHx8ICFlKVxuICAgIHJldHVybiBlO1xuICB2YXIgbiA9IGVbU3ltYm9sLnRvUHJpbWl0aXZlXTtcbiAgaWYgKG4gIT09IHZvaWQgMCkge1xuICAgIHZhciByID0gbi5jYWxsKGUsIHQgfHwgXCJkZWZhdWx0XCIpO1xuICAgIGlmIChnbyhyKSAhPSBcIm9iamVjdFwiKVxuICAgICAgcmV0dXJuIHI7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkBAdG9QcmltaXRpdmUgbXVzdCByZXR1cm4gYSBwcmltaXRpdmUgdmFsdWUuXCIpO1xuICB9XG4gIHJldHVybiAodCA9PT0gXCJzdHJpbmdcIiA/IFN0cmluZyA6IE51bWJlcikoZSk7XG59XG52YXIgVjAgPSBmdW5jdGlvbih0KSB7XG4gIHZhciBuID0gdC5jaGlsZHJlbiwgciA9IHQuZm9ybWF0dGVkR3JhcGhpY2FsSXRlbXMsIGkgPSB0LmxlZ2VuZFdpZHRoLCBvID0gdC5sZWdlbmRDb250ZW50LCBhID0gd3QobiwgVnIpO1xuICBpZiAoIWEpXG4gICAgcmV0dXJuIG51bGw7XG4gIHZhciBzO1xuICByZXR1cm4gYS5wcm9wcyAmJiBhLnByb3BzLnBheWxvYWQgPyBzID0gYS5wcm9wcyAmJiBhLnByb3BzLnBheWxvYWQgOiBvID09PSBcImNoaWxkcmVuXCIgPyBzID0gKHIgfHwgW10pLnJlZHVjZShmdW5jdGlvbih1LCBjKSB7XG4gICAgdmFyIGYgPSBjLml0ZW0sIGwgPSBjLnByb3BzLCBkID0gbC5zZWN0b3JzIHx8IGwuZGF0YSB8fCBbXTtcbiAgICByZXR1cm4gdS5jb25jYXQoZC5tYXAoZnVuY3Rpb24ocCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogYS5wcm9wcy5pY29uVHlwZSB8fCBmLnByb3BzLmxlZ2VuZFR5cGUsXG4gICAgICAgIHZhbHVlOiBwLm5hbWUsXG4gICAgICAgIGNvbG9yOiBwLmZpbGwsXG4gICAgICAgIHBheWxvYWQ6IHBcbiAgICAgIH07XG4gICAgfSkpO1xuICB9LCBbXSkgOiBzID0gKHIgfHwgW10pLm1hcChmdW5jdGlvbih1KSB7XG4gICAgdmFyIGMgPSB1Lml0ZW0sIGYgPSBjLnByb3BzLCBsID0gZi5kYXRhS2V5LCBkID0gZi5uYW1lLCBwID0gZi5sZWdlbmRUeXBlLCBnID0gZi5oaWRlO1xuICAgIHJldHVybiB7XG4gICAgICBpbmFjdGl2ZTogZyxcbiAgICAgIGRhdGFLZXk6IGwsXG4gICAgICB0eXBlOiBhLnByb3BzLmljb25UeXBlIHx8IHAgfHwgXCJzcXVhcmVcIixcbiAgICAgIGNvbG9yOiBsZChjKSxcbiAgICAgIHZhbHVlOiBkIHx8IGwsXG4gICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIHByb3BlcnR5IHN0cm9rZURhc2hhcnJheSBpcyByZXF1aXJlZCBpbiBQYXlsb2FkIGJ1dCBvcHRpb25hbCBpbiBwcm9wc1xuICAgICAgcGF5bG9hZDogYy5wcm9wc1xuICAgIH07XG4gIH0pLCBIdShIdShIdSh7fSwgYS5wcm9wcyksIFZyLmdldFdpdGhIZWlnaHQoYSwgaSkpLCB7fSwge1xuICAgIHBheWxvYWQ6IHMsXG4gICAgaXRlbTogYVxuICB9KTtcbn07XG5mdW5jdGlvbiB2byhlKSB7XG4gIFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjtcbiAgcmV0dXJuIHZvID0gdHlwZW9mIFN5bWJvbCA9PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PSBcInN5bWJvbFwiID8gZnVuY3Rpb24odCkge1xuICAgIHJldHVybiB0eXBlb2YgdDtcbiAgfSA6IGZ1bmN0aW9uKHQpIHtcbiAgICByZXR1cm4gdCAmJiB0eXBlb2YgU3ltYm9sID09IFwiZnVuY3Rpb25cIiAmJiB0LmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgdCAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2YgdDtcbiAgfSwgdm8oZSk7XG59XG5mdW5jdGlvbiBTZyhlLCB0KSB7XG4gIHZhciBuID0gT2JqZWN0LmtleXMoZSk7XG4gIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gICAgdmFyIHIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGUpO1xuICAgIHQgJiYgKHIgPSByLmZpbHRlcihmdW5jdGlvbihpKSB7XG4gICAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLCBpKS5lbnVtZXJhYmxlO1xuICAgIH0pKSwgbi5wdXNoLmFwcGx5KG4sIHIpO1xuICB9XG4gIHJldHVybiBuO1xufVxuZnVuY3Rpb24gUnQoZSkge1xuICBmb3IgKHZhciB0ID0gMTsgdCA8IGFyZ3VtZW50cy5sZW5ndGg7IHQrKykge1xuICAgIHZhciBuID0gYXJndW1lbnRzW3RdICE9IG51bGwgPyBhcmd1bWVudHNbdF0gOiB7fTtcbiAgICB0ICUgMiA/IFNnKE9iamVjdChuKSwgITApLmZvckVhY2goZnVuY3Rpb24ocikge1xuICAgICAganIoZSwgciwgbltyXSk7XG4gICAgfSkgOiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGUsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKG4pKSA6IFNnKE9iamVjdChuKSkuZm9yRWFjaChmdW5jdGlvbihyKSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgciwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihuLCByKSk7XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIGU7XG59XG5mdW5jdGlvbiBqcihlLCB0LCBuKSB7XG4gIHJldHVybiB0ID0gTjYodCksIHQgaW4gZSA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCB0LCB7IHZhbHVlOiBuLCBlbnVtZXJhYmxlOiAhMCwgY29uZmlndXJhYmxlOiAhMCwgd3JpdGFibGU6ICEwIH0pIDogZVt0XSA9IG4sIGU7XG59XG5mdW5jdGlvbiBONihlKSB7XG4gIHZhciB0ID0gRjYoZSwgXCJzdHJpbmdcIik7XG4gIHJldHVybiB2byh0KSA9PSBcInN5bWJvbFwiID8gdCA6IFN0cmluZyh0KTtcbn1cbmZ1bmN0aW9uIEY2KGUsIHQpIHtcbiAgaWYgKHZvKGUpICE9IFwib2JqZWN0XCIgfHwgIWUpXG4gICAgcmV0dXJuIGU7XG4gIHZhciBuID0gZVtTeW1ib2wudG9QcmltaXRpdmVdO1xuICBpZiAobiAhPT0gdm9pZCAwKSB7XG4gICAgdmFyIHIgPSBuLmNhbGwoZSwgdCB8fCBcImRlZmF1bHRcIik7XG4gICAgaWYgKHZvKHIpICE9IFwib2JqZWN0XCIpXG4gICAgICByZXR1cm4gcjtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQEB0b1ByaW1pdGl2ZSBtdXN0IHJldHVybiBhIHByaW1pdGl2ZSB2YWx1ZS5cIik7XG4gIH1cbiAgcmV0dXJuICh0ID09PSBcInN0cmluZ1wiID8gU3RyaW5nIDogTnVtYmVyKShlKTtcbn1cbmZ1bmN0aW9uICRnKGUpIHtcbiAgcmV0dXJuIFY2KGUpIHx8IHo2KGUpIHx8IEI2KGUpIHx8IEw2KCk7XG59XG5mdW5jdGlvbiBMNigpIHtcbiAgdGhyb3cgbmV3IFR5cGVFcnJvcihgSW52YWxpZCBhdHRlbXB0IHRvIHNwcmVhZCBub24taXRlcmFibGUgaW5zdGFuY2UuXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuYCk7XG59XG5mdW5jdGlvbiBCNihlLCB0KSB7XG4gIGlmIChlKSB7XG4gICAgaWYgKHR5cGVvZiBlID09IFwic3RyaW5nXCIpXG4gICAgICByZXR1cm4gcGwoZSwgdCk7XG4gICAgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoZSkuc2xpY2UoOCwgLTEpO1xuICAgIGlmIChuID09PSBcIk9iamVjdFwiICYmIGUuY29uc3RydWN0b3IgJiYgKG4gPSBlLmNvbnN0cnVjdG9yLm5hbWUpLCBuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpXG4gICAgICByZXR1cm4gQXJyYXkuZnJvbShlKTtcbiAgICBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSlcbiAgICAgIHJldHVybiBwbChlLCB0KTtcbiAgfVxufVxuZnVuY3Rpb24gejYoZSkge1xuICBpZiAodHlwZW9mIFN5bWJvbCA8IFwidVwiICYmIGVbU3ltYm9sLml0ZXJhdG9yXSAhPSBudWxsIHx8IGVbXCJAQGl0ZXJhdG9yXCJdICE9IG51bGwpXG4gICAgcmV0dXJuIEFycmF5LmZyb20oZSk7XG59XG5mdW5jdGlvbiBWNihlKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGUpKVxuICAgIHJldHVybiBwbChlKTtcbn1cbmZ1bmN0aW9uIHBsKGUsIHQpIHtcbiAgKHQgPT0gbnVsbCB8fCB0ID4gZS5sZW5ndGgpICYmICh0ID0gZS5sZW5ndGgpO1xuICBmb3IgKHZhciBuID0gMCwgciA9IG5ldyBBcnJheSh0KTsgbiA8IHQ7IG4rKylcbiAgICByW25dID0gZVtuXTtcbiAgcmV0dXJuIHI7XG59XG5mdW5jdGlvbiBBdChlLCB0LCBuKSB7XG4gIHJldHVybiBtZShlKSB8fCBtZSh0KSA/IG4gOiBLZSh0KSA/IGp0KGUsIHQsIG4pIDogcGUodCkgPyB0KGUpIDogbjtcbn1cbmZ1bmN0aW9uIFVpKGUsIHQsIG4sIHIpIHtcbiAgdmFyIGkgPSBxQihlLCBmdW5jdGlvbihzKSB7XG4gICAgcmV0dXJuIEF0KHMsIHQpO1xuICB9KTtcbiAgaWYgKG4gPT09IFwibnVtYmVyXCIpIHtcbiAgICB2YXIgbyA9IGkuZmlsdGVyKGZ1bmN0aW9uKHMpIHtcbiAgICAgIHJldHVybiBLKHMpIHx8IHBhcnNlRmxvYXQocyk7XG4gICAgfSk7XG4gICAgcmV0dXJuIG8ubGVuZ3RoID8gW2V1KG8pLCBRcyhvKV0gOiBbMSAvIDAsIC0xIC8gMF07XG4gIH1cbiAgdmFyIGEgPSByID8gaS5maWx0ZXIoZnVuY3Rpb24ocykge1xuICAgIHJldHVybiAhbWUocyk7XG4gIH0pIDogaTtcbiAgcmV0dXJuIGEubWFwKGZ1bmN0aW9uKHMpIHtcbiAgICByZXR1cm4gS2UocykgfHwgcyBpbnN0YW5jZW9mIERhdGUgPyBzIDogXCJcIjtcbiAgfSk7XG59XG52YXIgRzYgPSBmdW5jdGlvbih0KSB7XG4gIHZhciBuLCByID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB2b2lkIDAgPyBhcmd1bWVudHNbMV0gOiBbXSwgaSA9IGFyZ3VtZW50cy5sZW5ndGggPiAyID8gYXJndW1lbnRzWzJdIDogdm9pZCAwLCBvID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgPyBhcmd1bWVudHNbM10gOiB2b2lkIDAsIGEgPSAtMSwgcyA9IChuID0gciA9PSBudWxsID8gdm9pZCAwIDogci5sZW5ndGgpICE9PSBudWxsICYmIG4gIT09IHZvaWQgMCA/IG4gOiAwO1xuICBpZiAocyA8PSAxKVxuICAgIHJldHVybiAwO1xuICBpZiAobyAmJiBvLmF4aXNUeXBlID09PSBcImFuZ2xlQXhpc1wiICYmIE1hdGguYWJzKE1hdGguYWJzKG8ucmFuZ2VbMV0gLSBvLnJhbmdlWzBdKSAtIDM2MCkgPD0gMWUtNilcbiAgICBmb3IgKHZhciB1ID0gby5yYW5nZSwgYyA9IDA7IGMgPCBzOyBjKyspIHtcbiAgICAgIHZhciBmID0gYyA+IDAgPyBpW2MgLSAxXS5jb29yZGluYXRlIDogaVtzIC0gMV0uY29vcmRpbmF0ZSwgbCA9IGlbY10uY29vcmRpbmF0ZSwgZCA9IGMgPj0gcyAtIDEgPyBpWzBdLmNvb3JkaW5hdGUgOiBpW2MgKyAxXS5jb29yZGluYXRlLCBwID0gdm9pZCAwO1xuICAgICAgaWYgKEt0KGwgLSBmKSAhPT0gS3QoZCAtIGwpKSB7XG4gICAgICAgIHZhciBnID0gW107XG4gICAgICAgIGlmIChLdChkIC0gbCkgPT09IEt0KHVbMV0gLSB1WzBdKSkge1xuICAgICAgICAgIHAgPSBkO1xuICAgICAgICAgIHZhciBoID0gbCArIHVbMV0gLSB1WzBdO1xuICAgICAgICAgIGdbMF0gPSBNYXRoLm1pbihoLCAoaCArIGYpIC8gMiksIGdbMV0gPSBNYXRoLm1heChoLCAoaCArIGYpIC8gMik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcCA9IGY7XG4gICAgICAgICAgdmFyIHYgPSBkICsgdVsxXSAtIHVbMF07XG4gICAgICAgICAgZ1swXSA9IE1hdGgubWluKGwsICh2ICsgbCkgLyAyKSwgZ1sxXSA9IE1hdGgubWF4KGwsICh2ICsgbCkgLyAyKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdyA9IFtNYXRoLm1pbihsLCAocCArIGwpIC8gMiksIE1hdGgubWF4KGwsIChwICsgbCkgLyAyKV07XG4gICAgICAgIGlmICh0ID4gd1swXSAmJiB0IDw9IHdbMV0gfHwgdCA+PSBnWzBdICYmIHQgPD0gZ1sxXSkge1xuICAgICAgICAgIGEgPSBpW2NdLmluZGV4O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgYiA9IE1hdGgubWluKGYsIGQpLCB4ID0gTWF0aC5tYXgoZiwgZCk7XG4gICAgICAgIGlmICh0ID4gKGIgKyBsKSAvIDIgJiYgdCA8PSAoeCArIGwpIC8gMikge1xuICAgICAgICAgIGEgPSBpW2NdLmluZGV4O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICBlbHNlXG4gICAgZm9yICh2YXIgbSA9IDA7IG0gPCBzOyBtKyspXG4gICAgICBpZiAobSA9PT0gMCAmJiB0IDw9IChyW21dLmNvb3JkaW5hdGUgKyByW20gKyAxXS5jb29yZGluYXRlKSAvIDIgfHwgbSA+IDAgJiYgbSA8IHMgLSAxICYmIHQgPiAoclttXS5jb29yZGluYXRlICsgclttIC0gMV0uY29vcmRpbmF0ZSkgLyAyICYmIHQgPD0gKHJbbV0uY29vcmRpbmF0ZSArIHJbbSArIDFdLmNvb3JkaW5hdGUpIC8gMiB8fCBtID09PSBzIC0gMSAmJiB0ID4gKHJbbV0uY29vcmRpbmF0ZSArIHJbbSAtIDFdLmNvb3JkaW5hdGUpIC8gMikge1xuICAgICAgICBhID0gclttXS5pbmRleDtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gIHJldHVybiBhO1xufSwgbGQgPSBmdW5jdGlvbih0KSB7XG4gIHZhciBuID0gdCwgciA9IG4udHlwZS5kaXNwbGF5TmFtZSwgaSA9IHQucHJvcHMsIG8gPSBpLnN0cm9rZSwgYSA9IGkuZmlsbCwgcztcbiAgc3dpdGNoIChyKSB7XG4gICAgY2FzZSBcIkxpbmVcIjpcbiAgICAgIHMgPSBvO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcIkFyZWFcIjpcbiAgICBjYXNlIFwiUmFkYXJcIjpcbiAgICAgIHMgPSBvICYmIG8gIT09IFwibm9uZVwiID8gbyA6IGE7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgcyA9IGE7XG4gICAgICBicmVhaztcbiAgfVxuICByZXR1cm4gcztcbn0sIFc2ID0gZnVuY3Rpb24odCkge1xuICB2YXIgbiA9IHQuYmFyU2l6ZSwgciA9IHQudG90YWxTaXplLCBpID0gdC5zdGFja0dyb3VwcywgbyA9IGkgPT09IHZvaWQgMCA/IHt9IDogaTtcbiAgaWYgKCFvKVxuICAgIHJldHVybiB7fTtcbiAgZm9yICh2YXIgYSA9IHt9LCBzID0gT2JqZWN0LmtleXMobyksIHUgPSAwLCBjID0gcy5sZW5ndGg7IHUgPCBjOyB1KyspXG4gICAgZm9yICh2YXIgZiA9IG9bc1t1XV0uc3RhY2tHcm91cHMsIGwgPSBPYmplY3Qua2V5cyhmKSwgZCA9IDAsIHAgPSBsLmxlbmd0aDsgZCA8IHA7IGQrKykge1xuICAgICAgdmFyIGcgPSBmW2xbZF1dLCBoID0gZy5pdGVtcywgdiA9IGcuY2F0ZUF4aXNJZCwgdyA9IGguZmlsdGVyKGZ1bmN0aW9uKHkpIHtcbiAgICAgICAgcmV0dXJuIEZuKHkudHlwZSkuaW5kZXhPZihcIkJhclwiKSA+PSAwO1xuICAgICAgfSk7XG4gICAgICBpZiAodyAmJiB3Lmxlbmd0aCkge1xuICAgICAgICB2YXIgYiA9IHdbMF0ucHJvcHMuYmFyU2l6ZSwgeCA9IHdbMF0ucHJvcHNbdl07XG4gICAgICAgIGFbeF0gfHwgKGFbeF0gPSBbXSk7XG4gICAgICAgIHZhciBtID0gbWUoYikgPyBuIDogYjtcbiAgICAgICAgYVt4XS5wdXNoKHtcbiAgICAgICAgICBpdGVtOiB3WzBdLFxuICAgICAgICAgIHN0YWNrTGlzdDogdy5zbGljZSgxKSxcbiAgICAgICAgICBiYXJTaXplOiBtZShtKSA/IHZvaWQgMCA6IGxyKG0sIHIsIDApXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgcmV0dXJuIGE7XG59LCBVNiA9IGZ1bmN0aW9uKHQpIHtcbiAgdmFyIG4gPSB0LmJhckdhcCwgciA9IHQuYmFyQ2F0ZWdvcnlHYXAsIGkgPSB0LmJhbmRTaXplLCBvID0gdC5zaXplTGlzdCwgYSA9IG8gPT09IHZvaWQgMCA/IFtdIDogbywgcyA9IHQubWF4QmFyU2l6ZSwgdSA9IGEubGVuZ3RoO1xuICBpZiAodSA8IDEpXG4gICAgcmV0dXJuIG51bGw7XG4gIHZhciBjID0gbHIobiwgaSwgMCwgITApLCBmLCBsID0gW107XG4gIGlmIChhWzBdLmJhclNpemUgPT09ICthWzBdLmJhclNpemUpIHtcbiAgICB2YXIgZCA9ICExLCBwID0gaSAvIHUsIGcgPSBhLnJlZHVjZShmdW5jdGlvbihtLCB5KSB7XG4gICAgICByZXR1cm4gbSArIHkuYmFyU2l6ZSB8fCAwO1xuICAgIH0sIDApO1xuICAgIGcgKz0gKHUgLSAxKSAqIGMsIGcgPj0gaSAmJiAoZyAtPSAodSAtIDEpICogYywgYyA9IDApLCBnID49IGkgJiYgcCA+IDAgJiYgKGQgPSAhMCwgcCAqPSAwLjksIGcgPSB1ICogcCk7XG4gICAgdmFyIGggPSAoaSAtIGcpIC8gMiA+PiAwLCB2ID0ge1xuICAgICAgb2Zmc2V0OiBoIC0gYyxcbiAgICAgIHNpemU6IDBcbiAgICB9O1xuICAgIGYgPSBhLnJlZHVjZShmdW5jdGlvbihtLCB5KSB7XG4gICAgICB2YXIgUyA9IHtcbiAgICAgICAgaXRlbTogeS5pdGVtLFxuICAgICAgICBwb3NpdGlvbjoge1xuICAgICAgICAgIG9mZnNldDogdi5vZmZzZXQgKyB2LnNpemUgKyBjLFxuICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgdGhlIHR5cGUgY2hlY2sgYWJvdmUgZG9lcyBub3QgY2hlY2sgZm9yIHR5cGUgbnVtYmVyIGV4cGxpY2l0bHlcbiAgICAgICAgICBzaXplOiBkID8gcCA6IHkuYmFyU2l6ZVxuICAgICAgICB9XG4gICAgICB9LCAkID0gW10uY29uY2F0KCRnKG0pLCBbU10pO1xuICAgICAgcmV0dXJuIHYgPSAkWyQubGVuZ3RoIC0gMV0ucG9zaXRpb24sIHkuc3RhY2tMaXN0ICYmIHkuc3RhY2tMaXN0Lmxlbmd0aCAmJiB5LnN0YWNrTGlzdC5mb3JFYWNoKGZ1bmN0aW9uKE8pIHtcbiAgICAgICAgJC5wdXNoKHtcbiAgICAgICAgICBpdGVtOiBPLFxuICAgICAgICAgIHBvc2l0aW9uOiB2XG4gICAgICAgIH0pO1xuICAgICAgfSksICQ7XG4gICAgfSwgbCk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIHcgPSBscihyLCBpLCAwLCAhMCk7XG4gICAgaSAtIDIgKiB3IC0gKHUgLSAxKSAqIGMgPD0gMCAmJiAoYyA9IDApO1xuICAgIHZhciBiID0gKGkgLSAyICogdyAtICh1IC0gMSkgKiBjKSAvIHU7XG4gICAgYiA+IDEgJiYgKGIgPj49IDApO1xuICAgIHZhciB4ID0gcyA9PT0gK3MgPyBNYXRoLm1pbihiLCBzKSA6IGI7XG4gICAgZiA9IGEucmVkdWNlKGZ1bmN0aW9uKG0sIHksIFMpIHtcbiAgICAgIHZhciAkID0gW10uY29uY2F0KCRnKG0pLCBbe1xuICAgICAgICBpdGVtOiB5Lml0ZW0sXG4gICAgICAgIHBvc2l0aW9uOiB7XG4gICAgICAgICAgb2Zmc2V0OiB3ICsgKGIgKyBjKSAqIFMgKyAoYiAtIHgpIC8gMixcbiAgICAgICAgICBzaXplOiB4XG4gICAgICAgIH1cbiAgICAgIH1dKTtcbiAgICAgIHJldHVybiB5LnN0YWNrTGlzdCAmJiB5LnN0YWNrTGlzdC5sZW5ndGggJiYgeS5zdGFja0xpc3QuZm9yRWFjaChmdW5jdGlvbihPKSB7XG4gICAgICAgICQucHVzaCh7XG4gICAgICAgICAgaXRlbTogTyxcbiAgICAgICAgICBwb3NpdGlvbjogJFskLmxlbmd0aCAtIDFdLnBvc2l0aW9uXG4gICAgICAgIH0pO1xuICAgICAgfSksICQ7XG4gICAgfSwgbCk7XG4gIH1cbiAgcmV0dXJuIGY7XG59LCBINiA9IGZ1bmN0aW9uKHQsIG4sIHIsIGkpIHtcbiAgdmFyIG8gPSByLmNoaWxkcmVuLCBhID0gci53aWR0aCwgcyA9IHIubWFyZ2luLCB1ID0gYSAtIChzLmxlZnQgfHwgMCkgLSAocy5yaWdodCB8fCAwKSwgYyA9IFYwKHtcbiAgICBjaGlsZHJlbjogbyxcbiAgICBsZWdlbmRXaWR0aDogdVxuICB9KTtcbiAgaWYgKGMpIHtcbiAgICB2YXIgZiA9IGkgfHwge30sIGwgPSBmLndpZHRoLCBkID0gZi5oZWlnaHQsIHAgPSBjLmFsaWduLCBnID0gYy52ZXJ0aWNhbEFsaWduLCBoID0gYy5sYXlvdXQ7XG4gICAgaWYgKChoID09PSBcInZlcnRpY2FsXCIgfHwgaCA9PT0gXCJob3Jpem9udGFsXCIgJiYgZyA9PT0gXCJtaWRkbGVcIikgJiYgcCAhPT0gXCJjZW50ZXJcIiAmJiBLKHRbcF0pKVxuICAgICAgcmV0dXJuIFJ0KFJ0KHt9LCB0KSwge30sIGpyKHt9LCBwLCB0W3BdICsgKGwgfHwgMCkpKTtcbiAgICBpZiAoKGggPT09IFwiaG9yaXpvbnRhbFwiIHx8IGggPT09IFwidmVydGljYWxcIiAmJiBwID09PSBcImNlbnRlclwiKSAmJiBnICE9PSBcIm1pZGRsZVwiICYmIEsodFtnXSkpXG4gICAgICByZXR1cm4gUnQoUnQoe30sIHQpLCB7fSwganIoe30sIGcsIHRbZ10gKyAoZCB8fCAwKSkpO1xuICB9XG4gIHJldHVybiB0O1xufSwgcTYgPSBmdW5jdGlvbih0LCBuLCByKSB7XG4gIHJldHVybiBtZShuKSA/ICEwIDogdCA9PT0gXCJob3Jpem9udGFsXCIgPyBuID09PSBcInlBeGlzXCIgOiB0ID09PSBcInZlcnRpY2FsXCIgfHwgciA9PT0gXCJ4XCIgPyBuID09PSBcInhBeGlzXCIgOiByID09PSBcInlcIiA/IG4gPT09IFwieUF4aXNcIiA6ICEwO1xufSwgRzAgPSBmdW5jdGlvbih0LCBuLCByLCBpLCBvKSB7XG4gIHZhciBhID0gbi5wcm9wcy5jaGlsZHJlbiwgcyA9IGt0KGEsIFpvKS5maWx0ZXIoZnVuY3Rpb24oYykge1xuICAgIHJldHVybiBxNihpLCBvLCBjLnByb3BzLmRpcmVjdGlvbik7XG4gIH0pO1xuICBpZiAocyAmJiBzLmxlbmd0aCkge1xuICAgIHZhciB1ID0gcy5tYXAoZnVuY3Rpb24oYykge1xuICAgICAgcmV0dXJuIGMucHJvcHMuZGF0YUtleTtcbiAgICB9KTtcbiAgICByZXR1cm4gdC5yZWR1Y2UoZnVuY3Rpb24oYywgZikge1xuICAgICAgdmFyIGwgPSBBdChmLCByKTtcbiAgICAgIGlmIChtZShsKSlcbiAgICAgICAgcmV0dXJuIGM7XG4gICAgICB2YXIgZCA9IEFycmF5LmlzQXJyYXkobCkgPyBbZXUobCksIFFzKGwpXSA6IFtsLCBsXSwgcCA9IHUucmVkdWNlKGZ1bmN0aW9uKGcsIGgpIHtcbiAgICAgICAgdmFyIHYgPSBBdChmLCBoLCAwKSwgdyA9IGRbMF0gLSBNYXRoLmFicyhBcnJheS5pc0FycmF5KHYpID8gdlswXSA6IHYpLCBiID0gZFsxXSArIE1hdGguYWJzKEFycmF5LmlzQXJyYXkodikgPyB2WzFdIDogdik7XG4gICAgICAgIHJldHVybiBbTWF0aC5taW4odywgZ1swXSksIE1hdGgubWF4KGIsIGdbMV0pXTtcbiAgICAgIH0sIFsxIC8gMCwgLTEgLyAwXSk7XG4gICAgICByZXR1cm4gW01hdGgubWluKHBbMF0sIGNbMF0pLCBNYXRoLm1heChwWzFdLCBjWzFdKV07XG4gICAgfSwgWzEgLyAwLCAtMSAvIDBdKTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn0sIEs2ID0gZnVuY3Rpb24odCwgbiwgciwgaSwgbykge1xuICB2YXIgYSA9IG4ubWFwKGZ1bmN0aW9uKHMpIHtcbiAgICByZXR1cm4gRzAodCwgcywgciwgbywgaSk7XG4gIH0pLmZpbHRlcihmdW5jdGlvbihzKSB7XG4gICAgcmV0dXJuICFtZShzKTtcbiAgfSk7XG4gIHJldHVybiBhICYmIGEubGVuZ3RoID8gYS5yZWR1Y2UoZnVuY3Rpb24ocywgdSkge1xuICAgIHJldHVybiBbTWF0aC5taW4oc1swXSwgdVswXSksIE1hdGgubWF4KHNbMV0sIHVbMV0pXTtcbiAgfSwgWzEgLyAwLCAtMSAvIDBdKSA6IG51bGw7XG59LCBXMCA9IGZ1bmN0aW9uKHQsIG4sIHIsIGksIG8pIHtcbiAgdmFyIGEgPSBuLm1hcChmdW5jdGlvbih1KSB7XG4gICAgdmFyIGMgPSB1LnByb3BzLmRhdGFLZXk7XG4gICAgcmV0dXJuIHIgPT09IFwibnVtYmVyXCIgJiYgYyAmJiBHMCh0LCB1LCBjLCBpKSB8fCBVaSh0LCBjLCByLCBvKTtcbiAgfSk7XG4gIGlmIChyID09PSBcIm51bWJlclwiKVxuICAgIHJldHVybiBhLnJlZHVjZShcbiAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgaWYgKHR5cGUgPT09IG51bWJlcikgbWVhbnMgdGhhdCB0aGUgZG9tYWluIGlzIG51bWVyaWNhbCB0eXBlXG4gICAgICAvLyAtIGJ1dCB0aGlzIGxpbmsgaXMgbWlzc2luZyBpbiB0aGUgdHlwZSBkZWZpbml0aW9uXG4gICAgICBmdW5jdGlvbih1LCBjKSB7XG4gICAgICAgIHJldHVybiBbTWF0aC5taW4odVswXSwgY1swXSksIE1hdGgubWF4KHVbMV0sIGNbMV0pXTtcbiAgICAgIH0sXG4gICAgICBbMSAvIDAsIC0xIC8gMF1cbiAgICApO1xuICB2YXIgcyA9IHt9O1xuICByZXR1cm4gYS5yZWR1Y2UoZnVuY3Rpb24odSwgYykge1xuICAgIGZvciAodmFyIGYgPSAwLCBsID0gYy5sZW5ndGg7IGYgPCBsOyBmKyspXG4gICAgICBzW2NbZl1dIHx8IChzW2NbZl1dID0gITAsIHUucHVzaChjW2ZdKSk7XG4gICAgcmV0dXJuIHU7XG4gIH0sIFtdKTtcbn0sIFUwID0gZnVuY3Rpb24odCwgbikge1xuICByZXR1cm4gdCA9PT0gXCJob3Jpem9udGFsXCIgJiYgbiA9PT0gXCJ4QXhpc1wiIHx8IHQgPT09IFwidmVydGljYWxcIiAmJiBuID09PSBcInlBeGlzXCIgfHwgdCA9PT0gXCJjZW50cmljXCIgJiYgbiA9PT0gXCJhbmdsZUF4aXNcIiB8fCB0ID09PSBcInJhZGlhbFwiICYmIG4gPT09IFwicmFkaXVzQXhpc1wiO1xufSwgSDAgPSBmdW5jdGlvbih0LCBuLCByLCBpKSB7XG4gIGlmIChpKVxuICAgIHJldHVybiB0Lm1hcChmdW5jdGlvbih1KSB7XG4gICAgICByZXR1cm4gdS5jb29yZGluYXRlO1xuICAgIH0pO1xuICB2YXIgbywgYSwgcyA9IHQubWFwKGZ1bmN0aW9uKHUpIHtcbiAgICByZXR1cm4gdS5jb29yZGluYXRlID09PSBuICYmIChvID0gITApLCB1LmNvb3JkaW5hdGUgPT09IHIgJiYgKGEgPSAhMCksIHUuY29vcmRpbmF0ZTtcbiAgfSk7XG4gIHJldHVybiBvIHx8IHMucHVzaChuKSwgYSB8fCBzLnB1c2gociksIHM7XG59LCBtbiA9IGZ1bmN0aW9uKHQsIG4sIHIpIHtcbiAgaWYgKCF0KVxuICAgIHJldHVybiBudWxsO1xuICB2YXIgaSA9IHQuc2NhbGUsIG8gPSB0LmR1cGxpY2F0ZURvbWFpbiwgYSA9IHQudHlwZSwgcyA9IHQucmFuZ2UsIHUgPSB0LnJlYWxTY2FsZVR5cGUgPT09IFwic2NhbGVCYW5kXCIgPyBpLmJhbmR3aWR0aCgpIC8gMiA6IDIsIGMgPSAobiB8fCByKSAmJiBhID09PSBcImNhdGVnb3J5XCIgJiYgaS5iYW5kd2lkdGggPyBpLmJhbmR3aWR0aCgpIC8gdSA6IDA7XG4gIGlmIChjID0gdC5heGlzVHlwZSA9PT0gXCJhbmdsZUF4aXNcIiAmJiAocyA9PSBudWxsID8gdm9pZCAwIDogcy5sZW5ndGgpID49IDIgPyBLdChzWzBdIC0gc1sxXSkgKiAyICogYyA6IGMsIG4gJiYgKHQudGlja3MgfHwgdC5uaWNlVGlja3MpKSB7XG4gICAgdmFyIGYgPSAodC50aWNrcyB8fCB0Lm5pY2VUaWNrcykubWFwKGZ1bmN0aW9uKGwpIHtcbiAgICAgIHZhciBkID0gbyA/IG8uaW5kZXhPZihsKSA6IGw7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAvLyBJZiB0aGUgc2NhbGVDb250ZW50IGlzIG5vdCBhIG51bWJlciwgdGhlIGNvb3JkaW5hdGUgd2lsbCBiZSBOYU4uXG4gICAgICAgIC8vIFRoYXQgY291bGQgYmUgdGhlIGNhc2UgZm9yIGV4YW1wbGUgd2l0aCBhIFBvaW50U2NhbGUgYW5kIGEgc3RyaW5nIGFzIGRvbWFpbi5cbiAgICAgICAgY29vcmRpbmF0ZTogaShkKSArIGMsXG4gICAgICAgIHZhbHVlOiBsLFxuICAgICAgICBvZmZzZXQ6IGNcbiAgICAgIH07XG4gICAgfSk7XG4gICAgcmV0dXJuIGYuZmlsdGVyKGZ1bmN0aW9uKGwpIHtcbiAgICAgIHJldHVybiAhV28obC5jb29yZGluYXRlKTtcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gdC5pc0NhdGVnb3JpY2FsICYmIHQuY2F0ZWdvcmljYWxEb21haW4gPyB0LmNhdGVnb3JpY2FsRG9tYWluLm1hcChmdW5jdGlvbihsLCBkKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNvb3JkaW5hdGU6IGkobCkgKyBjLFxuICAgICAgdmFsdWU6IGwsXG4gICAgICBpbmRleDogZCxcbiAgICAgIG9mZnNldDogY1xuICAgIH07XG4gIH0pIDogaS50aWNrcyAmJiAhciA/IGkudGlja3ModC50aWNrQ291bnQpLm1hcChmdW5jdGlvbihsKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNvb3JkaW5hdGU6IGkobCkgKyBjLFxuICAgICAgdmFsdWU6IGwsXG4gICAgICBvZmZzZXQ6IGNcbiAgICB9O1xuICB9KSA6IGkuZG9tYWluKCkubWFwKGZ1bmN0aW9uKGwsIGQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgY29vcmRpbmF0ZTogaShsKSArIGMsXG4gICAgICB2YWx1ZTogbyA/IG9bbF0gOiBsLFxuICAgICAgaW5kZXg6IGQsXG4gICAgICBvZmZzZXQ6IGNcbiAgICB9O1xuICB9KTtcbn0sIHF1ID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCksIG1hID0gZnVuY3Rpb24odCwgbikge1xuICBpZiAodHlwZW9mIG4gIT0gXCJmdW5jdGlvblwiKVxuICAgIHJldHVybiB0O1xuICBxdS5oYXModCkgfHwgcXUuc2V0KHQsIC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpKTtcbiAgdmFyIHIgPSBxdS5nZXQodCk7XG4gIGlmIChyLmhhcyhuKSlcbiAgICByZXR1cm4gci5nZXQobik7XG4gIHZhciBpID0gZnVuY3Rpb24oKSB7XG4gICAgdC5hcHBseSh2b2lkIDAsIGFyZ3VtZW50cyksIG4uYXBwbHkodm9pZCAwLCBhcmd1bWVudHMpO1xuICB9O1xuICByZXR1cm4gci5zZXQobiwgaSksIGk7XG59LCBZNiA9IGZ1bmN0aW9uKHQsIG4sIHIpIHtcbiAgdmFyIGkgPSB0LnNjYWxlLCBvID0gdC50eXBlLCBhID0gdC5sYXlvdXQsIHMgPSB0LmF4aXNUeXBlO1xuICBpZiAoaSA9PT0gXCJhdXRvXCIpXG4gICAgcmV0dXJuIGEgPT09IFwicmFkaWFsXCIgJiYgcyA9PT0gXCJyYWRpdXNBeGlzXCIgPyB7XG4gICAgICBzY2FsZTogc28oKSxcbiAgICAgIHJlYWxTY2FsZVR5cGU6IFwiYmFuZFwiXG4gICAgfSA6IGEgPT09IFwicmFkaWFsXCIgJiYgcyA9PT0gXCJhbmdsZUF4aXNcIiA/IHtcbiAgICAgIHNjYWxlOiBvcygpLFxuICAgICAgcmVhbFNjYWxlVHlwZTogXCJsaW5lYXJcIlxuICAgIH0gOiBvID09PSBcImNhdGVnb3J5XCIgJiYgbiAmJiAobi5pbmRleE9mKFwiTGluZUNoYXJ0XCIpID49IDAgfHwgbi5pbmRleE9mKFwiQXJlYUNoYXJ0XCIpID49IDAgfHwgbi5pbmRleE9mKFwiQ29tcG9zZWRDaGFydFwiKSA+PSAwICYmICFyKSA/IHtcbiAgICAgIHNjYWxlOiBXaSgpLFxuICAgICAgcmVhbFNjYWxlVHlwZTogXCJwb2ludFwiXG4gICAgfSA6IG8gPT09IFwiY2F0ZWdvcnlcIiA/IHtcbiAgICAgIHNjYWxlOiBzbygpLFxuICAgICAgcmVhbFNjYWxlVHlwZTogXCJiYW5kXCJcbiAgICB9IDoge1xuICAgICAgc2NhbGU6IG9zKCksXG4gICAgICByZWFsU2NhbGVUeXBlOiBcImxpbmVhclwiXG4gICAgfTtcbiAgaWYgKEdvKGkpKSB7XG4gICAgdmFyIHUgPSBcInNjYWxlXCIuY29uY2F0KEJzKGkpKTtcbiAgICByZXR1cm4ge1xuICAgICAgc2NhbGU6ICh2Z1t1XSB8fCBXaSkoKSxcbiAgICAgIHJlYWxTY2FsZVR5cGU6IHZnW3VdID8gdSA6IFwicG9pbnRcIlxuICAgIH07XG4gIH1cbiAgcmV0dXJuIHBlKGkpID8ge1xuICAgIHNjYWxlOiBpXG4gIH0gOiB7XG4gICAgc2NhbGU6IFdpKCksXG4gICAgcmVhbFNjYWxlVHlwZTogXCJwb2ludFwiXG4gIH07XG59LCBPZyA9IDFlLTQsIFg2ID0gZnVuY3Rpb24odCkge1xuICB2YXIgbiA9IHQuZG9tYWluKCk7XG4gIGlmICghKCFuIHx8IG4ubGVuZ3RoIDw9IDIpKSB7XG4gICAgdmFyIHIgPSBuLmxlbmd0aCwgaSA9IHQucmFuZ2UoKSwgbyA9IE1hdGgubWluKGlbMF0sIGlbMV0pIC0gT2csIGEgPSBNYXRoLm1heChpWzBdLCBpWzFdKSArIE9nLCBzID0gdChuWzBdKSwgdSA9IHQobltyIC0gMV0pO1xuICAgIChzIDwgbyB8fCBzID4gYSB8fCB1IDwgbyB8fCB1ID4gYSkgJiYgdC5kb21haW4oW25bMF0sIG5bciAtIDFdXSk7XG4gIH1cbn0sIFo2ID0gZnVuY3Rpb24odCwgbikge1xuICBpZiAoIXQpXG4gICAgcmV0dXJuIG51bGw7XG4gIGZvciAodmFyIHIgPSAwLCBpID0gdC5sZW5ndGg7IHIgPCBpOyByKyspXG4gICAgaWYgKHRbcl0uaXRlbSA9PT0gbilcbiAgICAgIHJldHVybiB0W3JdLnBvc2l0aW9uO1xuICByZXR1cm4gbnVsbDtcbn0sIEo2ID0gZnVuY3Rpb24odCwgbikge1xuICBpZiAoIW4gfHwgbi5sZW5ndGggIT09IDIgfHwgIUsoblswXSkgfHwgIUsoblsxXSkpXG4gICAgcmV0dXJuIHQ7XG4gIHZhciByID0gTWF0aC5taW4oblswXSwgblsxXSksIGkgPSBNYXRoLm1heChuWzBdLCBuWzFdKSwgbyA9IFt0WzBdLCB0WzFdXTtcbiAgcmV0dXJuICghSyh0WzBdKSB8fCB0WzBdIDwgcikgJiYgKG9bMF0gPSByKSwgKCFLKHRbMV0pIHx8IHRbMV0gPiBpKSAmJiAob1sxXSA9IGkpLCBvWzBdID4gaSAmJiAob1swXSA9IGkpLCBvWzFdIDwgciAmJiAob1sxXSA9IHIpLCBvO1xufSwgUTYgPSBmdW5jdGlvbih0KSB7XG4gIHZhciBuID0gdC5sZW5ndGg7XG4gIGlmICghKG4gPD0gMCkpXG4gICAgZm9yICh2YXIgciA9IDAsIGkgPSB0WzBdLmxlbmd0aDsgciA8IGk7ICsrcilcbiAgICAgIGZvciAodmFyIG8gPSAwLCBhID0gMCwgcyA9IDA7IHMgPCBuOyArK3MpIHtcbiAgICAgICAgdmFyIHUgPSBXbyh0W3NdW3JdWzFdKSA/IHRbc11bcl1bMF0gOiB0W3NdW3JdWzFdO1xuICAgICAgICB1ID49IDAgPyAodFtzXVtyXVswXSA9IG8sIHRbc11bcl1bMV0gPSBvICsgdSwgbyA9IHRbc11bcl1bMV0pIDogKHRbc11bcl1bMF0gPSBhLCB0W3NdW3JdWzFdID0gYSArIHUsIGEgPSB0W3NdW3JdWzFdKTtcbiAgICAgIH1cbn0sIGU4ID0gZnVuY3Rpb24odCkge1xuICB2YXIgbiA9IHQubGVuZ3RoO1xuICBpZiAoIShuIDw9IDApKVxuICAgIGZvciAodmFyIHIgPSAwLCBpID0gdFswXS5sZW5ndGg7IHIgPCBpOyArK3IpXG4gICAgICBmb3IgKHZhciBvID0gMCwgYSA9IDA7IGEgPCBuOyArK2EpIHtcbiAgICAgICAgdmFyIHMgPSBXbyh0W2FdW3JdWzFdKSA/IHRbYV1bcl1bMF0gOiB0W2FdW3JdWzFdO1xuICAgICAgICBzID49IDAgPyAodFthXVtyXVswXSA9IG8sIHRbYV1bcl1bMV0gPSBvICsgcywgbyA9IHRbYV1bcl1bMV0pIDogKHRbYV1bcl1bMF0gPSAwLCB0W2FdW3JdWzFdID0gMCk7XG4gICAgICB9XG59LCB0OCA9IHtcbiAgc2lnbjogUTYsXG4gIC8vIEB0cy1leHBlY3QtZXJyb3IgZGVmaW5pdGVseXR5cGVkIHR5cGVzIGFyZSBpbmNvcnJlY3RcbiAgZXhwYW5kOiBJVCxcbiAgLy8gQHRzLWV4cGVjdC1lcnJvciBkZWZpbml0ZWx5dHlwZWQgdHlwZXMgYXJlIGluY29ycmVjdFxuICBub25lOiBMcixcbiAgLy8gQHRzLWV4cGVjdC1lcnJvciBkZWZpbml0ZWx5dHlwZWQgdHlwZXMgYXJlIGluY29ycmVjdFxuICBzaWxob3VldHRlOiBqVCxcbiAgLy8gQHRzLWV4cGVjdC1lcnJvciBkZWZpbml0ZWx5dHlwZWQgdHlwZXMgYXJlIGluY29ycmVjdFxuICB3aWdnbGU6IGtULFxuICBwb3NpdGl2ZTogZThcbn0sIG44ID0gZnVuY3Rpb24odCwgbiwgcikge1xuICB2YXIgaSA9IG4ubWFwKGZ1bmN0aW9uKHMpIHtcbiAgICByZXR1cm4gcy5wcm9wcy5kYXRhS2V5O1xuICB9KSwgbyA9IHQ4W3JdLCBhID0gUlQoKS5rZXlzKGkpLnZhbHVlKGZ1bmN0aW9uKHMsIHUpIHtcbiAgICByZXR1cm4gK0F0KHMsIHUsIDApO1xuICB9KS5vcmRlcihGYykub2Zmc2V0KG8pO1xuICByZXR1cm4gYSh0KTtcbn0sIHI4ID0gZnVuY3Rpb24odCwgbiwgciwgaSwgbywgYSkge1xuICBpZiAoIXQpXG4gICAgcmV0dXJuIG51bGw7XG4gIHZhciBzID0gYSA/IG4ucmV2ZXJzZSgpIDogbiwgdSA9IHt9LCBjID0gcy5yZWR1Y2UoZnVuY3Rpb24obCwgZCkge1xuICAgIHZhciBwID0gZC5wcm9wcywgZyA9IHAuc3RhY2tJZCwgaCA9IHAuaGlkZTtcbiAgICBpZiAoaClcbiAgICAgIHJldHVybiBsO1xuICAgIHZhciB2ID0gZC5wcm9wc1tyXSwgdyA9IGxbdl0gfHwge1xuICAgICAgaGFzU3RhY2s6ICExLFxuICAgICAgc3RhY2tHcm91cHM6IHt9XG4gICAgfTtcbiAgICBpZiAoS2UoZykpIHtcbiAgICAgIHZhciBiID0gdy5zdGFja0dyb3Vwc1tnXSB8fCB7XG4gICAgICAgIG51bWVyaWNBeGlzSWQ6IHIsXG4gICAgICAgIGNhdGVBeGlzSWQ6IGksXG4gICAgICAgIGl0ZW1zOiBbXVxuICAgICAgfTtcbiAgICAgIGIuaXRlbXMucHVzaChkKSwgdy5oYXNTdGFjayA9ICEwLCB3LnN0YWNrR3JvdXBzW2ddID0gYjtcbiAgICB9IGVsc2VcbiAgICAgIHcuc3RhY2tHcm91cHNbVW8oXCJfc3RhY2tJZF9cIildID0ge1xuICAgICAgICBudW1lcmljQXhpc0lkOiByLFxuICAgICAgICBjYXRlQXhpc0lkOiBpLFxuICAgICAgICBpdGVtczogW2RdXG4gICAgICB9O1xuICAgIHJldHVybiBSdChSdCh7fSwgbCksIHt9LCBqcih7fSwgdiwgdykpO1xuICB9LCB1KSwgZiA9IHt9O1xuICByZXR1cm4gT2JqZWN0LmtleXMoYykucmVkdWNlKGZ1bmN0aW9uKGwsIGQpIHtcbiAgICB2YXIgcCA9IGNbZF07XG4gICAgaWYgKHAuaGFzU3RhY2spIHtcbiAgICAgIHZhciBnID0ge307XG4gICAgICBwLnN0YWNrR3JvdXBzID0gT2JqZWN0LmtleXMocC5zdGFja0dyb3VwcykucmVkdWNlKGZ1bmN0aW9uKGgsIHYpIHtcbiAgICAgICAgdmFyIHcgPSBwLnN0YWNrR3JvdXBzW3ZdO1xuICAgICAgICByZXR1cm4gUnQoUnQoe30sIGgpLCB7fSwganIoe30sIHYsIHtcbiAgICAgICAgICBudW1lcmljQXhpc0lkOiByLFxuICAgICAgICAgIGNhdGVBeGlzSWQ6IGksXG4gICAgICAgICAgaXRlbXM6IHcuaXRlbXMsXG4gICAgICAgICAgc3RhY2tlZERhdGE6IG44KHQsIHcuaXRlbXMsIG8pXG4gICAgICAgIH0pKTtcbiAgICAgIH0sIGcpO1xuICAgIH1cbiAgICByZXR1cm4gUnQoUnQoe30sIGwpLCB7fSwganIoe30sIGQsIHApKTtcbiAgfSwgZik7XG59LCBpOCA9IGZ1bmN0aW9uKHQsIG4pIHtcbiAgdmFyIHIgPSBuLnJlYWxTY2FsZVR5cGUsIGkgPSBuLnR5cGUsIG8gPSBuLnRpY2tDb3VudCwgYSA9IG4ub3JpZ2luYWxEb21haW4sIHMgPSBuLmFsbG93RGVjaW1hbHMsIHUgPSByIHx8IG4uc2NhbGU7XG4gIGlmICh1ICE9PSBcImF1dG9cIiAmJiB1ICE9PSBcImxpbmVhclwiKVxuICAgIHJldHVybiBudWxsO1xuICBpZiAobyAmJiBpID09PSBcIm51bWJlclwiICYmIGEgJiYgKGFbMF0gPT09IFwiYXV0b1wiIHx8IGFbMV0gPT09IFwiYXV0b1wiKSkge1xuICAgIHZhciBjID0gdC5kb21haW4oKTtcbiAgICBpZiAoIWMubGVuZ3RoKVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgdmFyIGYgPSAkNihjLCBvLCBzKTtcbiAgICByZXR1cm4gdC5kb21haW4oW2V1KGYpLCBRcyhmKV0pLCB7XG4gICAgICBuaWNlVGlja3M6IGZcbiAgICB9O1xuICB9XG4gIGlmIChvICYmIGkgPT09IFwibnVtYmVyXCIpIHtcbiAgICB2YXIgbCA9IHQuZG9tYWluKCksIGQgPSBPNihsLCBvLCBzKTtcbiAgICByZXR1cm4ge1xuICAgICAgbmljZVRpY2tzOiBkXG4gICAgfTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn07XG5mdW5jdGlvbiBfZyhlKSB7XG4gIHZhciB0ID0gZS5heGlzLCBuID0gZS50aWNrcywgciA9IGUuYmFuZFNpemUsIGkgPSBlLmVudHJ5LCBvID0gZS5pbmRleCwgYSA9IGUuZGF0YUtleTtcbiAgaWYgKHQudHlwZSA9PT0gXCJjYXRlZ29yeVwiKSB7XG4gICAgaWYgKCF0LmFsbG93RHVwbGljYXRlZENhdGVnb3J5ICYmIHQuZGF0YUtleSAmJiAhbWUoaVt0LmRhdGFLZXldKSkge1xuICAgICAgdmFyIHMgPSBEYShuLCBcInZhbHVlXCIsIGlbdC5kYXRhS2V5XSk7XG4gICAgICBpZiAocylcbiAgICAgICAgcmV0dXJuIHMuY29vcmRpbmF0ZSArIHIgLyAyO1xuICAgIH1cbiAgICByZXR1cm4gbltvXSA/IG5bb10uY29vcmRpbmF0ZSArIHIgLyAyIDogbnVsbDtcbiAgfVxuICB2YXIgdSA9IEF0KGksIG1lKGEpID8gdC5kYXRhS2V5IDogYSk7XG4gIHJldHVybiBtZSh1KSA/IG51bGwgOiB0LnNjYWxlKHUpO1xufVxudmFyIEFnID0gZnVuY3Rpb24odCkge1xuICB2YXIgbiA9IHQuYXhpcywgciA9IHQudGlja3MsIGkgPSB0Lm9mZnNldCwgbyA9IHQuYmFuZFNpemUsIGEgPSB0LmVudHJ5LCBzID0gdC5pbmRleDtcbiAgaWYgKG4udHlwZSA9PT0gXCJjYXRlZ29yeVwiKVxuICAgIHJldHVybiByW3NdID8gcltzXS5jb29yZGluYXRlICsgaSA6IG51bGw7XG4gIHZhciB1ID0gQXQoYSwgbi5kYXRhS2V5LCBuLmRvbWFpbltzXSk7XG4gIHJldHVybiBtZSh1KSA/IG51bGwgOiBuLnNjYWxlKHUpIC0gbyAvIDIgKyBpO1xufSwgbzggPSBmdW5jdGlvbih0KSB7XG4gIHZhciBuID0gdC5udW1lcmljQXhpcywgciA9IG4uc2NhbGUuZG9tYWluKCk7XG4gIGlmIChuLnR5cGUgPT09IFwibnVtYmVyXCIpIHtcbiAgICB2YXIgaSA9IE1hdGgubWluKHJbMF0sIHJbMV0pLCBvID0gTWF0aC5tYXgoclswXSwgclsxXSk7XG4gICAgcmV0dXJuIGkgPD0gMCAmJiBvID49IDAgPyAwIDogbyA8IDAgPyBvIDogaTtcbiAgfVxuICByZXR1cm4gclswXTtcbn0sIGE4ID0gZnVuY3Rpb24odCwgbikge1xuICB2YXIgciA9IHQucHJvcHMuc3RhY2tJZDtcbiAgaWYgKEtlKHIpKSB7XG4gICAgdmFyIGkgPSBuW3JdO1xuICAgIGlmIChpKSB7XG4gICAgICB2YXIgbyA9IGkuaXRlbXMuaW5kZXhPZih0KTtcbiAgICAgIHJldHVybiBvID49IDAgPyBpLnN0YWNrZWREYXRhW29dIDogbnVsbDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59LCBzOCA9IGZ1bmN0aW9uKHQpIHtcbiAgcmV0dXJuIHQucmVkdWNlKGZ1bmN0aW9uKG4sIHIpIHtcbiAgICByZXR1cm4gW2V1KHIuY29uY2F0KFtuWzBdXSkuZmlsdGVyKEspKSwgUXMoci5jb25jYXQoW25bMV1dKS5maWx0ZXIoSykpXTtcbiAgfSwgWzEgLyAwLCAtMSAvIDBdKTtcbn0sIHEwID0gZnVuY3Rpb24odCwgbiwgcikge1xuICByZXR1cm4gT2JqZWN0LmtleXModCkucmVkdWNlKGZ1bmN0aW9uKGksIG8pIHtcbiAgICB2YXIgYSA9IHRbb10sIHMgPSBhLnN0YWNrZWREYXRhLCB1ID0gcy5yZWR1Y2UoZnVuY3Rpb24oYywgZikge1xuICAgICAgdmFyIGwgPSBzOChmLnNsaWNlKG4sIHIgKyAxKSk7XG4gICAgICByZXR1cm4gW01hdGgubWluKGNbMF0sIGxbMF0pLCBNYXRoLm1heChjWzFdLCBsWzFdKV07XG4gICAgfSwgWzEgLyAwLCAtMSAvIDBdKTtcbiAgICByZXR1cm4gW01hdGgubWluKHVbMF0sIGlbMF0pLCBNYXRoLm1heCh1WzFdLCBpWzFdKV07XG4gIH0sIFsxIC8gMCwgLTEgLyAwXSkubWFwKGZ1bmN0aW9uKGkpIHtcbiAgICByZXR1cm4gaSA9PT0gMSAvIDAgfHwgaSA9PT0gLTEgLyAwID8gMCA6IGk7XG4gIH0pO1xufSwgUGcgPSAvXmRhdGFNaW5bXFxzXSotW1xcc10qKFswLTldKyhbLl17MX1bMC05XSspezAsMX0pJC8sIENnID0gL15kYXRhTWF4W1xcc10qXFwrW1xcc10qKFswLTldKyhbLl17MX1bMC05XSspezAsMX0pJC8sIGhsID0gZnVuY3Rpb24odCwgbiwgcikge1xuICBpZiAocGUodCkpXG4gICAgcmV0dXJuIHQobiwgcik7XG4gIGlmICghQXJyYXkuaXNBcnJheSh0KSlcbiAgICByZXR1cm4gbjtcbiAgdmFyIGkgPSBbXTtcbiAgaWYgKEsodFswXSkpXG4gICAgaVswXSA9IHIgPyB0WzBdIDogTWF0aC5taW4odFswXSwgblswXSk7XG4gIGVsc2UgaWYgKFBnLnRlc3QodFswXSkpIHtcbiAgICB2YXIgbyA9ICtQZy5leGVjKHRbMF0pWzFdO1xuICAgIGlbMF0gPSBuWzBdIC0gbztcbiAgfSBlbHNlXG4gICAgcGUodFswXSkgPyBpWzBdID0gdFswXShuWzBdKSA6IGlbMF0gPSBuWzBdO1xuICBpZiAoSyh0WzFdKSlcbiAgICBpWzFdID0gciA/IHRbMV0gOiBNYXRoLm1heCh0WzFdLCBuWzFdKTtcbiAgZWxzZSBpZiAoQ2cudGVzdCh0WzFdKSkge1xuICAgIHZhciBhID0gK0NnLmV4ZWModFsxXSlbMV07XG4gICAgaVsxXSA9IG5bMV0gKyBhO1xuICB9IGVsc2VcbiAgICBwZSh0WzFdKSA/IGlbMV0gPSB0WzFdKG5bMV0pIDogaVsxXSA9IG5bMV07XG4gIHJldHVybiBpO1xufSwgZnMgPSBmdW5jdGlvbih0LCBuLCByKSB7XG4gIGlmICh0ICYmIHQuc2NhbGUgJiYgdC5zY2FsZS5iYW5kd2lkdGgpIHtcbiAgICB2YXIgaSA9IHQuc2NhbGUuYmFuZHdpZHRoKCk7XG4gICAgaWYgKCFyIHx8IGkgPiAwKVxuICAgICAgcmV0dXJuIGk7XG4gIH1cbiAgaWYgKHQgJiYgbiAmJiBuLmxlbmd0aCA+PSAyKSB7XG4gICAgZm9yICh2YXIgbyA9IEZmKG4sIGZ1bmN0aW9uKGwpIHtcbiAgICAgIHJldHVybiBsLmNvb3JkaW5hdGU7XG4gICAgfSksIGEgPSAxIC8gMCwgcyA9IDEsIHUgPSBvLmxlbmd0aDsgcyA8IHU7IHMrKykge1xuICAgICAgdmFyIGMgPSBvW3NdLCBmID0gb1tzIC0gMV07XG4gICAgICBhID0gTWF0aC5taW4oKGMuY29vcmRpbmF0ZSB8fCAwKSAtIChmLmNvb3JkaW5hdGUgfHwgMCksIGEpO1xuICAgIH1cbiAgICByZXR1cm4gYSA9PT0gMSAvIDAgPyAwIDogYTtcbiAgfVxuICByZXR1cm4gciA/IHZvaWQgMCA6IDA7XG59LCBFZyA9IGZ1bmN0aW9uKHQsIG4sIHIpIHtcbiAgcmV0dXJuICF0IHx8ICF0Lmxlbmd0aCB8fCB0dSh0LCBqdChyLCBcInR5cGUuZGVmYXVsdFByb3BzLmRvbWFpblwiKSkgPyBuIDogdDtcbn0sIEswID0gZnVuY3Rpb24odCwgbikge1xuICB2YXIgciA9IHQucHJvcHMsIGkgPSByLmRhdGFLZXksIG8gPSByLm5hbWUsIGEgPSByLnVuaXQsIHMgPSByLmZvcm1hdHRlciwgdSA9IHIudG9vbHRpcFR5cGUsIGMgPSByLmNoYXJ0VHlwZSwgZiA9IHIuaGlkZTtcbiAgcmV0dXJuIFJ0KFJ0KHt9LCB5ZSh0LCAhMSkpLCB7fSwge1xuICAgIGRhdGFLZXk6IGksXG4gICAgdW5pdDogYSxcbiAgICBmb3JtYXR0ZXI6IHMsXG4gICAgbmFtZTogbyB8fCBpLFxuICAgIGNvbG9yOiBsZCh0KSxcbiAgICB2YWx1ZTogQXQobiwgaSksXG4gICAgdHlwZTogdSxcbiAgICBwYXlsb2FkOiBuLFxuICAgIGNoYXJ0VHlwZTogYyxcbiAgICBoaWRlOiBmXG4gIH0pO1xufTtcbmZ1bmN0aW9uIG1vKGUpIHtcbiAgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiO1xuICByZXR1cm4gbW8gPSB0eXBlb2YgU3ltYm9sID09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09IFwic3ltYm9sXCIgPyBmdW5jdGlvbih0KSB7XG4gICAgcmV0dXJuIHR5cGVvZiB0O1xuICB9IDogZnVuY3Rpb24odCkge1xuICAgIHJldHVybiB0ICYmIHR5cGVvZiBTeW1ib2wgPT0gXCJmdW5jdGlvblwiICYmIHQuY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiB0ICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiB0O1xuICB9LCBtbyhlKTtcbn1cbmZ1bmN0aW9uIFRnKGUsIHQpIHtcbiAgdmFyIG4gPSBPYmplY3Qua2V5cyhlKTtcbiAgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcbiAgICB2YXIgciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZSk7XG4gICAgdCAmJiAociA9IHIuZmlsdGVyKGZ1bmN0aW9uKGkpIHtcbiAgICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsIGkpLmVudW1lcmFibGU7XG4gICAgfSkpLCBuLnB1c2guYXBwbHkobiwgcik7XG4gIH1cbiAgcmV0dXJuIG47XG59XG5mdW5jdGlvbiBNZyhlKSB7XG4gIGZvciAodmFyIHQgPSAxOyB0IDwgYXJndW1lbnRzLmxlbmd0aDsgdCsrKSB7XG4gICAgdmFyIG4gPSBhcmd1bWVudHNbdF0gIT0gbnVsbCA/IGFyZ3VtZW50c1t0XSA6IHt9O1xuICAgIHQgJSAyID8gVGcoT2JqZWN0KG4pLCAhMCkuZm9yRWFjaChmdW5jdGlvbihyKSB7XG4gICAgICB1OChlLCByLCBuW3JdKTtcbiAgICB9KSA6IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoZSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMobikpIDogVGcoT2JqZWN0KG4pKS5mb3JFYWNoKGZ1bmN0aW9uKHIpIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCByLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG4sIHIpKTtcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gZTtcbn1cbmZ1bmN0aW9uIHU4KGUsIHQsIG4pIHtcbiAgcmV0dXJuIHQgPSBjOCh0KSwgdCBpbiBlID8gT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIHQsIHsgdmFsdWU6IG4sIGVudW1lcmFibGU6ICEwLCBjb25maWd1cmFibGU6ICEwLCB3cml0YWJsZTogITAgfSkgOiBlW3RdID0gbiwgZTtcbn1cbmZ1bmN0aW9uIGM4KGUpIHtcbiAgdmFyIHQgPSBsOChlLCBcInN0cmluZ1wiKTtcbiAgcmV0dXJuIG1vKHQpID09IFwic3ltYm9sXCIgPyB0IDogU3RyaW5nKHQpO1xufVxuZnVuY3Rpb24gbDgoZSwgdCkge1xuICBpZiAobW8oZSkgIT0gXCJvYmplY3RcIiB8fCAhZSlcbiAgICByZXR1cm4gZTtcbiAgdmFyIG4gPSBlW1N5bWJvbC50b1ByaW1pdGl2ZV07XG4gIGlmIChuICE9PSB2b2lkIDApIHtcbiAgICB2YXIgciA9IG4uY2FsbChlLCB0IHx8IFwiZGVmYXVsdFwiKTtcbiAgICBpZiAobW8ocikgIT0gXCJvYmplY3RcIilcbiAgICAgIHJldHVybiByO1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJAQHRvUHJpbWl0aXZlIG11c3QgcmV0dXJuIGEgcHJpbWl0aXZlIHZhbHVlLlwiKTtcbiAgfVxuICByZXR1cm4gKHQgPT09IFwic3RyaW5nXCIgPyBTdHJpbmcgOiBOdW1iZXIpKGUpO1xufVxudmFyIGRzID0gTWF0aC5QSSAvIDE4MCwgZjggPSBmdW5jdGlvbih0KSB7XG4gIHJldHVybiB0ICogMTgwIC8gTWF0aC5QSTtcbn0sIG50ID0gZnVuY3Rpb24odCwgbiwgciwgaSkge1xuICByZXR1cm4ge1xuICAgIHg6IHQgKyBNYXRoLmNvcygtZHMgKiBpKSAqIHIsXG4gICAgeTogbiArIE1hdGguc2luKC1kcyAqIGkpICogclxuICB9O1xufSwgZDggPSBmdW5jdGlvbih0LCBuKSB7XG4gIHZhciByID0gdC54LCBpID0gdC55LCBvID0gbi54LCBhID0gbi55O1xuICByZXR1cm4gTWF0aC5zcXJ0KE1hdGgucG93KHIgLSBvLCAyKSArIE1hdGgucG93KGkgLSBhLCAyKSk7XG59LCBwOCA9IGZ1bmN0aW9uKHQsIG4pIHtcbiAgdmFyIHIgPSB0LngsIGkgPSB0LnksIG8gPSBuLmN4LCBhID0gbi5jeSwgcyA9IGQ4KHtcbiAgICB4OiByLFxuICAgIHk6IGlcbiAgfSwge1xuICAgIHg6IG8sXG4gICAgeTogYVxuICB9KTtcbiAgaWYgKHMgPD0gMClcbiAgICByZXR1cm4ge1xuICAgICAgcmFkaXVzOiBzXG4gICAgfTtcbiAgdmFyIHUgPSAociAtIG8pIC8gcywgYyA9IE1hdGguYWNvcyh1KTtcbiAgcmV0dXJuIGkgPiBhICYmIChjID0gMiAqIE1hdGguUEkgLSBjKSwge1xuICAgIHJhZGl1czogcyxcbiAgICBhbmdsZTogZjgoYyksXG4gICAgYW5nbGVJblJhZGlhbjogY1xuICB9O1xufSwgaDggPSBmdW5jdGlvbih0KSB7XG4gIHZhciBuID0gdC5zdGFydEFuZ2xlLCByID0gdC5lbmRBbmdsZSwgaSA9IE1hdGguZmxvb3IobiAvIDM2MCksIG8gPSBNYXRoLmZsb29yKHIgLyAzNjApLCBhID0gTWF0aC5taW4oaSwgbyk7XG4gIHJldHVybiB7XG4gICAgc3RhcnRBbmdsZTogbiAtIGEgKiAzNjAsXG4gICAgZW5kQW5nbGU6IHIgLSBhICogMzYwXG4gIH07XG59LCBnOCA9IGZ1bmN0aW9uKHQsIG4pIHtcbiAgdmFyIHIgPSBuLnN0YXJ0QW5nbGUsIGkgPSBuLmVuZEFuZ2xlLCBvID0gTWF0aC5mbG9vcihyIC8gMzYwKSwgYSA9IE1hdGguZmxvb3IoaSAvIDM2MCksIHMgPSBNYXRoLm1pbihvLCBhKTtcbiAgcmV0dXJuIHQgKyBzICogMzYwO1xufSwgUmcgPSBmdW5jdGlvbih0LCBuKSB7XG4gIHZhciByID0gdC54LCBpID0gdC55LCBvID0gcDgoe1xuICAgIHg6IHIsXG4gICAgeTogaVxuICB9LCBuKSwgYSA9IG8ucmFkaXVzLCBzID0gby5hbmdsZSwgdSA9IG4uaW5uZXJSYWRpdXMsIGMgPSBuLm91dGVyUmFkaXVzO1xuICBpZiAoYSA8IHUgfHwgYSA+IGMpXG4gICAgcmV0dXJuICExO1xuICBpZiAoYSA9PT0gMClcbiAgICByZXR1cm4gITA7XG4gIHZhciBmID0gaDgobiksIGwgPSBmLnN0YXJ0QW5nbGUsIGQgPSBmLmVuZEFuZ2xlLCBwID0gcywgZztcbiAgaWYgKGwgPD0gZCkge1xuICAgIGZvciAoOyBwID4gZDsgKVxuICAgICAgcCAtPSAzNjA7XG4gICAgZm9yICg7IHAgPCBsOyApXG4gICAgICBwICs9IDM2MDtcbiAgICBnID0gcCA+PSBsICYmIHAgPD0gZDtcbiAgfSBlbHNlIHtcbiAgICBmb3IgKDsgcCA+IGw7IClcbiAgICAgIHAgLT0gMzYwO1xuICAgIGZvciAoOyBwIDwgZDsgKVxuICAgICAgcCArPSAzNjA7XG4gICAgZyA9IHAgPj0gZCAmJiBwIDw9IGw7XG4gIH1cbiAgcmV0dXJuIGcgPyBNZyhNZyh7fSwgbiksIHt9LCB7XG4gICAgcmFkaXVzOiBhLFxuICAgIGFuZ2xlOiBnOChwLCBuKVxuICB9KSA6IG51bGw7XG59O1xuZnVuY3Rpb24geW8oZSkge1xuICBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7XG4gIHJldHVybiB5byA9IHR5cGVvZiBTeW1ib2wgPT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uKHQpIHtcbiAgICByZXR1cm4gdHlwZW9mIHQ7XG4gIH0gOiBmdW5jdGlvbih0KSB7XG4gICAgcmV0dXJuIHQgJiYgdHlwZW9mIFN5bWJvbCA9PSBcImZ1bmN0aW9uXCIgJiYgdC5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIHQgIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIHQ7XG4gIH0sIHlvKGUpO1xufVxudmFyIHY4ID0gW1wib2Zmc2V0XCJdO1xuZnVuY3Rpb24gbTgoZSkge1xuICByZXR1cm4geDgoZSkgfHwgdzgoZSkgfHwgYjgoZSkgfHwgeTgoKTtcbn1cbmZ1bmN0aW9uIHk4KCkge1xuICB0aHJvdyBuZXcgVHlwZUVycm9yKGBJbnZhbGlkIGF0dGVtcHQgdG8gc3ByZWFkIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5gKTtcbn1cbmZ1bmN0aW9uIGI4KGUsIHQpIHtcbiAgaWYgKGUpIHtcbiAgICBpZiAodHlwZW9mIGUgPT0gXCJzdHJpbmdcIilcbiAgICAgIHJldHVybiBnbChlLCB0KTtcbiAgICB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChlKS5zbGljZSg4LCAtMSk7XG4gICAgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgZS5jb25zdHJ1Y3RvciAmJiAobiA9IGUuY29uc3RydWN0b3IubmFtZSksIG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIilcbiAgICAgIHJldHVybiBBcnJheS5mcm9tKGUpO1xuICAgIGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKVxuICAgICAgcmV0dXJuIGdsKGUsIHQpO1xuICB9XG59XG5mdW5jdGlvbiB3OChlKSB7XG4gIGlmICh0eXBlb2YgU3ltYm9sIDwgXCJ1XCIgJiYgZVtTeW1ib2wuaXRlcmF0b3JdICE9IG51bGwgfHwgZVtcIkBAaXRlcmF0b3JcIl0gIT0gbnVsbClcbiAgICByZXR1cm4gQXJyYXkuZnJvbShlKTtcbn1cbmZ1bmN0aW9uIHg4KGUpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoZSkpXG4gICAgcmV0dXJuIGdsKGUpO1xufVxuZnVuY3Rpb24gZ2woZSwgdCkge1xuICAodCA9PSBudWxsIHx8IHQgPiBlLmxlbmd0aCkgJiYgKHQgPSBlLmxlbmd0aCk7XG4gIGZvciAodmFyIG4gPSAwLCByID0gbmV3IEFycmF5KHQpOyBuIDwgdDsgbisrKVxuICAgIHJbbl0gPSBlW25dO1xuICByZXR1cm4gcjtcbn1cbmZ1bmN0aW9uIFM4KGUsIHQpIHtcbiAgaWYgKGUgPT0gbnVsbClcbiAgICByZXR1cm4ge307XG4gIHZhciBuID0gJDgoZSwgdCksIHIsIGk7XG4gIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gICAgdmFyIG8gPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGUpO1xuICAgIGZvciAoaSA9IDA7IGkgPCBvLmxlbmd0aDsgaSsrKVxuICAgICAgciA9IG9baV0sICEodC5pbmRleE9mKHIpID49IDApICYmIE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChlLCByKSAmJiAobltyXSA9IGVbcl0pO1xuICB9XG4gIHJldHVybiBuO1xufVxuZnVuY3Rpb24gJDgoZSwgdCkge1xuICBpZiAoZSA9PSBudWxsKVxuICAgIHJldHVybiB7fTtcbiAgdmFyIG4gPSB7fSwgciA9IE9iamVjdC5rZXlzKGUpLCBpLCBvO1xuICBmb3IgKG8gPSAwOyBvIDwgci5sZW5ndGg7IG8rKylcbiAgICBpID0gcltvXSwgISh0LmluZGV4T2YoaSkgPj0gMCkgJiYgKG5baV0gPSBlW2ldKTtcbiAgcmV0dXJuIG47XG59XG5mdW5jdGlvbiBJZyhlLCB0KSB7XG4gIHZhciBuID0gT2JqZWN0LmtleXMoZSk7XG4gIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gICAgdmFyIHIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGUpO1xuICAgIHQgJiYgKHIgPSByLmZpbHRlcihmdW5jdGlvbihpKSB7XG4gICAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLCBpKS5lbnVtZXJhYmxlO1xuICAgIH0pKSwgbi5wdXNoLmFwcGx5KG4sIHIpO1xuICB9XG4gIHJldHVybiBuO1xufVxuZnVuY3Rpb24gcWUoZSkge1xuICBmb3IgKHZhciB0ID0gMTsgdCA8IGFyZ3VtZW50cy5sZW5ndGg7IHQrKykge1xuICAgIHZhciBuID0gYXJndW1lbnRzW3RdICE9IG51bGwgPyBhcmd1bWVudHNbdF0gOiB7fTtcbiAgICB0ICUgMiA/IElnKE9iamVjdChuKSwgITApLmZvckVhY2goZnVuY3Rpb24ocikge1xuICAgICAgTzgoZSwgciwgbltyXSk7XG4gICAgfSkgOiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGUsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKG4pKSA6IElnKE9iamVjdChuKSkuZm9yRWFjaChmdW5jdGlvbihyKSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgciwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihuLCByKSk7XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIGU7XG59XG5mdW5jdGlvbiBPOChlLCB0LCBuKSB7XG4gIHJldHVybiB0ID0gXzgodCksIHQgaW4gZSA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCB0LCB7IHZhbHVlOiBuLCBlbnVtZXJhYmxlOiAhMCwgY29uZmlndXJhYmxlOiAhMCwgd3JpdGFibGU6ICEwIH0pIDogZVt0XSA9IG4sIGU7XG59XG5mdW5jdGlvbiBfOChlKSB7XG4gIHZhciB0ID0gQTgoZSwgXCJzdHJpbmdcIik7XG4gIHJldHVybiB5byh0KSA9PSBcInN5bWJvbFwiID8gdCA6IFN0cmluZyh0KTtcbn1cbmZ1bmN0aW9uIEE4KGUsIHQpIHtcbiAgaWYgKHlvKGUpICE9IFwib2JqZWN0XCIgfHwgIWUpXG4gICAgcmV0dXJuIGU7XG4gIHZhciBuID0gZVtTeW1ib2wudG9QcmltaXRpdmVdO1xuICBpZiAobiAhPT0gdm9pZCAwKSB7XG4gICAgdmFyIHIgPSBuLmNhbGwoZSwgdCB8fCBcImRlZmF1bHRcIik7XG4gICAgaWYgKHlvKHIpICE9IFwib2JqZWN0XCIpXG4gICAgICByZXR1cm4gcjtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQEB0b1ByaW1pdGl2ZSBtdXN0IHJldHVybiBhIHByaW1pdGl2ZSB2YWx1ZS5cIik7XG4gIH1cbiAgcmV0dXJuICh0ID09PSBcInN0cmluZ1wiID8gU3RyaW5nIDogTnVtYmVyKShlKTtcbn1cbmZ1bmN0aW9uIGJvKCkge1xuICByZXR1cm4gYm8gPSBPYmplY3QuYXNzaWduID8gT2JqZWN0LmFzc2lnbi5iaW5kKCkgOiBmdW5jdGlvbihlKSB7XG4gICAgZm9yICh2YXIgdCA9IDE7IHQgPCBhcmd1bWVudHMubGVuZ3RoOyB0KyspIHtcbiAgICAgIHZhciBuID0gYXJndW1lbnRzW3RdO1xuICAgICAgZm9yICh2YXIgciBpbiBuKVxuICAgICAgICBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobiwgcikgJiYgKGVbcl0gPSBuW3JdKTtcbiAgICB9XG4gICAgcmV0dXJuIGU7XG4gIH0sIGJvLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG52YXIgUDggPSBmdW5jdGlvbih0KSB7XG4gIHZhciBuID0gdC52YWx1ZSwgciA9IHQuZm9ybWF0dGVyLCBpID0gbWUodC5jaGlsZHJlbikgPyBuIDogdC5jaGlsZHJlbjtcbiAgcmV0dXJuIHBlKHIpID8gcihpKSA6IGk7XG59LCBDOCA9IGZ1bmN0aW9uKHQsIG4pIHtcbiAgdmFyIHIgPSBLdChuIC0gdCksIGkgPSBNYXRoLm1pbihNYXRoLmFicyhuIC0gdCksIDM2MCk7XG4gIHJldHVybiByICogaTtcbn0sIEU4ID0gZnVuY3Rpb24odCwgbiwgcikge1xuICB2YXIgaSA9IHQucG9zaXRpb24sIG8gPSB0LnZpZXdCb3gsIGEgPSB0Lm9mZnNldCwgcyA9IHQuY2xhc3NOYW1lLCB1ID0gbywgYyA9IHUuY3gsIGYgPSB1LmN5LCBsID0gdS5pbm5lclJhZGl1cywgZCA9IHUub3V0ZXJSYWRpdXMsIHAgPSB1LnN0YXJ0QW5nbGUsIGcgPSB1LmVuZEFuZ2xlLCBoID0gdS5jbG9ja1dpc2UsIHYgPSAobCArIGQpIC8gMiwgdyA9IEM4KHAsIGcpLCBiID0gdyA+PSAwID8gMSA6IC0xLCB4LCBtO1xuICBpID09PSBcImluc2lkZVN0YXJ0XCIgPyAoeCA9IHAgKyBiICogYSwgbSA9IGgpIDogaSA9PT0gXCJpbnNpZGVFbmRcIiA/ICh4ID0gZyAtIGIgKiBhLCBtID0gIWgpIDogaSA9PT0gXCJlbmRcIiAmJiAoeCA9IGcgKyBiICogYSwgbSA9IGgpLCBtID0gdyA8PSAwID8gbSA6ICFtO1xuICB2YXIgeSA9IG50KGMsIGYsIHYsIHgpLCBTID0gbnQoYywgZiwgdiwgeCArIChtID8gMSA6IC0xKSAqIDM1OSksICQgPSBcIk1cIi5jb25jYXQoeS54LCBcIixcIikuY29uY2F0KHkueSwgYFxuICAgIEFgKS5jb25jYXQodiwgXCIsXCIpLmNvbmNhdCh2LCBcIiwwLDEsXCIpLmNvbmNhdChtID8gMCA6IDEsIGAsXG4gICAgYCkuY29uY2F0KFMueCwgXCIsXCIpLmNvbmNhdChTLnkpLCBPID0gbWUodC5pZCkgPyBVbyhcInJlY2hhcnRzLXJhZGlhbC1saW5lLVwiKSA6IHQuaWQ7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gUC5jcmVhdGVFbGVtZW50KFwidGV4dFwiLCBibyh7fSwgciwge1xuICAgIGRvbWluYW50QmFzZWxpbmU6IFwiY2VudHJhbFwiLFxuICAgIGNsYXNzTmFtZTogJGUoXCJyZWNoYXJ0cy1yYWRpYWwtYmFyLWxhYmVsXCIsIHMpXG4gIH0pLCAvKiBAX19QVVJFX18gKi8gUC5jcmVhdGVFbGVtZW50KFwiZGVmc1wiLCBudWxsLCAvKiBAX19QVVJFX18gKi8gUC5jcmVhdGVFbGVtZW50KFwicGF0aFwiLCB7XG4gICAgaWQ6IE8sXG4gICAgZDogJFxuICB9KSksIC8qIEBfX1BVUkVfXyAqLyBQLmNyZWF0ZUVsZW1lbnQoXCJ0ZXh0UGF0aFwiLCB7XG4gICAgeGxpbmtIcmVmOiBcIiNcIi5jb25jYXQoTylcbiAgfSwgbikpO1xufSwgVDggPSBmdW5jdGlvbih0KSB7XG4gIHZhciBuID0gdC52aWV3Qm94LCByID0gdC5vZmZzZXQsIGkgPSB0LnBvc2l0aW9uLCBvID0gbiwgYSA9IG8uY3gsIHMgPSBvLmN5LCB1ID0gby5pbm5lclJhZGl1cywgYyA9IG8ub3V0ZXJSYWRpdXMsIGYgPSBvLnN0YXJ0QW5nbGUsIGwgPSBvLmVuZEFuZ2xlLCBkID0gKGYgKyBsKSAvIDI7XG4gIGlmIChpID09PSBcIm91dHNpZGVcIikge1xuICAgIHZhciBwID0gbnQoYSwgcywgYyArIHIsIGQpLCBnID0gcC54LCBoID0gcC55O1xuICAgIHJldHVybiB7XG4gICAgICB4OiBnLFxuICAgICAgeTogaCxcbiAgICAgIHRleHRBbmNob3I6IGcgPj0gYSA/IFwic3RhcnRcIiA6IFwiZW5kXCIsXG4gICAgICB2ZXJ0aWNhbEFuY2hvcjogXCJtaWRkbGVcIlxuICAgIH07XG4gIH1cbiAgaWYgKGkgPT09IFwiY2VudGVyXCIpXG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IGEsXG4gICAgICB5OiBzLFxuICAgICAgdGV4dEFuY2hvcjogXCJtaWRkbGVcIixcbiAgICAgIHZlcnRpY2FsQW5jaG9yOiBcIm1pZGRsZVwiXG4gICAgfTtcbiAgaWYgKGkgPT09IFwiY2VudGVyVG9wXCIpXG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IGEsXG4gICAgICB5OiBzLFxuICAgICAgdGV4dEFuY2hvcjogXCJtaWRkbGVcIixcbiAgICAgIHZlcnRpY2FsQW5jaG9yOiBcInN0YXJ0XCJcbiAgICB9O1xuICBpZiAoaSA9PT0gXCJjZW50ZXJCb3R0b21cIilcbiAgICByZXR1cm4ge1xuICAgICAgeDogYSxcbiAgICAgIHk6IHMsXG4gICAgICB0ZXh0QW5jaG9yOiBcIm1pZGRsZVwiLFxuICAgICAgdmVydGljYWxBbmNob3I6IFwiZW5kXCJcbiAgICB9O1xuICB2YXIgdiA9ICh1ICsgYykgLyAyLCB3ID0gbnQoYSwgcywgdiwgZCksIGIgPSB3LngsIHggPSB3Lnk7XG4gIHJldHVybiB7XG4gICAgeDogYixcbiAgICB5OiB4LFxuICAgIHRleHRBbmNob3I6IFwibWlkZGxlXCIsXG4gICAgdmVydGljYWxBbmNob3I6IFwibWlkZGxlXCJcbiAgfTtcbn0sIE04ID0gZnVuY3Rpb24odCkge1xuICB2YXIgbiA9IHQudmlld0JveCwgciA9IHQucGFyZW50Vmlld0JveCwgaSA9IHQub2Zmc2V0LCBvID0gdC5wb3NpdGlvbiwgYSA9IG4sIHMgPSBhLngsIHUgPSBhLnksIGMgPSBhLndpZHRoLCBmID0gYS5oZWlnaHQsIGwgPSBmID49IDAgPyAxIDogLTEsIGQgPSBsICogaSwgcCA9IGwgPiAwID8gXCJlbmRcIiA6IFwic3RhcnRcIiwgZyA9IGwgPiAwID8gXCJzdGFydFwiIDogXCJlbmRcIiwgaCA9IGMgPj0gMCA/IDEgOiAtMSwgdiA9IGggKiBpLCB3ID0gaCA+IDAgPyBcImVuZFwiIDogXCJzdGFydFwiLCBiID0gaCA+IDAgPyBcInN0YXJ0XCIgOiBcImVuZFwiO1xuICBpZiAobyA9PT0gXCJ0b3BcIikge1xuICAgIHZhciB4ID0ge1xuICAgICAgeDogcyArIGMgLyAyLFxuICAgICAgeTogdSAtIGwgKiBpLFxuICAgICAgdGV4dEFuY2hvcjogXCJtaWRkbGVcIixcbiAgICAgIHZlcnRpY2FsQW5jaG9yOiBwXG4gICAgfTtcbiAgICByZXR1cm4gcWUocWUoe30sIHgpLCByID8ge1xuICAgICAgaGVpZ2h0OiBNYXRoLm1heCh1IC0gci55LCAwKSxcbiAgICAgIHdpZHRoOiBjXG4gICAgfSA6IHt9KTtcbiAgfVxuICBpZiAobyA9PT0gXCJib3R0b21cIikge1xuICAgIHZhciBtID0ge1xuICAgICAgeDogcyArIGMgLyAyLFxuICAgICAgeTogdSArIGYgKyBkLFxuICAgICAgdGV4dEFuY2hvcjogXCJtaWRkbGVcIixcbiAgICAgIHZlcnRpY2FsQW5jaG9yOiBnXG4gICAgfTtcbiAgICByZXR1cm4gcWUocWUoe30sIG0pLCByID8ge1xuICAgICAgaGVpZ2h0OiBNYXRoLm1heChyLnkgKyByLmhlaWdodCAtICh1ICsgZiksIDApLFxuICAgICAgd2lkdGg6IGNcbiAgICB9IDoge30pO1xuICB9XG4gIGlmIChvID09PSBcImxlZnRcIikge1xuICAgIHZhciB5ID0ge1xuICAgICAgeDogcyAtIHYsXG4gICAgICB5OiB1ICsgZiAvIDIsXG4gICAgICB0ZXh0QW5jaG9yOiB3LFxuICAgICAgdmVydGljYWxBbmNob3I6IFwibWlkZGxlXCJcbiAgICB9O1xuICAgIHJldHVybiBxZShxZSh7fSwgeSksIHIgPyB7XG4gICAgICB3aWR0aDogTWF0aC5tYXgoeS54IC0gci54LCAwKSxcbiAgICAgIGhlaWdodDogZlxuICAgIH0gOiB7fSk7XG4gIH1cbiAgaWYgKG8gPT09IFwicmlnaHRcIikge1xuICAgIHZhciBTID0ge1xuICAgICAgeDogcyArIGMgKyB2LFxuICAgICAgeTogdSArIGYgLyAyLFxuICAgICAgdGV4dEFuY2hvcjogYixcbiAgICAgIHZlcnRpY2FsQW5jaG9yOiBcIm1pZGRsZVwiXG4gICAgfTtcbiAgICByZXR1cm4gcWUocWUoe30sIFMpLCByID8ge1xuICAgICAgd2lkdGg6IE1hdGgubWF4KHIueCArIHIud2lkdGggLSBTLngsIDApLFxuICAgICAgaGVpZ2h0OiBmXG4gICAgfSA6IHt9KTtcbiAgfVxuICB2YXIgJCA9IHIgPyB7XG4gICAgd2lkdGg6IGMsXG4gICAgaGVpZ2h0OiBmXG4gIH0gOiB7fTtcbiAgcmV0dXJuIG8gPT09IFwiaW5zaWRlTGVmdFwiID8gcWUoe1xuICAgIHg6IHMgKyB2LFxuICAgIHk6IHUgKyBmIC8gMixcbiAgICB0ZXh0QW5jaG9yOiBiLFxuICAgIHZlcnRpY2FsQW5jaG9yOiBcIm1pZGRsZVwiXG4gIH0sICQpIDogbyA9PT0gXCJpbnNpZGVSaWdodFwiID8gcWUoe1xuICAgIHg6IHMgKyBjIC0gdixcbiAgICB5OiB1ICsgZiAvIDIsXG4gICAgdGV4dEFuY2hvcjogdyxcbiAgICB2ZXJ0aWNhbEFuY2hvcjogXCJtaWRkbGVcIlxuICB9LCAkKSA6IG8gPT09IFwiaW5zaWRlVG9wXCIgPyBxZSh7XG4gICAgeDogcyArIGMgLyAyLFxuICAgIHk6IHUgKyBkLFxuICAgIHRleHRBbmNob3I6IFwibWlkZGxlXCIsXG4gICAgdmVydGljYWxBbmNob3I6IGdcbiAgfSwgJCkgOiBvID09PSBcImluc2lkZUJvdHRvbVwiID8gcWUoe1xuICAgIHg6IHMgKyBjIC8gMixcbiAgICB5OiB1ICsgZiAtIGQsXG4gICAgdGV4dEFuY2hvcjogXCJtaWRkbGVcIixcbiAgICB2ZXJ0aWNhbEFuY2hvcjogcFxuICB9LCAkKSA6IG8gPT09IFwiaW5zaWRlVG9wTGVmdFwiID8gcWUoe1xuICAgIHg6IHMgKyB2LFxuICAgIHk6IHUgKyBkLFxuICAgIHRleHRBbmNob3I6IGIsXG4gICAgdmVydGljYWxBbmNob3I6IGdcbiAgfSwgJCkgOiBvID09PSBcImluc2lkZVRvcFJpZ2h0XCIgPyBxZSh7XG4gICAgeDogcyArIGMgLSB2LFxuICAgIHk6IHUgKyBkLFxuICAgIHRleHRBbmNob3I6IHcsXG4gICAgdmVydGljYWxBbmNob3I6IGdcbiAgfSwgJCkgOiBvID09PSBcImluc2lkZUJvdHRvbUxlZnRcIiA/IHFlKHtcbiAgICB4OiBzICsgdixcbiAgICB5OiB1ICsgZiAtIGQsXG4gICAgdGV4dEFuY2hvcjogYixcbiAgICB2ZXJ0aWNhbEFuY2hvcjogcFxuICB9LCAkKSA6IG8gPT09IFwiaW5zaWRlQm90dG9tUmlnaHRcIiA/IHFlKHtcbiAgICB4OiBzICsgYyAtIHYsXG4gICAgeTogdSArIGYgLSBkLFxuICAgIHRleHRBbmNob3I6IHcsXG4gICAgdmVydGljYWxBbmNob3I6IHBcbiAgfSwgJCkgOiBjaShvKSAmJiAoSyhvLngpIHx8IEFjKG8ueCkpICYmIChLKG8ueSkgfHwgQWMoby55KSkgPyBxZSh7XG4gICAgeDogcyArIGxyKG8ueCwgYyksXG4gICAgeTogdSArIGxyKG8ueSwgZiksXG4gICAgdGV4dEFuY2hvcjogXCJlbmRcIixcbiAgICB2ZXJ0aWNhbEFuY2hvcjogXCJlbmRcIlxuICB9LCAkKSA6IHFlKHtcbiAgICB4OiBzICsgYyAvIDIsXG4gICAgeTogdSArIGYgLyAyLFxuICAgIHRleHRBbmNob3I6IFwibWlkZGxlXCIsXG4gICAgdmVydGljYWxBbmNob3I6IFwibWlkZGxlXCJcbiAgfSwgJCk7XG59LCBSOCA9IGZ1bmN0aW9uKHQpIHtcbiAgcmV0dXJuIFwiY3hcIiBpbiB0ICYmIEsodC5jeCk7XG59O1xuZnVuY3Rpb24gYXQoZSkge1xuICB2YXIgdCA9IGUub2Zmc2V0LCBuID0gdCA9PT0gdm9pZCAwID8gNSA6IHQsIHIgPSBTOChlLCB2OCksIGkgPSBxZSh7XG4gICAgb2Zmc2V0OiBuXG4gIH0sIHIpLCBvID0gaS52aWV3Qm94LCBhID0gaS5wb3NpdGlvbiwgcyA9IGkudmFsdWUsIHUgPSBpLmNoaWxkcmVuLCBjID0gaS5jb250ZW50LCBmID0gaS5jbGFzc05hbWUsIGwgPSBmID09PSB2b2lkIDAgPyBcIlwiIDogZiwgZCA9IGkudGV4dEJyZWFrQWxsO1xuICBpZiAoIW8gfHwgbWUocykgJiYgbWUodSkgJiYgIS8qIEBfX1BVUkVfXyAqLyB2dChjKSAmJiAhcGUoYykpXG4gICAgcmV0dXJuIG51bGw7XG4gIGlmICgvKiBAX19QVVJFX18gKi8gdnQoYykpXG4gICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBHZShjLCBpKTtcbiAgdmFyIHA7XG4gIGlmIChwZShjKSkge1xuICAgIGlmIChwID0gLyogQF9fUFVSRV9fICovIFkoYywgaSksIC8qIEBfX1BVUkVfXyAqLyB2dChwKSlcbiAgICAgIHJldHVybiBwO1xuICB9IGVsc2VcbiAgICBwID0gUDgoaSk7XG4gIHZhciBnID0gUjgobyksIGggPSB5ZShpLCAhMCk7XG4gIGlmIChnICYmIChhID09PSBcImluc2lkZVN0YXJ0XCIgfHwgYSA9PT0gXCJpbnNpZGVFbmRcIiB8fCBhID09PSBcImVuZFwiKSlcbiAgICByZXR1cm4gRTgoaSwgcCwgaCk7XG4gIHZhciB2ID0gZyA/IFQ4KGkpIDogTTgoaSk7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gUC5jcmVhdGVFbGVtZW50KEphLCBibyh7XG4gICAgY2xhc3NOYW1lOiAkZShcInJlY2hhcnRzLWxhYmVsXCIsIGwpXG4gIH0sIGgsIHYsIHtcbiAgICBicmVha0FsbDogZFxuICB9KSwgcCk7XG59XG5hdC5kaXNwbGF5TmFtZSA9IFwiTGFiZWxcIjtcbnZhciBZMCA9IGZ1bmN0aW9uKHQpIHtcbiAgdmFyIG4gPSB0LmN4LCByID0gdC5jeSwgaSA9IHQuYW5nbGUsIG8gPSB0LnN0YXJ0QW5nbGUsIGEgPSB0LmVuZEFuZ2xlLCBzID0gdC5yLCB1ID0gdC5yYWRpdXMsIGMgPSB0LmlubmVyUmFkaXVzLCBmID0gdC5vdXRlclJhZGl1cywgbCA9IHQueCwgZCA9IHQueSwgcCA9IHQudG9wLCBnID0gdC5sZWZ0LCBoID0gdC53aWR0aCwgdiA9IHQuaGVpZ2h0LCB3ID0gdC5jbG9ja1dpc2UsIGIgPSB0LmxhYmVsVmlld0JveDtcbiAgaWYgKGIpXG4gICAgcmV0dXJuIGI7XG4gIGlmIChLKGgpICYmIEsodikpIHtcbiAgICBpZiAoSyhsKSAmJiBLKGQpKVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeDogbCxcbiAgICAgICAgeTogZCxcbiAgICAgICAgd2lkdGg6IGgsXG4gICAgICAgIGhlaWdodDogdlxuICAgICAgfTtcbiAgICBpZiAoSyhwKSAmJiBLKGcpKVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeDogcCxcbiAgICAgICAgeTogZyxcbiAgICAgICAgd2lkdGg6IGgsXG4gICAgICAgIGhlaWdodDogdlxuICAgICAgfTtcbiAgfVxuICByZXR1cm4gSyhsKSAmJiBLKGQpID8ge1xuICAgIHg6IGwsXG4gICAgeTogZCxcbiAgICB3aWR0aDogMCxcbiAgICBoZWlnaHQ6IDBcbiAgfSA6IEsobikgJiYgSyhyKSA/IHtcbiAgICBjeDogbixcbiAgICBjeTogcixcbiAgICBzdGFydEFuZ2xlOiBvIHx8IGkgfHwgMCxcbiAgICBlbmRBbmdsZTogYSB8fCBpIHx8IDAsXG4gICAgaW5uZXJSYWRpdXM6IGMgfHwgMCxcbiAgICBvdXRlclJhZGl1czogZiB8fCB1IHx8IHMgfHwgMCxcbiAgICBjbG9ja1dpc2U6IHdcbiAgfSA6IHQudmlld0JveCA/IHQudmlld0JveCA6IHt9O1xufSwgSTggPSBmdW5jdGlvbih0LCBuKSB7XG4gIHJldHVybiB0ID8gdCA9PT0gITAgPyAvKiBAX19QVVJFX18gKi8gUC5jcmVhdGVFbGVtZW50KGF0LCB7XG4gICAga2V5OiBcImxhYmVsLWltcGxpY2l0XCIsXG4gICAgdmlld0JveDogblxuICB9KSA6IEtlKHQpID8gLyogQF9fUFVSRV9fICovIFAuY3JlYXRlRWxlbWVudChhdCwge1xuICAgIGtleTogXCJsYWJlbC1pbXBsaWNpdFwiLFxuICAgIHZpZXdCb3g6IG4sXG4gICAgdmFsdWU6IHRcbiAgfSkgOiAvKiBAX19QVVJFX18gKi8gdnQodCkgPyB0LnR5cGUgPT09IGF0ID8gLyogQF9fUFVSRV9fICovIEdlKHQsIHtcbiAgICBrZXk6IFwibGFiZWwtaW1wbGljaXRcIixcbiAgICB2aWV3Qm94OiBuXG4gIH0pIDogLyogQF9fUFVSRV9fICovIFAuY3JlYXRlRWxlbWVudChhdCwge1xuICAgIGtleTogXCJsYWJlbC1pbXBsaWNpdFwiLFxuICAgIGNvbnRlbnQ6IHQsXG4gICAgdmlld0JveDogblxuICB9KSA6IHBlKHQpID8gLyogQF9fUFVSRV9fICovIFAuY3JlYXRlRWxlbWVudChhdCwge1xuICAgIGtleTogXCJsYWJlbC1pbXBsaWNpdFwiLFxuICAgIGNvbnRlbnQ6IHQsXG4gICAgdmlld0JveDogblxuICB9KSA6IGNpKHQpID8gLyogQF9fUFVSRV9fICovIFAuY3JlYXRlRWxlbWVudChhdCwgYm8oe1xuICAgIHZpZXdCb3g6IG5cbiAgfSwgdCwge1xuICAgIGtleTogXCJsYWJlbC1pbXBsaWNpdFwiXG4gIH0pKSA6IG51bGwgOiBudWxsO1xufSwgajggPSBmdW5jdGlvbih0LCBuKSB7XG4gIHZhciByID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB2b2lkIDAgPyBhcmd1bWVudHNbMl0gOiAhMDtcbiAgaWYgKCF0IHx8ICF0LmNoaWxkcmVuICYmIHIgJiYgIXQubGFiZWwpXG4gICAgcmV0dXJuIG51bGw7XG4gIHZhciBpID0gdC5jaGlsZHJlbiwgbyA9IFkwKHQpLCBhID0ga3QoaSwgYXQpLm1hcChmdW5jdGlvbih1LCBjKSB7XG4gICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBHZSh1LCB7XG4gICAgICB2aWV3Qm94OiBuIHx8IG8sXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3Qvbm8tYXJyYXktaW5kZXgta2V5XG4gICAgICBrZXk6IFwibGFiZWwtXCIuY29uY2F0KGMpXG4gICAgfSk7XG4gIH0pO1xuICBpZiAoIXIpXG4gICAgcmV0dXJuIGE7XG4gIHZhciBzID0gSTgodC5sYWJlbCwgbiB8fCBvKTtcbiAgcmV0dXJuIFtzXS5jb25jYXQobTgoYSkpO1xufTtcbmF0LnBhcnNlVmlld0JveCA9IFkwO1xuYXQucmVuZGVyQ2FsbEJ5UGFyZW50ID0gajg7XG5mdW5jdGlvbiBrOChlKSB7XG4gIHZhciB0ID0gZSA9PSBudWxsID8gMCA6IGUubGVuZ3RoO1xuICByZXR1cm4gdCA/IGVbdCAtIDFdIDogdm9pZCAwO1xufVxudmFyIEQ4ID0gazg7XG5jb25zdCBOOCA9IC8qIEBfX1BVUkVfXyAqLyBqZShEOCk7XG5mdW5jdGlvbiB3byhlKSB7XG4gIFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjtcbiAgcmV0dXJuIHdvID0gdHlwZW9mIFN5bWJvbCA9PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PSBcInN5bWJvbFwiID8gZnVuY3Rpb24odCkge1xuICAgIHJldHVybiB0eXBlb2YgdDtcbiAgfSA6IGZ1bmN0aW9uKHQpIHtcbiAgICByZXR1cm4gdCAmJiB0eXBlb2YgU3ltYm9sID09IFwiZnVuY3Rpb25cIiAmJiB0LmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgdCAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2YgdDtcbiAgfSwgd28oZSk7XG59XG52YXIgRjggPSBbXCJ2YWx1ZUFjY2Vzc29yXCJdLCBMOCA9IFtcImRhdGFcIiwgXCJkYXRhS2V5XCIsIFwiY2xvY2tXaXNlXCIsIFwiaWRcIiwgXCJ0ZXh0QnJlYWtBbGxcIl07XG5mdW5jdGlvbiBCOChlKSB7XG4gIHJldHVybiBXOChlKSB8fCBHOChlKSB8fCBWOChlKSB8fCB6OCgpO1xufVxuZnVuY3Rpb24gejgoKSB7XG4gIHRocm93IG5ldyBUeXBlRXJyb3IoYEludmFsaWQgYXR0ZW1wdCB0byBzcHJlYWQgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLmApO1xufVxuZnVuY3Rpb24gVjgoZSwgdCkge1xuICBpZiAoZSkge1xuICAgIGlmICh0eXBlb2YgZSA9PSBcInN0cmluZ1wiKVxuICAgICAgcmV0dXJuIHZsKGUsIHQpO1xuICAgIHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGUpLnNsaWNlKDgsIC0xKTtcbiAgICBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBlLmNvbnN0cnVjdG9yICYmIChuID0gZS5jb25zdHJ1Y3Rvci5uYW1lKSwgbiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKVxuICAgICAgcmV0dXJuIEFycmF5LmZyb20oZSk7XG4gICAgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpXG4gICAgICByZXR1cm4gdmwoZSwgdCk7XG4gIH1cbn1cbmZ1bmN0aW9uIEc4KGUpIHtcbiAgaWYgKHR5cGVvZiBTeW1ib2wgPCBcInVcIiAmJiBlW1N5bWJvbC5pdGVyYXRvcl0gIT0gbnVsbCB8fCBlW1wiQEBpdGVyYXRvclwiXSAhPSBudWxsKVxuICAgIHJldHVybiBBcnJheS5mcm9tKGUpO1xufVxuZnVuY3Rpb24gVzgoZSkge1xuICBpZiAoQXJyYXkuaXNBcnJheShlKSlcbiAgICByZXR1cm4gdmwoZSk7XG59XG5mdW5jdGlvbiB2bChlLCB0KSB7XG4gICh0ID09IG51bGwgfHwgdCA+IGUubGVuZ3RoKSAmJiAodCA9IGUubGVuZ3RoKTtcbiAgZm9yICh2YXIgbiA9IDAsIHIgPSBuZXcgQXJyYXkodCk7IG4gPCB0OyBuKyspXG4gICAgcltuXSA9IGVbbl07XG4gIHJldHVybiByO1xufVxuZnVuY3Rpb24gcHMoKSB7XG4gIHJldHVybiBwcyA9IE9iamVjdC5hc3NpZ24gPyBPYmplY3QuYXNzaWduLmJpbmQoKSA6IGZ1bmN0aW9uKGUpIHtcbiAgICBmb3IgKHZhciB0ID0gMTsgdCA8IGFyZ3VtZW50cy5sZW5ndGg7IHQrKykge1xuICAgICAgdmFyIG4gPSBhcmd1bWVudHNbdF07XG4gICAgICBmb3IgKHZhciByIGluIG4pXG4gICAgICAgIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChuLCByKSAmJiAoZVtyXSA9IG5bcl0pO1xuICAgIH1cbiAgICByZXR1cm4gZTtcbiAgfSwgcHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cbmZ1bmN0aW9uIGpnKGUsIHQpIHtcbiAgdmFyIG4gPSBPYmplY3Qua2V5cyhlKTtcbiAgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcbiAgICB2YXIgciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZSk7XG4gICAgdCAmJiAociA9IHIuZmlsdGVyKGZ1bmN0aW9uKGkpIHtcbiAgICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsIGkpLmVudW1lcmFibGU7XG4gICAgfSkpLCBuLnB1c2guYXBwbHkobiwgcik7XG4gIH1cbiAgcmV0dXJuIG47XG59XG5mdW5jdGlvbiBrZyhlKSB7XG4gIGZvciAodmFyIHQgPSAxOyB0IDwgYXJndW1lbnRzLmxlbmd0aDsgdCsrKSB7XG4gICAgdmFyIG4gPSBhcmd1bWVudHNbdF0gIT0gbnVsbCA/IGFyZ3VtZW50c1t0XSA6IHt9O1xuICAgIHQgJSAyID8gamcoT2JqZWN0KG4pLCAhMCkuZm9yRWFjaChmdW5jdGlvbihyKSB7XG4gICAgICBVOChlLCByLCBuW3JdKTtcbiAgICB9KSA6IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoZSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMobikpIDogamcoT2JqZWN0KG4pKS5mb3JFYWNoKGZ1bmN0aW9uKHIpIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCByLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG4sIHIpKTtcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gZTtcbn1cbmZ1bmN0aW9uIFU4KGUsIHQsIG4pIHtcbiAgcmV0dXJuIHQgPSBIOCh0KSwgdCBpbiBlID8gT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIHQsIHsgdmFsdWU6IG4sIGVudW1lcmFibGU6ICEwLCBjb25maWd1cmFibGU6ICEwLCB3cml0YWJsZTogITAgfSkgOiBlW3RdID0gbiwgZTtcbn1cbmZ1bmN0aW9uIEg4KGUpIHtcbiAgdmFyIHQgPSBxOChlLCBcInN0cmluZ1wiKTtcbiAgcmV0dXJuIHdvKHQpID09IFwic3ltYm9sXCIgPyB0IDogU3RyaW5nKHQpO1xufVxuZnVuY3Rpb24gcTgoZSwgdCkge1xuICBpZiAod28oZSkgIT0gXCJvYmplY3RcIiB8fCAhZSlcbiAgICByZXR1cm4gZTtcbiAgdmFyIG4gPSBlW1N5bWJvbC50b1ByaW1pdGl2ZV07XG4gIGlmIChuICE9PSB2b2lkIDApIHtcbiAgICB2YXIgciA9IG4uY2FsbChlLCB0IHx8IFwiZGVmYXVsdFwiKTtcbiAgICBpZiAod28ocikgIT0gXCJvYmplY3RcIilcbiAgICAgIHJldHVybiByO1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJAQHRvUHJpbWl0aXZlIG11c3QgcmV0dXJuIGEgcHJpbWl0aXZlIHZhbHVlLlwiKTtcbiAgfVxuICByZXR1cm4gKHQgPT09IFwic3RyaW5nXCIgPyBTdHJpbmcgOiBOdW1iZXIpKGUpO1xufVxuZnVuY3Rpb24gRGcoZSwgdCkge1xuICBpZiAoZSA9PSBudWxsKVxuICAgIHJldHVybiB7fTtcbiAgdmFyIG4gPSBLOChlLCB0KSwgciwgaTtcbiAgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcbiAgICB2YXIgbyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZSk7XG4gICAgZm9yIChpID0gMDsgaSA8IG8ubGVuZ3RoOyBpKyspXG4gICAgICByID0gb1tpXSwgISh0LmluZGV4T2YocikgPj0gMCkgJiYgT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKGUsIHIpICYmIChuW3JdID0gZVtyXSk7XG4gIH1cbiAgcmV0dXJuIG47XG59XG5mdW5jdGlvbiBLOChlLCB0KSB7XG4gIGlmIChlID09IG51bGwpXG4gICAgcmV0dXJuIHt9O1xuICB2YXIgbiA9IHt9LCByID0gT2JqZWN0LmtleXMoZSksIGksIG87XG4gIGZvciAobyA9IDA7IG8gPCByLmxlbmd0aDsgbysrKVxuICAgIGkgPSByW29dLCAhKHQuaW5kZXhPZihpKSA+PSAwKSAmJiAobltpXSA9IGVbaV0pO1xuICByZXR1cm4gbjtcbn1cbnZhciBZOCA9IGZ1bmN0aW9uKHQpIHtcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkodC52YWx1ZSkgPyBOOCh0LnZhbHVlKSA6IHQudmFsdWU7XG59O1xuZnVuY3Rpb24gQm4oZSkge1xuICB2YXIgdCA9IGUudmFsdWVBY2Nlc3NvciwgbiA9IHQgPT09IHZvaWQgMCA/IFk4IDogdCwgciA9IERnKGUsIEY4KSwgaSA9IHIuZGF0YSwgbyA9IHIuZGF0YUtleSwgYSA9IHIuY2xvY2tXaXNlLCBzID0gci5pZCwgdSA9IHIudGV4dEJyZWFrQWxsLCBjID0gRGcociwgTDgpO1xuICByZXR1cm4gIWkgfHwgIWkubGVuZ3RoID8gbnVsbCA6IC8qIEBfX1BVUkVfXyAqLyBQLmNyZWF0ZUVsZW1lbnQoV2UsIHtcbiAgICBjbGFzc05hbWU6IFwicmVjaGFydHMtbGFiZWwtbGlzdFwiXG4gIH0sIGkubWFwKGZ1bmN0aW9uKGYsIGwpIHtcbiAgICB2YXIgZCA9IG1lKG8pID8gbihmLCBsKSA6IEF0KGYgJiYgZi5wYXlsb2FkLCBvKSwgcCA9IG1lKHMpID8ge30gOiB7XG4gICAgICBpZDogXCJcIi5jb25jYXQocywgXCItXCIpLmNvbmNhdChsKVxuICAgIH07XG4gICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBQLmNyZWF0ZUVsZW1lbnQoYXQsIHBzKHt9LCB5ZShmLCAhMCksIGMsIHAsIHtcbiAgICAgIHBhcmVudFZpZXdCb3g6IGYucGFyZW50Vmlld0JveCxcbiAgICAgIHZhbHVlOiBkLFxuICAgICAgdGV4dEJyZWFrQWxsOiB1LFxuICAgICAgdmlld0JveDogYXQucGFyc2VWaWV3Qm94KG1lKGEpID8gZiA6IGtnKGtnKHt9LCBmKSwge30sIHtcbiAgICAgICAgY2xvY2tXaXNlOiBhXG4gICAgICB9KSksXG4gICAgICBrZXk6IFwibGFiZWwtXCIuY29uY2F0KGwpLFxuICAgICAgaW5kZXg6IGxcbiAgICB9KSk7XG4gIH0pKTtcbn1cbkJuLmRpc3BsYXlOYW1lID0gXCJMYWJlbExpc3RcIjtcbmZ1bmN0aW9uIFg4KGUsIHQpIHtcbiAgcmV0dXJuIGUgPyBlID09PSAhMCA/IC8qIEBfX1BVUkVfXyAqLyBQLmNyZWF0ZUVsZW1lbnQoQm4sIHtcbiAgICBrZXk6IFwibGFiZWxMaXN0LWltcGxpY2l0XCIsXG4gICAgZGF0YTogdFxuICB9KSA6IC8qIEBfX1BVUkVfXyAqLyBQLmlzVmFsaWRFbGVtZW50KGUpIHx8IHBlKGUpID8gLyogQF9fUFVSRV9fICovIFAuY3JlYXRlRWxlbWVudChCbiwge1xuICAgIGtleTogXCJsYWJlbExpc3QtaW1wbGljaXRcIixcbiAgICBkYXRhOiB0LFxuICAgIGNvbnRlbnQ6IGVcbiAgfSkgOiBjaShlKSA/IC8qIEBfX1BVUkVfXyAqLyBQLmNyZWF0ZUVsZW1lbnQoQm4sIHBzKHtcbiAgICBkYXRhOiB0XG4gIH0sIGUsIHtcbiAgICBrZXk6IFwibGFiZWxMaXN0LWltcGxpY2l0XCJcbiAgfSkpIDogbnVsbCA6IG51bGw7XG59XG5mdW5jdGlvbiBaOChlLCB0KSB7XG4gIHZhciBuID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB2b2lkIDAgPyBhcmd1bWVudHNbMl0gOiAhMDtcbiAgaWYgKCFlIHx8ICFlLmNoaWxkcmVuICYmIG4gJiYgIWUubGFiZWwpXG4gICAgcmV0dXJuIG51bGw7XG4gIHZhciByID0gZS5jaGlsZHJlbiwgaSA9IGt0KHIsIEJuKS5tYXAoZnVuY3Rpb24oYSwgcykge1xuICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8gR2UoYSwge1xuICAgICAgZGF0YTogdCxcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC9uby1hcnJheS1pbmRleC1rZXlcbiAgICAgIGtleTogXCJsYWJlbExpc3QtXCIuY29uY2F0KHMpXG4gICAgfSk7XG4gIH0pO1xuICBpZiAoIW4pXG4gICAgcmV0dXJuIGk7XG4gIHZhciBvID0gWDgoZS5sYWJlbCwgdCk7XG4gIHJldHVybiBbb10uY29uY2F0KEI4KGkpKTtcbn1cbkJuLnJlbmRlckNhbGxCeVBhcmVudCA9IFo4O1xuZnVuY3Rpb24geG8oZSkge1xuICBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7XG4gIHJldHVybiB4byA9IHR5cGVvZiBTeW1ib2wgPT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uKHQpIHtcbiAgICByZXR1cm4gdHlwZW9mIHQ7XG4gIH0gOiBmdW5jdGlvbih0KSB7XG4gICAgcmV0dXJuIHQgJiYgdHlwZW9mIFN5bWJvbCA9PSBcImZ1bmN0aW9uXCIgJiYgdC5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIHQgIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIHQ7XG4gIH0sIHhvKGUpO1xufVxuZnVuY3Rpb24gbWwoKSB7XG4gIHJldHVybiBtbCA9IE9iamVjdC5hc3NpZ24gPyBPYmplY3QuYXNzaWduLmJpbmQoKSA6IGZ1bmN0aW9uKGUpIHtcbiAgICBmb3IgKHZhciB0ID0gMTsgdCA8IGFyZ3VtZW50cy5sZW5ndGg7IHQrKykge1xuICAgICAgdmFyIG4gPSBhcmd1bWVudHNbdF07XG4gICAgICBmb3IgKHZhciByIGluIG4pXG4gICAgICAgIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChuLCByKSAmJiAoZVtyXSA9IG5bcl0pO1xuICAgIH1cbiAgICByZXR1cm4gZTtcbiAgfSwgbWwuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cbmZ1bmN0aW9uIE5nKGUsIHQpIHtcbiAgdmFyIG4gPSBPYmplY3Qua2V5cyhlKTtcbiAgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcbiAgICB2YXIgciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZSk7XG4gICAgdCAmJiAociA9IHIuZmlsdGVyKGZ1bmN0aW9uKGkpIHtcbiAgICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsIGkpLmVudW1lcmFibGU7XG4gICAgfSkpLCBuLnB1c2guYXBwbHkobiwgcik7XG4gIH1cbiAgcmV0dXJuIG47XG59XG5mdW5jdGlvbiBGZyhlKSB7XG4gIGZvciAodmFyIHQgPSAxOyB0IDwgYXJndW1lbnRzLmxlbmd0aDsgdCsrKSB7XG4gICAgdmFyIG4gPSBhcmd1bWVudHNbdF0gIT0gbnVsbCA/IGFyZ3VtZW50c1t0XSA6IHt9O1xuICAgIHQgJSAyID8gTmcoT2JqZWN0KG4pLCAhMCkuZm9yRWFjaChmdW5jdGlvbihyKSB7XG4gICAgICBKOChlLCByLCBuW3JdKTtcbiAgICB9KSA6IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoZSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMobikpIDogTmcoT2JqZWN0KG4pKS5mb3JFYWNoKGZ1bmN0aW9uKHIpIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCByLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG4sIHIpKTtcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gZTtcbn1cbmZ1bmN0aW9uIEo4KGUsIHQsIG4pIHtcbiAgcmV0dXJuIHQgPSBROCh0KSwgdCBpbiBlID8gT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIHQsIHsgdmFsdWU6IG4sIGVudW1lcmFibGU6ICEwLCBjb25maWd1cmFibGU6ICEwLCB3cml0YWJsZTogITAgfSkgOiBlW3RdID0gbiwgZTtcbn1cbmZ1bmN0aW9uIFE4KGUpIHtcbiAgdmFyIHQgPSBleihlLCBcInN0cmluZ1wiKTtcbiAgcmV0dXJuIHhvKHQpID09IFwic3ltYm9sXCIgPyB0IDogU3RyaW5nKHQpO1xufVxuZnVuY3Rpb24gZXooZSwgdCkge1xuICBpZiAoeG8oZSkgIT0gXCJvYmplY3RcIiB8fCAhZSlcbiAgICByZXR1cm4gZTtcbiAgdmFyIG4gPSBlW1N5bWJvbC50b1ByaW1pdGl2ZV07XG4gIGlmIChuICE9PSB2b2lkIDApIHtcbiAgICB2YXIgciA9IG4uY2FsbChlLCB0IHx8IFwiZGVmYXVsdFwiKTtcbiAgICBpZiAoeG8ocikgIT0gXCJvYmplY3RcIilcbiAgICAgIHJldHVybiByO1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJAQHRvUHJpbWl0aXZlIG11c3QgcmV0dXJuIGEgcHJpbWl0aXZlIHZhbHVlLlwiKTtcbiAgfVxuICByZXR1cm4gKHQgPT09IFwic3RyaW5nXCIgPyBTdHJpbmcgOiBOdW1iZXIpKGUpO1xufVxudmFyIHR6ID0gZnVuY3Rpb24odCwgbikge1xuICB2YXIgciA9IEt0KG4gLSB0KSwgaSA9IE1hdGgubWluKE1hdGguYWJzKG4gLSB0KSwgMzU5Ljk5OSk7XG4gIHJldHVybiByICogaTtcbn0sIHlhID0gZnVuY3Rpb24odCkge1xuICB2YXIgbiA9IHQuY3gsIHIgPSB0LmN5LCBpID0gdC5yYWRpdXMsIG8gPSB0LmFuZ2xlLCBhID0gdC5zaWduLCBzID0gdC5pc0V4dGVybmFsLCB1ID0gdC5jb3JuZXJSYWRpdXMsIGMgPSB0LmNvcm5lcklzRXh0ZXJuYWwsIGYgPSB1ICogKHMgPyAxIDogLTEpICsgaSwgbCA9IE1hdGguYXNpbih1IC8gZikgLyBkcywgZCA9IGMgPyBvIDogbyArIGEgKiBsLCBwID0gbnQobiwgciwgZiwgZCksIGcgPSBudChuLCByLCBpLCBkKSwgaCA9IGMgPyBvIC0gYSAqIGwgOiBvLCB2ID0gbnQobiwgciwgZiAqIE1hdGguY29zKGwgKiBkcyksIGgpO1xuICByZXR1cm4ge1xuICAgIGNlbnRlcjogcCxcbiAgICBjaXJjbGVUYW5nZW5jeTogZyxcbiAgICBsaW5lVGFuZ2VuY3k6IHYsXG4gICAgdGhldGE6IGxcbiAgfTtcbn0sIFgwID0gZnVuY3Rpb24odCkge1xuICB2YXIgbiA9IHQuY3gsIHIgPSB0LmN5LCBpID0gdC5pbm5lclJhZGl1cywgbyA9IHQub3V0ZXJSYWRpdXMsIGEgPSB0LnN0YXJ0QW5nbGUsIHMgPSB0LmVuZEFuZ2xlLCB1ID0gdHooYSwgcyksIGMgPSBhICsgdSwgZiA9IG50KG4sIHIsIG8sIGEpLCBsID0gbnQobiwgciwgbywgYyksIGQgPSBcIk0gXCIuY29uY2F0KGYueCwgXCIsXCIpLmNvbmNhdChmLnksIGBcbiAgICBBIGApLmNvbmNhdChvLCBcIixcIikuY29uY2F0KG8sIGAsMCxcbiAgICBgKS5jb25jYXQoKyhNYXRoLmFicyh1KSA+IDE4MCksIFwiLFwiKS5jb25jYXQoKyhhID4gYyksIGAsXG4gICAgYCkuY29uY2F0KGwueCwgXCIsXCIpLmNvbmNhdChsLnksIGBcbiAgYCk7XG4gIGlmIChpID4gMCkge1xuICAgIHZhciBwID0gbnQobiwgciwgaSwgYSksIGcgPSBudChuLCByLCBpLCBjKTtcbiAgICBkICs9IFwiTCBcIi5jb25jYXQoZy54LCBcIixcIikuY29uY2F0KGcueSwgYFxuICAgICAgICAgICAgQSBgKS5jb25jYXQoaSwgXCIsXCIpLmNvbmNhdChpLCBgLDAsXG4gICAgICAgICAgICBgKS5jb25jYXQoKyhNYXRoLmFicyh1KSA+IDE4MCksIFwiLFwiKS5jb25jYXQoKyhhIDw9IGMpLCBgLFxuICAgICAgICAgICAgYCkuY29uY2F0KHAueCwgXCIsXCIpLmNvbmNhdChwLnksIFwiIFpcIik7XG4gIH0gZWxzZVxuICAgIGQgKz0gXCJMIFwiLmNvbmNhdChuLCBcIixcIikuY29uY2F0KHIsIFwiIFpcIik7XG4gIHJldHVybiBkO1xufSwgbnogPSBmdW5jdGlvbih0KSB7XG4gIHZhciBuID0gdC5jeCwgciA9IHQuY3ksIGkgPSB0LmlubmVyUmFkaXVzLCBvID0gdC5vdXRlclJhZGl1cywgYSA9IHQuY29ybmVyUmFkaXVzLCBzID0gdC5mb3JjZUNvcm5lclJhZGl1cywgdSA9IHQuY29ybmVySXNFeHRlcm5hbCwgYyA9IHQuc3RhcnRBbmdsZSwgZiA9IHQuZW5kQW5nbGUsIGwgPSBLdChmIC0gYyksIGQgPSB5YSh7XG4gICAgY3g6IG4sXG4gICAgY3k6IHIsXG4gICAgcmFkaXVzOiBvLFxuICAgIGFuZ2xlOiBjLFxuICAgIHNpZ246IGwsXG4gICAgY29ybmVyUmFkaXVzOiBhLFxuICAgIGNvcm5lcklzRXh0ZXJuYWw6IHVcbiAgfSksIHAgPSBkLmNpcmNsZVRhbmdlbmN5LCBnID0gZC5saW5lVGFuZ2VuY3ksIGggPSBkLnRoZXRhLCB2ID0geWEoe1xuICAgIGN4OiBuLFxuICAgIGN5OiByLFxuICAgIHJhZGl1czogbyxcbiAgICBhbmdsZTogZixcbiAgICBzaWduOiAtbCxcbiAgICBjb3JuZXJSYWRpdXM6IGEsXG4gICAgY29ybmVySXNFeHRlcm5hbDogdVxuICB9KSwgdyA9IHYuY2lyY2xlVGFuZ2VuY3ksIGIgPSB2LmxpbmVUYW5nZW5jeSwgeCA9IHYudGhldGEsIG0gPSB1ID8gTWF0aC5hYnMoYyAtIGYpIDogTWF0aC5hYnMoYyAtIGYpIC0gaCAtIHg7XG4gIGlmIChtIDwgMClcbiAgICByZXR1cm4gcyA/IFwiTSBcIi5jb25jYXQoZy54LCBcIixcIikuY29uY2F0KGcueSwgYFxuICAgICAgICBhYCkuY29uY2F0KGEsIFwiLFwiKS5jb25jYXQoYSwgXCIsMCwwLDEsXCIpLmNvbmNhdChhICogMiwgYCwwXG4gICAgICAgIGFgKS5jb25jYXQoYSwgXCIsXCIpLmNvbmNhdChhLCBcIiwwLDAsMSxcIikuY29uY2F0KC1hICogMiwgYCwwXG4gICAgICBgKSA6IFgwKHtcbiAgICAgIGN4OiBuLFxuICAgICAgY3k6IHIsXG4gICAgICBpbm5lclJhZGl1czogaSxcbiAgICAgIG91dGVyUmFkaXVzOiBvLFxuICAgICAgc3RhcnRBbmdsZTogYyxcbiAgICAgIGVuZEFuZ2xlOiBmXG4gICAgfSk7XG4gIHZhciB5ID0gXCJNIFwiLmNvbmNhdChnLngsIFwiLFwiKS5jb25jYXQoZy55LCBgXG4gICAgQWApLmNvbmNhdChhLCBcIixcIikuY29uY2F0KGEsIFwiLDAsMCxcIikuY29uY2F0KCsobCA8IDApLCBcIixcIikuY29uY2F0KHAueCwgXCIsXCIpLmNvbmNhdChwLnksIGBcbiAgICBBYCkuY29uY2F0KG8sIFwiLFwiKS5jb25jYXQobywgXCIsMCxcIikuY29uY2F0KCsobSA+IDE4MCksIFwiLFwiKS5jb25jYXQoKyhsIDwgMCksIFwiLFwiKS5jb25jYXQody54LCBcIixcIikuY29uY2F0KHcueSwgYFxuICAgIEFgKS5jb25jYXQoYSwgXCIsXCIpLmNvbmNhdChhLCBcIiwwLDAsXCIpLmNvbmNhdCgrKGwgPCAwKSwgXCIsXCIpLmNvbmNhdChiLngsIFwiLFwiKS5jb25jYXQoYi55LCBgXG4gIGApO1xuICBpZiAoaSA+IDApIHtcbiAgICB2YXIgUyA9IHlhKHtcbiAgICAgIGN4OiBuLFxuICAgICAgY3k6IHIsXG4gICAgICByYWRpdXM6IGksXG4gICAgICBhbmdsZTogYyxcbiAgICAgIHNpZ246IGwsXG4gICAgICBpc0V4dGVybmFsOiAhMCxcbiAgICAgIGNvcm5lclJhZGl1czogYSxcbiAgICAgIGNvcm5lcklzRXh0ZXJuYWw6IHVcbiAgICB9KSwgJCA9IFMuY2lyY2xlVGFuZ2VuY3ksIE8gPSBTLmxpbmVUYW5nZW5jeSwgVCA9IFMudGhldGEsIE0gPSB5YSh7XG4gICAgICBjeDogbixcbiAgICAgIGN5OiByLFxuICAgICAgcmFkaXVzOiBpLFxuICAgICAgYW5nbGU6IGYsXG4gICAgICBzaWduOiAtbCxcbiAgICAgIGlzRXh0ZXJuYWw6ICEwLFxuICAgICAgY29ybmVyUmFkaXVzOiBhLFxuICAgICAgY29ybmVySXNFeHRlcm5hbDogdVxuICAgIH0pLCBFID0gTS5jaXJjbGVUYW5nZW5jeSwgQSA9IE0ubGluZVRhbmdlbmN5LCBqID0gTS50aGV0YSwgUiA9IHUgPyBNYXRoLmFicyhjIC0gZikgOiBNYXRoLmFicyhjIC0gZikgLSBUIC0gajtcbiAgICBpZiAoUiA8IDAgJiYgYSA9PT0gMClcbiAgICAgIHJldHVybiBcIlwiLmNvbmNhdCh5LCBcIkxcIikuY29uY2F0KG4sIFwiLFwiKS5jb25jYXQociwgXCJaXCIpO1xuICAgIHkgKz0gXCJMXCIuY29uY2F0KEEueCwgXCIsXCIpLmNvbmNhdChBLnksIGBcbiAgICAgIEFgKS5jb25jYXQoYSwgXCIsXCIpLmNvbmNhdChhLCBcIiwwLDAsXCIpLmNvbmNhdCgrKGwgPCAwKSwgXCIsXCIpLmNvbmNhdChFLngsIFwiLFwiKS5jb25jYXQoRS55LCBgXG4gICAgICBBYCkuY29uY2F0KGksIFwiLFwiKS5jb25jYXQoaSwgXCIsMCxcIikuY29uY2F0KCsoUiA+IDE4MCksIFwiLFwiKS5jb25jYXQoKyhsID4gMCksIFwiLFwiKS5jb25jYXQoJC54LCBcIixcIikuY29uY2F0KCQueSwgYFxuICAgICAgQWApLmNvbmNhdChhLCBcIixcIikuY29uY2F0KGEsIFwiLDAsMCxcIikuY29uY2F0KCsobCA8IDApLCBcIixcIikuY29uY2F0KE8ueCwgXCIsXCIpLmNvbmNhdChPLnksIFwiWlwiKTtcbiAgfSBlbHNlXG4gICAgeSArPSBcIkxcIi5jb25jYXQobiwgXCIsXCIpLmNvbmNhdChyLCBcIlpcIik7XG4gIHJldHVybiB5O1xufSwgcnogPSB7XG4gIGN4OiAwLFxuICBjeTogMCxcbiAgaW5uZXJSYWRpdXM6IDAsXG4gIG91dGVyUmFkaXVzOiAwLFxuICBzdGFydEFuZ2xlOiAwLFxuICBlbmRBbmdsZTogMCxcbiAgY29ybmVyUmFkaXVzOiAwLFxuICBmb3JjZUNvcm5lclJhZGl1czogITEsXG4gIGNvcm5lcklzRXh0ZXJuYWw6ICExXG59LCBaMCA9IGZ1bmN0aW9uKHQpIHtcbiAgdmFyIG4gPSBGZyhGZyh7fSwgcnopLCB0KSwgciA9IG4uY3gsIGkgPSBuLmN5LCBvID0gbi5pbm5lclJhZGl1cywgYSA9IG4ub3V0ZXJSYWRpdXMsIHMgPSBuLmNvcm5lclJhZGl1cywgdSA9IG4uZm9yY2VDb3JuZXJSYWRpdXMsIGMgPSBuLmNvcm5lcklzRXh0ZXJuYWwsIGYgPSBuLnN0YXJ0QW5nbGUsIGwgPSBuLmVuZEFuZ2xlLCBkID0gbi5jbGFzc05hbWU7XG4gIGlmIChhIDwgbyB8fCBmID09PSBsKVxuICAgIHJldHVybiBudWxsO1xuICB2YXIgcCA9ICRlKFwicmVjaGFydHMtc2VjdG9yXCIsIGQpLCBnID0gYSAtIG8sIGggPSBscihzLCBnLCAwLCAhMCksIHY7XG4gIHJldHVybiBoID4gMCAmJiBNYXRoLmFicyhmIC0gbCkgPCAzNjAgPyB2ID0gbnooe1xuICAgIGN4OiByLFxuICAgIGN5OiBpLFxuICAgIGlubmVyUmFkaXVzOiBvLFxuICAgIG91dGVyUmFkaXVzOiBhLFxuICAgIGNvcm5lclJhZGl1czogTWF0aC5taW4oaCwgZyAvIDIpLFxuICAgIGZvcmNlQ29ybmVyUmFkaXVzOiB1LFxuICAgIGNvcm5lcklzRXh0ZXJuYWw6IGMsXG4gICAgc3RhcnRBbmdsZTogZixcbiAgICBlbmRBbmdsZTogbFxuICB9KSA6IHYgPSBYMCh7XG4gICAgY3g6IHIsXG4gICAgY3k6IGksXG4gICAgaW5uZXJSYWRpdXM6IG8sXG4gICAgb3V0ZXJSYWRpdXM6IGEsXG4gICAgc3RhcnRBbmdsZTogZixcbiAgICBlbmRBbmdsZTogbFxuICB9KSwgLyogQF9fUFVSRV9fICovIFAuY3JlYXRlRWxlbWVudChcInBhdGhcIiwgbWwoe30sIHllKG4sICEwKSwge1xuICAgIGNsYXNzTmFtZTogcCxcbiAgICBkOiB2LFxuICAgIHJvbGU6IFwiaW1nXCJcbiAgfSkpO1xufTtcbmZ1bmN0aW9uIFNvKGUpIHtcbiAgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiO1xuICByZXR1cm4gU28gPSB0eXBlb2YgU3ltYm9sID09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09IFwic3ltYm9sXCIgPyBmdW5jdGlvbih0KSB7XG4gICAgcmV0dXJuIHR5cGVvZiB0O1xuICB9IDogZnVuY3Rpb24odCkge1xuICAgIHJldHVybiB0ICYmIHR5cGVvZiBTeW1ib2wgPT0gXCJmdW5jdGlvblwiICYmIHQuY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiB0ICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiB0O1xuICB9LCBTbyhlKTtcbn1cbmZ1bmN0aW9uIHlsKCkge1xuICByZXR1cm4geWwgPSBPYmplY3QuYXNzaWduID8gT2JqZWN0LmFzc2lnbi5iaW5kKCkgOiBmdW5jdGlvbihlKSB7XG4gICAgZm9yICh2YXIgdCA9IDE7IHQgPCBhcmd1bWVudHMubGVuZ3RoOyB0KyspIHtcbiAgICAgIHZhciBuID0gYXJndW1lbnRzW3RdO1xuICAgICAgZm9yICh2YXIgciBpbiBuKVxuICAgICAgICBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobiwgcikgJiYgKGVbcl0gPSBuW3JdKTtcbiAgICB9XG4gICAgcmV0dXJuIGU7XG4gIH0sIHlsLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5mdW5jdGlvbiBMZyhlLCB0KSB7XG4gIHZhciBuID0gT2JqZWN0LmtleXMoZSk7XG4gIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gICAgdmFyIHIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGUpO1xuICAgIHQgJiYgKHIgPSByLmZpbHRlcihmdW5jdGlvbihpKSB7XG4gICAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLCBpKS5lbnVtZXJhYmxlO1xuICAgIH0pKSwgbi5wdXNoLmFwcGx5KG4sIHIpO1xuICB9XG4gIHJldHVybiBuO1xufVxuZnVuY3Rpb24gQmcoZSkge1xuICBmb3IgKHZhciB0ID0gMTsgdCA8IGFyZ3VtZW50cy5sZW5ndGg7IHQrKykge1xuICAgIHZhciBuID0gYXJndW1lbnRzW3RdICE9IG51bGwgPyBhcmd1bWVudHNbdF0gOiB7fTtcbiAgICB0ICUgMiA/IExnKE9iamVjdChuKSwgITApLmZvckVhY2goZnVuY3Rpb24ocikge1xuICAgICAgaXooZSwgciwgbltyXSk7XG4gICAgfSkgOiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGUsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKG4pKSA6IExnKE9iamVjdChuKSkuZm9yRWFjaChmdW5jdGlvbihyKSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgciwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihuLCByKSk7XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIGU7XG59XG5mdW5jdGlvbiBpeihlLCB0LCBuKSB7XG4gIHJldHVybiB0ID0gb3oodCksIHQgaW4gZSA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCB0LCB7IHZhbHVlOiBuLCBlbnVtZXJhYmxlOiAhMCwgY29uZmlndXJhYmxlOiAhMCwgd3JpdGFibGU6ICEwIH0pIDogZVt0XSA9IG4sIGU7XG59XG5mdW5jdGlvbiBveihlKSB7XG4gIHZhciB0ID0gYXooZSwgXCJzdHJpbmdcIik7XG4gIHJldHVybiBTbyh0KSA9PSBcInN5bWJvbFwiID8gdCA6IFN0cmluZyh0KTtcbn1cbmZ1bmN0aW9uIGF6KGUsIHQpIHtcbiAgaWYgKFNvKGUpICE9IFwib2JqZWN0XCIgfHwgIWUpXG4gICAgcmV0dXJuIGU7XG4gIHZhciBuID0gZVtTeW1ib2wudG9QcmltaXRpdmVdO1xuICBpZiAobiAhPT0gdm9pZCAwKSB7XG4gICAgdmFyIHIgPSBuLmNhbGwoZSwgdCB8fCBcImRlZmF1bHRcIik7XG4gICAgaWYgKFNvKHIpICE9IFwib2JqZWN0XCIpXG4gICAgICByZXR1cm4gcjtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQEB0b1ByaW1pdGl2ZSBtdXN0IHJldHVybiBhIHByaW1pdGl2ZSB2YWx1ZS5cIik7XG4gIH1cbiAgcmV0dXJuICh0ID09PSBcInN0cmluZ1wiID8gU3RyaW5nIDogTnVtYmVyKShlKTtcbn1cbnZhciB6ZyA9IHtcbiAgY3VydmVCYXNpc0Nsb3NlZDogeFQsXG4gIGN1cnZlQmFzaXNPcGVuOiBTVCxcbiAgY3VydmVCYXNpczogd1QsXG4gIGN1cnZlQnVtcFg6IGFULFxuICBjdXJ2ZUJ1bXBZOiBzVCxcbiAgY3VydmVMaW5lYXJDbG9zZWQ6ICRULFxuICBjdXJ2ZUxpbmVhcjogVnMsXG4gIGN1cnZlTW9ub3RvbmVYOiBPVCxcbiAgY3VydmVNb25vdG9uZVk6IF9ULFxuICBjdXJ2ZU5hdHVyYWw6IEFULFxuICBjdXJ2ZVN0ZXA6IFBULFxuICBjdXJ2ZVN0ZXBBZnRlcjogRVQsXG4gIGN1cnZlU3RlcEJlZm9yZTogQ1Rcbn0sIGJhID0gZnVuY3Rpb24odCkge1xuICByZXR1cm4gdC54ID09PSArdC54ICYmIHQueSA9PT0gK3QueTtcbn0sIERpID0gZnVuY3Rpb24odCkge1xuICByZXR1cm4gdC54O1xufSwgTmkgPSBmdW5jdGlvbih0KSB7XG4gIHJldHVybiB0Lnk7XG59LCBzeiA9IGZ1bmN0aW9uKHQsIG4pIHtcbiAgaWYgKHBlKHQpKVxuICAgIHJldHVybiB0O1xuICB2YXIgciA9IFwiY3VydmVcIi5jb25jYXQoQnModCkpO1xuICByZXR1cm4gKHIgPT09IFwiY3VydmVNb25vdG9uZVwiIHx8IHIgPT09IFwiY3VydmVCdW1wXCIpICYmIG4gPyB6Z1tcIlwiLmNvbmNhdChyKS5jb25jYXQobiA9PT0gXCJ2ZXJ0aWNhbFwiID8gXCJZXCIgOiBcIlhcIildIDogemdbcl0gfHwgVnM7XG59LCB1eiA9IGZ1bmN0aW9uKHQpIHtcbiAgdmFyIG4gPSB0LnR5cGUsIHIgPSBuID09PSB2b2lkIDAgPyBcImxpbmVhclwiIDogbiwgaSA9IHQucG9pbnRzLCBvID0gaSA9PT0gdm9pZCAwID8gW10gOiBpLCBhID0gdC5iYXNlTGluZSwgcyA9IHQubGF5b3V0LCB1ID0gdC5jb25uZWN0TnVsbHMsIGMgPSB1ID09PSB2b2lkIDAgPyAhMSA6IHUsIGYgPSBzeihyLCBzKSwgbCA9IGMgPyBvLmZpbHRlcihmdW5jdGlvbihoKSB7XG4gICAgcmV0dXJuIGJhKGgpO1xuICB9KSA6IG8sIGQ7XG4gIGlmIChBcnJheS5pc0FycmF5KGEpKSB7XG4gICAgdmFyIHAgPSBjID8gYS5maWx0ZXIoZnVuY3Rpb24oaCkge1xuICAgICAgcmV0dXJuIGJhKGgpO1xuICAgIH0pIDogYSwgZyA9IGwubWFwKGZ1bmN0aW9uKGgsIHYpIHtcbiAgICAgIHJldHVybiBCZyhCZyh7fSwgaCksIHt9LCB7XG4gICAgICAgIGJhc2U6IHBbdl1cbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIHJldHVybiBzID09PSBcInZlcnRpY2FsXCIgPyBkID0gbGEoKS55KE5pKS54MShEaSkueDAoZnVuY3Rpb24oaCkge1xuICAgICAgcmV0dXJuIGguYmFzZS54O1xuICAgIH0pIDogZCA9IGxhKCkueChEaSkueTEoTmkpLnkwKGZ1bmN0aW9uKGgpIHtcbiAgICAgIHJldHVybiBoLmJhc2UueTtcbiAgICB9KSwgZC5kZWZpbmVkKGJhKS5jdXJ2ZShmKSwgZChnKTtcbiAgfVxuICByZXR1cm4gcyA9PT0gXCJ2ZXJ0aWNhbFwiICYmIEsoYSkgPyBkID0gbGEoKS55KE5pKS54MShEaSkueDAoYSkgOiBLKGEpID8gZCA9IGxhKCkueChEaSkueTEoTmkpLnkwKGEpIDogZCA9IGViKCkueChEaSkueShOaSksIGQuZGVmaW5lZChiYSkuY3VydmUoZiksIGQobCk7XG59LCBibCA9IGZ1bmN0aW9uKHQpIHtcbiAgdmFyIG4gPSB0LmNsYXNzTmFtZSwgciA9IHQucG9pbnRzLCBpID0gdC5wYXRoLCBvID0gdC5wYXRoUmVmO1xuICBpZiAoKCFyIHx8ICFyLmxlbmd0aCkgJiYgIWkpXG4gICAgcmV0dXJuIG51bGw7XG4gIHZhciBhID0gciAmJiByLmxlbmd0aCA/IHV6KHQpIDogaTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBQLmNyZWF0ZUVsZW1lbnQoXCJwYXRoXCIsIHlsKHt9LCB5ZSh0LCAhMSksIE5hKHQpLCB7XG4gICAgY2xhc3NOYW1lOiAkZShcInJlY2hhcnRzLWN1cnZlXCIsIG4pLFxuICAgIGQ6IGEsXG4gICAgcmVmOiBvXG4gIH0pKTtcbn0sIHdsID0geyBleHBvcnRzOiB7fSB9O1xuLypcbm9iamVjdC1hc3NpZ25cbihjKSBTaW5kcmUgU29yaHVzXG5AbGljZW5zZSBNSVRcbiovXG52YXIgS3UsIFZnO1xuZnVuY3Rpb24gY3ooKSB7XG4gIGlmIChWZylcbiAgICByZXR1cm4gS3U7XG4gIFZnID0gMTtcbiAgdmFyIGUgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzLCB0ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSwgbiA9IE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGU7XG4gIGZ1bmN0aW9uIHIobykge1xuICAgIGlmIChvID09IG51bGwpXG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiT2JqZWN0LmFzc2lnbiBjYW5ub3QgYmUgY2FsbGVkIHdpdGggbnVsbCBvciB1bmRlZmluZWRcIik7XG4gICAgcmV0dXJuIE9iamVjdChvKTtcbiAgfVxuICBmdW5jdGlvbiBpKCkge1xuICAgIHRyeSB7XG4gICAgICBpZiAoIU9iamVjdC5hc3NpZ24pXG4gICAgICAgIHJldHVybiAhMTtcbiAgICAgIHZhciBvID0gbmV3IFN0cmluZyhcImFiY1wiKTtcbiAgICAgIGlmIChvWzVdID0gXCJkZVwiLCBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhvKVswXSA9PT0gXCI1XCIpXG4gICAgICAgIHJldHVybiAhMTtcbiAgICAgIGZvciAodmFyIGEgPSB7fSwgcyA9IDA7IHMgPCAxMDsgcysrKVxuICAgICAgICBhW1wiX1wiICsgU3RyaW5nLmZyb21DaGFyQ29kZShzKV0gPSBzO1xuICAgICAgdmFyIHUgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhhKS5tYXAoZnVuY3Rpb24oZikge1xuICAgICAgICByZXR1cm4gYVtmXTtcbiAgICAgIH0pO1xuICAgICAgaWYgKHUuam9pbihcIlwiKSAhPT0gXCIwMTIzNDU2Nzg5XCIpXG4gICAgICAgIHJldHVybiAhMTtcbiAgICAgIHZhciBjID0ge307XG4gICAgICByZXR1cm4gXCJhYmNkZWZnaGlqa2xtbm9wcXJzdFwiLnNwbGl0KFwiXCIpLmZvckVhY2goZnVuY3Rpb24oZikge1xuICAgICAgICBjW2ZdID0gZjtcbiAgICAgIH0pLCBPYmplY3Qua2V5cyhPYmplY3QuYXNzaWduKHt9LCBjKSkuam9pbihcIlwiKSA9PT0gXCJhYmNkZWZnaGlqa2xtbm9wcXJzdFwiO1xuICAgIH0gY2F0Y2gge1xuICAgICAgcmV0dXJuICExO1xuICAgIH1cbiAgfVxuICByZXR1cm4gS3UgPSBpKCkgPyBPYmplY3QuYXNzaWduIDogZnVuY3Rpb24obywgYSkge1xuICAgIGZvciAodmFyIHMsIHUgPSByKG8pLCBjLCBmID0gMTsgZiA8IGFyZ3VtZW50cy5sZW5ndGg7IGYrKykge1xuICAgICAgcyA9IE9iamVjdChhcmd1bWVudHNbZl0pO1xuICAgICAgZm9yICh2YXIgbCBpbiBzKVxuICAgICAgICB0LmNhbGwocywgbCkgJiYgKHVbbF0gPSBzW2xdKTtcbiAgICAgIGlmIChlKSB7XG4gICAgICAgIGMgPSBlKHMpO1xuICAgICAgICBmb3IgKHZhciBkID0gMDsgZCA8IGMubGVuZ3RoOyBkKyspXG4gICAgICAgICAgbi5jYWxsKHMsIGNbZF0pICYmICh1W2NbZF1dID0gc1tjW2RdXSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB1O1xuICB9LCBLdTtcbn1cbnZhciBZdSwgR2c7XG5mdW5jdGlvbiBmZCgpIHtcbiAgaWYgKEdnKVxuICAgIHJldHVybiBZdTtcbiAgR2cgPSAxO1xuICB2YXIgZSA9IFwiU0VDUkVUX0RPX05PVF9QQVNTX1RISVNfT1JfWU9VX1dJTExfQkVfRklSRURcIjtcbiAgcmV0dXJuIFl1ID0gZSwgWXU7XG59XG52YXIgWHUsIFdnO1xuZnVuY3Rpb24gSjAoKSB7XG4gIHJldHVybiBXZyB8fCAoV2cgPSAxLCBYdSA9IEZ1bmN0aW9uLmNhbGwuYmluZChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5KSksIFh1O1xufVxudmFyIFp1LCBVZztcbmZ1bmN0aW9uIGx6KCkge1xuICBpZiAoVWcpXG4gICAgcmV0dXJuIFp1O1xuICBVZyA9IDE7XG4gIHZhciBlID0gZnVuY3Rpb24oKSB7XG4gIH07XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICB2YXIgdCA9IGZkKCksIG4gPSB7fSwgciA9IEowKCk7XG4gICAgZSA9IGZ1bmN0aW9uKG8pIHtcbiAgICAgIHZhciBhID0gXCJXYXJuaW5nOiBcIiArIG87XG4gICAgICB0eXBlb2YgY29uc29sZSA8IFwidVwiICYmIGNvbnNvbGUuZXJyb3IoYSk7XG4gICAgICB0cnkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYSk7XG4gICAgICB9IGNhdGNoIHtcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIGZ1bmN0aW9uIGkobywgYSwgcywgdSwgYykge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgIGZvciAodmFyIGYgaW4gbylcbiAgICAgICAgaWYgKHIobywgZikpIHtcbiAgICAgICAgICB2YXIgbDtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBvW2ZdICE9IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICB2YXIgZCA9IEVycm9yKFxuICAgICAgICAgICAgICAgICh1IHx8IFwiUmVhY3QgY2xhc3NcIikgKyBcIjogXCIgKyBzICsgXCIgdHlwZSBgXCIgKyBmICsgXCJgIGlzIGludmFsaWQ7IGl0IG11c3QgYmUgYSBmdW5jdGlvbiwgdXN1YWxseSBmcm9tIHRoZSBgcHJvcC10eXBlc2AgcGFja2FnZSwgYnV0IHJlY2VpdmVkIGBcIiArIHR5cGVvZiBvW2ZdICsgXCJgLlRoaXMgb2Z0ZW4gaGFwcGVucyBiZWNhdXNlIG9mIHR5cG9zIHN1Y2ggYXMgYFByb3BUeXBlcy5mdW5jdGlvbmAgaW5zdGVhZCBvZiBgUHJvcFR5cGVzLmZ1bmNgLlwiXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIHRocm93IGQubmFtZSA9IFwiSW52YXJpYW50IFZpb2xhdGlvblwiLCBkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbCA9IG9bZl0oYSwgZiwgdSwgcywgbnVsbCwgdCk7XG4gICAgICAgICAgfSBjYXRjaCAoZykge1xuICAgICAgICAgICAgbCA9IGc7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChsICYmICEobCBpbnN0YW5jZW9mIEVycm9yKSAmJiBlKFxuICAgICAgICAgICAgKHUgfHwgXCJSZWFjdCBjbGFzc1wiKSArIFwiOiB0eXBlIHNwZWNpZmljYXRpb24gb2YgXCIgKyBzICsgXCIgYFwiICsgZiArIFwiYCBpcyBpbnZhbGlkOyB0aGUgdHlwZSBjaGVja2VyIGZ1bmN0aW9uIG11c3QgcmV0dXJuIGBudWxsYCBvciBhbiBgRXJyb3JgIGJ1dCByZXR1cm5lZCBhIFwiICsgdHlwZW9mIGwgKyBcIi4gWW91IG1heSBoYXZlIGZvcmdvdHRlbiB0byBwYXNzIGFuIGFyZ3VtZW50IHRvIHRoZSB0eXBlIGNoZWNrZXIgY3JlYXRvciAoYXJyYXlPZiwgaW5zdGFuY2VPZiwgb2JqZWN0T2YsIG9uZU9mLCBvbmVPZlR5cGUsIGFuZCBzaGFwZSBhbGwgcmVxdWlyZSBhbiBhcmd1bWVudCkuXCJcbiAgICAgICAgICApLCBsIGluc3RhbmNlb2YgRXJyb3IgJiYgIShsLm1lc3NhZ2UgaW4gbikpIHtcbiAgICAgICAgICAgIG5bbC5tZXNzYWdlXSA9ICEwO1xuICAgICAgICAgICAgdmFyIHAgPSBjID8gYygpIDogXCJcIjtcbiAgICAgICAgICAgIGUoXG4gICAgICAgICAgICAgIFwiRmFpbGVkIFwiICsgcyArIFwiIHR5cGU6IFwiICsgbC5tZXNzYWdlICsgKHAgPz8gXCJcIilcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBpLnJlc2V0V2FybmluZ0NhY2hlID0gZnVuY3Rpb24oKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIChuID0ge30pO1xuICB9LCBadSA9IGksIFp1O1xufVxudmFyIEp1LCBIZztcbmZ1bmN0aW9uIGZ6KCkge1xuICBpZiAoSGcpXG4gICAgcmV0dXJuIEp1O1xuICBIZyA9IDE7XG4gIHZhciBlID0gT2YsIHQgPSBjeigpLCBuID0gZmQoKSwgciA9IEowKCksIGkgPSBseigpLCBvID0gZnVuY3Rpb24oKSB7XG4gIH07XG4gIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiAobyA9IGZ1bmN0aW9uKHMpIHtcbiAgICB2YXIgdSA9IFwiV2FybmluZzogXCIgKyBzO1xuICAgIHR5cGVvZiBjb25zb2xlIDwgXCJ1XCIgJiYgY29uc29sZS5lcnJvcih1KTtcbiAgICB0cnkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKHUpO1xuICAgIH0gY2F0Y2gge1xuICAgIH1cbiAgfSk7XG4gIGZ1bmN0aW9uIGEoKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmV0dXJuIEp1ID0gZnVuY3Rpb24ocywgdSkge1xuICAgIHZhciBjID0gdHlwZW9mIFN5bWJvbCA9PSBcImZ1bmN0aW9uXCIgJiYgU3ltYm9sLml0ZXJhdG9yLCBmID0gXCJAQGl0ZXJhdG9yXCI7XG4gICAgZnVuY3Rpb24gbChJKSB7XG4gICAgICB2YXIgRCA9IEkgJiYgKGMgJiYgSVtjXSB8fCBJW2ZdKTtcbiAgICAgIGlmICh0eXBlb2YgRCA9PSBcImZ1bmN0aW9uXCIpXG4gICAgICAgIHJldHVybiBEO1xuICAgIH1cbiAgICB2YXIgZCA9IFwiPDxhbm9ueW1vdXM+PlwiLCBwID0ge1xuICAgICAgYXJyYXk6IHcoXCJhcnJheVwiKSxcbiAgICAgIGJpZ2ludDogdyhcImJpZ2ludFwiKSxcbiAgICAgIGJvb2w6IHcoXCJib29sZWFuXCIpLFxuICAgICAgZnVuYzogdyhcImZ1bmN0aW9uXCIpLFxuICAgICAgbnVtYmVyOiB3KFwibnVtYmVyXCIpLFxuICAgICAgb2JqZWN0OiB3KFwib2JqZWN0XCIpLFxuICAgICAgc3RyaW5nOiB3KFwic3RyaW5nXCIpLFxuICAgICAgc3ltYm9sOiB3KFwic3ltYm9sXCIpLFxuICAgICAgYW55OiBiKCksXG4gICAgICBhcnJheU9mOiB4LFxuICAgICAgZWxlbWVudDogbSgpLFxuICAgICAgZWxlbWVudFR5cGU6IHkoKSxcbiAgICAgIGluc3RhbmNlT2Y6IFMsXG4gICAgICBub2RlOiBNKCksXG4gICAgICBvYmplY3RPZjogTyxcbiAgICAgIG9uZU9mOiAkLFxuICAgICAgb25lT2ZUeXBlOiBULFxuICAgICAgc2hhcGU6IEEsXG4gICAgICBleGFjdDogalxuICAgIH07XG4gICAgZnVuY3Rpb24gZyhJLCBEKSB7XG4gICAgICByZXR1cm4gSSA9PT0gRCA/IEkgIT09IDAgfHwgMSAvIEkgPT09IDEgLyBEIDogSSAhPT0gSSAmJiBEICE9PSBEO1xuICAgIH1cbiAgICBmdW5jdGlvbiBoKEksIEQpIHtcbiAgICAgIHRoaXMubWVzc2FnZSA9IEksIHRoaXMuZGF0YSA9IEQgJiYgdHlwZW9mIEQgPT0gXCJvYmplY3RcIiA/IEQgOiB7fSwgdGhpcy5zdGFjayA9IFwiXCI7XG4gICAgfVxuICAgIGgucHJvdG90eXBlID0gRXJyb3IucHJvdG90eXBlO1xuICAgIGZ1bmN0aW9uIHYoSSkge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIilcbiAgICAgICAgdmFyIEQgPSB7fSwgRyA9IDA7XG4gICAgICBmdW5jdGlvbiBxKG5lLCB0ZSwgZWUsIGllLCBCLCBVLCByZSkge1xuICAgICAgICBpZiAoaWUgPSBpZSB8fCBkLCBVID0gVSB8fCBlZSwgcmUgIT09IG4pIHtcbiAgICAgICAgICBpZiAodSkge1xuICAgICAgICAgICAgdmFyIEMgPSBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgIFwiQ2FsbGluZyBQcm9wVHlwZXMgdmFsaWRhdG9ycyBkaXJlY3RseSBpcyBub3Qgc3VwcG9ydGVkIGJ5IHRoZSBgcHJvcC10eXBlc2AgcGFja2FnZS4gVXNlIGBQcm9wVHlwZXMuY2hlY2tQcm9wVHlwZXMoKWAgdG8gY2FsbCB0aGVtLiBSZWFkIG1vcmUgYXQgaHR0cDovL2ZiLm1lL3VzZS1jaGVjay1wcm9wLXR5cGVzXCJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICB0aHJvdyBDLm5hbWUgPSBcIkludmFyaWFudCBWaW9sYXRpb25cIiwgQztcbiAgICAgICAgICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiB0eXBlb2YgY29uc29sZSA8IFwidVwiKSB7XG4gICAgICAgICAgICB2YXIgZ2UgPSBpZSArIFwiOlwiICsgZWU7XG4gICAgICAgICAgICAhRFtnZV0gJiYgLy8gQXZvaWQgc3BhbW1pbmcgdGhlIGNvbnNvbGUgYmVjYXVzZSB0aGV5IGFyZSBvZnRlbiBub3QgYWN0aW9uYWJsZSBleGNlcHQgZm9yIGxpYiBhdXRob3JzXG4gICAgICAgICAgICBHIDwgMyAmJiAobyhcbiAgICAgICAgICAgICAgXCJZb3UgYXJlIG1hbnVhbGx5IGNhbGxpbmcgYSBSZWFjdC5Qcm9wVHlwZXMgdmFsaWRhdGlvbiBmdW5jdGlvbiBmb3IgdGhlIGBcIiArIFUgKyBcImAgcHJvcCBvbiBgXCIgKyBpZSArIFwiYC4gVGhpcyBpcyBkZXByZWNhdGVkIGFuZCB3aWxsIHRocm93IGluIHRoZSBzdGFuZGFsb25lIGBwcm9wLXR5cGVzYCBwYWNrYWdlLiBZb3UgbWF5IGJlIHNlZWluZyB0aGlzIHdhcm5pbmcgZHVlIHRvIGEgdGhpcmQtcGFydHkgUHJvcFR5cGVzIGxpYnJhcnkuIFNlZSBodHRwczovL2ZiLm1lL3JlYWN0LXdhcm5pbmctZG9udC1jYWxsLXByb3B0eXBlcyBmb3IgZGV0YWlscy5cIlxuICAgICAgICAgICAgKSwgRFtnZV0gPSAhMCwgRysrKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRlW2VlXSA9PSBudWxsID8gbmUgPyB0ZVtlZV0gPT09IG51bGwgPyBuZXcgaChcIlRoZSBcIiArIEIgKyBcIiBgXCIgKyBVICsgXCJgIGlzIG1hcmtlZCBhcyByZXF1aXJlZCBcIiArIChcImluIGBcIiArIGllICsgXCJgLCBidXQgaXRzIHZhbHVlIGlzIGBudWxsYC5cIikpIDogbmV3IGgoXCJUaGUgXCIgKyBCICsgXCIgYFwiICsgVSArIFwiYCBpcyBtYXJrZWQgYXMgcmVxdWlyZWQgaW4gXCIgKyAoXCJgXCIgKyBpZSArIFwiYCwgYnV0IGl0cyB2YWx1ZSBpcyBgdW5kZWZpbmVkYC5cIikpIDogbnVsbCA6IEkodGUsIGVlLCBpZSwgQiwgVSk7XG4gICAgICB9XG4gICAgICB2YXIgSiA9IHEuYmluZChudWxsLCAhMSk7XG4gICAgICByZXR1cm4gSi5pc1JlcXVpcmVkID0gcS5iaW5kKG51bGwsICEwKSwgSjtcbiAgICB9XG4gICAgZnVuY3Rpb24gdyhJKSB7XG4gICAgICBmdW5jdGlvbiBEKEcsIHEsIEosIG5lLCB0ZSwgZWUpIHtcbiAgICAgICAgdmFyIGllID0gR1txXSwgQiA9IGsoaWUpO1xuICAgICAgICBpZiAoQiAhPT0gSSkge1xuICAgICAgICAgIHZhciBVID0gRihpZSk7XG4gICAgICAgICAgcmV0dXJuIG5ldyBoKFxuICAgICAgICAgICAgXCJJbnZhbGlkIFwiICsgbmUgKyBcIiBgXCIgKyB0ZSArIFwiYCBvZiB0eXBlIFwiICsgKFwiYFwiICsgVSArIFwiYCBzdXBwbGllZCB0byBgXCIgKyBKICsgXCJgLCBleHBlY3RlZCBcIikgKyAoXCJgXCIgKyBJICsgXCJgLlwiKSxcbiAgICAgICAgICAgIHsgZXhwZWN0ZWRUeXBlOiBJIH1cbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHYoRCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGIoKSB7XG4gICAgICByZXR1cm4gdihhKTtcbiAgICB9XG4gICAgZnVuY3Rpb24geChJKSB7XG4gICAgICBmdW5jdGlvbiBEKEcsIHEsIEosIG5lLCB0ZSkge1xuICAgICAgICBpZiAodHlwZW9mIEkgIT0gXCJmdW5jdGlvblwiKVxuICAgICAgICAgIHJldHVybiBuZXcgaChcIlByb3BlcnR5IGBcIiArIHRlICsgXCJgIG9mIGNvbXBvbmVudCBgXCIgKyBKICsgXCJgIGhhcyBpbnZhbGlkIFByb3BUeXBlIG5vdGF0aW9uIGluc2lkZSBhcnJheU9mLlwiKTtcbiAgICAgICAgdmFyIGVlID0gR1txXTtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGVlKSkge1xuICAgICAgICAgIHZhciBpZSA9IGsoZWUpO1xuICAgICAgICAgIHJldHVybiBuZXcgaChcIkludmFsaWQgXCIgKyBuZSArIFwiIGBcIiArIHRlICsgXCJgIG9mIHR5cGUgXCIgKyAoXCJgXCIgKyBpZSArIFwiYCBzdXBwbGllZCB0byBgXCIgKyBKICsgXCJgLCBleHBlY3RlZCBhbiBhcnJheS5cIikpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIEIgPSAwOyBCIDwgZWUubGVuZ3RoOyBCKyspIHtcbiAgICAgICAgICB2YXIgVSA9IEkoZWUsIEIsIEosIG5lLCB0ZSArIFwiW1wiICsgQiArIFwiXVwiLCBuKTtcbiAgICAgICAgICBpZiAoVSBpbnN0YW5jZW9mIEVycm9yKVxuICAgICAgICAgICAgcmV0dXJuIFU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICByZXR1cm4gdihEKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gbSgpIHtcbiAgICAgIGZ1bmN0aW9uIEkoRCwgRywgcSwgSiwgbmUpIHtcbiAgICAgICAgdmFyIHRlID0gRFtHXTtcbiAgICAgICAgaWYgKCFzKHRlKSkge1xuICAgICAgICAgIHZhciBlZSA9IGsodGUpO1xuICAgICAgICAgIHJldHVybiBuZXcgaChcIkludmFsaWQgXCIgKyBKICsgXCIgYFwiICsgbmUgKyBcImAgb2YgdHlwZSBcIiArIChcImBcIiArIGVlICsgXCJgIHN1cHBsaWVkIHRvIGBcIiArIHEgKyBcImAsIGV4cGVjdGVkIGEgc2luZ2xlIFJlYWN0RWxlbWVudC5cIikpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHYoSSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHkoKSB7XG4gICAgICBmdW5jdGlvbiBJKEQsIEcsIHEsIEosIG5lKSB7XG4gICAgICAgIHZhciB0ZSA9IERbR107XG4gICAgICAgIGlmICghZS5pc1ZhbGlkRWxlbWVudFR5cGUodGUpKSB7XG4gICAgICAgICAgdmFyIGVlID0gayh0ZSk7XG4gICAgICAgICAgcmV0dXJuIG5ldyBoKFwiSW52YWxpZCBcIiArIEogKyBcIiBgXCIgKyBuZSArIFwiYCBvZiB0eXBlIFwiICsgKFwiYFwiICsgZWUgKyBcImAgc3VwcGxpZWQgdG8gYFwiICsgcSArIFwiYCwgZXhwZWN0ZWQgYSBzaW5nbGUgUmVhY3RFbGVtZW50IHR5cGUuXCIpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2KEkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBTKEkpIHtcbiAgICAgIGZ1bmN0aW9uIEQoRywgcSwgSiwgbmUsIHRlKSB7XG4gICAgICAgIGlmICghKEdbcV0gaW5zdGFuY2VvZiBJKSkge1xuICAgICAgICAgIHZhciBlZSA9IEkubmFtZSB8fCBkLCBpZSA9IEwoR1txXSk7XG4gICAgICAgICAgcmV0dXJuIG5ldyBoKFwiSW52YWxpZCBcIiArIG5lICsgXCIgYFwiICsgdGUgKyBcImAgb2YgdHlwZSBcIiArIChcImBcIiArIGllICsgXCJgIHN1cHBsaWVkIHRvIGBcIiArIEogKyBcImAsIGV4cGVjdGVkIFwiKSArIChcImluc3RhbmNlIG9mIGBcIiArIGVlICsgXCJgLlwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICByZXR1cm4gdihEKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gJChJKSB7XG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkoSSkpXG4gICAgICAgIHJldHVybiBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgKGFyZ3VtZW50cy5sZW5ndGggPiAxID8gbyhcbiAgICAgICAgICBcIkludmFsaWQgYXJndW1lbnRzIHN1cHBsaWVkIHRvIG9uZU9mLCBleHBlY3RlZCBhbiBhcnJheSwgZ290IFwiICsgYXJndW1lbnRzLmxlbmd0aCArIFwiIGFyZ3VtZW50cy4gQSBjb21tb24gbWlzdGFrZSBpcyB0byB3cml0ZSBvbmVPZih4LCB5LCB6KSBpbnN0ZWFkIG9mIG9uZU9mKFt4LCB5LCB6XSkuXCJcbiAgICAgICAgKSA6IG8oXCJJbnZhbGlkIGFyZ3VtZW50IHN1cHBsaWVkIHRvIG9uZU9mLCBleHBlY3RlZCBhbiBhcnJheS5cIikpLCBhO1xuICAgICAgZnVuY3Rpb24gRChHLCBxLCBKLCBuZSwgdGUpIHtcbiAgICAgICAgZm9yICh2YXIgZWUgPSBHW3FdLCBpZSA9IDA7IGllIDwgSS5sZW5ndGg7IGllKyspXG4gICAgICAgICAgaWYgKGcoZWUsIElbaWVdKSlcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB2YXIgQiA9IEpTT04uc3RyaW5naWZ5KEksIGZ1bmN0aW9uKHJlLCBDKSB7XG4gICAgICAgICAgdmFyIGdlID0gRihDKTtcbiAgICAgICAgICByZXR1cm4gZ2UgPT09IFwic3ltYm9sXCIgPyBTdHJpbmcoQykgOiBDO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG5ldyBoKFwiSW52YWxpZCBcIiArIG5lICsgXCIgYFwiICsgdGUgKyBcImAgb2YgdmFsdWUgYFwiICsgU3RyaW5nKGVlKSArIFwiYCBcIiArIChcInN1cHBsaWVkIHRvIGBcIiArIEogKyBcImAsIGV4cGVjdGVkIG9uZSBvZiBcIiArIEIgKyBcIi5cIikpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHYoRCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIE8oSSkge1xuICAgICAgZnVuY3Rpb24gRChHLCBxLCBKLCBuZSwgdGUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBJICE9IFwiZnVuY3Rpb25cIilcbiAgICAgICAgICByZXR1cm4gbmV3IGgoXCJQcm9wZXJ0eSBgXCIgKyB0ZSArIFwiYCBvZiBjb21wb25lbnQgYFwiICsgSiArIFwiYCBoYXMgaW52YWxpZCBQcm9wVHlwZSBub3RhdGlvbiBpbnNpZGUgb2JqZWN0T2YuXCIpO1xuICAgICAgICB2YXIgZWUgPSBHW3FdLCBpZSA9IGsoZWUpO1xuICAgICAgICBpZiAoaWUgIT09IFwib2JqZWN0XCIpXG4gICAgICAgICAgcmV0dXJuIG5ldyBoKFwiSW52YWxpZCBcIiArIG5lICsgXCIgYFwiICsgdGUgKyBcImAgb2YgdHlwZSBcIiArIChcImBcIiArIGllICsgXCJgIHN1cHBsaWVkIHRvIGBcIiArIEogKyBcImAsIGV4cGVjdGVkIGFuIG9iamVjdC5cIikpO1xuICAgICAgICBmb3IgKHZhciBCIGluIGVlKVxuICAgICAgICAgIGlmIChyKGVlLCBCKSkge1xuICAgICAgICAgICAgdmFyIFUgPSBJKGVlLCBCLCBKLCBuZSwgdGUgKyBcIi5cIiArIEIsIG4pO1xuICAgICAgICAgICAgaWYgKFUgaW5zdGFuY2VvZiBFcnJvcilcbiAgICAgICAgICAgICAgcmV0dXJuIFU7XG4gICAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2KEQpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBUKEkpIHtcbiAgICAgIGlmICghQXJyYXkuaXNBcnJheShJKSlcbiAgICAgICAgcmV0dXJuIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiBvKFwiSW52YWxpZCBhcmd1bWVudCBzdXBwbGllZCB0byBvbmVPZlR5cGUsIGV4cGVjdGVkIGFuIGluc3RhbmNlIG9mIGFycmF5LlwiKSwgYTtcbiAgICAgIGZvciAodmFyIEQgPSAwOyBEIDwgSS5sZW5ndGg7IEQrKykge1xuICAgICAgICB2YXIgRyA9IElbRF07XG4gICAgICAgIGlmICh0eXBlb2YgRyAhPSBcImZ1bmN0aW9uXCIpXG4gICAgICAgICAgcmV0dXJuIG8oXG4gICAgICAgICAgICBcIkludmFsaWQgYXJndW1lbnQgc3VwcGxpZWQgdG8gb25lT2ZUeXBlLiBFeHBlY3RlZCBhbiBhcnJheSBvZiBjaGVjayBmdW5jdGlvbnMsIGJ1dCByZWNlaXZlZCBcIiArIFYoRykgKyBcIiBhdCBpbmRleCBcIiArIEQgKyBcIi5cIlxuICAgICAgICAgICksIGE7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBxKEosIG5lLCB0ZSwgZWUsIGllKSB7XG4gICAgICAgIGZvciAodmFyIEIgPSBbXSwgVSA9IDA7IFUgPCBJLmxlbmd0aDsgVSsrKSB7XG4gICAgICAgICAgdmFyIHJlID0gSVtVXSwgQyA9IHJlKEosIG5lLCB0ZSwgZWUsIGllLCBuKTtcbiAgICAgICAgICBpZiAoQyA9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgQy5kYXRhICYmIHIoQy5kYXRhLCBcImV4cGVjdGVkVHlwZVwiKSAmJiBCLnB1c2goQy5kYXRhLmV4cGVjdGVkVHlwZSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGdlID0gQi5sZW5ndGggPiAwID8gXCIsIGV4cGVjdGVkIG9uZSBvZiB0eXBlIFtcIiArIEIuam9pbihcIiwgXCIpICsgXCJdXCIgOiBcIlwiO1xuICAgICAgICByZXR1cm4gbmV3IGgoXCJJbnZhbGlkIFwiICsgZWUgKyBcIiBgXCIgKyBpZSArIFwiYCBzdXBwbGllZCB0byBcIiArIChcImBcIiArIHRlICsgXCJgXCIgKyBnZSArIFwiLlwiKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdihxKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gTSgpIHtcbiAgICAgIGZ1bmN0aW9uIEkoRCwgRywgcSwgSiwgbmUpIHtcbiAgICAgICAgcmV0dXJuIFIoRFtHXSkgPyBudWxsIDogbmV3IGgoXCJJbnZhbGlkIFwiICsgSiArIFwiIGBcIiArIG5lICsgXCJgIHN1cHBsaWVkIHRvIFwiICsgKFwiYFwiICsgcSArIFwiYCwgZXhwZWN0ZWQgYSBSZWFjdE5vZGUuXCIpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2KEkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBFKEksIEQsIEcsIHEsIEopIHtcbiAgICAgIHJldHVybiBuZXcgaChcbiAgICAgICAgKEkgfHwgXCJSZWFjdCBjbGFzc1wiKSArIFwiOiBcIiArIEQgKyBcIiB0eXBlIGBcIiArIEcgKyBcIi5cIiArIHEgKyBcImAgaXMgaW52YWxpZDsgaXQgbXVzdCBiZSBhIGZ1bmN0aW9uLCB1c3VhbGx5IGZyb20gdGhlIGBwcm9wLXR5cGVzYCBwYWNrYWdlLCBidXQgcmVjZWl2ZWQgYFwiICsgSiArIFwiYC5cIlxuICAgICAgKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gQShJKSB7XG4gICAgICBmdW5jdGlvbiBEKEcsIHEsIEosIG5lLCB0ZSkge1xuICAgICAgICB2YXIgZWUgPSBHW3FdLCBpZSA9IGsoZWUpO1xuICAgICAgICBpZiAoaWUgIT09IFwib2JqZWN0XCIpXG4gICAgICAgICAgcmV0dXJuIG5ldyBoKFwiSW52YWxpZCBcIiArIG5lICsgXCIgYFwiICsgdGUgKyBcImAgb2YgdHlwZSBgXCIgKyBpZSArIFwiYCBcIiArIChcInN1cHBsaWVkIHRvIGBcIiArIEogKyBcImAsIGV4cGVjdGVkIGBvYmplY3RgLlwiKSk7XG4gICAgICAgIGZvciAodmFyIEIgaW4gSSkge1xuICAgICAgICAgIHZhciBVID0gSVtCXTtcbiAgICAgICAgICBpZiAodHlwZW9mIFUgIT0gXCJmdW5jdGlvblwiKVxuICAgICAgICAgICAgcmV0dXJuIEUoSiwgbmUsIHRlLCBCLCBGKFUpKTtcbiAgICAgICAgICB2YXIgcmUgPSBVKGVlLCBCLCBKLCBuZSwgdGUgKyBcIi5cIiArIEIsIG4pO1xuICAgICAgICAgIGlmIChyZSlcbiAgICAgICAgICAgIHJldHVybiByZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2KEQpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBqKEkpIHtcbiAgICAgIGZ1bmN0aW9uIEQoRywgcSwgSiwgbmUsIHRlKSB7XG4gICAgICAgIHZhciBlZSA9IEdbcV0sIGllID0gayhlZSk7XG4gICAgICAgIGlmIChpZSAhPT0gXCJvYmplY3RcIilcbiAgICAgICAgICByZXR1cm4gbmV3IGgoXCJJbnZhbGlkIFwiICsgbmUgKyBcIiBgXCIgKyB0ZSArIFwiYCBvZiB0eXBlIGBcIiArIGllICsgXCJgIFwiICsgKFwic3VwcGxpZWQgdG8gYFwiICsgSiArIFwiYCwgZXhwZWN0ZWQgYG9iamVjdGAuXCIpKTtcbiAgICAgICAgdmFyIEIgPSB0KHt9LCBHW3FdLCBJKTtcbiAgICAgICAgZm9yICh2YXIgVSBpbiBCKSB7XG4gICAgICAgICAgdmFyIHJlID0gSVtVXTtcbiAgICAgICAgICBpZiAocihJLCBVKSAmJiB0eXBlb2YgcmUgIT0gXCJmdW5jdGlvblwiKVxuICAgICAgICAgICAgcmV0dXJuIEUoSiwgbmUsIHRlLCBVLCBGKHJlKSk7XG4gICAgICAgICAgaWYgKCFyZSlcbiAgICAgICAgICAgIHJldHVybiBuZXcgaChcbiAgICAgICAgICAgICAgXCJJbnZhbGlkIFwiICsgbmUgKyBcIiBgXCIgKyB0ZSArIFwiYCBrZXkgYFwiICsgVSArIFwiYCBzdXBwbGllZCB0byBgXCIgKyBKICsgXCJgLlxcbkJhZCBvYmplY3Q6IFwiICsgSlNPTi5zdHJpbmdpZnkoR1txXSwgbnVsbCwgXCIgIFwiKSArIGBcblZhbGlkIGtleXM6IGAgKyBKU09OLnN0cmluZ2lmeShPYmplY3Qua2V5cyhJKSwgbnVsbCwgXCIgIFwiKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB2YXIgQyA9IHJlKGVlLCBVLCBKLCBuZSwgdGUgKyBcIi5cIiArIFUsIG4pO1xuICAgICAgICAgIGlmIChDKVxuICAgICAgICAgICAgcmV0dXJuIEM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICByZXR1cm4gdihEKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gUihJKSB7XG4gICAgICBzd2l0Y2ggKHR5cGVvZiBJKSB7XG4gICAgICAgIGNhc2UgXCJudW1iZXJcIjpcbiAgICAgICAgY2FzZSBcInN0cmluZ1wiOlxuICAgICAgICBjYXNlIFwidW5kZWZpbmVkXCI6XG4gICAgICAgICAgcmV0dXJuICEwO1xuICAgICAgICBjYXNlIFwiYm9vbGVhblwiOlxuICAgICAgICAgIHJldHVybiAhSTtcbiAgICAgICAgY2FzZSBcIm9iamVjdFwiOlxuICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KEkpKVxuICAgICAgICAgICAgcmV0dXJuIEkuZXZlcnkoUik7XG4gICAgICAgICAgaWYgKEkgPT09IG51bGwgfHwgcyhJKSlcbiAgICAgICAgICAgIHJldHVybiAhMDtcbiAgICAgICAgICB2YXIgRCA9IGwoSSk7XG4gICAgICAgICAgaWYgKEQpIHtcbiAgICAgICAgICAgIHZhciBHID0gRC5jYWxsKEkpLCBxO1xuICAgICAgICAgICAgaWYgKEQgIT09IEkuZW50cmllcykge1xuICAgICAgICAgICAgICBmb3IgKDsgIShxID0gRy5uZXh0KCkpLmRvbmU7IClcbiAgICAgICAgICAgICAgICBpZiAoIVIocS52YWx1ZSkpXG4gICAgICAgICAgICAgICAgICByZXR1cm4gITE7XG4gICAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgICAgZm9yICg7ICEocSA9IEcubmV4dCgpKS5kb25lOyApIHtcbiAgICAgICAgICAgICAgICB2YXIgSiA9IHEudmFsdWU7XG4gICAgICAgICAgICAgICAgaWYgKEogJiYgIVIoSlsxXSkpXG4gICAgICAgICAgICAgICAgICByZXR1cm4gITE7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgIHJldHVybiAhMTtcbiAgICAgICAgICByZXR1cm4gITA7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuICExO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBOKEksIEQpIHtcbiAgICAgIHJldHVybiBJID09PSBcInN5bWJvbFwiID8gITAgOiBEID8gRFtcIkBAdG9TdHJpbmdUYWdcIl0gPT09IFwiU3ltYm9sXCIgfHwgdHlwZW9mIFN5bWJvbCA9PSBcImZ1bmN0aW9uXCIgJiYgRCBpbnN0YW5jZW9mIFN5bWJvbCA6ICExO1xuICAgIH1cbiAgICBmdW5jdGlvbiBrKEkpIHtcbiAgICAgIHZhciBEID0gdHlwZW9mIEk7XG4gICAgICByZXR1cm4gQXJyYXkuaXNBcnJheShJKSA/IFwiYXJyYXlcIiA6IEkgaW5zdGFuY2VvZiBSZWdFeHAgPyBcIm9iamVjdFwiIDogTihELCBJKSA/IFwic3ltYm9sXCIgOiBEO1xuICAgIH1cbiAgICBmdW5jdGlvbiBGKEkpIHtcbiAgICAgIGlmICh0eXBlb2YgSSA+IFwidVwiIHx8IEkgPT09IG51bGwpXG4gICAgICAgIHJldHVybiBcIlwiICsgSTtcbiAgICAgIHZhciBEID0gayhJKTtcbiAgICAgIGlmIChEID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIGlmIChJIGluc3RhbmNlb2YgRGF0ZSlcbiAgICAgICAgICByZXR1cm4gXCJkYXRlXCI7XG4gICAgICAgIGlmIChJIGluc3RhbmNlb2YgUmVnRXhwKVxuICAgICAgICAgIHJldHVybiBcInJlZ2V4cFwiO1xuICAgICAgfVxuICAgICAgcmV0dXJuIEQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFYoSSkge1xuICAgICAgdmFyIEQgPSBGKEkpO1xuICAgICAgc3dpdGNoIChEKSB7XG4gICAgICAgIGNhc2UgXCJhcnJheVwiOlxuICAgICAgICBjYXNlIFwib2JqZWN0XCI6XG4gICAgICAgICAgcmV0dXJuIFwiYW4gXCIgKyBEO1xuICAgICAgICBjYXNlIFwiYm9vbGVhblwiOlxuICAgICAgICBjYXNlIFwiZGF0ZVwiOlxuICAgICAgICBjYXNlIFwicmVnZXhwXCI6XG4gICAgICAgICAgcmV0dXJuIFwiYSBcIiArIEQ7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuIEQ7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIEwoSSkge1xuICAgICAgcmV0dXJuICFJLmNvbnN0cnVjdG9yIHx8ICFJLmNvbnN0cnVjdG9yLm5hbWUgPyBkIDogSS5jb25zdHJ1Y3Rvci5uYW1lO1xuICAgIH1cbiAgICByZXR1cm4gcC5jaGVja1Byb3BUeXBlcyA9IGksIHAucmVzZXRXYXJuaW5nQ2FjaGUgPSBpLnJlc2V0V2FybmluZ0NhY2hlLCBwLlByb3BUeXBlcyA9IHAsIHA7XG4gIH0sIEp1O1xufVxudmFyIFF1LCBxZztcbmZ1bmN0aW9uIGR6KCkge1xuICBpZiAocWcpXG4gICAgcmV0dXJuIFF1O1xuICBxZyA9IDE7XG4gIHZhciBlID0gZmQoKTtcbiAgZnVuY3Rpb24gdCgpIHtcbiAgfVxuICBmdW5jdGlvbiBuKCkge1xuICB9XG4gIHJldHVybiBuLnJlc2V0V2FybmluZ0NhY2hlID0gdCwgUXUgPSBmdW5jdGlvbigpIHtcbiAgICBmdW5jdGlvbiByKGEsIHMsIHUsIGMsIGYsIGwpIHtcbiAgICAgIGlmIChsICE9PSBlKSB7XG4gICAgICAgIHZhciBkID0gbmV3IEVycm9yKFxuICAgICAgICAgIFwiQ2FsbGluZyBQcm9wVHlwZXMgdmFsaWRhdG9ycyBkaXJlY3RseSBpcyBub3Qgc3VwcG9ydGVkIGJ5IHRoZSBgcHJvcC10eXBlc2AgcGFja2FnZS4gVXNlIFByb3BUeXBlcy5jaGVja1Byb3BUeXBlcygpIHRvIGNhbGwgdGhlbS4gUmVhZCBtb3JlIGF0IGh0dHA6Ly9mYi5tZS91c2UtY2hlY2stcHJvcC10eXBlc1wiXG4gICAgICAgICk7XG4gICAgICAgIHRocm93IGQubmFtZSA9IFwiSW52YXJpYW50IFZpb2xhdGlvblwiLCBkO1xuICAgICAgfVxuICAgIH1cbiAgICByLmlzUmVxdWlyZWQgPSByO1xuICAgIGZ1bmN0aW9uIGkoKSB7XG4gICAgICByZXR1cm4gcjtcbiAgICB9XG4gICAgdmFyIG8gPSB7XG4gICAgICBhcnJheTogcixcbiAgICAgIGJpZ2ludDogcixcbiAgICAgIGJvb2w6IHIsXG4gICAgICBmdW5jOiByLFxuICAgICAgbnVtYmVyOiByLFxuICAgICAgb2JqZWN0OiByLFxuICAgICAgc3RyaW5nOiByLFxuICAgICAgc3ltYm9sOiByLFxuICAgICAgYW55OiByLFxuICAgICAgYXJyYXlPZjogaSxcbiAgICAgIGVsZW1lbnQ6IHIsXG4gICAgICBlbGVtZW50VHlwZTogcixcbiAgICAgIGluc3RhbmNlT2Y6IGksXG4gICAgICBub2RlOiByLFxuICAgICAgb2JqZWN0T2Y6IGksXG4gICAgICBvbmVPZjogaSxcbiAgICAgIG9uZU9mVHlwZTogaSxcbiAgICAgIHNoYXBlOiBpLFxuICAgICAgZXhhY3Q6IGksXG4gICAgICBjaGVja1Byb3BUeXBlczogbixcbiAgICAgIHJlc2V0V2FybmluZ0NhY2hlOiB0XG4gICAgfTtcbiAgICByZXR1cm4gby5Qcm9wVHlwZXMgPSBvLCBvO1xuICB9LCBRdTtcbn1cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgdmFyIHB6ID0gT2YsIGh6ID0gITA7XG4gIHdsLmV4cG9ydHMgPSBmeigpKHB6LmlzRWxlbWVudCwgaHopO1xufSBlbHNlXG4gIHdsLmV4cG9ydHMgPSBkeigpKCk7XG52YXIgZ3ogPSB3bC5leHBvcnRzO1xuY29uc3QgZGUgPSAvKiBAX19QVVJFX18gKi8gamUoZ3opO1xudmFyIHZ6ID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMsIG16ID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scywgeXogPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuZnVuY3Rpb24gS2coZSwgdCkge1xuICByZXR1cm4gZnVuY3Rpb24ociwgaSwgbykge1xuICAgIHJldHVybiBlKHIsIGksIG8pICYmIHQociwgaSwgbyk7XG4gIH07XG59XG5mdW5jdGlvbiB3YShlKSB7XG4gIHJldHVybiBmdW5jdGlvbihuLCByLCBpKSB7XG4gICAgaWYgKCFuIHx8ICFyIHx8IHR5cGVvZiBuICE9IFwib2JqZWN0XCIgfHwgdHlwZW9mIHIgIT0gXCJvYmplY3RcIilcbiAgICAgIHJldHVybiBlKG4sIHIsIGkpO1xuICAgIHZhciBvID0gaS5jYWNoZSwgYSA9IG8uZ2V0KG4pLCBzID0gby5nZXQocik7XG4gICAgaWYgKGEgJiYgcylcbiAgICAgIHJldHVybiBhID09PSByICYmIHMgPT09IG47XG4gICAgby5zZXQobiwgciksIG8uc2V0KHIsIG4pO1xuICAgIHZhciB1ID0gZShuLCByLCBpKTtcbiAgICByZXR1cm4gby5kZWxldGUobiksIG8uZGVsZXRlKHIpLCB1O1xuICB9O1xufVxuZnVuY3Rpb24gWWcoZSkge1xuICByZXR1cm4gdnooZSkuY29uY2F0KG16KGUpKTtcbn1cbnZhciBRMCA9IE9iamVjdC5oYXNPd24gfHwgZnVuY3Rpb24oZSwgdCkge1xuICByZXR1cm4geXouY2FsbChlLCB0KTtcbn07XG5mdW5jdGlvbiBiaShlLCB0KSB7XG4gIHJldHVybiBlIHx8IHQgPyBlID09PSB0IDogZSA9PT0gdCB8fCBlICE9PSBlICYmIHQgIT09IHQ7XG59XG52YXIgZXcgPSBcIl9vd25lclwiLCBYZyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IsIFpnID0gT2JqZWN0LmtleXM7XG5mdW5jdGlvbiBieihlLCB0LCBuKSB7XG4gIHZhciByID0gZS5sZW5ndGg7XG4gIGlmICh0Lmxlbmd0aCAhPT0gcilcbiAgICByZXR1cm4gITE7XG4gIGZvciAoOyByLS0gPiAwOyApXG4gICAgaWYgKCFuLmVxdWFscyhlW3JdLCB0W3JdLCByLCByLCBlLCB0LCBuKSlcbiAgICAgIHJldHVybiAhMTtcbiAgcmV0dXJuICEwO1xufVxuZnVuY3Rpb24gd3ooZSwgdCkge1xuICByZXR1cm4gYmkoZS5nZXRUaW1lKCksIHQuZ2V0VGltZSgpKTtcbn1cbmZ1bmN0aW9uIEpnKGUsIHQsIG4pIHtcbiAgaWYgKGUuc2l6ZSAhPT0gdC5zaXplKVxuICAgIHJldHVybiAhMTtcbiAgZm9yICh2YXIgciA9IHt9LCBpID0gZS5lbnRyaWVzKCksIG8gPSAwLCBhLCBzOyAoYSA9IGkubmV4dCgpKSAmJiAhYS5kb25lOyApIHtcbiAgICBmb3IgKHZhciB1ID0gdC5lbnRyaWVzKCksIGMgPSAhMSwgZiA9IDA7IChzID0gdS5uZXh0KCkpICYmICFzLmRvbmU7ICkge1xuICAgICAgdmFyIGwgPSBhLnZhbHVlLCBkID0gbFswXSwgcCA9IGxbMV0sIGcgPSBzLnZhbHVlLCBoID0gZ1swXSwgdiA9IGdbMV07XG4gICAgICAhYyAmJiAhcltmXSAmJiAoYyA9IG4uZXF1YWxzKGQsIGgsIG8sIGYsIGUsIHQsIG4pICYmIG4uZXF1YWxzKHAsIHYsIGQsIGgsIGUsIHQsIG4pKSAmJiAocltmXSA9ICEwKSwgZisrO1xuICAgIH1cbiAgICBpZiAoIWMpXG4gICAgICByZXR1cm4gITE7XG4gICAgbysrO1xuICB9XG4gIHJldHVybiAhMDtcbn1cbmZ1bmN0aW9uIHh6KGUsIHQsIG4pIHtcbiAgdmFyIHIgPSBaZyhlKSwgaSA9IHIubGVuZ3RoO1xuICBpZiAoWmcodCkubGVuZ3RoICE9PSBpKVxuICAgIHJldHVybiAhMTtcbiAgZm9yICh2YXIgbzsgaS0tID4gMDsgKVxuICAgIGlmIChvID0gcltpXSwgbyA9PT0gZXcgJiYgKGUuJCR0eXBlb2YgfHwgdC4kJHR5cGVvZikgJiYgZS4kJHR5cGVvZiAhPT0gdC4kJHR5cGVvZiB8fCAhUTAodCwgbykgfHwgIW4uZXF1YWxzKGVbb10sIHRbb10sIG8sIG8sIGUsIHQsIG4pKVxuICAgICAgcmV0dXJuICExO1xuICByZXR1cm4gITA7XG59XG5mdW5jdGlvbiBGaShlLCB0LCBuKSB7XG4gIHZhciByID0gWWcoZSksIGkgPSByLmxlbmd0aDtcbiAgaWYgKFlnKHQpLmxlbmd0aCAhPT0gaSlcbiAgICByZXR1cm4gITE7XG4gIGZvciAodmFyIG8sIGEsIHM7IGktLSA+IDA7IClcbiAgICBpZiAobyA9IHJbaV0sIG8gPT09IGV3ICYmIChlLiQkdHlwZW9mIHx8IHQuJCR0eXBlb2YpICYmIGUuJCR0eXBlb2YgIT09IHQuJCR0eXBlb2YgfHwgIVEwKHQsIG8pIHx8ICFuLmVxdWFscyhlW29dLCB0W29dLCBvLCBvLCBlLCB0LCBuKSB8fCAoYSA9IFhnKGUsIG8pLCBzID0gWGcodCwgbyksIChhIHx8IHMpICYmICghYSB8fCAhcyB8fCBhLmNvbmZpZ3VyYWJsZSAhPT0gcy5jb25maWd1cmFibGUgfHwgYS5lbnVtZXJhYmxlICE9PSBzLmVudW1lcmFibGUgfHwgYS53cml0YWJsZSAhPT0gcy53cml0YWJsZSkpKVxuICAgICAgcmV0dXJuICExO1xuICByZXR1cm4gITA7XG59XG5mdW5jdGlvbiBTeihlLCB0KSB7XG4gIHJldHVybiBiaShlLnZhbHVlT2YoKSwgdC52YWx1ZU9mKCkpO1xufVxuZnVuY3Rpb24gJHooZSwgdCkge1xuICByZXR1cm4gZS5zb3VyY2UgPT09IHQuc291cmNlICYmIGUuZmxhZ3MgPT09IHQuZmxhZ3M7XG59XG5mdW5jdGlvbiBRZyhlLCB0LCBuKSB7XG4gIGlmIChlLnNpemUgIT09IHQuc2l6ZSlcbiAgICByZXR1cm4gITE7XG4gIGZvciAodmFyIHIgPSB7fSwgaSA9IGUudmFsdWVzKCksIG8sIGE7IChvID0gaS5uZXh0KCkpICYmICFvLmRvbmU7ICkge1xuICAgIGZvciAodmFyIHMgPSB0LnZhbHVlcygpLCB1ID0gITEsIGMgPSAwOyAoYSA9IHMubmV4dCgpKSAmJiAhYS5kb25lOyApXG4gICAgICAhdSAmJiAhcltjXSAmJiAodSA9IG4uZXF1YWxzKG8udmFsdWUsIGEudmFsdWUsIG8udmFsdWUsIGEudmFsdWUsIGUsIHQsIG4pKSAmJiAocltjXSA9ICEwKSwgYysrO1xuICAgIGlmICghdSlcbiAgICAgIHJldHVybiAhMTtcbiAgfVxuICByZXR1cm4gITA7XG59XG5mdW5jdGlvbiBPeihlLCB0KSB7XG4gIHZhciBuID0gZS5sZW5ndGg7XG4gIGlmICh0Lmxlbmd0aCAhPT0gbilcbiAgICByZXR1cm4gITE7XG4gIGZvciAoOyBuLS0gPiAwOyApXG4gICAgaWYgKGVbbl0gIT09IHRbbl0pXG4gICAgICByZXR1cm4gITE7XG4gIHJldHVybiAhMDtcbn1cbnZhciBfeiA9IFwiW29iamVjdCBBcmd1bWVudHNdXCIsIEF6ID0gXCJbb2JqZWN0IEJvb2xlYW5dXCIsIFB6ID0gXCJbb2JqZWN0IERhdGVdXCIsIEN6ID0gXCJbb2JqZWN0IE1hcF1cIiwgRXogPSBcIltvYmplY3QgTnVtYmVyXVwiLCBUeiA9IFwiW29iamVjdCBPYmplY3RdXCIsIE16ID0gXCJbb2JqZWN0IFJlZ0V4cF1cIiwgUnogPSBcIltvYmplY3QgU2V0XVwiLCBJeiA9IFwiW29iamVjdCBTdHJpbmddXCIsIGp6ID0gQXJyYXkuaXNBcnJheSwgZXYgPSB0eXBlb2YgQXJyYXlCdWZmZXIgPT0gXCJmdW5jdGlvblwiICYmIEFycmF5QnVmZmVyLmlzVmlldyA/IEFycmF5QnVmZmVyLmlzVmlldyA6IG51bGwsIHR2ID0gT2JqZWN0LmFzc2lnbiwga3ogPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwuYmluZChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nKTtcbmZ1bmN0aW9uIER6KGUpIHtcbiAgdmFyIHQgPSBlLmFyZUFycmF5c0VxdWFsLCBuID0gZS5hcmVEYXRlc0VxdWFsLCByID0gZS5hcmVNYXBzRXF1YWwsIGkgPSBlLmFyZU9iamVjdHNFcXVhbCwgbyA9IGUuYXJlUHJpbWl0aXZlV3JhcHBlcnNFcXVhbCwgYSA9IGUuYXJlUmVnRXhwc0VxdWFsLCBzID0gZS5hcmVTZXRzRXF1YWwsIHUgPSBlLmFyZVR5cGVkQXJyYXlzRXF1YWw7XG4gIHJldHVybiBmdW5jdGlvbihmLCBsLCBkKSB7XG4gICAgaWYgKGYgPT09IGwpXG4gICAgICByZXR1cm4gITA7XG4gICAgaWYgKGYgPT0gbnVsbCB8fCBsID09IG51bGwgfHwgdHlwZW9mIGYgIT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgbCAhPSBcIm9iamVjdFwiKVxuICAgICAgcmV0dXJuIGYgIT09IGYgJiYgbCAhPT0gbDtcbiAgICB2YXIgcCA9IGYuY29uc3RydWN0b3I7XG4gICAgaWYgKHAgIT09IGwuY29uc3RydWN0b3IpXG4gICAgICByZXR1cm4gITE7XG4gICAgaWYgKHAgPT09IE9iamVjdClcbiAgICAgIHJldHVybiBpKGYsIGwsIGQpO1xuICAgIGlmIChqeihmKSlcbiAgICAgIHJldHVybiB0KGYsIGwsIGQpO1xuICAgIGlmIChldiAhPSBudWxsICYmIGV2KGYpKVxuICAgICAgcmV0dXJuIHUoZiwgbCwgZCk7XG4gICAgaWYgKHAgPT09IERhdGUpXG4gICAgICByZXR1cm4gbihmLCBsLCBkKTtcbiAgICBpZiAocCA9PT0gUmVnRXhwKVxuICAgICAgcmV0dXJuIGEoZiwgbCwgZCk7XG4gICAgaWYgKHAgPT09IE1hcClcbiAgICAgIHJldHVybiByKGYsIGwsIGQpO1xuICAgIGlmIChwID09PSBTZXQpXG4gICAgICByZXR1cm4gcyhmLCBsLCBkKTtcbiAgICB2YXIgZyA9IGt6KGYpO1xuICAgIHJldHVybiBnID09PSBQeiA/IG4oZiwgbCwgZCkgOiBnID09PSBNeiA/IGEoZiwgbCwgZCkgOiBnID09PSBDeiA/IHIoZiwgbCwgZCkgOiBnID09PSBSeiA/IHMoZiwgbCwgZCkgOiBnID09PSBUeiA/IHR5cGVvZiBmLnRoZW4gIT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBsLnRoZW4gIT0gXCJmdW5jdGlvblwiICYmIGkoZiwgbCwgZCkgOiBnID09PSBfeiA/IGkoZiwgbCwgZCkgOiBnID09PSBBeiB8fCBnID09PSBFeiB8fCBnID09PSBJeiA/IG8oZiwgbCwgZCkgOiAhMTtcbiAgfTtcbn1cbmZ1bmN0aW9uIE56KGUpIHtcbiAgdmFyIHQgPSBlLmNpcmN1bGFyLCBuID0gZS5jcmVhdGVDdXN0b21Db25maWcsIHIgPSBlLnN0cmljdCwgaSA9IHtcbiAgICBhcmVBcnJheXNFcXVhbDogciA/IEZpIDogYnosXG4gICAgYXJlRGF0ZXNFcXVhbDogd3osXG4gICAgYXJlTWFwc0VxdWFsOiByID8gS2coSmcsIEZpKSA6IEpnLFxuICAgIGFyZU9iamVjdHNFcXVhbDogciA/IEZpIDogeHosXG4gICAgYXJlUHJpbWl0aXZlV3JhcHBlcnNFcXVhbDogU3osXG4gICAgYXJlUmVnRXhwc0VxdWFsOiAkeixcbiAgICBhcmVTZXRzRXF1YWw6IHIgPyBLZyhRZywgRmkpIDogUWcsXG4gICAgYXJlVHlwZWRBcnJheXNFcXVhbDogciA/IEZpIDogT3pcbiAgfTtcbiAgaWYgKG4gJiYgKGkgPSB0dih7fSwgaSwgbihpKSkpLCB0KSB7XG4gICAgdmFyIG8gPSB3YShpLmFyZUFycmF5c0VxdWFsKSwgYSA9IHdhKGkuYXJlTWFwc0VxdWFsKSwgcyA9IHdhKGkuYXJlT2JqZWN0c0VxdWFsKSwgdSA9IHdhKGkuYXJlU2V0c0VxdWFsKTtcbiAgICBpID0gdHYoe30sIGksIHtcbiAgICAgIGFyZUFycmF5c0VxdWFsOiBvLFxuICAgICAgYXJlTWFwc0VxdWFsOiBhLFxuICAgICAgYXJlT2JqZWN0c0VxdWFsOiBzLFxuICAgICAgYXJlU2V0c0VxdWFsOiB1XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIGk7XG59XG5mdW5jdGlvbiBGeihlKSB7XG4gIHJldHVybiBmdW5jdGlvbih0LCBuLCByLCBpLCBvLCBhLCBzKSB7XG4gICAgcmV0dXJuIGUodCwgbiwgcyk7XG4gIH07XG59XG5mdW5jdGlvbiBMeihlKSB7XG4gIHZhciB0ID0gZS5jaXJjdWxhciwgbiA9IGUuY29tcGFyYXRvciwgciA9IGUuY3JlYXRlU3RhdGUsIGkgPSBlLmVxdWFscywgbyA9IGUuc3RyaWN0O1xuICBpZiAocilcbiAgICByZXR1cm4gZnVuY3Rpb24odSwgYykge1xuICAgICAgdmFyIGYgPSByKCksIGwgPSBmLmNhY2hlLCBkID0gbCA9PT0gdm9pZCAwID8gdCA/IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpIDogdm9pZCAwIDogbCwgcCA9IGYubWV0YTtcbiAgICAgIHJldHVybiBuKHUsIGMsIHtcbiAgICAgICAgY2FjaGU6IGQsXG4gICAgICAgIGVxdWFsczogaSxcbiAgICAgICAgbWV0YTogcCxcbiAgICAgICAgc3RyaWN0OiBvXG4gICAgICB9KTtcbiAgICB9O1xuICBpZiAodClcbiAgICByZXR1cm4gZnVuY3Rpb24odSwgYykge1xuICAgICAgcmV0dXJuIG4odSwgYywge1xuICAgICAgICBjYWNoZTogLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCksXG4gICAgICAgIGVxdWFsczogaSxcbiAgICAgICAgbWV0YTogdm9pZCAwLFxuICAgICAgICBzdHJpY3Q6IG9cbiAgICAgIH0pO1xuICAgIH07XG4gIHZhciBhID0ge1xuICAgIGNhY2hlOiB2b2lkIDAsXG4gICAgZXF1YWxzOiBpLFxuICAgIG1ldGE6IHZvaWQgMCxcbiAgICBzdHJpY3Q6IG9cbiAgfTtcbiAgcmV0dXJuIGZ1bmN0aW9uKHUsIGMpIHtcbiAgICByZXR1cm4gbih1LCBjLCBhKTtcbiAgfTtcbn1cbnZhciBCeiA9IFluKCk7XG5Zbih7IHN0cmljdDogITAgfSk7XG5Zbih7IGNpcmN1bGFyOiAhMCB9KTtcblluKHtcbiAgY2lyY3VsYXI6ICEwLFxuICBzdHJpY3Q6ICEwXG59KTtcblluKHtcbiAgY3JlYXRlSW50ZXJuYWxDb21wYXJhdG9yOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gYmk7XG4gIH1cbn0pO1xuWW4oe1xuICBzdHJpY3Q6ICEwLFxuICBjcmVhdGVJbnRlcm5hbENvbXBhcmF0b3I6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBiaTtcbiAgfVxufSk7XG5Zbih7XG4gIGNpcmN1bGFyOiAhMCxcbiAgY3JlYXRlSW50ZXJuYWxDb21wYXJhdG9yOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gYmk7XG4gIH1cbn0pO1xuWW4oe1xuICBjaXJjdWxhcjogITAsXG4gIGNyZWF0ZUludGVybmFsQ29tcGFyYXRvcjogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGJpO1xuICB9LFxuICBzdHJpY3Q6ICEwXG59KTtcbmZ1bmN0aW9uIFluKGUpIHtcbiAgZSA9PT0gdm9pZCAwICYmIChlID0ge30pO1xuICB2YXIgdCA9IGUuY2lyY3VsYXIsIG4gPSB0ID09PSB2b2lkIDAgPyAhMSA6IHQsIHIgPSBlLmNyZWF0ZUludGVybmFsQ29tcGFyYXRvciwgaSA9IGUuY3JlYXRlU3RhdGUsIG8gPSBlLnN0cmljdCwgYSA9IG8gPT09IHZvaWQgMCA/ICExIDogbywgcyA9IE56KGUpLCB1ID0gRHoocyksIGMgPSByID8gcih1KSA6IEZ6KHUpO1xuICByZXR1cm4gTHooeyBjaXJjdWxhcjogbiwgY29tcGFyYXRvcjogdSwgY3JlYXRlU3RhdGU6IGksIGVxdWFsczogYywgc3RyaWN0OiBhIH0pO1xufVxuZnVuY3Rpb24genooZSkge1xuICB0eXBlb2YgcmVxdWVzdEFuaW1hdGlvbkZyYW1lIDwgXCJ1XCIgJiYgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGUpO1xufVxuZnVuY3Rpb24gbnYoZSkge1xuICB2YXIgdCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdm9pZCAwID8gYXJndW1lbnRzWzFdIDogMCwgbiA9IC0xLCByID0gZnVuY3Rpb24gaShvKSB7XG4gICAgbiA8IDAgJiYgKG4gPSBvKSwgbyAtIG4gPiB0ID8gKGUobyksIG4gPSAtMSkgOiB6eihpKTtcbiAgfTtcbiAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHIpO1xufVxuZnVuY3Rpb24geGwoZSkge1xuICBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7XG4gIHJldHVybiB4bCA9IHR5cGVvZiBTeW1ib2wgPT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uKHQpIHtcbiAgICByZXR1cm4gdHlwZW9mIHQ7XG4gIH0gOiBmdW5jdGlvbih0KSB7XG4gICAgcmV0dXJuIHQgJiYgdHlwZW9mIFN5bWJvbCA9PSBcImZ1bmN0aW9uXCIgJiYgdC5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIHQgIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIHQ7XG4gIH0sIHhsKGUpO1xufVxuZnVuY3Rpb24gVnooZSkge1xuICByZXR1cm4gSHooZSkgfHwgVXooZSkgfHwgV3ooZSkgfHwgR3ooKTtcbn1cbmZ1bmN0aW9uIEd6KCkge1xuICB0aHJvdyBuZXcgVHlwZUVycm9yKGBJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLmApO1xufVxuZnVuY3Rpb24gV3ooZSwgdCkge1xuICBpZiAoZSkge1xuICAgIGlmICh0eXBlb2YgZSA9PSBcInN0cmluZ1wiKVxuICAgICAgcmV0dXJuIHJ2KGUsIHQpO1xuICAgIHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGUpLnNsaWNlKDgsIC0xKTtcbiAgICBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBlLmNvbnN0cnVjdG9yICYmIChuID0gZS5jb25zdHJ1Y3Rvci5uYW1lKSwgbiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKVxuICAgICAgcmV0dXJuIEFycmF5LmZyb20oZSk7XG4gICAgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpXG4gICAgICByZXR1cm4gcnYoZSwgdCk7XG4gIH1cbn1cbmZ1bmN0aW9uIHJ2KGUsIHQpIHtcbiAgKHQgPT0gbnVsbCB8fCB0ID4gZS5sZW5ndGgpICYmICh0ID0gZS5sZW5ndGgpO1xuICBmb3IgKHZhciBuID0gMCwgciA9IG5ldyBBcnJheSh0KTsgbiA8IHQ7IG4rKylcbiAgICByW25dID0gZVtuXTtcbiAgcmV0dXJuIHI7XG59XG5mdW5jdGlvbiBVeihlKSB7XG4gIGlmICh0eXBlb2YgU3ltYm9sIDwgXCJ1XCIgJiYgZVtTeW1ib2wuaXRlcmF0b3JdICE9IG51bGwgfHwgZVtcIkBAaXRlcmF0b3JcIl0gIT0gbnVsbClcbiAgICByZXR1cm4gQXJyYXkuZnJvbShlKTtcbn1cbmZ1bmN0aW9uIEh6KGUpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoZSkpXG4gICAgcmV0dXJuIGU7XG59XG5mdW5jdGlvbiBxeigpIHtcbiAgdmFyIGUgPSB7fSwgdCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBudWxsO1xuICB9LCBuID0gITEsIHIgPSBmdW5jdGlvbiBpKG8pIHtcbiAgICBpZiAoIW4pIHtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KG8pKSB7XG4gICAgICAgIGlmICghby5sZW5ndGgpXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB2YXIgYSA9IG8sIHMgPSBWeihhKSwgdSA9IHNbMF0sIGMgPSBzLnNsaWNlKDEpO1xuICAgICAgICBpZiAodHlwZW9mIHUgPT0gXCJudW1iZXJcIikge1xuICAgICAgICAgIG52KGkuYmluZChudWxsLCBjKSwgdSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGkodSksIG52KGkuYmluZChudWxsLCBjKSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHhsKG8pID09PSBcIm9iamVjdFwiICYmIChlID0gbywgdChlKSksIHR5cGVvZiBvID09IFwiZnVuY3Rpb25cIiAmJiBvKCk7XG4gICAgfVxuICB9O1xuICByZXR1cm4ge1xuICAgIHN0b3A6IGZ1bmN0aW9uKCkge1xuICAgICAgbiA9ICEwO1xuICAgIH0sXG4gICAgc3RhcnQ6IGZ1bmN0aW9uKG8pIHtcbiAgICAgIG4gPSAhMSwgcihvKTtcbiAgICB9LFxuICAgIHN1YnNjcmliZTogZnVuY3Rpb24obykge1xuICAgICAgcmV0dXJuIHQgPSBvLCBmdW5jdGlvbigpIHtcbiAgICAgICAgdCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9O1xuICAgICAgfTtcbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiAkbyhlKSB7XG4gIFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjtcbiAgcmV0dXJuICRvID0gdHlwZW9mIFN5bWJvbCA9PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PSBcInN5bWJvbFwiID8gZnVuY3Rpb24odCkge1xuICAgIHJldHVybiB0eXBlb2YgdDtcbiAgfSA6IGZ1bmN0aW9uKHQpIHtcbiAgICByZXR1cm4gdCAmJiB0eXBlb2YgU3ltYm9sID09IFwiZnVuY3Rpb25cIiAmJiB0LmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgdCAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2YgdDtcbiAgfSwgJG8oZSk7XG59XG5mdW5jdGlvbiBpdihlLCB0KSB7XG4gIHZhciBuID0gT2JqZWN0LmtleXMoZSk7XG4gIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gICAgdmFyIHIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGUpO1xuICAgIHQgJiYgKHIgPSByLmZpbHRlcihmdW5jdGlvbihpKSB7XG4gICAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLCBpKS5lbnVtZXJhYmxlO1xuICAgIH0pKSwgbi5wdXNoLmFwcGx5KG4sIHIpO1xuICB9XG4gIHJldHVybiBuO1xufVxuZnVuY3Rpb24gb3YoZSkge1xuICBmb3IgKHZhciB0ID0gMTsgdCA8IGFyZ3VtZW50cy5sZW5ndGg7IHQrKykge1xuICAgIHZhciBuID0gYXJndW1lbnRzW3RdICE9IG51bGwgPyBhcmd1bWVudHNbdF0gOiB7fTtcbiAgICB0ICUgMiA/IGl2KE9iamVjdChuKSwgITApLmZvckVhY2goZnVuY3Rpb24ocikge1xuICAgICAgdHcoZSwgciwgbltyXSk7XG4gICAgfSkgOiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGUsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKG4pKSA6IGl2KE9iamVjdChuKSkuZm9yRWFjaChmdW5jdGlvbihyKSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgciwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihuLCByKSk7XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIGU7XG59XG5mdW5jdGlvbiB0dyhlLCB0LCBuKSB7XG4gIHJldHVybiB0ID0gS3oodCksIHQgaW4gZSA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCB0LCB7IHZhbHVlOiBuLCBlbnVtZXJhYmxlOiAhMCwgY29uZmlndXJhYmxlOiAhMCwgd3JpdGFibGU6ICEwIH0pIDogZVt0XSA9IG4sIGU7XG59XG5mdW5jdGlvbiBLeihlKSB7XG4gIHZhciB0ID0gWXooZSwgXCJzdHJpbmdcIik7XG4gIHJldHVybiAkbyh0KSA9PT0gXCJzeW1ib2xcIiA/IHQgOiBTdHJpbmcodCk7XG59XG5mdW5jdGlvbiBZeihlLCB0KSB7XG4gIGlmICgkbyhlKSAhPT0gXCJvYmplY3RcIiB8fCBlID09PSBudWxsKVxuICAgIHJldHVybiBlO1xuICB2YXIgbiA9IGVbU3ltYm9sLnRvUHJpbWl0aXZlXTtcbiAgaWYgKG4gIT09IHZvaWQgMCkge1xuICAgIHZhciByID0gbi5jYWxsKGUsIHQgfHwgXCJkZWZhdWx0XCIpO1xuICAgIGlmICgkbyhyKSAhPT0gXCJvYmplY3RcIilcbiAgICAgIHJldHVybiByO1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJAQHRvUHJpbWl0aXZlIG11c3QgcmV0dXJuIGEgcHJpbWl0aXZlIHZhbHVlLlwiKTtcbiAgfVxuICByZXR1cm4gKHQgPT09IFwic3RyaW5nXCIgPyBTdHJpbmcgOiBOdW1iZXIpKGUpO1xufVxudmFyIFh6ID0gZnVuY3Rpb24odCwgbikge1xuICByZXR1cm4gW09iamVjdC5rZXlzKHQpLCBPYmplY3Qua2V5cyhuKV0ucmVkdWNlKGZ1bmN0aW9uKHIsIGkpIHtcbiAgICByZXR1cm4gci5maWx0ZXIoZnVuY3Rpb24obykge1xuICAgICAgcmV0dXJuIGkuaW5jbHVkZXMobyk7XG4gICAgfSk7XG4gIH0pO1xufSwgWnogPSBmdW5jdGlvbih0KSB7XG4gIHJldHVybiB0O1xufSwgSnogPSBmdW5jdGlvbih0KSB7XG4gIHJldHVybiB0LnJlcGxhY2UoLyhbQS1aXSkvZywgZnVuY3Rpb24obikge1xuICAgIHJldHVybiBcIi1cIi5jb25jYXQobi50b0xvd2VyQ2FzZSgpKTtcbiAgfSk7XG59LCBIaSA9IGZ1bmN0aW9uKHQsIG4pIHtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKG4pLnJlZHVjZShmdW5jdGlvbihyLCBpKSB7XG4gICAgcmV0dXJuIG92KG92KHt9LCByKSwge30sIHR3KHt9LCBpLCB0KGksIG5baV0pKSk7XG4gIH0sIHt9KTtcbn0sIGF2ID0gZnVuY3Rpb24odCwgbiwgcikge1xuICByZXR1cm4gdC5tYXAoZnVuY3Rpb24oaSkge1xuICAgIHJldHVybiBcIlwiLmNvbmNhdChKeihpKSwgXCIgXCIpLmNvbmNhdChuLCBcIm1zIFwiKS5jb25jYXQocik7XG4gIH0pLmpvaW4oXCIsXCIpO1xufSwgUXogPSBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIsIGhzID0gZnVuY3Rpb24odCwgbiwgciwgaSwgbywgYSwgcywgdSkge1xuICBpZiAoUXogJiYgdHlwZW9mIGNvbnNvbGUgPCBcInVcIiAmJiBjb25zb2xlLndhcm4gJiYgKG4gPT09IHZvaWQgMCAmJiBjb25zb2xlLndhcm4oXCJMb2dVdGlscyByZXF1aXJlcyBhbiBlcnJvciBtZXNzYWdlIGFyZ3VtZW50XCIpLCAhdCkpXG4gICAgaWYgKG4gPT09IHZvaWQgMClcbiAgICAgIGNvbnNvbGUud2FybihcIk1pbmlmaWVkIGV4Y2VwdGlvbiBvY2N1cnJlZDsgdXNlIHRoZSBub24tbWluaWZpZWQgZGV2IGVudmlyb25tZW50IGZvciB0aGUgZnVsbCBlcnJvciBtZXNzYWdlIGFuZCBhZGRpdGlvbmFsIGhlbHBmdWwgd2FybmluZ3MuXCIpO1xuICAgIGVsc2Uge1xuICAgICAgdmFyIGMgPSBbciwgaSwgbywgYSwgcywgdV0sIGYgPSAwO1xuICAgICAgY29uc29sZS53YXJuKG4ucmVwbGFjZSgvJXMvZywgZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBjW2YrK107XG4gICAgICB9KSk7XG4gICAgfVxufTtcbmZ1bmN0aW9uIGU3KGUsIHQpIHtcbiAgcmV0dXJuIHI3KGUpIHx8IG43KGUsIHQpIHx8IG53KGUsIHQpIHx8IHQ3KCk7XG59XG5mdW5jdGlvbiB0NygpIHtcbiAgdGhyb3cgbmV3IFR5cGVFcnJvcihgSW52YWxpZCBhdHRlbXB0IHRvIGRlc3RydWN0dXJlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5gKTtcbn1cbmZ1bmN0aW9uIG43KGUsIHQpIHtcbiAgdmFyIG4gPSBlID09IG51bGwgPyBudWxsIDogdHlwZW9mIFN5bWJvbCA8IFwidVwiICYmIGVbU3ltYm9sLml0ZXJhdG9yXSB8fCBlW1wiQEBpdGVyYXRvclwiXTtcbiAgaWYgKG4gIT0gbnVsbCkge1xuICAgIHZhciByLCBpLCBvLCBhLCBzID0gW10sIHUgPSAhMCwgYyA9ICExO1xuICAgIHRyeSB7XG4gICAgICBpZiAobyA9IChuID0gbi5jYWxsKGUpKS5uZXh0LCB0ICE9PSAwKVxuICAgICAgICBmb3IgKDsgISh1ID0gKHIgPSBvLmNhbGwobikpLmRvbmUpICYmIChzLnB1c2goci52YWx1ZSksIHMubGVuZ3RoICE9PSB0KTsgdSA9ICEwKVxuICAgICAgICAgIDtcbiAgICB9IGNhdGNoIChmKSB7XG4gICAgICBjID0gITAsIGkgPSBmO1xuICAgIH0gZmluYWxseSB7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAoIXUgJiYgbi5yZXR1cm4gIT0gbnVsbCAmJiAoYSA9IG4ucmV0dXJuKCksIE9iamVjdChhKSAhPT0gYSkpXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgaWYgKGMpXG4gICAgICAgICAgdGhyb3cgaTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHM7XG4gIH1cbn1cbmZ1bmN0aW9uIHI3KGUpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoZSkpXG4gICAgcmV0dXJuIGU7XG59XG5mdW5jdGlvbiBpNyhlKSB7XG4gIHJldHVybiBzNyhlKSB8fCBhNyhlKSB8fCBudyhlKSB8fCBvNygpO1xufVxuZnVuY3Rpb24gbzcoKSB7XG4gIHRocm93IG5ldyBUeXBlRXJyb3IoYEludmFsaWQgYXR0ZW1wdCB0byBzcHJlYWQgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLmApO1xufVxuZnVuY3Rpb24gbncoZSwgdCkge1xuICBpZiAoZSkge1xuICAgIGlmICh0eXBlb2YgZSA9PSBcInN0cmluZ1wiKVxuICAgICAgcmV0dXJuIFNsKGUsIHQpO1xuICAgIHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGUpLnNsaWNlKDgsIC0xKTtcbiAgICBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBlLmNvbnN0cnVjdG9yICYmIChuID0gZS5jb25zdHJ1Y3Rvci5uYW1lKSwgbiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKVxuICAgICAgcmV0dXJuIEFycmF5LmZyb20oZSk7XG4gICAgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpXG4gICAgICByZXR1cm4gU2woZSwgdCk7XG4gIH1cbn1cbmZ1bmN0aW9uIGE3KGUpIHtcbiAgaWYgKHR5cGVvZiBTeW1ib2wgPCBcInVcIiAmJiBlW1N5bWJvbC5pdGVyYXRvcl0gIT0gbnVsbCB8fCBlW1wiQEBpdGVyYXRvclwiXSAhPSBudWxsKVxuICAgIHJldHVybiBBcnJheS5mcm9tKGUpO1xufVxuZnVuY3Rpb24gczcoZSkge1xuICBpZiAoQXJyYXkuaXNBcnJheShlKSlcbiAgICByZXR1cm4gU2woZSk7XG59XG5mdW5jdGlvbiBTbChlLCB0KSB7XG4gICh0ID09IG51bGwgfHwgdCA+IGUubGVuZ3RoKSAmJiAodCA9IGUubGVuZ3RoKTtcbiAgZm9yICh2YXIgbiA9IDAsIHIgPSBuZXcgQXJyYXkodCk7IG4gPCB0OyBuKyspXG4gICAgcltuXSA9IGVbbl07XG4gIHJldHVybiByO1xufVxudmFyIGdzID0gMWUtNCwgcncgPSBmdW5jdGlvbih0LCBuKSB7XG4gIHJldHVybiBbMCwgMyAqIHQsIDMgKiBuIC0gNiAqIHQsIDMgKiB0IC0gMyAqIG4gKyAxXTtcbn0sIGl3ID0gZnVuY3Rpb24odCwgbikge1xuICByZXR1cm4gdC5tYXAoZnVuY3Rpb24ociwgaSkge1xuICAgIHJldHVybiByICogTWF0aC5wb3cobiwgaSk7XG4gIH0pLnJlZHVjZShmdW5jdGlvbihyLCBpKSB7XG4gICAgcmV0dXJuIHIgKyBpO1xuICB9KTtcbn0sIHN2ID0gZnVuY3Rpb24odCwgbikge1xuICByZXR1cm4gZnVuY3Rpb24ocikge1xuICAgIHZhciBpID0gcncodCwgbik7XG4gICAgcmV0dXJuIGl3KGksIHIpO1xuICB9O1xufSwgdTcgPSBmdW5jdGlvbih0LCBuKSB7XG4gIHJldHVybiBmdW5jdGlvbihyKSB7XG4gICAgdmFyIGkgPSBydyh0LCBuKSwgbyA9IFtdLmNvbmNhdChpNyhpLm1hcChmdW5jdGlvbihhLCBzKSB7XG4gICAgICByZXR1cm4gYSAqIHM7XG4gICAgfSkuc2xpY2UoMSkpLCBbMF0pO1xuICAgIHJldHVybiBpdyhvLCByKTtcbiAgfTtcbn0sIHV2ID0gZnVuY3Rpb24oKSB7XG4gIGZvciAodmFyIHQgPSBhcmd1bWVudHMubGVuZ3RoLCBuID0gbmV3IEFycmF5KHQpLCByID0gMDsgciA8IHQ7IHIrKylcbiAgICBuW3JdID0gYXJndW1lbnRzW3JdO1xuICB2YXIgaSA9IG5bMF0sIG8gPSBuWzFdLCBhID0gblsyXSwgcyA9IG5bM107XG4gIGlmIChuLmxlbmd0aCA9PT0gMSlcbiAgICBzd2l0Y2ggKG5bMF0pIHtcbiAgICAgIGNhc2UgXCJsaW5lYXJcIjpcbiAgICAgICAgaSA9IDAsIG8gPSAwLCBhID0gMSwgcyA9IDE7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcImVhc2VcIjpcbiAgICAgICAgaSA9IDAuMjUsIG8gPSAwLjEsIGEgPSAwLjI1LCBzID0gMTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiZWFzZS1pblwiOlxuICAgICAgICBpID0gMC40MiwgbyA9IDAsIGEgPSAxLCBzID0gMTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiZWFzZS1vdXRcIjpcbiAgICAgICAgaSA9IDAuNDIsIG8gPSAwLCBhID0gMC41OCwgcyA9IDE7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcImVhc2UtaW4tb3V0XCI6XG4gICAgICAgIGkgPSAwLCBvID0gMCwgYSA9IDAuNTgsIHMgPSAxO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgdmFyIHUgPSBuWzBdLnNwbGl0KFwiKFwiKTtcbiAgICAgICAgaWYgKHVbMF0gPT09IFwiY3ViaWMtYmV6aWVyXCIgJiYgdVsxXS5zcGxpdChcIilcIilbMF0uc3BsaXQoXCIsXCIpLmxlbmd0aCA9PT0gNCkge1xuICAgICAgICAgIHZhciBjID0gdVsxXS5zcGxpdChcIilcIilbMF0uc3BsaXQoXCIsXCIpLm1hcChmdW5jdGlvbih2KSB7XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VGbG9hdCh2KTtcbiAgICAgICAgICB9KSwgZiA9IGU3KGMsIDQpO1xuICAgICAgICAgIGkgPSBmWzBdLCBvID0gZlsxXSwgYSA9IGZbMl0sIHMgPSBmWzNdO1xuICAgICAgICB9IGVsc2VcbiAgICAgICAgICBocyghMSwgXCJbY29uZmlnQmV6aWVyXTogYXJndW1lbnRzIHNob3VsZCBiZSBvbmUgb2Ygb25lT2YgJ2xpbmVhcicsICdlYXNlJywgJ2Vhc2UtaW4nLCAnZWFzZS1vdXQnLCAnZWFzZS1pbi1vdXQnLCdjdWJpYy1iZXppZXIoeDEseTEseDIseTIpJywgaW5zdGVhZCByZWNlaXZlZCAlc1wiLCBuKTtcbiAgICAgIH1cbiAgICB9XG4gIGhzKFtpLCBhLCBvLCBzXS5ldmVyeShmdW5jdGlvbih2KSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2ID09IFwibnVtYmVyXCIgJiYgdiA+PSAwICYmIHYgPD0gMTtcbiAgfSksIFwiW2NvbmZpZ0Jlemllcl06IGFyZ3VtZW50cyBzaG91bGQgYmUgeDEsIHkxLCB4MiwgeTIgb2YgWzAsIDFdIGluc3RlYWQgcmVjZWl2ZWQgJXNcIiwgbik7XG4gIHZhciBsID0gc3YoaSwgYSksIGQgPSBzdihvLCBzKSwgcCA9IHU3KGksIGEpLCBnID0gZnVuY3Rpb24odykge1xuICAgIHJldHVybiB3ID4gMSA/IDEgOiB3IDwgMCA/IDAgOiB3O1xuICB9LCBoID0gZnVuY3Rpb24odykge1xuICAgIGZvciAodmFyIGIgPSB3ID4gMSA/IDEgOiB3LCB4ID0gYiwgbSA9IDA7IG0gPCA4OyArK20pIHtcbiAgICAgIHZhciB5ID0gbCh4KSAtIGIsIFMgPSBwKHgpO1xuICAgICAgaWYgKE1hdGguYWJzKHkgLSBiKSA8IGdzIHx8IFMgPCBncylcbiAgICAgICAgcmV0dXJuIGQoeCk7XG4gICAgICB4ID0gZyh4IC0geSAvIFMpO1xuICAgIH1cbiAgICByZXR1cm4gZCh4KTtcbiAgfTtcbiAgcmV0dXJuIGguaXNTdGVwcGVyID0gITEsIGg7XG59LCBjNyA9IGZ1bmN0aW9uKCkge1xuICB2YXIgdCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdm9pZCAwID8gYXJndW1lbnRzWzBdIDoge30sIG4gPSB0LnN0aWZmLCByID0gbiA9PT0gdm9pZCAwID8gMTAwIDogbiwgaSA9IHQuZGFtcGluZywgbyA9IGkgPT09IHZvaWQgMCA/IDggOiBpLCBhID0gdC5kdCwgcyA9IGEgPT09IHZvaWQgMCA/IDE3IDogYSwgdSA9IGZ1bmN0aW9uKGYsIGwsIGQpIHtcbiAgICB2YXIgcCA9IC0oZiAtIGwpICogciwgZyA9IGQgKiBvLCBoID0gZCArIChwIC0gZykgKiBzIC8gMWUzLCB2ID0gZCAqIHMgLyAxZTMgKyBmO1xuICAgIHJldHVybiBNYXRoLmFicyh2IC0gbCkgPCBncyAmJiBNYXRoLmFicyhoKSA8IGdzID8gW2wsIDBdIDogW3YsIGhdO1xuICB9O1xuICByZXR1cm4gdS5pc1N0ZXBwZXIgPSAhMCwgdS5kdCA9IHMsIHU7XG59LCBsNyA9IGZ1bmN0aW9uKCkge1xuICBmb3IgKHZhciB0ID0gYXJndW1lbnRzLmxlbmd0aCwgbiA9IG5ldyBBcnJheSh0KSwgciA9IDA7IHIgPCB0OyByKyspXG4gICAgbltyXSA9IGFyZ3VtZW50c1tyXTtcbiAgdmFyIGkgPSBuWzBdO1xuICBpZiAodHlwZW9mIGkgPT0gXCJzdHJpbmdcIilcbiAgICBzd2l0Y2ggKGkpIHtcbiAgICAgIGNhc2UgXCJlYXNlXCI6XG4gICAgICBjYXNlIFwiZWFzZS1pbi1vdXRcIjpcbiAgICAgIGNhc2UgXCJlYXNlLW91dFwiOlxuICAgICAgY2FzZSBcImVhc2UtaW5cIjpcbiAgICAgIGNhc2UgXCJsaW5lYXJcIjpcbiAgICAgICAgcmV0dXJuIHV2KGkpO1xuICAgICAgY2FzZSBcInNwcmluZ1wiOlxuICAgICAgICByZXR1cm4gYzcoKTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChpLnNwbGl0KFwiKFwiKVswXSA9PT0gXCJjdWJpYy1iZXppZXJcIilcbiAgICAgICAgICByZXR1cm4gdXYoaSk7XG4gICAgICAgIGhzKCExLCBcIltjb25maWdFYXNpbmddOiBmaXJzdCBhcmd1bWVudCBzaG91bGQgYmUgb25lIG9mICdlYXNlJywgJ2Vhc2UtaW4nLCAnZWFzZS1vdXQnLCAnZWFzZS1pbi1vdXQnLCdjdWJpYy1iZXppZXIoeDEseTEseDIseTIpJywgJ2xpbmVhcicgYW5kICdzcHJpbmcnLCBpbnN0ZWFkICByZWNlaXZlZCAlc1wiLCBuKTtcbiAgICB9XG4gIHJldHVybiB0eXBlb2YgaSA9PSBcImZ1bmN0aW9uXCIgPyBpIDogKGhzKCExLCBcIltjb25maWdFYXNpbmddOiBmaXJzdCBhcmd1bWVudCB0eXBlIHNob3VsZCBiZSBmdW5jdGlvbiBvciBzdHJpbmcsIGluc3RlYWQgcmVjZWl2ZWQgJXNcIiwgbiksIG51bGwpO1xufTtcbmZ1bmN0aW9uIE9vKGUpIHtcbiAgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiO1xuICByZXR1cm4gT28gPSB0eXBlb2YgU3ltYm9sID09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09IFwic3ltYm9sXCIgPyBmdW5jdGlvbih0KSB7XG4gICAgcmV0dXJuIHR5cGVvZiB0O1xuICB9IDogZnVuY3Rpb24odCkge1xuICAgIHJldHVybiB0ICYmIHR5cGVvZiBTeW1ib2wgPT0gXCJmdW5jdGlvblwiICYmIHQuY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiB0ICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiB0O1xuICB9LCBPbyhlKTtcbn1cbmZ1bmN0aW9uIGN2KGUpIHtcbiAgcmV0dXJuIHA3KGUpIHx8IGQ3KGUpIHx8IG93KGUpIHx8IGY3KCk7XG59XG5mdW5jdGlvbiBmNygpIHtcbiAgdGhyb3cgbmV3IFR5cGVFcnJvcihgSW52YWxpZCBhdHRlbXB0IHRvIHNwcmVhZCBub24taXRlcmFibGUgaW5zdGFuY2UuXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuYCk7XG59XG5mdW5jdGlvbiBkNyhlKSB7XG4gIGlmICh0eXBlb2YgU3ltYm9sIDwgXCJ1XCIgJiYgZVtTeW1ib2wuaXRlcmF0b3JdICE9IG51bGwgfHwgZVtcIkBAaXRlcmF0b3JcIl0gIT0gbnVsbClcbiAgICByZXR1cm4gQXJyYXkuZnJvbShlKTtcbn1cbmZ1bmN0aW9uIHA3KGUpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoZSkpXG4gICAgcmV0dXJuIE9sKGUpO1xufVxuZnVuY3Rpb24gbHYoZSwgdCkge1xuICB2YXIgbiA9IE9iamVjdC5rZXlzKGUpO1xuICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykge1xuICAgIHZhciByID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhlKTtcbiAgICB0ICYmIChyID0gci5maWx0ZXIoZnVuY3Rpb24oaSkge1xuICAgICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSwgaSkuZW51bWVyYWJsZTtcbiAgICB9KSksIG4ucHVzaC5hcHBseShuLCByKTtcbiAgfVxuICByZXR1cm4gbjtcbn1cbmZ1bmN0aW9uIHR0KGUpIHtcbiAgZm9yICh2YXIgdCA9IDE7IHQgPCBhcmd1bWVudHMubGVuZ3RoOyB0KyspIHtcbiAgICB2YXIgbiA9IGFyZ3VtZW50c1t0XSAhPSBudWxsID8gYXJndW1lbnRzW3RdIDoge307XG4gICAgdCAlIDIgPyBsdihPYmplY3QobiksICEwKS5mb3JFYWNoKGZ1bmN0aW9uKHIpIHtcbiAgICAgICRsKGUsIHIsIG5bcl0pO1xuICAgIH0pIDogT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhlLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhuKSkgOiBsdihPYmplY3QobikpLmZvckVhY2goZnVuY3Rpb24ocikge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIHIsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobiwgcikpO1xuICAgIH0pO1xuICB9XG4gIHJldHVybiBlO1xufVxuZnVuY3Rpb24gJGwoZSwgdCwgbikge1xuICByZXR1cm4gdCA9IGg3KHQpLCB0IGluIGUgPyBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgdCwgeyB2YWx1ZTogbiwgZW51bWVyYWJsZTogITAsIGNvbmZpZ3VyYWJsZTogITAsIHdyaXRhYmxlOiAhMCB9KSA6IGVbdF0gPSBuLCBlO1xufVxuZnVuY3Rpb24gaDcoZSkge1xuICB2YXIgdCA9IGc3KGUsIFwic3RyaW5nXCIpO1xuICByZXR1cm4gT28odCkgPT09IFwic3ltYm9sXCIgPyB0IDogU3RyaW5nKHQpO1xufVxuZnVuY3Rpb24gZzcoZSwgdCkge1xuICBpZiAoT28oZSkgIT09IFwib2JqZWN0XCIgfHwgZSA9PT0gbnVsbClcbiAgICByZXR1cm4gZTtcbiAgdmFyIG4gPSBlW1N5bWJvbC50b1ByaW1pdGl2ZV07XG4gIGlmIChuICE9PSB2b2lkIDApIHtcbiAgICB2YXIgciA9IG4uY2FsbChlLCB0IHx8IFwiZGVmYXVsdFwiKTtcbiAgICBpZiAoT28ocikgIT09IFwib2JqZWN0XCIpXG4gICAgICByZXR1cm4gcjtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQEB0b1ByaW1pdGl2ZSBtdXN0IHJldHVybiBhIHByaW1pdGl2ZSB2YWx1ZS5cIik7XG4gIH1cbiAgcmV0dXJuICh0ID09PSBcInN0cmluZ1wiID8gU3RyaW5nIDogTnVtYmVyKShlKTtcbn1cbmZ1bmN0aW9uIHY3KGUsIHQpIHtcbiAgcmV0dXJuIGI3KGUpIHx8IHk3KGUsIHQpIHx8IG93KGUsIHQpIHx8IG03KCk7XG59XG5mdW5jdGlvbiBtNygpIHtcbiAgdGhyb3cgbmV3IFR5cGVFcnJvcihgSW52YWxpZCBhdHRlbXB0IHRvIGRlc3RydWN0dXJlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5gKTtcbn1cbmZ1bmN0aW9uIG93KGUsIHQpIHtcbiAgaWYgKGUpIHtcbiAgICBpZiAodHlwZW9mIGUgPT0gXCJzdHJpbmdcIilcbiAgICAgIHJldHVybiBPbChlLCB0KTtcbiAgICB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChlKS5zbGljZSg4LCAtMSk7XG4gICAgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgZS5jb25zdHJ1Y3RvciAmJiAobiA9IGUuY29uc3RydWN0b3IubmFtZSksIG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIilcbiAgICAgIHJldHVybiBBcnJheS5mcm9tKGUpO1xuICAgIGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKVxuICAgICAgcmV0dXJuIE9sKGUsIHQpO1xuICB9XG59XG5mdW5jdGlvbiBPbChlLCB0KSB7XG4gICh0ID09IG51bGwgfHwgdCA+IGUubGVuZ3RoKSAmJiAodCA9IGUubGVuZ3RoKTtcbiAgZm9yICh2YXIgbiA9IDAsIHIgPSBuZXcgQXJyYXkodCk7IG4gPCB0OyBuKyspXG4gICAgcltuXSA9IGVbbl07XG4gIHJldHVybiByO1xufVxuZnVuY3Rpb24geTcoZSwgdCkge1xuICB2YXIgbiA9IGUgPT0gbnVsbCA/IG51bGwgOiB0eXBlb2YgU3ltYm9sIDwgXCJ1XCIgJiYgZVtTeW1ib2wuaXRlcmF0b3JdIHx8IGVbXCJAQGl0ZXJhdG9yXCJdO1xuICBpZiAobiAhPSBudWxsKSB7XG4gICAgdmFyIHIsIGksIG8sIGEsIHMgPSBbXSwgdSA9ICEwLCBjID0gITE7XG4gICAgdHJ5IHtcbiAgICAgIGlmIChvID0gKG4gPSBuLmNhbGwoZSkpLm5leHQsIHQgIT09IDApXG4gICAgICAgIGZvciAoOyAhKHUgPSAociA9IG8uY2FsbChuKSkuZG9uZSkgJiYgKHMucHVzaChyLnZhbHVlKSwgcy5sZW5ndGggIT09IHQpOyB1ID0gITApXG4gICAgICAgICAgO1xuICAgIH0gY2F0Y2ggKGYpIHtcbiAgICAgIGMgPSAhMCwgaSA9IGY7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmICghdSAmJiBuLnJldHVybiAhPSBudWxsICYmIChhID0gbi5yZXR1cm4oKSwgT2JqZWN0KGEpICE9PSBhKSlcbiAgICAgICAgICByZXR1cm47XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBpZiAoYylcbiAgICAgICAgICB0aHJvdyBpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcztcbiAgfVxufVxuZnVuY3Rpb24gYjcoZSkge1xuICBpZiAoQXJyYXkuaXNBcnJheShlKSlcbiAgICByZXR1cm4gZTtcbn1cbnZhciB2cyA9IGZ1bmN0aW9uKHQsIG4sIHIpIHtcbiAgcmV0dXJuIHQgKyAobiAtIHQpICogcjtcbn0sIF9sID0gZnVuY3Rpb24odCkge1xuICB2YXIgbiA9IHQuZnJvbSwgciA9IHQudG87XG4gIHJldHVybiBuICE9PSByO1xufSwgdzcgPSBmdW5jdGlvbiBlKHQsIG4sIHIpIHtcbiAgdmFyIGkgPSBIaShmdW5jdGlvbihvLCBhKSB7XG4gICAgaWYgKF9sKGEpKSB7XG4gICAgICB2YXIgcyA9IHQoYS5mcm9tLCBhLnRvLCBhLnZlbG9jaXR5KSwgdSA9IHY3KHMsIDIpLCBjID0gdVswXSwgZiA9IHVbMV07XG4gICAgICByZXR1cm4gdHQodHQoe30sIGEpLCB7fSwge1xuICAgICAgICBmcm9tOiBjLFxuICAgICAgICB2ZWxvY2l0eTogZlxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBhO1xuICB9LCBuKTtcbiAgcmV0dXJuIHIgPCAxID8gSGkoZnVuY3Rpb24obywgYSkge1xuICAgIHJldHVybiBfbChhKSA/IHR0KHR0KHt9LCBhKSwge30sIHtcbiAgICAgIHZlbG9jaXR5OiB2cyhhLnZlbG9jaXR5LCBpW29dLnZlbG9jaXR5LCByKSxcbiAgICAgIGZyb206IHZzKGEuZnJvbSwgaVtvXS5mcm9tLCByKVxuICAgIH0pIDogYTtcbiAgfSwgbikgOiBlKHQsIGksIHIgLSAxKTtcbn07XG5jb25zdCB4NyA9IGZ1bmN0aW9uKGUsIHQsIG4sIHIsIGkpIHtcbiAgdmFyIG8gPSBYeihlLCB0KSwgYSA9IG8ucmVkdWNlKGZ1bmN0aW9uKHYsIHcpIHtcbiAgICByZXR1cm4gdHQodHQoe30sIHYpLCB7fSwgJGwoe30sIHcsIFtlW3ddLCB0W3ddXSkpO1xuICB9LCB7fSksIHMgPSBvLnJlZHVjZShmdW5jdGlvbih2LCB3KSB7XG4gICAgcmV0dXJuIHR0KHR0KHt9LCB2KSwge30sICRsKHt9LCB3LCB7XG4gICAgICBmcm9tOiBlW3ddLFxuICAgICAgdmVsb2NpdHk6IDAsXG4gICAgICB0bzogdFt3XVxuICAgIH0pKTtcbiAgfSwge30pLCB1ID0gLTEsIGMsIGYsIGwgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfSwgZCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBIaShmdW5jdGlvbih3LCBiKSB7XG4gICAgICByZXR1cm4gYi5mcm9tO1xuICAgIH0sIHMpO1xuICB9LCBwID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuICFPYmplY3QudmFsdWVzKHMpLmZpbHRlcihfbCkubGVuZ3RoO1xuICB9LCBnID0gZnVuY3Rpb24odykge1xuICAgIGMgfHwgKGMgPSB3KTtcbiAgICB2YXIgYiA9IHcgLSBjLCB4ID0gYiAvIG4uZHQ7XG4gICAgcyA9IHc3KG4sIHMsIHgpLCBpKHR0KHR0KHR0KHt9LCBlKSwgdCksIGQoKSkpLCBjID0gdywgcCgpIHx8ICh1ID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGwpKTtcbiAgfSwgaCA9IGZ1bmN0aW9uKHcpIHtcbiAgICBmIHx8IChmID0gdyk7XG4gICAgdmFyIGIgPSAodyAtIGYpIC8gciwgeCA9IEhpKGZ1bmN0aW9uKHksIFMpIHtcbiAgICAgIHJldHVybiB2cy5hcHBseSh2b2lkIDAsIGN2KFMpLmNvbmNhdChbbihiKV0pKTtcbiAgICB9LCBhKTtcbiAgICBpZiAoaSh0dCh0dCh0dCh7fSwgZSksIHQpLCB4KSksIGIgPCAxKVxuICAgICAgdSA9IHJlcXVlc3RBbmltYXRpb25GcmFtZShsKTtcbiAgICBlbHNlIHtcbiAgICAgIHZhciBtID0gSGkoZnVuY3Rpb24oeSwgUykge1xuICAgICAgICByZXR1cm4gdnMuYXBwbHkodm9pZCAwLCBjdihTKS5jb25jYXQoW24oMSldKSk7XG4gICAgICB9LCBhKTtcbiAgICAgIGkodHQodHQodHQoe30sIGUpLCB0KSwgbSkpO1xuICAgIH1cbiAgfTtcbiAgcmV0dXJuIGwgPSBuLmlzU3RlcHBlciA/IGcgOiBoLCBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGwpLCBmdW5jdGlvbigpIHtcbiAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHUpO1xuICAgIH07XG4gIH07XG59O1xuZnVuY3Rpb24gS3IoZSkge1xuICBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7XG4gIHJldHVybiBLciA9IHR5cGVvZiBTeW1ib2wgPT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uKHQpIHtcbiAgICByZXR1cm4gdHlwZW9mIHQ7XG4gIH0gOiBmdW5jdGlvbih0KSB7XG4gICAgcmV0dXJuIHQgJiYgdHlwZW9mIFN5bWJvbCA9PSBcImZ1bmN0aW9uXCIgJiYgdC5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIHQgIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIHQ7XG4gIH0sIEtyKGUpO1xufVxudmFyIFM3ID0gW1wiY2hpbGRyZW5cIiwgXCJiZWdpblwiLCBcImR1cmF0aW9uXCIsIFwiYXR0cmlidXRlTmFtZVwiLCBcImVhc2luZ1wiLCBcImlzQWN0aXZlXCIsIFwic3RlcHNcIiwgXCJmcm9tXCIsIFwidG9cIiwgXCJjYW5CZWdpblwiLCBcIm9uQW5pbWF0aW9uRW5kXCIsIFwic2hvdWxkUmVBbmltYXRlXCIsIFwib25BbmltYXRpb25SZVN0YXJ0XCJdO1xuZnVuY3Rpb24gJDcoZSwgdCkge1xuICBpZiAoZSA9PSBudWxsKVxuICAgIHJldHVybiB7fTtcbiAgdmFyIG4gPSBPNyhlLCB0KSwgciwgaTtcbiAgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcbiAgICB2YXIgbyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZSk7XG4gICAgZm9yIChpID0gMDsgaSA8IG8ubGVuZ3RoOyBpKyspXG4gICAgICByID0gb1tpXSwgISh0LmluZGV4T2YocikgPj0gMCkgJiYgT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKGUsIHIpICYmIChuW3JdID0gZVtyXSk7XG4gIH1cbiAgcmV0dXJuIG47XG59XG5mdW5jdGlvbiBPNyhlLCB0KSB7XG4gIGlmIChlID09IG51bGwpXG4gICAgcmV0dXJuIHt9O1xuICB2YXIgbiA9IHt9LCByID0gT2JqZWN0LmtleXMoZSksIGksIG87XG4gIGZvciAobyA9IDA7IG8gPCByLmxlbmd0aDsgbysrKVxuICAgIGkgPSByW29dLCAhKHQuaW5kZXhPZihpKSA+PSAwKSAmJiAobltpXSA9IGVbaV0pO1xuICByZXR1cm4gbjtcbn1cbmZ1bmN0aW9uIGVjKGUpIHtcbiAgcmV0dXJuIEM3KGUpIHx8IFA3KGUpIHx8IEE3KGUpIHx8IF83KCk7XG59XG5mdW5jdGlvbiBfNygpIHtcbiAgdGhyb3cgbmV3IFR5cGVFcnJvcihgSW52YWxpZCBhdHRlbXB0IHRvIHNwcmVhZCBub24taXRlcmFibGUgaW5zdGFuY2UuXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuYCk7XG59XG5mdW5jdGlvbiBBNyhlLCB0KSB7XG4gIGlmIChlKSB7XG4gICAgaWYgKHR5cGVvZiBlID09IFwic3RyaW5nXCIpXG4gICAgICByZXR1cm4gQWwoZSwgdCk7XG4gICAgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoZSkuc2xpY2UoOCwgLTEpO1xuICAgIGlmIChuID09PSBcIk9iamVjdFwiICYmIGUuY29uc3RydWN0b3IgJiYgKG4gPSBlLmNvbnN0cnVjdG9yLm5hbWUpLCBuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpXG4gICAgICByZXR1cm4gQXJyYXkuZnJvbShlKTtcbiAgICBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSlcbiAgICAgIHJldHVybiBBbChlLCB0KTtcbiAgfVxufVxuZnVuY3Rpb24gUDcoZSkge1xuICBpZiAodHlwZW9mIFN5bWJvbCA8IFwidVwiICYmIGVbU3ltYm9sLml0ZXJhdG9yXSAhPSBudWxsIHx8IGVbXCJAQGl0ZXJhdG9yXCJdICE9IG51bGwpXG4gICAgcmV0dXJuIEFycmF5LmZyb20oZSk7XG59XG5mdW5jdGlvbiBDNyhlKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGUpKVxuICAgIHJldHVybiBBbChlKTtcbn1cbmZ1bmN0aW9uIEFsKGUsIHQpIHtcbiAgKHQgPT0gbnVsbCB8fCB0ID4gZS5sZW5ndGgpICYmICh0ID0gZS5sZW5ndGgpO1xuICBmb3IgKHZhciBuID0gMCwgciA9IG5ldyBBcnJheSh0KTsgbiA8IHQ7IG4rKylcbiAgICByW25dID0gZVtuXTtcbiAgcmV0dXJuIHI7XG59XG5mdW5jdGlvbiBmdihlLCB0KSB7XG4gIHZhciBuID0gT2JqZWN0LmtleXMoZSk7XG4gIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gICAgdmFyIHIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGUpO1xuICAgIHQgJiYgKHIgPSByLmZpbHRlcihmdW5jdGlvbihpKSB7XG4gICAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLCBpKS5lbnVtZXJhYmxlO1xuICAgIH0pKSwgbi5wdXNoLmFwcGx5KG4sIHIpO1xuICB9XG4gIHJldHVybiBuO1xufVxuZnVuY3Rpb24gR3QoZSkge1xuICBmb3IgKHZhciB0ID0gMTsgdCA8IGFyZ3VtZW50cy5sZW5ndGg7IHQrKykge1xuICAgIHZhciBuID0gYXJndW1lbnRzW3RdICE9IG51bGwgPyBhcmd1bWVudHNbdF0gOiB7fTtcbiAgICB0ICUgMiA/IGZ2KE9iamVjdChuKSwgITApLmZvckVhY2goZnVuY3Rpb24ocikge1xuICAgICAgemkoZSwgciwgbltyXSk7XG4gICAgfSkgOiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGUsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKG4pKSA6IGZ2KE9iamVjdChuKSkuZm9yRWFjaChmdW5jdGlvbihyKSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgciwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihuLCByKSk7XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIGU7XG59XG5mdW5jdGlvbiB6aShlLCB0LCBuKSB7XG4gIHJldHVybiB0ID0gYXcodCksIHQgaW4gZSA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCB0LCB7IHZhbHVlOiBuLCBlbnVtZXJhYmxlOiAhMCwgY29uZmlndXJhYmxlOiAhMCwgd3JpdGFibGU6ICEwIH0pIDogZVt0XSA9IG4sIGU7XG59XG5mdW5jdGlvbiBFNyhlLCB0KSB7XG4gIGlmICghKGUgaW5zdGFuY2VvZiB0KSlcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xufVxuZnVuY3Rpb24gVDcoZSwgdCkge1xuICBmb3IgKHZhciBuID0gMDsgbiA8IHQubGVuZ3RoOyBuKyspIHtcbiAgICB2YXIgciA9IHRbbl07XG4gICAgci5lbnVtZXJhYmxlID0gci5lbnVtZXJhYmxlIHx8ICExLCByLmNvbmZpZ3VyYWJsZSA9ICEwLCBcInZhbHVlXCIgaW4gciAmJiAoci53cml0YWJsZSA9ICEwKSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIGF3KHIua2V5KSwgcik7XG4gIH1cbn1cbmZ1bmN0aW9uIE03KGUsIHQsIG4pIHtcbiAgcmV0dXJuIHQgJiYgVDcoZS5wcm90b3R5cGUsIHQpLCBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgXCJwcm90b3R5cGVcIiwgeyB3cml0YWJsZTogITEgfSksIGU7XG59XG5mdW5jdGlvbiBhdyhlKSB7XG4gIHZhciB0ID0gUjcoZSwgXCJzdHJpbmdcIik7XG4gIHJldHVybiBLcih0KSA9PT0gXCJzeW1ib2xcIiA/IHQgOiBTdHJpbmcodCk7XG59XG5mdW5jdGlvbiBSNyhlLCB0KSB7XG4gIGlmIChLcihlKSAhPT0gXCJvYmplY3RcIiB8fCBlID09PSBudWxsKVxuICAgIHJldHVybiBlO1xuICB2YXIgbiA9IGVbU3ltYm9sLnRvUHJpbWl0aXZlXTtcbiAgaWYgKG4gIT09IHZvaWQgMCkge1xuICAgIHZhciByID0gbi5jYWxsKGUsIHQgfHwgXCJkZWZhdWx0XCIpO1xuICAgIGlmIChLcihyKSAhPT0gXCJvYmplY3RcIilcbiAgICAgIHJldHVybiByO1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJAQHRvUHJpbWl0aXZlIG11c3QgcmV0dXJuIGEgcHJpbWl0aXZlIHZhbHVlLlwiKTtcbiAgfVxuICByZXR1cm4gKHQgPT09IFwic3RyaW5nXCIgPyBTdHJpbmcgOiBOdW1iZXIpKGUpO1xufVxuZnVuY3Rpb24gSTcoZSwgdCkge1xuICBpZiAodHlwZW9mIHQgIT0gXCJmdW5jdGlvblwiICYmIHQgIT09IG51bGwpXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpO1xuICBlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUodCAmJiB0LnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogZSwgd3JpdGFibGU6ICEwLCBjb25maWd1cmFibGU6ICEwIH0gfSksIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCBcInByb3RvdHlwZVwiLCB7IHdyaXRhYmxlOiAhMSB9KSwgdCAmJiBQbChlLCB0KTtcbn1cbmZ1bmN0aW9uIFBsKGUsIHQpIHtcbiAgcmV0dXJuIFBsID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mLmJpbmQoKSA6IGZ1bmN0aW9uKHIsIGkpIHtcbiAgICByZXR1cm4gci5fX3Byb3RvX18gPSBpLCByO1xuICB9LCBQbChlLCB0KTtcbn1cbmZ1bmN0aW9uIGo3KGUpIHtcbiAgdmFyIHQgPSBrNygpO1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHIgPSBtcyhlKSwgaTtcbiAgICBpZiAodCkge1xuICAgICAgdmFyIG8gPSBtcyh0aGlzKS5jb25zdHJ1Y3RvcjtcbiAgICAgIGkgPSBSZWZsZWN0LmNvbnN0cnVjdChyLCBhcmd1bWVudHMsIG8pO1xuICAgIH0gZWxzZVxuICAgICAgaSA9IHIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICByZXR1cm4gQ2wodGhpcywgaSk7XG4gIH07XG59XG5mdW5jdGlvbiBDbChlLCB0KSB7XG4gIGlmICh0ICYmIChLcih0KSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgdCA9PSBcImZ1bmN0aW9uXCIpKVxuICAgIHJldHVybiB0O1xuICBpZiAodCAhPT0gdm9pZCAwKVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJEZXJpdmVkIGNvbnN0cnVjdG9ycyBtYXkgb25seSByZXR1cm4gb2JqZWN0IG9yIHVuZGVmaW5lZFwiKTtcbiAgcmV0dXJuIEVsKGUpO1xufVxuZnVuY3Rpb24gRWwoZSkge1xuICBpZiAoZSA9PT0gdm9pZCAwKVxuICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTtcbiAgcmV0dXJuIGU7XG59XG5mdW5jdGlvbiBrNygpIHtcbiAgaWYgKHR5cGVvZiBSZWZsZWN0ID4gXCJ1XCIgfHwgIVJlZmxlY3QuY29uc3RydWN0IHx8IFJlZmxlY3QuY29uc3RydWN0LnNoYW0pXG4gICAgcmV0dXJuICExO1xuICBpZiAodHlwZW9mIFByb3h5ID09IFwiZnVuY3Rpb25cIilcbiAgICByZXR1cm4gITA7XG4gIHRyeSB7XG4gICAgcmV0dXJuIEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24oKSB7XG4gICAgfSkpLCAhMDtcbiAgfSBjYXRjaCB7XG4gICAgcmV0dXJuICExO1xuICB9XG59XG5mdW5jdGlvbiBtcyhlKSB7XG4gIHJldHVybiBtcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZi5iaW5kKCkgOiBmdW5jdGlvbihuKSB7XG4gICAgcmV0dXJuIG4uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihuKTtcbiAgfSwgbXMoZSk7XG59XG52YXIgX24gPSAvKiBAX19QVVJFX18gKi8gZnVuY3Rpb24oZSkge1xuICBJNyhuLCBlKTtcbiAgdmFyIHQgPSBqNyhuKTtcbiAgZnVuY3Rpb24gbihyLCBpKSB7XG4gICAgdmFyIG87XG4gICAgRTcodGhpcywgbiksIG8gPSB0LmNhbGwodGhpcywgciwgaSk7XG4gICAgdmFyIGEgPSBvLnByb3BzLCBzID0gYS5pc0FjdGl2ZSwgdSA9IGEuYXR0cmlidXRlTmFtZSwgYyA9IGEuZnJvbSwgZiA9IGEudG8sIGwgPSBhLnN0ZXBzLCBkID0gYS5jaGlsZHJlbiwgcCA9IGEuZHVyYXRpb247XG4gICAgaWYgKG8uaGFuZGxlU3R5bGVDaGFuZ2UgPSBvLmhhbmRsZVN0eWxlQ2hhbmdlLmJpbmQoRWwobykpLCBvLmNoYW5nZVN0eWxlID0gby5jaGFuZ2VTdHlsZS5iaW5kKEVsKG8pKSwgIXMgfHwgcCA8PSAwKVxuICAgICAgcmV0dXJuIG8uc3RhdGUgPSB7XG4gICAgICAgIHN0eWxlOiB7fVxuICAgICAgfSwgdHlwZW9mIGQgPT0gXCJmdW5jdGlvblwiICYmIChvLnN0YXRlID0ge1xuICAgICAgICBzdHlsZTogZlxuICAgICAgfSksIENsKG8pO1xuICAgIGlmIChsICYmIGwubGVuZ3RoKVxuICAgICAgby5zdGF0ZSA9IHtcbiAgICAgICAgc3R5bGU6IGxbMF0uc3R5bGVcbiAgICAgIH07XG4gICAgZWxzZSBpZiAoYykge1xuICAgICAgaWYgKHR5cGVvZiBkID09IFwiZnVuY3Rpb25cIilcbiAgICAgICAgcmV0dXJuIG8uc3RhdGUgPSB7XG4gICAgICAgICAgc3R5bGU6IGNcbiAgICAgICAgfSwgQ2wobyk7XG4gICAgICBvLnN0YXRlID0ge1xuICAgICAgICBzdHlsZTogdSA/IHppKHt9LCB1LCBjKSA6IGNcbiAgICAgIH07XG4gICAgfSBlbHNlXG4gICAgICBvLnN0YXRlID0ge1xuICAgICAgICBzdHlsZToge31cbiAgICAgIH07XG4gICAgcmV0dXJuIG87XG4gIH1cbiAgcmV0dXJuIE03KG4sIFt7XG4gICAga2V5OiBcImNvbXBvbmVudERpZE1vdW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGkgPSB0aGlzLnByb3BzLCBvID0gaS5pc0FjdGl2ZSwgYSA9IGkuY2FuQmVnaW47XG4gICAgICB0aGlzLm1vdW50ZWQgPSAhMCwgISghbyB8fCAhYSkgJiYgdGhpcy5ydW5BbmltYXRpb24odGhpcy5wcm9wcyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNvbXBvbmVudERpZFVwZGF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbihpKSB7XG4gICAgICB2YXIgbyA9IHRoaXMucHJvcHMsIGEgPSBvLmlzQWN0aXZlLCBzID0gby5jYW5CZWdpbiwgdSA9IG8uYXR0cmlidXRlTmFtZSwgYyA9IG8uc2hvdWxkUmVBbmltYXRlLCBmID0gby50bywgbCA9IG8uZnJvbSwgZCA9IHRoaXMuc3RhdGUuc3R5bGU7XG4gICAgICBpZiAocykge1xuICAgICAgICBpZiAoIWEpIHtcbiAgICAgICAgICB2YXIgcCA9IHtcbiAgICAgICAgICAgIHN0eWxlOiB1ID8gemkoe30sIHUsIGYpIDogZlxuICAgICAgICAgIH07XG4gICAgICAgICAgdGhpcy5zdGF0ZSAmJiBkICYmICh1ICYmIGRbdV0gIT09IGYgfHwgIXUgJiYgZCAhPT0gZikgJiYgdGhpcy5zZXRTdGF0ZShwKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCEoQnooaS50bywgZikgJiYgaS5jYW5CZWdpbiAmJiBpLmlzQWN0aXZlKSkge1xuICAgICAgICAgIHZhciBnID0gIWkuY2FuQmVnaW4gfHwgIWkuaXNBY3RpdmU7XG4gICAgICAgICAgdGhpcy5tYW5hZ2VyICYmIHRoaXMubWFuYWdlci5zdG9wKCksIHRoaXMuc3RvcEpTQW5pbWF0aW9uICYmIHRoaXMuc3RvcEpTQW5pbWF0aW9uKCk7XG4gICAgICAgICAgdmFyIGggPSBnIHx8IGMgPyBsIDogaS50bztcbiAgICAgICAgICBpZiAodGhpcy5zdGF0ZSAmJiBkKSB7XG4gICAgICAgICAgICB2YXIgdiA9IHtcbiAgICAgICAgICAgICAgc3R5bGU6IHUgPyB6aSh7fSwgdSwgaCkgOiBoXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgKHUgJiYgZFt1XSAhPT0gaCB8fCAhdSAmJiBkICE9PSBoKSAmJiB0aGlzLnNldFN0YXRlKHYpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLnJ1bkFuaW1hdGlvbihHdChHdCh7fSwgdGhpcy5wcm9wcyksIHt9LCB7XG4gICAgICAgICAgICBmcm9tOiBoLFxuICAgICAgICAgICAgYmVnaW46IDBcbiAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY29tcG9uZW50V2lsbFVubW91bnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLm1vdW50ZWQgPSAhMTtcbiAgICAgIHZhciBpID0gdGhpcy5wcm9wcy5vbkFuaW1hdGlvbkVuZDtcbiAgICAgIHRoaXMudW5TdWJzY3JpYmUgJiYgdGhpcy51blN1YnNjcmliZSgpLCB0aGlzLm1hbmFnZXIgJiYgKHRoaXMubWFuYWdlci5zdG9wKCksIHRoaXMubWFuYWdlciA9IG51bGwpLCB0aGlzLnN0b3BKU0FuaW1hdGlvbiAmJiB0aGlzLnN0b3BKU0FuaW1hdGlvbigpLCBpICYmIGkoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaGFuZGxlU3R5bGVDaGFuZ2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24oaSkge1xuICAgICAgdGhpcy5jaGFuZ2VTdHlsZShpKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY2hhbmdlU3R5bGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24oaSkge1xuICAgICAgdGhpcy5tb3VudGVkICYmIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICBzdHlsZTogaVxuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJ1bkpTQW5pbWF0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uKGkpIHtcbiAgICAgIHZhciBvID0gdGhpcywgYSA9IGkuZnJvbSwgcyA9IGkudG8sIHUgPSBpLmR1cmF0aW9uLCBjID0gaS5lYXNpbmcsIGYgPSBpLmJlZ2luLCBsID0gaS5vbkFuaW1hdGlvbkVuZCwgZCA9IGkub25BbmltYXRpb25TdGFydCwgcCA9IHg3KGEsIHMsIGw3KGMpLCB1LCB0aGlzLmNoYW5nZVN0eWxlKSwgZyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBvLnN0b3BKU0FuaW1hdGlvbiA9IHAoKTtcbiAgICAgIH07XG4gICAgICB0aGlzLm1hbmFnZXIuc3RhcnQoW2QsIGYsIGcsIHUsIGxdKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicnVuU3RlcEFuaW1hdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbihpKSB7XG4gICAgICB2YXIgbyA9IHRoaXMsIGEgPSBpLnN0ZXBzLCBzID0gaS5iZWdpbiwgdSA9IGkub25BbmltYXRpb25TdGFydCwgYyA9IGFbMF0sIGYgPSBjLnN0eWxlLCBsID0gYy5kdXJhdGlvbiwgZCA9IGwgPT09IHZvaWQgMCA/IDAgOiBsLCBwID0gZnVuY3Rpb24oaCwgdiwgdykge1xuICAgICAgICBpZiAodyA9PT0gMClcbiAgICAgICAgICByZXR1cm4gaDtcbiAgICAgICAgdmFyIGIgPSB2LmR1cmF0aW9uLCB4ID0gdi5lYXNpbmcsIG0gPSB4ID09PSB2b2lkIDAgPyBcImVhc2VcIiA6IHgsIHkgPSB2LnN0eWxlLCBTID0gdi5wcm9wZXJ0aWVzLCAkID0gdi5vbkFuaW1hdGlvbkVuZCwgTyA9IHcgPiAwID8gYVt3IC0gMV0gOiB2LCBUID0gUyB8fCBPYmplY3Qua2V5cyh5KTtcbiAgICAgICAgaWYgKHR5cGVvZiBtID09IFwiZnVuY3Rpb25cIiB8fCBtID09PSBcInNwcmluZ1wiKVxuICAgICAgICAgIHJldHVybiBbXS5jb25jYXQoZWMoaCksIFtvLnJ1bkpTQW5pbWF0aW9uLmJpbmQobywge1xuICAgICAgICAgICAgZnJvbTogTy5zdHlsZSxcbiAgICAgICAgICAgIHRvOiB5LFxuICAgICAgICAgICAgZHVyYXRpb246IGIsXG4gICAgICAgICAgICBlYXNpbmc6IG1cbiAgICAgICAgICB9KSwgYl0pO1xuICAgICAgICB2YXIgTSA9IGF2KFQsIGIsIG0pLCBFID0gR3QoR3QoR3Qoe30sIE8uc3R5bGUpLCB5KSwge30sIHtcbiAgICAgICAgICB0cmFuc2l0aW9uOiBNXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gW10uY29uY2F0KGVjKGgpLCBbRSwgYiwgJF0pLmZpbHRlcihaeik7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIHRoaXMubWFuYWdlci5zdGFydChbdV0uY29uY2F0KGVjKGEucmVkdWNlKHAsIFtmLCBNYXRoLm1heChkLCBzKV0pKSwgW2kub25BbmltYXRpb25FbmRdKSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJ1bkFuaW1hdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbihpKSB7XG4gICAgICB0aGlzLm1hbmFnZXIgfHwgKHRoaXMubWFuYWdlciA9IHF6KCkpO1xuICAgICAgdmFyIG8gPSBpLmJlZ2luLCBhID0gaS5kdXJhdGlvbiwgcyA9IGkuYXR0cmlidXRlTmFtZSwgdSA9IGkudG8sIGMgPSBpLmVhc2luZywgZiA9IGkub25BbmltYXRpb25TdGFydCwgbCA9IGkub25BbmltYXRpb25FbmQsIGQgPSBpLnN0ZXBzLCBwID0gaS5jaGlsZHJlbiwgZyA9IHRoaXMubWFuYWdlcjtcbiAgICAgIGlmICh0aGlzLnVuU3Vic2NyaWJlID0gZy5zdWJzY3JpYmUodGhpcy5oYW5kbGVTdHlsZUNoYW5nZSksIHR5cGVvZiBjID09IFwiZnVuY3Rpb25cIiB8fCB0eXBlb2YgcCA9PSBcImZ1bmN0aW9uXCIgfHwgYyA9PT0gXCJzcHJpbmdcIikge1xuICAgICAgICB0aGlzLnJ1bkpTQW5pbWF0aW9uKGkpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoZC5sZW5ndGggPiAxKSB7XG4gICAgICAgIHRoaXMucnVuU3RlcEFuaW1hdGlvbihpKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIGggPSBzID8gemkoe30sIHMsIHUpIDogdSwgdiA9IGF2KE9iamVjdC5rZXlzKGgpLCBhLCBjKTtcbiAgICAgIGcuc3RhcnQoW2YsIG8sIEd0KEd0KHt9LCBoKSwge30sIHtcbiAgICAgICAgdHJhbnNpdGlvbjogdlxuICAgICAgfSksIGEsIGxdKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVuZGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGkgPSB0aGlzLnByb3BzLCBvID0gaS5jaGlsZHJlbjtcbiAgICAgIGkuYmVnaW47XG4gICAgICB2YXIgYSA9IGkuZHVyYXRpb247XG4gICAgICBpLmF0dHJpYnV0ZU5hbWUsIGkuZWFzaW5nO1xuICAgICAgdmFyIHMgPSBpLmlzQWN0aXZlO1xuICAgICAgaS5zdGVwcywgaS5mcm9tLCBpLnRvLCBpLmNhbkJlZ2luLCBpLm9uQW5pbWF0aW9uRW5kLCBpLnNob3VsZFJlQW5pbWF0ZSwgaS5vbkFuaW1hdGlvblJlU3RhcnQ7XG4gICAgICB2YXIgdSA9ICQ3KGksIFM3KSwgYyA9ICR0LmNvdW50KG8pLCBmID0gdGhpcy5zdGF0ZS5zdHlsZTtcbiAgICAgIGlmICh0eXBlb2YgbyA9PSBcImZ1bmN0aW9uXCIpXG4gICAgICAgIHJldHVybiBvKGYpO1xuICAgICAgaWYgKCFzIHx8IGMgPT09IDAgfHwgYSA8PSAwKVxuICAgICAgICByZXR1cm4gbztcbiAgICAgIHZhciBsID0gZnVuY3Rpb24ocCkge1xuICAgICAgICB2YXIgZyA9IHAucHJvcHMsIGggPSBnLnN0eWxlLCB2ID0gaCA9PT0gdm9pZCAwID8ge30gOiBoLCB3ID0gZy5jbGFzc05hbWUsIGIgPSAvKiBAX19QVVJFX18gKi8gR2UocCwgR3QoR3Qoe30sIHUpLCB7fSwge1xuICAgICAgICAgIHN0eWxlOiBHdChHdCh7fSwgdiksIGYpLFxuICAgICAgICAgIGNsYXNzTmFtZTogd1xuICAgICAgICB9KSk7XG4gICAgICAgIHJldHVybiBiO1xuICAgICAgfTtcbiAgICAgIHJldHVybiBjID09PSAxID8gbCgkdC5vbmx5KG8pKSA6IC8qIEBfX1BVUkVfXyAqLyBQLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgbnVsbCwgJHQubWFwKG8sIGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgcmV0dXJuIGwoZCk7XG4gICAgICB9KSk7XG4gICAgfVxuICB9XSksIG47XG59KFduKTtcbl9uLmRpc3BsYXlOYW1lID0gXCJBbmltYXRlXCI7XG5fbi5kZWZhdWx0UHJvcHMgPSB7XG4gIGJlZ2luOiAwLFxuICBkdXJhdGlvbjogMWUzLFxuICBmcm9tOiBcIlwiLFxuICB0bzogXCJcIixcbiAgYXR0cmlidXRlTmFtZTogXCJcIixcbiAgZWFzaW5nOiBcImVhc2VcIixcbiAgaXNBY3RpdmU6ICEwLFxuICBjYW5CZWdpbjogITAsXG4gIHN0ZXBzOiBbXSxcbiAgb25BbmltYXRpb25FbmQ6IGZ1bmN0aW9uKCkge1xuICB9LFxuICBvbkFuaW1hdGlvblN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgfVxufTtcbl9uLnByb3BUeXBlcyA9IHtcbiAgZnJvbTogZGUub25lT2ZUeXBlKFtkZS5vYmplY3QsIGRlLnN0cmluZ10pLFxuICB0bzogZGUub25lT2ZUeXBlKFtkZS5vYmplY3QsIGRlLnN0cmluZ10pLFxuICBhdHRyaWJ1dGVOYW1lOiBkZS5zdHJpbmcsXG4gIC8vIGFuaW1hdGlvbiBkdXJhdGlvblxuICBkdXJhdGlvbjogZGUubnVtYmVyLFxuICBiZWdpbjogZGUubnVtYmVyLFxuICBlYXNpbmc6IGRlLm9uZU9mVHlwZShbZGUuc3RyaW5nLCBkZS5mdW5jXSksXG4gIHN0ZXBzOiBkZS5hcnJheU9mKGRlLnNoYXBlKHtcbiAgICBkdXJhdGlvbjogZGUubnVtYmVyLmlzUmVxdWlyZWQsXG4gICAgc3R5bGU6IGRlLm9iamVjdC5pc1JlcXVpcmVkLFxuICAgIGVhc2luZzogZGUub25lT2ZUeXBlKFtkZS5vbmVPZihbXCJlYXNlXCIsIFwiZWFzZS1pblwiLCBcImVhc2Utb3V0XCIsIFwiZWFzZS1pbi1vdXRcIiwgXCJsaW5lYXJcIl0pLCBkZS5mdW5jXSksXG4gICAgLy8gdHJhbnNpdGlvbiBjc3MgcHJvcGVydGllcyhkYXNoIGNhc2UpLCBvcHRpb25hbFxuICAgIHByb3BlcnRpZXM6IGRlLmFycmF5T2YoXCJzdHJpbmdcIiksXG4gICAgb25BbmltYXRpb25FbmQ6IGRlLmZ1bmNcbiAgfSkpLFxuICBjaGlsZHJlbjogZGUub25lT2ZUeXBlKFtkZS5ub2RlLCBkZS5mdW5jXSksXG4gIGlzQWN0aXZlOiBkZS5ib29sLFxuICBjYW5CZWdpbjogZGUuYm9vbCxcbiAgb25BbmltYXRpb25FbmQ6IGRlLmZ1bmMsXG4gIC8vIGRlY2lkZSBpZiBpdCBzaG91bGQgcmVhbmltYXRlIHdpdGggaW5pdGlhbCBmcm9tIHN0eWxlIHdoZW4gcHJvcHMgY2hhbmdlXG4gIHNob3VsZFJlQW5pbWF0ZTogZGUuYm9vbCxcbiAgb25BbmltYXRpb25TdGFydDogZGUuZnVuYyxcbiAgb25BbmltYXRpb25SZVN0YXJ0OiBkZS5mdW5jXG59O1xuZGUub2JqZWN0LCBkZS5vYmplY3QsIGRlLm9iamVjdCwgZGUuZWxlbWVudDtcbmRlLm9iamVjdCwgZGUub2JqZWN0LCBkZS5vYmplY3QsIGRlLm9uZU9mVHlwZShbZGUuYXJyYXksIGRlLmVsZW1lbnRdKSwgZGUuYW55O1xuZnVuY3Rpb24gX28oZSkge1xuICBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7XG4gIHJldHVybiBfbyA9IHR5cGVvZiBTeW1ib2wgPT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uKHQpIHtcbiAgICByZXR1cm4gdHlwZW9mIHQ7XG4gIH0gOiBmdW5jdGlvbih0KSB7XG4gICAgcmV0dXJuIHQgJiYgdHlwZW9mIFN5bWJvbCA9PSBcImZ1bmN0aW9uXCIgJiYgdC5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIHQgIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIHQ7XG4gIH0sIF9vKGUpO1xufVxuZnVuY3Rpb24geXMoKSB7XG4gIHJldHVybiB5cyA9IE9iamVjdC5hc3NpZ24gPyBPYmplY3QuYXNzaWduLmJpbmQoKSA6IGZ1bmN0aW9uKGUpIHtcbiAgICBmb3IgKHZhciB0ID0gMTsgdCA8IGFyZ3VtZW50cy5sZW5ndGg7IHQrKykge1xuICAgICAgdmFyIG4gPSBhcmd1bWVudHNbdF07XG4gICAgICBmb3IgKHZhciByIGluIG4pXG4gICAgICAgIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChuLCByKSAmJiAoZVtyXSA9IG5bcl0pO1xuICAgIH1cbiAgICByZXR1cm4gZTtcbiAgfSwgeXMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cbmZ1bmN0aW9uIEQ3KGUsIHQpIHtcbiAgcmV0dXJuIEI3KGUpIHx8IEw3KGUsIHQpIHx8IEY3KGUsIHQpIHx8IE43KCk7XG59XG5mdW5jdGlvbiBONygpIHtcbiAgdGhyb3cgbmV3IFR5cGVFcnJvcihgSW52YWxpZCBhdHRlbXB0IHRvIGRlc3RydWN0dXJlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5gKTtcbn1cbmZ1bmN0aW9uIEY3KGUsIHQpIHtcbiAgaWYgKGUpIHtcbiAgICBpZiAodHlwZW9mIGUgPT0gXCJzdHJpbmdcIilcbiAgICAgIHJldHVybiBkdihlLCB0KTtcbiAgICB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChlKS5zbGljZSg4LCAtMSk7XG4gICAgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgZS5jb25zdHJ1Y3RvciAmJiAobiA9IGUuY29uc3RydWN0b3IubmFtZSksIG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIilcbiAgICAgIHJldHVybiBBcnJheS5mcm9tKGUpO1xuICAgIGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKVxuICAgICAgcmV0dXJuIGR2KGUsIHQpO1xuICB9XG59XG5mdW5jdGlvbiBkdihlLCB0KSB7XG4gICh0ID09IG51bGwgfHwgdCA+IGUubGVuZ3RoKSAmJiAodCA9IGUubGVuZ3RoKTtcbiAgZm9yICh2YXIgbiA9IDAsIHIgPSBuZXcgQXJyYXkodCk7IG4gPCB0OyBuKyspXG4gICAgcltuXSA9IGVbbl07XG4gIHJldHVybiByO1xufVxuZnVuY3Rpb24gTDcoZSwgdCkge1xuICB2YXIgbiA9IGUgPT0gbnVsbCA/IG51bGwgOiB0eXBlb2YgU3ltYm9sIDwgXCJ1XCIgJiYgZVtTeW1ib2wuaXRlcmF0b3JdIHx8IGVbXCJAQGl0ZXJhdG9yXCJdO1xuICBpZiAobiAhPSBudWxsKSB7XG4gICAgdmFyIHIsIGksIG8sIGEsIHMgPSBbXSwgdSA9ICEwLCBjID0gITE7XG4gICAgdHJ5IHtcbiAgICAgIGlmIChvID0gKG4gPSBuLmNhbGwoZSkpLm5leHQsIHQgIT09IDApXG4gICAgICAgIGZvciAoOyAhKHUgPSAociA9IG8uY2FsbChuKSkuZG9uZSkgJiYgKHMucHVzaChyLnZhbHVlKSwgcy5sZW5ndGggIT09IHQpOyB1ID0gITApXG4gICAgICAgICAgO1xuICAgIH0gY2F0Y2ggKGYpIHtcbiAgICAgIGMgPSAhMCwgaSA9IGY7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmICghdSAmJiBuLnJldHVybiAhPSBudWxsICYmIChhID0gbi5yZXR1cm4oKSwgT2JqZWN0KGEpICE9PSBhKSlcbiAgICAgICAgICByZXR1cm47XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBpZiAoYylcbiAgICAgICAgICB0aHJvdyBpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcztcbiAgfVxufVxuZnVuY3Rpb24gQjcoZSkge1xuICBpZiAoQXJyYXkuaXNBcnJheShlKSlcbiAgICByZXR1cm4gZTtcbn1cbmZ1bmN0aW9uIHB2KGUsIHQpIHtcbiAgdmFyIG4gPSBPYmplY3Qua2V5cyhlKTtcbiAgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcbiAgICB2YXIgciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZSk7XG4gICAgdCAmJiAociA9IHIuZmlsdGVyKGZ1bmN0aW9uKGkpIHtcbiAgICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsIGkpLmVudW1lcmFibGU7XG4gICAgfSkpLCBuLnB1c2guYXBwbHkobiwgcik7XG4gIH1cbiAgcmV0dXJuIG47XG59XG5mdW5jdGlvbiBodihlKSB7XG4gIGZvciAodmFyIHQgPSAxOyB0IDwgYXJndW1lbnRzLmxlbmd0aDsgdCsrKSB7XG4gICAgdmFyIG4gPSBhcmd1bWVudHNbdF0gIT0gbnVsbCA/IGFyZ3VtZW50c1t0XSA6IHt9O1xuICAgIHQgJSAyID8gcHYoT2JqZWN0KG4pLCAhMCkuZm9yRWFjaChmdW5jdGlvbihyKSB7XG4gICAgICB6NyhlLCByLCBuW3JdKTtcbiAgICB9KSA6IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoZSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMobikpIDogcHYoT2JqZWN0KG4pKS5mb3JFYWNoKGZ1bmN0aW9uKHIpIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCByLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG4sIHIpKTtcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gZTtcbn1cbmZ1bmN0aW9uIHo3KGUsIHQsIG4pIHtcbiAgcmV0dXJuIHQgPSBWNyh0KSwgdCBpbiBlID8gT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIHQsIHsgdmFsdWU6IG4sIGVudW1lcmFibGU6ICEwLCBjb25maWd1cmFibGU6ICEwLCB3cml0YWJsZTogITAgfSkgOiBlW3RdID0gbiwgZTtcbn1cbmZ1bmN0aW9uIFY3KGUpIHtcbiAgdmFyIHQgPSBHNyhlLCBcInN0cmluZ1wiKTtcbiAgcmV0dXJuIF9vKHQpID09IFwic3ltYm9sXCIgPyB0IDogU3RyaW5nKHQpO1xufVxuZnVuY3Rpb24gRzcoZSwgdCkge1xuICBpZiAoX28oZSkgIT0gXCJvYmplY3RcIiB8fCAhZSlcbiAgICByZXR1cm4gZTtcbiAgdmFyIG4gPSBlW1N5bWJvbC50b1ByaW1pdGl2ZV07XG4gIGlmIChuICE9PSB2b2lkIDApIHtcbiAgICB2YXIgciA9IG4uY2FsbChlLCB0IHx8IFwiZGVmYXVsdFwiKTtcbiAgICBpZiAoX28ocikgIT0gXCJvYmplY3RcIilcbiAgICAgIHJldHVybiByO1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJAQHRvUHJpbWl0aXZlIG11c3QgcmV0dXJuIGEgcHJpbWl0aXZlIHZhbHVlLlwiKTtcbiAgfVxuICByZXR1cm4gKHQgPT09IFwic3RyaW5nXCIgPyBTdHJpbmcgOiBOdW1iZXIpKGUpO1xufVxudmFyIGd2ID0gZnVuY3Rpb24odCwgbiwgciwgaSwgbykge1xuICB2YXIgYSA9IE1hdGgubWluKE1hdGguYWJzKHIpIC8gMiwgTWF0aC5hYnMoaSkgLyAyKSwgcyA9IGkgPj0gMCA/IDEgOiAtMSwgdSA9IHIgPj0gMCA/IDEgOiAtMSwgYyA9IGkgPj0gMCAmJiByID49IDAgfHwgaSA8IDAgJiYgciA8IDAgPyAxIDogMCwgZjtcbiAgaWYgKGEgPiAwICYmIG8gaW5zdGFuY2VvZiBBcnJheSkge1xuICAgIGZvciAodmFyIGwgPSBbMCwgMCwgMCwgMF0sIGQgPSAwLCBwID0gNDsgZCA8IHA7IGQrKylcbiAgICAgIGxbZF0gPSBvW2RdID4gYSA/IGEgOiBvW2RdO1xuICAgIGYgPSBcIk1cIi5jb25jYXQodCwgXCIsXCIpLmNvbmNhdChuICsgcyAqIGxbMF0pLCBsWzBdID4gMCAmJiAoZiArPSBcIkEgXCIuY29uY2F0KGxbMF0sIFwiLFwiKS5jb25jYXQobFswXSwgXCIsMCwwLFwiKS5jb25jYXQoYywgXCIsXCIpLmNvbmNhdCh0ICsgdSAqIGxbMF0sIFwiLFwiKS5jb25jYXQobikpLCBmICs9IFwiTCBcIi5jb25jYXQodCArIHIgLSB1ICogbFsxXSwgXCIsXCIpLmNvbmNhdChuKSwgbFsxXSA+IDAgJiYgKGYgKz0gXCJBIFwiLmNvbmNhdChsWzFdLCBcIixcIikuY29uY2F0KGxbMV0sIFwiLDAsMCxcIikuY29uY2F0KGMsIGAsXG4gICAgICAgIGApLmNvbmNhdCh0ICsgciwgXCIsXCIpLmNvbmNhdChuICsgcyAqIGxbMV0pKSwgZiArPSBcIkwgXCIuY29uY2F0KHQgKyByLCBcIixcIikuY29uY2F0KG4gKyBpIC0gcyAqIGxbMl0pLCBsWzJdID4gMCAmJiAoZiArPSBcIkEgXCIuY29uY2F0KGxbMl0sIFwiLFwiKS5jb25jYXQobFsyXSwgXCIsMCwwLFwiKS5jb25jYXQoYywgYCxcbiAgICAgICAgYCkuY29uY2F0KHQgKyByIC0gdSAqIGxbMl0sIFwiLFwiKS5jb25jYXQobiArIGkpKSwgZiArPSBcIkwgXCIuY29uY2F0KHQgKyB1ICogbFszXSwgXCIsXCIpLmNvbmNhdChuICsgaSksIGxbM10gPiAwICYmIChmICs9IFwiQSBcIi5jb25jYXQobFszXSwgXCIsXCIpLmNvbmNhdChsWzNdLCBcIiwwLDAsXCIpLmNvbmNhdChjLCBgLFxuICAgICAgICBgKS5jb25jYXQodCwgXCIsXCIpLmNvbmNhdChuICsgaSAtIHMgKiBsWzNdKSksIGYgKz0gXCJaXCI7XG4gIH0gZWxzZSBpZiAoYSA+IDAgJiYgbyA9PT0gK28gJiYgbyA+IDApIHtcbiAgICB2YXIgZyA9IE1hdGgubWluKGEsIG8pO1xuICAgIGYgPSBcIk0gXCIuY29uY2F0KHQsIFwiLFwiKS5jb25jYXQobiArIHMgKiBnLCBgXG4gICAgICAgICAgICBBIGApLmNvbmNhdChnLCBcIixcIikuY29uY2F0KGcsIFwiLDAsMCxcIikuY29uY2F0KGMsIFwiLFwiKS5jb25jYXQodCArIHUgKiBnLCBcIixcIikuY29uY2F0KG4sIGBcbiAgICAgICAgICAgIEwgYCkuY29uY2F0KHQgKyByIC0gdSAqIGcsIFwiLFwiKS5jb25jYXQobiwgYFxuICAgICAgICAgICAgQSBgKS5jb25jYXQoZywgXCIsXCIpLmNvbmNhdChnLCBcIiwwLDAsXCIpLmNvbmNhdChjLCBcIixcIikuY29uY2F0KHQgKyByLCBcIixcIikuY29uY2F0KG4gKyBzICogZywgYFxuICAgICAgICAgICAgTCBgKS5jb25jYXQodCArIHIsIFwiLFwiKS5jb25jYXQobiArIGkgLSBzICogZywgYFxuICAgICAgICAgICAgQSBgKS5jb25jYXQoZywgXCIsXCIpLmNvbmNhdChnLCBcIiwwLDAsXCIpLmNvbmNhdChjLCBcIixcIikuY29uY2F0KHQgKyByIC0gdSAqIGcsIFwiLFwiKS5jb25jYXQobiArIGksIGBcbiAgICAgICAgICAgIEwgYCkuY29uY2F0KHQgKyB1ICogZywgXCIsXCIpLmNvbmNhdChuICsgaSwgYFxuICAgICAgICAgICAgQSBgKS5jb25jYXQoZywgXCIsXCIpLmNvbmNhdChnLCBcIiwwLDAsXCIpLmNvbmNhdChjLCBcIixcIikuY29uY2F0KHQsIFwiLFwiKS5jb25jYXQobiArIGkgLSBzICogZywgXCIgWlwiKTtcbiAgfSBlbHNlXG4gICAgZiA9IFwiTSBcIi5jb25jYXQodCwgXCIsXCIpLmNvbmNhdChuLCBcIiBoIFwiKS5jb25jYXQociwgXCIgdiBcIikuY29uY2F0KGksIFwiIGggXCIpLmNvbmNhdCgtciwgXCIgWlwiKTtcbiAgcmV0dXJuIGY7XG59LCBXNyA9IGZ1bmN0aW9uKHQsIG4pIHtcbiAgaWYgKCF0IHx8ICFuKVxuICAgIHJldHVybiAhMTtcbiAgdmFyIHIgPSB0LngsIGkgPSB0LnksIG8gPSBuLngsIGEgPSBuLnksIHMgPSBuLndpZHRoLCB1ID0gbi5oZWlnaHQ7XG4gIGlmIChNYXRoLmFicyhzKSA+IDAgJiYgTWF0aC5hYnModSkgPiAwKSB7XG4gICAgdmFyIGMgPSBNYXRoLm1pbihvLCBvICsgcyksIGYgPSBNYXRoLm1heChvLCBvICsgcyksIGwgPSBNYXRoLm1pbihhLCBhICsgdSksIGQgPSBNYXRoLm1heChhLCBhICsgdSk7XG4gICAgcmV0dXJuIHIgPj0gYyAmJiByIDw9IGYgJiYgaSA+PSBsICYmIGkgPD0gZDtcbiAgfVxuICByZXR1cm4gITE7XG59LCBVNyA9IHtcbiAgeDogMCxcbiAgeTogMCxcbiAgd2lkdGg6IDAsXG4gIGhlaWdodDogMCxcbiAgLy8gVGhlIHJhZGl1cyBvZiBib3JkZXJcbiAgLy8gVGhlIHJhZGl1cyBvZiBmb3VyIGNvcm5lcnMgd2hlbiByYWRpdXMgaXMgYSBudW1iZXJcbiAgLy8gVGhlIHJhZGl1cyBvZiBsZWZ0LXRvcCwgcmlnaHQtdG9wLCByaWdodC1ib3R0b20sIGxlZnQtYm90dG9tIHdoZW4gcmFkaXVzIGlzIGFuIGFycmF5XG4gIHJhZGl1czogMCxcbiAgaXNBbmltYXRpb25BY3RpdmU6ICExLFxuICBpc1VwZGF0ZUFuaW1hdGlvbkFjdGl2ZTogITEsXG4gIGFuaW1hdGlvbkJlZ2luOiAwLFxuICBhbmltYXRpb25EdXJhdGlvbjogMTUwMCxcbiAgYW5pbWF0aW9uRWFzaW5nOiBcImVhc2VcIlxufSwgZGQgPSBmdW5jdGlvbih0KSB7XG4gIHZhciBuID0gaHYoaHYoe30sIFU3KSwgdCksIHIgPSBfZSgpLCBpID0gWWUoLTEpLCBvID0gRDcoaSwgMiksIGEgPSBvWzBdLCBzID0gb1sxXTtcbiAgRmUoZnVuY3Rpb24oKSB7XG4gICAgaWYgKHIuY3VycmVudCAmJiByLmN1cnJlbnQuZ2V0VG90YWxMZW5ndGgpXG4gICAgICB0cnkge1xuICAgICAgICB2YXIgbSA9IHIuY3VycmVudC5nZXRUb3RhbExlbmd0aCgpO1xuICAgICAgICBtICYmIHMobSk7XG4gICAgICB9IGNhdGNoIHtcbiAgICAgIH1cbiAgfSwgW10pO1xuICB2YXIgdSA9IG4ueCwgYyA9IG4ueSwgZiA9IG4ud2lkdGgsIGwgPSBuLmhlaWdodCwgZCA9IG4ucmFkaXVzLCBwID0gbi5jbGFzc05hbWUsIGcgPSBuLmFuaW1hdGlvbkVhc2luZywgaCA9IG4uYW5pbWF0aW9uRHVyYXRpb24sIHYgPSBuLmFuaW1hdGlvbkJlZ2luLCB3ID0gbi5pc0FuaW1hdGlvbkFjdGl2ZSwgYiA9IG4uaXNVcGRhdGVBbmltYXRpb25BY3RpdmU7XG4gIGlmICh1ICE9PSArdSB8fCBjICE9PSArYyB8fCBmICE9PSArZiB8fCBsICE9PSArbCB8fCBmID09PSAwIHx8IGwgPT09IDApXG4gICAgcmV0dXJuIG51bGw7XG4gIHZhciB4ID0gJGUoXCJyZWNoYXJ0cy1yZWN0YW5nbGVcIiwgcCk7XG4gIHJldHVybiBiID8gLyogQF9fUFVSRV9fICovIFAuY3JlYXRlRWxlbWVudChfbiwge1xuICAgIGNhbkJlZ2luOiBhID4gMCxcbiAgICBmcm9tOiB7XG4gICAgICB3aWR0aDogZixcbiAgICAgIGhlaWdodDogbCxcbiAgICAgIHg6IHUsXG4gICAgICB5OiBjXG4gICAgfSxcbiAgICB0bzoge1xuICAgICAgd2lkdGg6IGYsXG4gICAgICBoZWlnaHQ6IGwsXG4gICAgICB4OiB1LFxuICAgICAgeTogY1xuICAgIH0sXG4gICAgZHVyYXRpb246IGgsXG4gICAgYW5pbWF0aW9uRWFzaW5nOiBnLFxuICAgIGlzQWN0aXZlOiBiXG4gIH0sIGZ1bmN0aW9uKG0pIHtcbiAgICB2YXIgeSA9IG0ud2lkdGgsIFMgPSBtLmhlaWdodCwgJCA9IG0ueCwgTyA9IG0ueTtcbiAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIFAuY3JlYXRlRWxlbWVudChfbiwge1xuICAgICAgY2FuQmVnaW46IGEgPiAwLFxuICAgICAgZnJvbTogXCIwcHggXCIuY29uY2F0KGEgPT09IC0xID8gMSA6IGEsIFwicHhcIiksXG4gICAgICB0bzogXCJcIi5jb25jYXQoYSwgXCJweCAwcHhcIiksXG4gICAgICBhdHRyaWJ1dGVOYW1lOiBcInN0cm9rZURhc2hhcnJheVwiLFxuICAgICAgYmVnaW46IHYsXG4gICAgICBkdXJhdGlvbjogaCxcbiAgICAgIGlzQWN0aXZlOiB3LFxuICAgICAgZWFzaW5nOiBnXG4gICAgfSwgLyogQF9fUFVSRV9fICovIFAuY3JlYXRlRWxlbWVudChcInBhdGhcIiwgeXMoe30sIHllKG4sICEwKSwge1xuICAgICAgY2xhc3NOYW1lOiB4LFxuICAgICAgZDogZ3YoJCwgTywgeSwgUywgZCksXG4gICAgICByZWY6IHJcbiAgICB9KSkpO1xuICB9KSA6IC8qIEBfX1BVUkVfXyAqLyBQLmNyZWF0ZUVsZW1lbnQoXCJwYXRoXCIsIHlzKHt9LCB5ZShuLCAhMCksIHtcbiAgICBjbGFzc05hbWU6IHgsXG4gICAgZDogZ3YodSwgYywgZiwgbCwgZClcbiAgfSkpO1xufTtcbmZ1bmN0aW9uIFRsKCkge1xuICByZXR1cm4gVGwgPSBPYmplY3QuYXNzaWduID8gT2JqZWN0LmFzc2lnbi5iaW5kKCkgOiBmdW5jdGlvbihlKSB7XG4gICAgZm9yICh2YXIgdCA9IDE7IHQgPCBhcmd1bWVudHMubGVuZ3RoOyB0KyspIHtcbiAgICAgIHZhciBuID0gYXJndW1lbnRzW3RdO1xuICAgICAgZm9yICh2YXIgciBpbiBuKVxuICAgICAgICBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobiwgcikgJiYgKGVbcl0gPSBuW3JdKTtcbiAgICB9XG4gICAgcmV0dXJuIGU7XG4gIH0sIFRsLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG52YXIgcGQgPSBmdW5jdGlvbih0KSB7XG4gIHZhciBuID0gdC5jeCwgciA9IHQuY3ksIGkgPSB0LnIsIG8gPSB0LmNsYXNzTmFtZSwgYSA9ICRlKFwicmVjaGFydHMtZG90XCIsIG8pO1xuICByZXR1cm4gbiA9PT0gK24gJiYgciA9PT0gK3IgJiYgaSA9PT0gK2kgPyAvKiBAX19QVVJFX18gKi8gUC5jcmVhdGVFbGVtZW50KFwiY2lyY2xlXCIsIFRsKHt9LCB5ZSh0LCAhMSksIE5hKHQpLCB7XG4gICAgY2xhc3NOYW1lOiBhLFxuICAgIGN4OiBuLFxuICAgIGN5OiByLFxuICAgIHI6IGlcbiAgfSkpIDogbnVsbDtcbn07XG5mdW5jdGlvbiBBbyhlKSB7XG4gIFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjtcbiAgcmV0dXJuIEFvID0gdHlwZW9mIFN5bWJvbCA9PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PSBcInN5bWJvbFwiID8gZnVuY3Rpb24odCkge1xuICAgIHJldHVybiB0eXBlb2YgdDtcbiAgfSA6IGZ1bmN0aW9uKHQpIHtcbiAgICByZXR1cm4gdCAmJiB0eXBlb2YgU3ltYm9sID09IFwiZnVuY3Rpb25cIiAmJiB0LmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgdCAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2YgdDtcbiAgfSwgQW8oZSk7XG59XG52YXIgSDcgPSBbXCJ4XCIsIFwieVwiLCBcInRvcFwiLCBcImxlZnRcIiwgXCJ3aWR0aFwiLCBcImhlaWdodFwiLCBcImNsYXNzTmFtZVwiXTtcbmZ1bmN0aW9uIE1sKCkge1xuICByZXR1cm4gTWwgPSBPYmplY3QuYXNzaWduID8gT2JqZWN0LmFzc2lnbi5iaW5kKCkgOiBmdW5jdGlvbihlKSB7XG4gICAgZm9yICh2YXIgdCA9IDE7IHQgPCBhcmd1bWVudHMubGVuZ3RoOyB0KyspIHtcbiAgICAgIHZhciBuID0gYXJndW1lbnRzW3RdO1xuICAgICAgZm9yICh2YXIgciBpbiBuKVxuICAgICAgICBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobiwgcikgJiYgKGVbcl0gPSBuW3JdKTtcbiAgICB9XG4gICAgcmV0dXJuIGU7XG4gIH0sIE1sLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5mdW5jdGlvbiB2dihlLCB0KSB7XG4gIHZhciBuID0gT2JqZWN0LmtleXMoZSk7XG4gIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gICAgdmFyIHIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGUpO1xuICAgIHQgJiYgKHIgPSByLmZpbHRlcihmdW5jdGlvbihpKSB7XG4gICAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLCBpKS5lbnVtZXJhYmxlO1xuICAgIH0pKSwgbi5wdXNoLmFwcGx5KG4sIHIpO1xuICB9XG4gIHJldHVybiBuO1xufVxuZnVuY3Rpb24gcTcoZSkge1xuICBmb3IgKHZhciB0ID0gMTsgdCA8IGFyZ3VtZW50cy5sZW5ndGg7IHQrKykge1xuICAgIHZhciBuID0gYXJndW1lbnRzW3RdICE9IG51bGwgPyBhcmd1bWVudHNbdF0gOiB7fTtcbiAgICB0ICUgMiA/IHZ2KE9iamVjdChuKSwgITApLmZvckVhY2goZnVuY3Rpb24ocikge1xuICAgICAgSzcoZSwgciwgbltyXSk7XG4gICAgfSkgOiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGUsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKG4pKSA6IHZ2KE9iamVjdChuKSkuZm9yRWFjaChmdW5jdGlvbihyKSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgciwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihuLCByKSk7XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIGU7XG59XG5mdW5jdGlvbiBLNyhlLCB0LCBuKSB7XG4gIHJldHVybiB0ID0gWTcodCksIHQgaW4gZSA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCB0LCB7IHZhbHVlOiBuLCBlbnVtZXJhYmxlOiAhMCwgY29uZmlndXJhYmxlOiAhMCwgd3JpdGFibGU6ICEwIH0pIDogZVt0XSA9IG4sIGU7XG59XG5mdW5jdGlvbiBZNyhlKSB7XG4gIHZhciB0ID0gWDcoZSwgXCJzdHJpbmdcIik7XG4gIHJldHVybiBBbyh0KSA9PSBcInN5bWJvbFwiID8gdCA6IFN0cmluZyh0KTtcbn1cbmZ1bmN0aW9uIFg3KGUsIHQpIHtcbiAgaWYgKEFvKGUpICE9IFwib2JqZWN0XCIgfHwgIWUpXG4gICAgcmV0dXJuIGU7XG4gIHZhciBuID0gZVtTeW1ib2wudG9QcmltaXRpdmVdO1xuICBpZiAobiAhPT0gdm9pZCAwKSB7XG4gICAgdmFyIHIgPSBuLmNhbGwoZSwgdCB8fCBcImRlZmF1bHRcIik7XG4gICAgaWYgKEFvKHIpICE9IFwib2JqZWN0XCIpXG4gICAgICByZXR1cm4gcjtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQEB0b1ByaW1pdGl2ZSBtdXN0IHJldHVybiBhIHByaW1pdGl2ZSB2YWx1ZS5cIik7XG4gIH1cbiAgcmV0dXJuICh0ID09PSBcInN0cmluZ1wiID8gU3RyaW5nIDogTnVtYmVyKShlKTtcbn1cbmZ1bmN0aW9uIFo3KGUsIHQpIHtcbiAgaWYgKGUgPT0gbnVsbClcbiAgICByZXR1cm4ge307XG4gIHZhciBuID0gSjcoZSwgdCksIHIsIGk7XG4gIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gICAgdmFyIG8gPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGUpO1xuICAgIGZvciAoaSA9IDA7IGkgPCBvLmxlbmd0aDsgaSsrKVxuICAgICAgciA9IG9baV0sICEodC5pbmRleE9mKHIpID49IDApICYmIE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChlLCByKSAmJiAobltyXSA9IGVbcl0pO1xuICB9XG4gIHJldHVybiBuO1xufVxuZnVuY3Rpb24gSjcoZSwgdCkge1xuICBpZiAoZSA9PSBudWxsKVxuICAgIHJldHVybiB7fTtcbiAgdmFyIG4gPSB7fSwgciA9IE9iamVjdC5rZXlzKGUpLCBpLCBvO1xuICBmb3IgKG8gPSAwOyBvIDwgci5sZW5ndGg7IG8rKylcbiAgICBpID0gcltvXSwgISh0LmluZGV4T2YoaSkgPj0gMCkgJiYgKG5baV0gPSBlW2ldKTtcbiAgcmV0dXJuIG47XG59XG52YXIgUTcgPSBmdW5jdGlvbih0LCBuLCByLCBpLCBvLCBhKSB7XG4gIHJldHVybiBcIk1cIi5jb25jYXQodCwgXCIsXCIpLmNvbmNhdChvLCBcInZcIikuY29uY2F0KGksIFwiTVwiKS5jb25jYXQoYSwgXCIsXCIpLmNvbmNhdChuLCBcImhcIikuY29uY2F0KHIpO1xufSwgZTkgPSBmdW5jdGlvbih0KSB7XG4gIHZhciBuID0gdC54LCByID0gbiA9PT0gdm9pZCAwID8gMCA6IG4sIGkgPSB0LnksIG8gPSBpID09PSB2b2lkIDAgPyAwIDogaSwgYSA9IHQudG9wLCBzID0gYSA9PT0gdm9pZCAwID8gMCA6IGEsIHUgPSB0LmxlZnQsIGMgPSB1ID09PSB2b2lkIDAgPyAwIDogdSwgZiA9IHQud2lkdGgsIGwgPSBmID09PSB2b2lkIDAgPyAwIDogZiwgZCA9IHQuaGVpZ2h0LCBwID0gZCA9PT0gdm9pZCAwID8gMCA6IGQsIGcgPSB0LmNsYXNzTmFtZSwgaCA9IFo3KHQsIEg3KSwgdiA9IHE3KHtcbiAgICB4OiByLFxuICAgIHk6IG8sXG4gICAgdG9wOiBzLFxuICAgIGxlZnQ6IGMsXG4gICAgd2lkdGg6IGwsXG4gICAgaGVpZ2h0OiBwXG4gIH0sIGgpO1xuICByZXR1cm4gIUsocikgfHwgIUsobykgfHwgIUsobCkgfHwgIUsocCkgfHwgIUsocykgfHwgIUsoYykgPyBudWxsIDogLyogQF9fUFVSRV9fICovIFAuY3JlYXRlRWxlbWVudChcInBhdGhcIiwgTWwoe30sIHllKHYsICEwKSwge1xuICAgIGNsYXNzTmFtZTogJGUoXCJyZWNoYXJ0cy1jcm9zc1wiLCBnKSxcbiAgICBkOiBRNyhyLCBvLCBsLCBwLCBzLCBjKVxuICB9KSk7XG59LCB0OSA9IE9iLCBuOSA9IHQ5KE9iamVjdC5nZXRQcm90b3R5cGVPZiwgT2JqZWN0KSwgcjkgPSBuOSwgaTkgPSBQbiwgbzkgPSByOSwgYTkgPSBDbiwgczkgPSBcIltvYmplY3QgT2JqZWN0XVwiLCB1OSA9IEZ1bmN0aW9uLnByb3RvdHlwZSwgYzkgPSBPYmplY3QucHJvdG90eXBlLCBzdyA9IHU5LnRvU3RyaW5nLCBsOSA9IGM5Lmhhc093blByb3BlcnR5LCBmOSA9IHN3LmNhbGwoT2JqZWN0KTtcbmZ1bmN0aW9uIGQ5KGUpIHtcbiAgaWYgKCFhOShlKSB8fCBpOShlKSAhPSBzOSlcbiAgICByZXR1cm4gITE7XG4gIHZhciB0ID0gbzkoZSk7XG4gIGlmICh0ID09PSBudWxsKVxuICAgIHJldHVybiAhMDtcbiAgdmFyIG4gPSBsOS5jYWxsKHQsIFwiY29uc3RydWN0b3JcIikgJiYgdC5jb25zdHJ1Y3RvcjtcbiAgcmV0dXJuIHR5cGVvZiBuID09IFwiZnVuY3Rpb25cIiAmJiBuIGluc3RhbmNlb2YgbiAmJiBzdy5jYWxsKG4pID09IGY5O1xufVxudmFyIHA5ID0gZDk7XG5jb25zdCBoOSA9IC8qIEBfX1BVUkVfXyAqLyBqZShwOSk7XG52YXIgZzkgPSBQbiwgdjkgPSBDbiwgbTkgPSBcIltvYmplY3QgQm9vbGVhbl1cIjtcbmZ1bmN0aW9uIHk5KGUpIHtcbiAgcmV0dXJuIGUgPT09ICEwIHx8IGUgPT09ICExIHx8IHY5KGUpICYmIGc5KGUpID09IG05O1xufVxudmFyIGI5ID0geTk7XG5jb25zdCB3OSA9IC8qIEBfX1BVUkVfXyAqLyBqZShiOSk7XG5mdW5jdGlvbiBQbyhlKSB7XG4gIFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjtcbiAgcmV0dXJuIFBvID0gdHlwZW9mIFN5bWJvbCA9PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PSBcInN5bWJvbFwiID8gZnVuY3Rpb24odCkge1xuICAgIHJldHVybiB0eXBlb2YgdDtcbiAgfSA6IGZ1bmN0aW9uKHQpIHtcbiAgICByZXR1cm4gdCAmJiB0eXBlb2YgU3ltYm9sID09IFwiZnVuY3Rpb25cIiAmJiB0LmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgdCAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2YgdDtcbiAgfSwgUG8oZSk7XG59XG5mdW5jdGlvbiBicygpIHtcbiAgcmV0dXJuIGJzID0gT2JqZWN0LmFzc2lnbiA/IE9iamVjdC5hc3NpZ24uYmluZCgpIDogZnVuY3Rpb24oZSkge1xuICAgIGZvciAodmFyIHQgPSAxOyB0IDwgYXJndW1lbnRzLmxlbmd0aDsgdCsrKSB7XG4gICAgICB2YXIgbiA9IGFyZ3VtZW50c1t0XTtcbiAgICAgIGZvciAodmFyIHIgaW4gbilcbiAgICAgICAgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG4sIHIpICYmIChlW3JdID0gbltyXSk7XG4gICAgfVxuICAgIHJldHVybiBlO1xuICB9LCBicy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuZnVuY3Rpb24geDkoZSwgdCkge1xuICByZXR1cm4gXzkoZSkgfHwgTzkoZSwgdCkgfHwgJDkoZSwgdCkgfHwgUzkoKTtcbn1cbmZ1bmN0aW9uIFM5KCkge1xuICB0aHJvdyBuZXcgVHlwZUVycm9yKGBJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLmApO1xufVxuZnVuY3Rpb24gJDkoZSwgdCkge1xuICBpZiAoZSkge1xuICAgIGlmICh0eXBlb2YgZSA9PSBcInN0cmluZ1wiKVxuICAgICAgcmV0dXJuIG12KGUsIHQpO1xuICAgIHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGUpLnNsaWNlKDgsIC0xKTtcbiAgICBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBlLmNvbnN0cnVjdG9yICYmIChuID0gZS5jb25zdHJ1Y3Rvci5uYW1lKSwgbiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKVxuICAgICAgcmV0dXJuIEFycmF5LmZyb20oZSk7XG4gICAgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpXG4gICAgICByZXR1cm4gbXYoZSwgdCk7XG4gIH1cbn1cbmZ1bmN0aW9uIG12KGUsIHQpIHtcbiAgKHQgPT0gbnVsbCB8fCB0ID4gZS5sZW5ndGgpICYmICh0ID0gZS5sZW5ndGgpO1xuICBmb3IgKHZhciBuID0gMCwgciA9IG5ldyBBcnJheSh0KTsgbiA8IHQ7IG4rKylcbiAgICByW25dID0gZVtuXTtcbiAgcmV0dXJuIHI7XG59XG5mdW5jdGlvbiBPOShlLCB0KSB7XG4gIHZhciBuID0gZSA9PSBudWxsID8gbnVsbCA6IHR5cGVvZiBTeW1ib2wgPCBcInVcIiAmJiBlW1N5bWJvbC5pdGVyYXRvcl0gfHwgZVtcIkBAaXRlcmF0b3JcIl07XG4gIGlmIChuICE9IG51bGwpIHtcbiAgICB2YXIgciwgaSwgbywgYSwgcyA9IFtdLCB1ID0gITAsIGMgPSAhMTtcbiAgICB0cnkge1xuICAgICAgaWYgKG8gPSAobiA9IG4uY2FsbChlKSkubmV4dCwgdCAhPT0gMClcbiAgICAgICAgZm9yICg7ICEodSA9IChyID0gby5jYWxsKG4pKS5kb25lKSAmJiAocy5wdXNoKHIudmFsdWUpLCBzLmxlbmd0aCAhPT0gdCk7IHUgPSAhMClcbiAgICAgICAgICA7XG4gICAgfSBjYXRjaCAoZikge1xuICAgICAgYyA9ICEwLCBpID0gZjtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKCF1ICYmIG4ucmV0dXJuICE9IG51bGwgJiYgKGEgPSBuLnJldHVybigpLCBPYmplY3QoYSkgIT09IGEpKVxuICAgICAgICAgIHJldHVybjtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGlmIChjKVxuICAgICAgICAgIHRocm93IGk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzO1xuICB9XG59XG5mdW5jdGlvbiBfOShlKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGUpKVxuICAgIHJldHVybiBlO1xufVxuZnVuY3Rpb24geXYoZSwgdCkge1xuICB2YXIgbiA9IE9iamVjdC5rZXlzKGUpO1xuICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykge1xuICAgIHZhciByID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhlKTtcbiAgICB0ICYmIChyID0gci5maWx0ZXIoZnVuY3Rpb24oaSkge1xuICAgICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSwgaSkuZW51bWVyYWJsZTtcbiAgICB9KSksIG4ucHVzaC5hcHBseShuLCByKTtcbiAgfVxuICByZXR1cm4gbjtcbn1cbmZ1bmN0aW9uIGJ2KGUpIHtcbiAgZm9yICh2YXIgdCA9IDE7IHQgPCBhcmd1bWVudHMubGVuZ3RoOyB0KyspIHtcbiAgICB2YXIgbiA9IGFyZ3VtZW50c1t0XSAhPSBudWxsID8gYXJndW1lbnRzW3RdIDoge307XG4gICAgdCAlIDIgPyB5dihPYmplY3QobiksICEwKS5mb3JFYWNoKGZ1bmN0aW9uKHIpIHtcbiAgICAgIEE5KGUsIHIsIG5bcl0pO1xuICAgIH0pIDogT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhlLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhuKSkgOiB5dihPYmplY3QobikpLmZvckVhY2goZnVuY3Rpb24ocikge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIHIsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobiwgcikpO1xuICAgIH0pO1xuICB9XG4gIHJldHVybiBlO1xufVxuZnVuY3Rpb24gQTkoZSwgdCwgbikge1xuICByZXR1cm4gdCA9IFA5KHQpLCB0IGluIGUgPyBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgdCwgeyB2YWx1ZTogbiwgZW51bWVyYWJsZTogITAsIGNvbmZpZ3VyYWJsZTogITAsIHdyaXRhYmxlOiAhMCB9KSA6IGVbdF0gPSBuLCBlO1xufVxuZnVuY3Rpb24gUDkoZSkge1xuICB2YXIgdCA9IEM5KGUsIFwic3RyaW5nXCIpO1xuICByZXR1cm4gUG8odCkgPT0gXCJzeW1ib2xcIiA/IHQgOiBTdHJpbmcodCk7XG59XG5mdW5jdGlvbiBDOShlLCB0KSB7XG4gIGlmIChQbyhlKSAhPSBcIm9iamVjdFwiIHx8ICFlKVxuICAgIHJldHVybiBlO1xuICB2YXIgbiA9IGVbU3ltYm9sLnRvUHJpbWl0aXZlXTtcbiAgaWYgKG4gIT09IHZvaWQgMCkge1xuICAgIHZhciByID0gbi5jYWxsKGUsIHQgfHwgXCJkZWZhdWx0XCIpO1xuICAgIGlmIChQbyhyKSAhPSBcIm9iamVjdFwiKVxuICAgICAgcmV0dXJuIHI7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkBAdG9QcmltaXRpdmUgbXVzdCByZXR1cm4gYSBwcmltaXRpdmUgdmFsdWUuXCIpO1xuICB9XG4gIHJldHVybiAodCA9PT0gXCJzdHJpbmdcIiA/IFN0cmluZyA6IE51bWJlcikoZSk7XG59XG52YXIgd3YgPSBmdW5jdGlvbih0LCBuLCByLCBpLCBvKSB7XG4gIHZhciBhID0gciAtIGksIHM7XG4gIHJldHVybiBzID0gXCJNIFwiLmNvbmNhdCh0LCBcIixcIikuY29uY2F0KG4pLCBzICs9IFwiTCBcIi5jb25jYXQodCArIHIsIFwiLFwiKS5jb25jYXQobiksIHMgKz0gXCJMIFwiLmNvbmNhdCh0ICsgciAtIGEgLyAyLCBcIixcIikuY29uY2F0KG4gKyBvKSwgcyArPSBcIkwgXCIuY29uY2F0KHQgKyByIC0gYSAvIDIgLSBpLCBcIixcIikuY29uY2F0KG4gKyBvKSwgcyArPSBcIkwgXCIuY29uY2F0KHQsIFwiLFwiKS5jb25jYXQobiwgXCIgWlwiKSwgcztcbn0sIEU5ID0ge1xuICB4OiAwLFxuICB5OiAwLFxuICB1cHBlcldpZHRoOiAwLFxuICBsb3dlcldpZHRoOiAwLFxuICBoZWlnaHQ6IDAsXG4gIGlzVXBkYXRlQW5pbWF0aW9uQWN0aXZlOiAhMSxcbiAgYW5pbWF0aW9uQmVnaW46IDAsXG4gIGFuaW1hdGlvbkR1cmF0aW9uOiAxNTAwLFxuICBhbmltYXRpb25FYXNpbmc6IFwiZWFzZVwiXG59LCBUOSA9IGZ1bmN0aW9uKHQpIHtcbiAgdmFyIG4gPSBidihidih7fSwgRTkpLCB0KSwgciA9IF9lKCksIGkgPSBZZSgtMSksIG8gPSB4OShpLCAyKSwgYSA9IG9bMF0sIHMgPSBvWzFdO1xuICBGZShmdW5jdGlvbigpIHtcbiAgICBpZiAoci5jdXJyZW50ICYmIHIuY3VycmVudC5nZXRUb3RhbExlbmd0aClcbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciB4ID0gci5jdXJyZW50LmdldFRvdGFsTGVuZ3RoKCk7XG4gICAgICAgIHggJiYgcyh4KTtcbiAgICAgIH0gY2F0Y2gge1xuICAgICAgfVxuICB9LCBbXSk7XG4gIHZhciB1ID0gbi54LCBjID0gbi55LCBmID0gbi51cHBlcldpZHRoLCBsID0gbi5sb3dlcldpZHRoLCBkID0gbi5oZWlnaHQsIHAgPSBuLmNsYXNzTmFtZSwgZyA9IG4uYW5pbWF0aW9uRWFzaW5nLCBoID0gbi5hbmltYXRpb25EdXJhdGlvbiwgdiA9IG4uYW5pbWF0aW9uQmVnaW4sIHcgPSBuLmlzVXBkYXRlQW5pbWF0aW9uQWN0aXZlO1xuICBpZiAodSAhPT0gK3UgfHwgYyAhPT0gK2MgfHwgZiAhPT0gK2YgfHwgbCAhPT0gK2wgfHwgZCAhPT0gK2QgfHwgZiA9PT0gMCAmJiBsID09PSAwIHx8IGQgPT09IDApXG4gICAgcmV0dXJuIG51bGw7XG4gIHZhciBiID0gJGUoXCJyZWNoYXJ0cy10cmFwZXpvaWRcIiwgcCk7XG4gIHJldHVybiB3ID8gLyogQF9fUFVSRV9fICovIFAuY3JlYXRlRWxlbWVudChfbiwge1xuICAgIGNhbkJlZ2luOiBhID4gMCxcbiAgICBmcm9tOiB7XG4gICAgICB1cHBlcldpZHRoOiAwLFxuICAgICAgbG93ZXJXaWR0aDogMCxcbiAgICAgIGhlaWdodDogZCxcbiAgICAgIHg6IHUsXG4gICAgICB5OiBjXG4gICAgfSxcbiAgICB0bzoge1xuICAgICAgdXBwZXJXaWR0aDogZixcbiAgICAgIGxvd2VyV2lkdGg6IGwsXG4gICAgICBoZWlnaHQ6IGQsXG4gICAgICB4OiB1LFxuICAgICAgeTogY1xuICAgIH0sXG4gICAgZHVyYXRpb246IGgsXG4gICAgYW5pbWF0aW9uRWFzaW5nOiBnLFxuICAgIGlzQWN0aXZlOiB3XG4gIH0sIGZ1bmN0aW9uKHgpIHtcbiAgICB2YXIgbSA9IHgudXBwZXJXaWR0aCwgeSA9IHgubG93ZXJXaWR0aCwgUyA9IHguaGVpZ2h0LCAkID0geC54LCBPID0geC55O1xuICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8gUC5jcmVhdGVFbGVtZW50KF9uLCB7XG4gICAgICBjYW5CZWdpbjogYSA+IDAsXG4gICAgICBmcm9tOiBcIjBweCBcIi5jb25jYXQoYSA9PT0gLTEgPyAxIDogYSwgXCJweFwiKSxcbiAgICAgIHRvOiBcIlwiLmNvbmNhdChhLCBcInB4IDBweFwiKSxcbiAgICAgIGF0dHJpYnV0ZU5hbWU6IFwic3Ryb2tlRGFzaGFycmF5XCIsXG4gICAgICBiZWdpbjogdixcbiAgICAgIGR1cmF0aW9uOiBoLFxuICAgICAgZWFzaW5nOiBnXG4gICAgfSwgLyogQF9fUFVSRV9fICovIFAuY3JlYXRlRWxlbWVudChcInBhdGhcIiwgYnMoe30sIHllKG4sICEwKSwge1xuICAgICAgY2xhc3NOYW1lOiBiLFxuICAgICAgZDogd3YoJCwgTywgbSwgeSwgUyksXG4gICAgICByZWY6IHJcbiAgICB9KSkpO1xuICB9KSA6IC8qIEBfX1BVUkVfXyAqLyBQLmNyZWF0ZUVsZW1lbnQoXCJnXCIsIG51bGwsIC8qIEBfX1BVUkVfXyAqLyBQLmNyZWF0ZUVsZW1lbnQoXCJwYXRoXCIsIGJzKHt9LCB5ZShuLCAhMCksIHtcbiAgICBjbGFzc05hbWU6IGIsXG4gICAgZDogd3YodSwgYywgZiwgbCwgZClcbiAgfSkpKTtcbn0sIE05ID0gW1wib3B0aW9uXCIsIFwic2hhcGVUeXBlXCIsIFwicHJvcFRyYW5zZm9ybWVyXCIsIFwiYWN0aXZlQ2xhc3NOYW1lXCIsIFwiaXNBY3RpdmVcIl07XG5mdW5jdGlvbiBDbyhlKSB7XG4gIFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjtcbiAgcmV0dXJuIENvID0gdHlwZW9mIFN5bWJvbCA9PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PSBcInN5bWJvbFwiID8gZnVuY3Rpb24odCkge1xuICAgIHJldHVybiB0eXBlb2YgdDtcbiAgfSA6IGZ1bmN0aW9uKHQpIHtcbiAgICByZXR1cm4gdCAmJiB0eXBlb2YgU3ltYm9sID09IFwiZnVuY3Rpb25cIiAmJiB0LmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgdCAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2YgdDtcbiAgfSwgQ28oZSk7XG59XG5mdW5jdGlvbiBSOShlLCB0KSB7XG4gIGlmIChlID09IG51bGwpXG4gICAgcmV0dXJuIHt9O1xuICB2YXIgbiA9IEk5KGUsIHQpLCByLCBpO1xuICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykge1xuICAgIHZhciBvID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhlKTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgby5sZW5ndGg7IGkrKylcbiAgICAgIHIgPSBvW2ldLCAhKHQuaW5kZXhPZihyKSA+PSAwKSAmJiBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwoZSwgcikgJiYgKG5bcl0gPSBlW3JdKTtcbiAgfVxuICByZXR1cm4gbjtcbn1cbmZ1bmN0aW9uIEk5KGUsIHQpIHtcbiAgaWYgKGUgPT0gbnVsbClcbiAgICByZXR1cm4ge307XG4gIHZhciBuID0ge30sIHIgPSBPYmplY3Qua2V5cyhlKSwgaSwgbztcbiAgZm9yIChvID0gMDsgbyA8IHIubGVuZ3RoOyBvKyspXG4gICAgaSA9IHJbb10sICEodC5pbmRleE9mKGkpID49IDApICYmIChuW2ldID0gZVtpXSk7XG4gIHJldHVybiBuO1xufVxuZnVuY3Rpb24geHYoZSwgdCkge1xuICB2YXIgbiA9IE9iamVjdC5rZXlzKGUpO1xuICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykge1xuICAgIHZhciByID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhlKTtcbiAgICB0ICYmIChyID0gci5maWx0ZXIoZnVuY3Rpb24oaSkge1xuICAgICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSwgaSkuZW51bWVyYWJsZTtcbiAgICB9KSksIG4ucHVzaC5hcHBseShuLCByKTtcbiAgfVxuICByZXR1cm4gbjtcbn1cbmZ1bmN0aW9uIHdzKGUpIHtcbiAgZm9yICh2YXIgdCA9IDE7IHQgPCBhcmd1bWVudHMubGVuZ3RoOyB0KyspIHtcbiAgICB2YXIgbiA9IGFyZ3VtZW50c1t0XSAhPSBudWxsID8gYXJndW1lbnRzW3RdIDoge307XG4gICAgdCAlIDIgPyB4dihPYmplY3QobiksICEwKS5mb3JFYWNoKGZ1bmN0aW9uKHIpIHtcbiAgICAgIGo5KGUsIHIsIG5bcl0pO1xuICAgIH0pIDogT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhlLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhuKSkgOiB4dihPYmplY3QobikpLmZvckVhY2goZnVuY3Rpb24ocikge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIHIsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobiwgcikpO1xuICAgIH0pO1xuICB9XG4gIHJldHVybiBlO1xufVxuZnVuY3Rpb24gajkoZSwgdCwgbikge1xuICByZXR1cm4gdCA9IGs5KHQpLCB0IGluIGUgPyBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgdCwgeyB2YWx1ZTogbiwgZW51bWVyYWJsZTogITAsIGNvbmZpZ3VyYWJsZTogITAsIHdyaXRhYmxlOiAhMCB9KSA6IGVbdF0gPSBuLCBlO1xufVxuZnVuY3Rpb24gazkoZSkge1xuICB2YXIgdCA9IEQ5KGUsIFwic3RyaW5nXCIpO1xuICByZXR1cm4gQ28odCkgPT0gXCJzeW1ib2xcIiA/IHQgOiBTdHJpbmcodCk7XG59XG5mdW5jdGlvbiBEOShlLCB0KSB7XG4gIGlmIChDbyhlKSAhPSBcIm9iamVjdFwiIHx8ICFlKVxuICAgIHJldHVybiBlO1xuICB2YXIgbiA9IGVbU3ltYm9sLnRvUHJpbWl0aXZlXTtcbiAgaWYgKG4gIT09IHZvaWQgMCkge1xuICAgIHZhciByID0gbi5jYWxsKGUsIHQgfHwgXCJkZWZhdWx0XCIpO1xuICAgIGlmIChDbyhyKSAhPSBcIm9iamVjdFwiKVxuICAgICAgcmV0dXJuIHI7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkBAdG9QcmltaXRpdmUgbXVzdCByZXR1cm4gYSBwcmltaXRpdmUgdmFsdWUuXCIpO1xuICB9XG4gIHJldHVybiAodCA9PT0gXCJzdHJpbmdcIiA/IFN0cmluZyA6IE51bWJlcikoZSk7XG59XG5mdW5jdGlvbiBOOShlLCB0KSB7XG4gIHJldHVybiB3cyh3cyh7fSwgdCksIGUpO1xufVxuZnVuY3Rpb24gRjkoZSwgdCkge1xuICByZXR1cm4gZSA9PT0gXCJzeW1ib2xzXCI7XG59XG5mdW5jdGlvbiBTdihlKSB7XG4gIHZhciB0ID0gZS5zaGFwZVR5cGUsIG4gPSBlLmVsZW1lbnRQcm9wcztcbiAgc3dpdGNoICh0KSB7XG4gICAgY2FzZSBcInJlY3RhbmdsZVwiOlxuICAgICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBQLmNyZWF0ZUVsZW1lbnQoZGQsIG4pO1xuICAgIGNhc2UgXCJ0cmFwZXpvaWRcIjpcbiAgICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8gUC5jcmVhdGVFbGVtZW50KFQ5LCBuKTtcbiAgICBjYXNlIFwic2VjdG9yXCI6XG4gICAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIFAuY3JlYXRlRWxlbWVudChaMCwgbik7XG4gICAgY2FzZSBcInN5bWJvbHNcIjpcbiAgICAgIGlmIChGOSh0KSlcbiAgICAgICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBQLmNyZWF0ZUVsZW1lbnQoVGYsIG4pO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBudWxsO1xuICB9XG59XG5mdW5jdGlvbiBMOShlKSB7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gdnQoZSkgPyBlLnByb3BzIDogZTtcbn1cbmZ1bmN0aW9uIEI5KGUpIHtcbiAgdmFyIHQgPSBlLm9wdGlvbiwgbiA9IGUuc2hhcGVUeXBlLCByID0gZS5wcm9wVHJhbnNmb3JtZXIsIGkgPSByID09PSB2b2lkIDAgPyBOOSA6IHIsIG8gPSBlLmFjdGl2ZUNsYXNzTmFtZSwgYSA9IG8gPT09IHZvaWQgMCA/IFwicmVjaGFydHMtYWN0aXZlLXNoYXBlXCIgOiBvLCBzID0gZS5pc0FjdGl2ZSwgdSA9IFI5KGUsIE05KSwgYztcbiAgaWYgKC8qIEBfX1BVUkVfXyAqLyB2dCh0KSlcbiAgICBjID0gLyogQF9fUFVSRV9fICovIEdlKHQsIHdzKHdzKHt9LCB1KSwgTDkodCkpKTtcbiAgZWxzZSBpZiAocGUodCkpXG4gICAgYyA9IHQodSk7XG4gIGVsc2UgaWYgKGg5KHQpICYmICF3OSh0KSkge1xuICAgIHZhciBmID0gaSh0LCB1KTtcbiAgICBjID0gLyogQF9fUFVSRV9fICovIFAuY3JlYXRlRWxlbWVudChTdiwge1xuICAgICAgc2hhcGVUeXBlOiBuLFxuICAgICAgZWxlbWVudFByb3BzOiBmXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGwgPSB1O1xuICAgIGMgPSAvKiBAX19QVVJFX18gKi8gUC5jcmVhdGVFbGVtZW50KFN2LCB7XG4gICAgICBzaGFwZVR5cGU6IG4sXG4gICAgICBlbGVtZW50UHJvcHM6IGxcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gcyA/IC8qIEBfX1BVUkVfXyAqLyBQLmNyZWF0ZUVsZW1lbnQoV2UsIHtcbiAgICBjbGFzc05hbWU6IGFcbiAgfSwgYykgOiBjO1xufVxuZnVuY3Rpb24gaXUoZSwgdCkge1xuICByZXR1cm4gdCAhPSBudWxsICYmIFwidHJhcGV6b2lkc1wiIGluIGUucHJvcHM7XG59XG5mdW5jdGlvbiBvdShlLCB0KSB7XG4gIHJldHVybiB0ICE9IG51bGwgJiYgXCJzZWN0b3JzXCIgaW4gZS5wcm9wcztcbn1cbmZ1bmN0aW9uIEVvKGUsIHQpIHtcbiAgcmV0dXJuIHQgIT0gbnVsbCAmJiBcInBvaW50c1wiIGluIGUucHJvcHM7XG59XG5mdW5jdGlvbiB6OShlLCB0KSB7XG4gIHZhciBuLCByLCBpID0gZS54ID09PSAodCA9PSBudWxsIHx8IChuID0gdC5sYWJlbFZpZXdCb3gpID09PSBudWxsIHx8IG4gPT09IHZvaWQgMCA/IHZvaWQgMCA6IG4ueCkgfHwgZS54ID09PSB0LngsIG8gPSBlLnkgPT09ICh0ID09IG51bGwgfHwgKHIgPSB0LmxhYmVsVmlld0JveCkgPT09IG51bGwgfHwgciA9PT0gdm9pZCAwID8gdm9pZCAwIDogci55KSB8fCBlLnkgPT09IHQueTtcbiAgcmV0dXJuIGkgJiYgbztcbn1cbmZ1bmN0aW9uIFY5KGUsIHQpIHtcbiAgdmFyIG4gPSBlLmVuZEFuZ2xlID09PSB0LmVuZEFuZ2xlLCByID0gZS5zdGFydEFuZ2xlID09PSB0LnN0YXJ0QW5nbGU7XG4gIHJldHVybiBuICYmIHI7XG59XG5mdW5jdGlvbiBHOShlLCB0KSB7XG4gIHZhciBuID0gZS54ID09PSB0LngsIHIgPSBlLnkgPT09IHQueSwgaSA9IGUueiA9PT0gdC56O1xuICByZXR1cm4gbiAmJiByICYmIGk7XG59XG5mdW5jdGlvbiBXOShlLCB0KSB7XG4gIHZhciBuO1xuICByZXR1cm4gaXUoZSwgdCkgPyBuID0gejkgOiBvdShlLCB0KSA/IG4gPSBWOSA6IEVvKGUsIHQpICYmIChuID0gRzkpLCBuO1xufVxuZnVuY3Rpb24gVTkoZSwgdCkge1xuICB2YXIgbjtcbiAgcmV0dXJuIGl1KGUsIHQpID8gbiA9IFwidHJhcGV6b2lkc1wiIDogb3UoZSwgdCkgPyBuID0gXCJzZWN0b3JzXCIgOiBFbyhlLCB0KSAmJiAobiA9IFwicG9pbnRzXCIpLCBuO1xufVxuZnVuY3Rpb24gSDkoZSwgdCkge1xuICBpZiAoaXUoZSwgdCkpIHtcbiAgICB2YXIgbjtcbiAgICByZXR1cm4gKG4gPSB0LnRvb2x0aXBQYXlsb2FkKSA9PT0gbnVsbCB8fCBuID09PSB2b2lkIDAgfHwgKG4gPSBuWzBdKSA9PT0gbnVsbCB8fCBuID09PSB2b2lkIDAgfHwgKG4gPSBuLnBheWxvYWQpID09PSBudWxsIHx8IG4gPT09IHZvaWQgMCA/IHZvaWQgMCA6IG4ucGF5bG9hZDtcbiAgfVxuICBpZiAob3UoZSwgdCkpIHtcbiAgICB2YXIgcjtcbiAgICByZXR1cm4gKHIgPSB0LnRvb2x0aXBQYXlsb2FkKSA9PT0gbnVsbCB8fCByID09PSB2b2lkIDAgfHwgKHIgPSByWzBdKSA9PT0gbnVsbCB8fCByID09PSB2b2lkIDAgfHwgKHIgPSByLnBheWxvYWQpID09PSBudWxsIHx8IHIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHIucGF5bG9hZDtcbiAgfVxuICByZXR1cm4gRW8oZSwgdCkgPyB0LnBheWxvYWQgOiB7fTtcbn1cbmZ1bmN0aW9uIHE5KGUpIHtcbiAgdmFyIHQgPSBlLmFjdGl2ZVRvb2x0aXBJdGVtLCBuID0gZS5ncmFwaGljYWxJdGVtLCByID0gZS5pdGVtRGF0YSwgaSA9IFU5KG4sIHQpLCBvID0gSDkobiwgdCksIGEgPSByLmZpbHRlcihmdW5jdGlvbih1LCBjKSB7XG4gICAgdmFyIGYgPSB0dShvLCB1KSwgbCA9IG4ucHJvcHNbaV0uZmlsdGVyKGZ1bmN0aW9uKGcpIHtcbiAgICAgIHZhciBoID0gVzkobiwgdCk7XG4gICAgICByZXR1cm4gaChnLCB0KTtcbiAgICB9KSwgZCA9IG4ucHJvcHNbaV0uaW5kZXhPZihsW2wubGVuZ3RoIC0gMV0pLCBwID0gYyA9PT0gZDtcbiAgICByZXR1cm4gZiAmJiBwO1xuICB9KSwgcyA9IHIuaW5kZXhPZihhW2EubGVuZ3RoIC0gMV0pO1xuICByZXR1cm4gcztcbn1cbnZhciBLOSA9IE1hdGguY2VpbCwgWTkgPSBNYXRoLm1heDtcbmZ1bmN0aW9uIFg5KGUsIHQsIG4sIHIpIHtcbiAgZm9yICh2YXIgaSA9IC0xLCBvID0gWTkoSzkoKHQgLSBlKSAvIChuIHx8IDEpKSwgMCksIGEgPSBBcnJheShvKTsgby0tOyApXG4gICAgYVtyID8gbyA6ICsraV0gPSBlLCBlICs9IG47XG4gIHJldHVybiBhO1xufVxudmFyIFo5ID0gWDksIEo5ID0gV2IsICR2ID0gMSAvIDAsIFE5ID0gMTc5NzY5MzEzNDg2MjMxNTdlMjkyO1xuZnVuY3Rpb24gZVYoZSkge1xuICBpZiAoIWUpXG4gICAgcmV0dXJuIGUgPT09IDAgPyBlIDogMDtcbiAgaWYgKGUgPSBKOShlKSwgZSA9PT0gJHYgfHwgZSA9PT0gLSR2KSB7XG4gICAgdmFyIHQgPSBlIDwgMCA/IC0xIDogMTtcbiAgICByZXR1cm4gdCAqIFE5O1xuICB9XG4gIHJldHVybiBlID09PSBlID8gZSA6IDA7XG59XG52YXIgdXcgPSBlViwgdFYgPSBaOSwgblYgPSBIcywgdGMgPSB1dztcbmZ1bmN0aW9uIHJWKGUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHQsIG4sIHIpIHtcbiAgICByZXR1cm4gciAmJiB0eXBlb2YgciAhPSBcIm51bWJlclwiICYmIG5WKHQsIG4sIHIpICYmIChuID0gciA9IHZvaWQgMCksIHQgPSB0Yyh0KSwgbiA9PT0gdm9pZCAwID8gKG4gPSB0LCB0ID0gMCkgOiBuID0gdGMobiksIHIgPSByID09PSB2b2lkIDAgPyB0IDwgbiA/IDEgOiAtMSA6IHRjKHIpLCB0Vih0LCBuLCByLCBlKTtcbiAgfTtcbn1cbnZhciBpViA9IHJWLCBvViA9IGlWLCBhViA9IG9WKCksIHNWID0gYVY7XG5jb25zdCB4cyA9IC8qIEBfX1BVUkVfXyAqLyBqZShzVik7XG5mdW5jdGlvbiBUbyhlKSB7XG4gIFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjtcbiAgcmV0dXJuIFRvID0gdHlwZW9mIFN5bWJvbCA9PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PSBcInN5bWJvbFwiID8gZnVuY3Rpb24odCkge1xuICAgIHJldHVybiB0eXBlb2YgdDtcbiAgfSA6IGZ1bmN0aW9uKHQpIHtcbiAgICByZXR1cm4gdCAmJiB0eXBlb2YgU3ltYm9sID09IFwiZnVuY3Rpb25cIiAmJiB0LmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgdCAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2YgdDtcbiAgfSwgVG8oZSk7XG59XG5mdW5jdGlvbiBPdihlLCB0KSB7XG4gIHZhciBuID0gT2JqZWN0LmtleXMoZSk7XG4gIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gICAgdmFyIHIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGUpO1xuICAgIHQgJiYgKHIgPSByLmZpbHRlcihmdW5jdGlvbihpKSB7XG4gICAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLCBpKS5lbnVtZXJhYmxlO1xuICAgIH0pKSwgbi5wdXNoLmFwcGx5KG4sIHIpO1xuICB9XG4gIHJldHVybiBuO1xufVxuZnVuY3Rpb24gX3YoZSkge1xuICBmb3IgKHZhciB0ID0gMTsgdCA8IGFyZ3VtZW50cy5sZW5ndGg7IHQrKykge1xuICAgIHZhciBuID0gYXJndW1lbnRzW3RdICE9IG51bGwgPyBhcmd1bWVudHNbdF0gOiB7fTtcbiAgICB0ICUgMiA/IE92KE9iamVjdChuKSwgITApLmZvckVhY2goZnVuY3Rpb24ocikge1xuICAgICAgY3coZSwgciwgbltyXSk7XG4gICAgfSkgOiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGUsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKG4pKSA6IE92KE9iamVjdChuKSkuZm9yRWFjaChmdW5jdGlvbihyKSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgciwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihuLCByKSk7XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIGU7XG59XG5mdW5jdGlvbiBjdyhlLCB0LCBuKSB7XG4gIHJldHVybiB0ID0gdVYodCksIHQgaW4gZSA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCB0LCB7IHZhbHVlOiBuLCBlbnVtZXJhYmxlOiAhMCwgY29uZmlndXJhYmxlOiAhMCwgd3JpdGFibGU6ICEwIH0pIDogZVt0XSA9IG4sIGU7XG59XG5mdW5jdGlvbiB1VihlKSB7XG4gIHZhciB0ID0gY1YoZSwgXCJzdHJpbmdcIik7XG4gIHJldHVybiBUbyh0KSA9PSBcInN5bWJvbFwiID8gdCA6IFN0cmluZyh0KTtcbn1cbmZ1bmN0aW9uIGNWKGUsIHQpIHtcbiAgaWYgKFRvKGUpICE9IFwib2JqZWN0XCIgfHwgIWUpXG4gICAgcmV0dXJuIGU7XG4gIHZhciBuID0gZVtTeW1ib2wudG9QcmltaXRpdmVdO1xuICBpZiAobiAhPT0gdm9pZCAwKSB7XG4gICAgdmFyIHIgPSBuLmNhbGwoZSwgdCB8fCBcImRlZmF1bHRcIik7XG4gICAgaWYgKFRvKHIpICE9IFwib2JqZWN0XCIpXG4gICAgICByZXR1cm4gcjtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQEB0b1ByaW1pdGl2ZSBtdXN0IHJldHVybiBhIHByaW1pdGl2ZSB2YWx1ZS5cIik7XG4gIH1cbiAgcmV0dXJuICh0ID09PSBcInN0cmluZ1wiID8gU3RyaW5nIDogTnVtYmVyKShlKTtcbn1cbnZhciBsViA9IFtcIldlYmtpdFwiLCBcIk1velwiLCBcIk9cIiwgXCJtc1wiXSwgZlYgPSBmdW5jdGlvbih0LCBuKSB7XG4gIHZhciByID0gdC5yZXBsYWNlKC8oXFx3KS8sIGZ1bmN0aW9uKG8pIHtcbiAgICByZXR1cm4gby50b1VwcGVyQ2FzZSgpO1xuICB9KSwgaSA9IGxWLnJlZHVjZShmdW5jdGlvbihvLCBhKSB7XG4gICAgcmV0dXJuIF92KF92KHt9LCBvKSwge30sIGN3KHt9LCBhICsgciwgbikpO1xuICB9LCB7fSk7XG4gIHJldHVybiBpW3RdID0gbiwgaTtcbn07XG5mdW5jdGlvbiBZcihlKSB7XG4gIFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjtcbiAgcmV0dXJuIFlyID0gdHlwZW9mIFN5bWJvbCA9PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PSBcInN5bWJvbFwiID8gZnVuY3Rpb24odCkge1xuICAgIHJldHVybiB0eXBlb2YgdDtcbiAgfSA6IGZ1bmN0aW9uKHQpIHtcbiAgICByZXR1cm4gdCAmJiB0eXBlb2YgU3ltYm9sID09IFwiZnVuY3Rpb25cIiAmJiB0LmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgdCAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2YgdDtcbiAgfSwgWXIoZSk7XG59XG5mdW5jdGlvbiBTcygpIHtcbiAgcmV0dXJuIFNzID0gT2JqZWN0LmFzc2lnbiA/IE9iamVjdC5hc3NpZ24uYmluZCgpIDogZnVuY3Rpb24oZSkge1xuICAgIGZvciAodmFyIHQgPSAxOyB0IDwgYXJndW1lbnRzLmxlbmd0aDsgdCsrKSB7XG4gICAgICB2YXIgbiA9IGFyZ3VtZW50c1t0XTtcbiAgICAgIGZvciAodmFyIHIgaW4gbilcbiAgICAgICAgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG4sIHIpICYmIChlW3JdID0gbltyXSk7XG4gICAgfVxuICAgIHJldHVybiBlO1xuICB9LCBTcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuZnVuY3Rpb24gQXYoZSwgdCkge1xuICB2YXIgbiA9IE9iamVjdC5rZXlzKGUpO1xuICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykge1xuICAgIHZhciByID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhlKTtcbiAgICB0ICYmIChyID0gci5maWx0ZXIoZnVuY3Rpb24oaSkge1xuICAgICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSwgaSkuZW51bWVyYWJsZTtcbiAgICB9KSksIG4ucHVzaC5hcHBseShuLCByKTtcbiAgfVxuICByZXR1cm4gbjtcbn1cbmZ1bmN0aW9uIG5jKGUpIHtcbiAgZm9yICh2YXIgdCA9IDE7IHQgPCBhcmd1bWVudHMubGVuZ3RoOyB0KyspIHtcbiAgICB2YXIgbiA9IGFyZ3VtZW50c1t0XSAhPSBudWxsID8gYXJndW1lbnRzW3RdIDoge307XG4gICAgdCAlIDIgPyBBdihPYmplY3QobiksICEwKS5mb3JFYWNoKGZ1bmN0aW9uKHIpIHtcbiAgICAgIGJ0KGUsIHIsIG5bcl0pO1xuICAgIH0pIDogT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhlLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhuKSkgOiBBdihPYmplY3QobikpLmZvckVhY2goZnVuY3Rpb24ocikge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIHIsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobiwgcikpO1xuICAgIH0pO1xuICB9XG4gIHJldHVybiBlO1xufVxuZnVuY3Rpb24gZFYoZSwgdCkge1xuICBpZiAoIShlIGluc3RhbmNlb2YgdCkpXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcbn1cbmZ1bmN0aW9uIFB2KGUsIHQpIHtcbiAgZm9yICh2YXIgbiA9IDA7IG4gPCB0Lmxlbmd0aDsgbisrKSB7XG4gICAgdmFyIHIgPSB0W25dO1xuICAgIHIuZW51bWVyYWJsZSA9IHIuZW51bWVyYWJsZSB8fCAhMSwgci5jb25maWd1cmFibGUgPSAhMCwgXCJ2YWx1ZVwiIGluIHIgJiYgKHIud3JpdGFibGUgPSAhMCksIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCBmdyhyLmtleSksIHIpO1xuICB9XG59XG5mdW5jdGlvbiBwVihlLCB0LCBuKSB7XG4gIHJldHVybiB0ICYmIFB2KGUucHJvdG90eXBlLCB0KSwgbiAmJiBQdihlLCBuKSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIFwicHJvdG90eXBlXCIsIHsgd3JpdGFibGU6ICExIH0pLCBlO1xufVxuZnVuY3Rpb24gaFYoZSwgdCwgbikge1xuICByZXR1cm4gdCA9ICRzKHQpLCBnVihlLCBsdygpID8gUmVmbGVjdC5jb25zdHJ1Y3QodCwgbiB8fCBbXSwgJHMoZSkuY29uc3RydWN0b3IpIDogdC5hcHBseShlLCBuKSk7XG59XG5mdW5jdGlvbiBnVihlLCB0KSB7XG4gIGlmICh0ICYmIChZcih0KSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgdCA9PSBcImZ1bmN0aW9uXCIpKVxuICAgIHJldHVybiB0O1xuICBpZiAodCAhPT0gdm9pZCAwKVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJEZXJpdmVkIGNvbnN0cnVjdG9ycyBtYXkgb25seSByZXR1cm4gb2JqZWN0IG9yIHVuZGVmaW5lZFwiKTtcbiAgcmV0dXJuIGVuKGUpO1xufVxuZnVuY3Rpb24gbHcoKSB7XG4gIHRyeSB7XG4gICAgdmFyIGUgPSAhQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbigpIHtcbiAgICB9KSk7XG4gIH0gY2F0Y2gge1xuICB9XG4gIHJldHVybiAobHcgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gISFlO1xuICB9KSgpO1xufVxuZnVuY3Rpb24gJHMoZSkge1xuICByZXR1cm4gJHMgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YuYmluZCgpIDogZnVuY3Rpb24obikge1xuICAgIHJldHVybiBuLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobik7XG4gIH0sICRzKGUpO1xufVxuZnVuY3Rpb24gZW4oZSkge1xuICBpZiAoZSA9PT0gdm9pZCAwKVxuICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTtcbiAgcmV0dXJuIGU7XG59XG5mdW5jdGlvbiB2VihlLCB0KSB7XG4gIGlmICh0eXBlb2YgdCAhPSBcImZ1bmN0aW9uXCIgJiYgdCAhPT0gbnVsbClcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7XG4gIGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSh0ICYmIHQucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBlLCB3cml0YWJsZTogITAsIGNvbmZpZ3VyYWJsZTogITAgfSB9KSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIFwicHJvdG90eXBlXCIsIHsgd3JpdGFibGU6ICExIH0pLCB0ICYmIFJsKGUsIHQpO1xufVxuZnVuY3Rpb24gUmwoZSwgdCkge1xuICByZXR1cm4gUmwgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2YuYmluZCgpIDogZnVuY3Rpb24ociwgaSkge1xuICAgIHJldHVybiByLl9fcHJvdG9fXyA9IGksIHI7XG4gIH0sIFJsKGUsIHQpO1xufVxuZnVuY3Rpb24gYnQoZSwgdCwgbikge1xuICByZXR1cm4gdCA9IGZ3KHQpLCB0IGluIGUgPyBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgdCwgeyB2YWx1ZTogbiwgZW51bWVyYWJsZTogITAsIGNvbmZpZ3VyYWJsZTogITAsIHdyaXRhYmxlOiAhMCB9KSA6IGVbdF0gPSBuLCBlO1xufVxuZnVuY3Rpb24gZncoZSkge1xuICB2YXIgdCA9IG1WKGUsIFwic3RyaW5nXCIpO1xuICByZXR1cm4gWXIodCkgPT0gXCJzeW1ib2xcIiA/IHQgOiBTdHJpbmcodCk7XG59XG5mdW5jdGlvbiBtVihlLCB0KSB7XG4gIGlmIChZcihlKSAhPSBcIm9iamVjdFwiIHx8ICFlKVxuICAgIHJldHVybiBlO1xuICB2YXIgbiA9IGVbU3ltYm9sLnRvUHJpbWl0aXZlXTtcbiAgaWYgKG4gIT09IHZvaWQgMCkge1xuICAgIHZhciByID0gbi5jYWxsKGUsIHQgfHwgXCJkZWZhdWx0XCIpO1xuICAgIGlmIChZcihyKSAhPSBcIm9iamVjdFwiKVxuICAgICAgcmV0dXJuIHI7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkBAdG9QcmltaXRpdmUgbXVzdCByZXR1cm4gYSBwcmltaXRpdmUgdmFsdWUuXCIpO1xuICB9XG4gIHJldHVybiAodCA9PT0gXCJzdHJpbmdcIiA/IFN0cmluZyA6IE51bWJlcikoZSk7XG59XG52YXIgeVYgPSBmdW5jdGlvbih0KSB7XG4gIHZhciBuID0gdC5kYXRhLCByID0gdC5zdGFydEluZGV4LCBpID0gdC5lbmRJbmRleCwgbyA9IHQueCwgYSA9IHQud2lkdGgsIHMgPSB0LnRyYXZlbGxlcldpZHRoO1xuICBpZiAoIW4gfHwgIW4ubGVuZ3RoKVxuICAgIHJldHVybiB7fTtcbiAgdmFyIHUgPSBuLmxlbmd0aCwgYyA9IFdpKCkuZG9tYWluKHhzKDAsIHUpKS5yYW5nZShbbywgbyArIGEgLSBzXSksIGYgPSBjLmRvbWFpbigpLm1hcChmdW5jdGlvbihsKSB7XG4gICAgcmV0dXJuIGMobCk7XG4gIH0pO1xuICByZXR1cm4ge1xuICAgIGlzVGV4dEFjdGl2ZTogITEsXG4gICAgaXNTbGlkZU1vdmluZzogITEsXG4gICAgaXNUcmF2ZWxsZXJNb3Zpbmc6ICExLFxuICAgIGlzVHJhdmVsbGVyRm9jdXNlZDogITEsXG4gICAgc3RhcnRYOiBjKHIpLFxuICAgIGVuZFg6IGMoaSksXG4gICAgc2NhbGU6IGMsXG4gICAgc2NhbGVWYWx1ZXM6IGZcbiAgfTtcbn0sIEN2ID0gZnVuY3Rpb24odCkge1xuICByZXR1cm4gdC5jaGFuZ2VkVG91Y2hlcyAmJiAhIXQuY2hhbmdlZFRvdWNoZXMubGVuZ3RoO1xufSwgWHIgPSAvKiBAX19QVVJFX18gKi8gZnVuY3Rpb24oZSkge1xuICB2Vih0LCBlKTtcbiAgZnVuY3Rpb24gdChuKSB7XG4gICAgdmFyIHI7XG4gICAgcmV0dXJuIGRWKHRoaXMsIHQpLCByID0gaFYodGhpcywgdCwgW25dKSwgYnQoZW4ociksIFwiaGFuZGxlRHJhZ1wiLCBmdW5jdGlvbihpKSB7XG4gICAgICByLmxlYXZlVGltZXIgJiYgKGNsZWFyVGltZW91dChyLmxlYXZlVGltZXIpLCByLmxlYXZlVGltZXIgPSBudWxsKSwgci5zdGF0ZS5pc1RyYXZlbGxlck1vdmluZyA/IHIuaGFuZGxlVHJhdmVsbGVyTW92ZShpKSA6IHIuc3RhdGUuaXNTbGlkZU1vdmluZyAmJiByLmhhbmRsZVNsaWRlRHJhZyhpKTtcbiAgICB9KSwgYnQoZW4ociksIFwiaGFuZGxlVG91Y2hNb3ZlXCIsIGZ1bmN0aW9uKGkpIHtcbiAgICAgIGkuY2hhbmdlZFRvdWNoZXMgIT0gbnVsbCAmJiBpLmNoYW5nZWRUb3VjaGVzLmxlbmd0aCA+IDAgJiYgci5oYW5kbGVEcmFnKGkuY2hhbmdlZFRvdWNoZXNbMF0pO1xuICAgIH0pLCBidChlbihyKSwgXCJoYW5kbGVEcmFnRW5kXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgci5zZXRTdGF0ZSh7XG4gICAgICAgIGlzVHJhdmVsbGVyTW92aW5nOiAhMSxcbiAgICAgICAgaXNTbGlkZU1vdmluZzogITFcbiAgICAgIH0sIGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgaSA9IHIucHJvcHMsIG8gPSBpLmVuZEluZGV4LCBhID0gaS5vbkRyYWdFbmQsIHMgPSBpLnN0YXJ0SW5kZXg7XG4gICAgICAgIGEgPT0gbnVsbCB8fCBhKHtcbiAgICAgICAgICBlbmRJbmRleDogbyxcbiAgICAgICAgICBzdGFydEluZGV4OiBzXG4gICAgICAgIH0pO1xuICAgICAgfSksIHIuZGV0YWNoRHJhZ0VuZExpc3RlbmVyKCk7XG4gICAgfSksIGJ0KGVuKHIpLCBcImhhbmRsZUxlYXZlV3JhcHBlclwiLCBmdW5jdGlvbigpIHtcbiAgICAgIChyLnN0YXRlLmlzVHJhdmVsbGVyTW92aW5nIHx8IHIuc3RhdGUuaXNTbGlkZU1vdmluZykgJiYgKHIubGVhdmVUaW1lciA9IHdpbmRvdy5zZXRUaW1lb3V0KHIuaGFuZGxlRHJhZ0VuZCwgci5wcm9wcy5sZWF2ZVRpbWVPdXQpKTtcbiAgICB9KSwgYnQoZW4ociksIFwiaGFuZGxlRW50ZXJTbGlkZU9yVHJhdmVsbGVyXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgci5zZXRTdGF0ZSh7XG4gICAgICAgIGlzVGV4dEFjdGl2ZTogITBcbiAgICAgIH0pO1xuICAgIH0pLCBidChlbihyKSwgXCJoYW5kbGVMZWF2ZVNsaWRlT3JUcmF2ZWxsZXJcIiwgZnVuY3Rpb24oKSB7XG4gICAgICByLnNldFN0YXRlKHtcbiAgICAgICAgaXNUZXh0QWN0aXZlOiAhMVxuICAgICAgfSk7XG4gICAgfSksIGJ0KGVuKHIpLCBcImhhbmRsZVNsaWRlRHJhZ1N0YXJ0XCIsIGZ1bmN0aW9uKGkpIHtcbiAgICAgIHZhciBvID0gQ3YoaSkgPyBpLmNoYW5nZWRUb3VjaGVzWzBdIDogaTtcbiAgICAgIHIuc2V0U3RhdGUoe1xuICAgICAgICBpc1RyYXZlbGxlck1vdmluZzogITEsXG4gICAgICAgIGlzU2xpZGVNb3Zpbmc6ICEwLFxuICAgICAgICBzbGlkZU1vdmVTdGFydFg6IG8ucGFnZVhcbiAgICAgIH0pLCByLmF0dGFjaERyYWdFbmRMaXN0ZW5lcigpO1xuICAgIH0pLCByLnRyYXZlbGxlckRyYWdTdGFydEhhbmRsZXJzID0ge1xuICAgICAgc3RhcnRYOiByLmhhbmRsZVRyYXZlbGxlckRyYWdTdGFydC5iaW5kKGVuKHIpLCBcInN0YXJ0WFwiKSxcbiAgICAgIGVuZFg6IHIuaGFuZGxlVHJhdmVsbGVyRHJhZ1N0YXJ0LmJpbmQoZW4ociksIFwiZW5kWFwiKVxuICAgIH0sIHIuc3RhdGUgPSB7fSwgcjtcbiAgfVxuICByZXR1cm4gcFYodCwgW3tcbiAgICBrZXk6IFwiY29tcG9uZW50V2lsbFVubW91bnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLmxlYXZlVGltZXIgJiYgKGNsZWFyVGltZW91dCh0aGlzLmxlYXZlVGltZXIpLCB0aGlzLmxlYXZlVGltZXIgPSBudWxsKSwgdGhpcy5kZXRhY2hEcmFnRW5kTGlzdGVuZXIoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0SW5kZXhcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24ocikge1xuICAgICAgdmFyIGkgPSByLnN0YXJ0WCwgbyA9IHIuZW5kWCwgYSA9IHRoaXMuc3RhdGUuc2NhbGVWYWx1ZXMsIHMgPSB0aGlzLnByb3BzLCB1ID0gcy5nYXAsIGMgPSBzLmRhdGEsIGYgPSBjLmxlbmd0aCAtIDEsIGwgPSBNYXRoLm1pbihpLCBvKSwgZCA9IE1hdGgubWF4KGksIG8pLCBwID0gdC5nZXRJbmRleEluUmFuZ2UoYSwgbCksIGcgPSB0LmdldEluZGV4SW5SYW5nZShhLCBkKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHN0YXJ0SW5kZXg6IHAgLSBwICUgdSxcbiAgICAgICAgZW5kSW5kZXg6IGcgPT09IGYgPyBmIDogZyAtIGcgJSB1XG4gICAgICB9O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRUZXh0T2ZUaWNrXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uKHIpIHtcbiAgICAgIHZhciBpID0gdGhpcy5wcm9wcywgbyA9IGkuZGF0YSwgYSA9IGkudGlja0Zvcm1hdHRlciwgcyA9IGkuZGF0YUtleSwgdSA9IEF0KG9bcl0sIHMsIHIpO1xuICAgICAgcmV0dXJuIHBlKGEpID8gYSh1LCByKSA6IHU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImF0dGFjaERyYWdFbmRMaXN0ZW5lclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwibW91c2V1cFwiLCB0aGlzLmhhbmRsZURyYWdFbmQsICEwKSwgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJ0b3VjaGVuZFwiLCB0aGlzLmhhbmRsZURyYWdFbmQsICEwKSwgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZW1vdmVcIiwgdGhpcy5oYW5kbGVEcmFnLCAhMCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRldGFjaERyYWdFbmRMaXN0ZW5lclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2V1cFwiLCB0aGlzLmhhbmRsZURyYWdFbmQsICEwKSwgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ0b3VjaGVuZFwiLCB0aGlzLmhhbmRsZURyYWdFbmQsICEwKSwgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZW1vdmVcIiwgdGhpcy5oYW5kbGVEcmFnLCAhMCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImhhbmRsZVNsaWRlRHJhZ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbihyKSB7XG4gICAgICB2YXIgaSA9IHRoaXMuc3RhdGUsIG8gPSBpLnNsaWRlTW92ZVN0YXJ0WCwgYSA9IGkuc3RhcnRYLCBzID0gaS5lbmRYLCB1ID0gdGhpcy5wcm9wcywgYyA9IHUueCwgZiA9IHUud2lkdGgsIGwgPSB1LnRyYXZlbGxlcldpZHRoLCBkID0gdS5zdGFydEluZGV4LCBwID0gdS5lbmRJbmRleCwgZyA9IHUub25DaGFuZ2UsIGggPSByLnBhZ2VYIC0gbztcbiAgICAgIGggPiAwID8gaCA9IE1hdGgubWluKGgsIGMgKyBmIC0gbCAtIHMsIGMgKyBmIC0gbCAtIGEpIDogaCA8IDAgJiYgKGggPSBNYXRoLm1heChoLCBjIC0gYSwgYyAtIHMpKTtcbiAgICAgIHZhciB2ID0gdGhpcy5nZXRJbmRleCh7XG4gICAgICAgIHN0YXJ0WDogYSArIGgsXG4gICAgICAgIGVuZFg6IHMgKyBoXG4gICAgICB9KTtcbiAgICAgICh2LnN0YXJ0SW5kZXggIT09IGQgfHwgdi5lbmRJbmRleCAhPT0gcCkgJiYgZyAmJiBnKHYpLCB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgc3RhcnRYOiBhICsgaCxcbiAgICAgICAgZW5kWDogcyArIGgsXG4gICAgICAgIHNsaWRlTW92ZVN0YXJ0WDogci5wYWdlWFxuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImhhbmRsZVRyYXZlbGxlckRyYWdTdGFydFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbihyLCBpKSB7XG4gICAgICB2YXIgbyA9IEN2KGkpID8gaS5jaGFuZ2VkVG91Y2hlc1swXSA6IGk7XG4gICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgaXNTbGlkZU1vdmluZzogITEsXG4gICAgICAgIGlzVHJhdmVsbGVyTW92aW5nOiAhMCxcbiAgICAgICAgbW92aW5nVHJhdmVsbGVySWQ6IHIsXG4gICAgICAgIGJydXNoTW92ZVN0YXJ0WDogby5wYWdlWFxuICAgICAgfSksIHRoaXMuYXR0YWNoRHJhZ0VuZExpc3RlbmVyKCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImhhbmRsZVRyYXZlbGxlck1vdmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24ocikge1xuICAgICAgdmFyIGkgPSB0aGlzLnN0YXRlLCBvID0gaS5icnVzaE1vdmVTdGFydFgsIGEgPSBpLm1vdmluZ1RyYXZlbGxlcklkLCBzID0gaS5lbmRYLCB1ID0gaS5zdGFydFgsIGMgPSB0aGlzLnN0YXRlW2FdLCBmID0gdGhpcy5wcm9wcywgbCA9IGYueCwgZCA9IGYud2lkdGgsIHAgPSBmLnRyYXZlbGxlcldpZHRoLCBnID0gZi5vbkNoYW5nZSwgaCA9IGYuZ2FwLCB2ID0gZi5kYXRhLCB3ID0ge1xuICAgICAgICBzdGFydFg6IHRoaXMuc3RhdGUuc3RhcnRYLFxuICAgICAgICBlbmRYOiB0aGlzLnN0YXRlLmVuZFhcbiAgICAgIH0sIGIgPSByLnBhZ2VYIC0gbztcbiAgICAgIGIgPiAwID8gYiA9IE1hdGgubWluKGIsIGwgKyBkIC0gcCAtIGMpIDogYiA8IDAgJiYgKGIgPSBNYXRoLm1heChiLCBsIC0gYykpLCB3W2FdID0gYyArIGI7XG4gICAgICB2YXIgeCA9IHRoaXMuZ2V0SW5kZXgodyksIG0gPSB4LnN0YXJ0SW5kZXgsIHkgPSB4LmVuZEluZGV4LCBTID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBPID0gdi5sZW5ndGggLSAxO1xuICAgICAgICByZXR1cm4gYSA9PT0gXCJzdGFydFhcIiAmJiAocyA+IHUgPyBtICUgaCA9PT0gMCA6IHkgJSBoID09PSAwKSB8fCBzIDwgdSAmJiB5ID09PSBPIHx8IGEgPT09IFwiZW5kWFwiICYmIChzID4gdSA/IHkgJSBoID09PSAwIDogbSAlIGggPT09IDApIHx8IHMgPiB1ICYmIHkgPT09IE87XG4gICAgICB9O1xuICAgICAgdGhpcy5zZXRTdGF0ZShidChidCh7fSwgYSwgYyArIGIpLCBcImJydXNoTW92ZVN0YXJ0WFwiLCByLnBhZ2VYKSwgZnVuY3Rpb24oKSB7XG4gICAgICAgIGcgJiYgUygpICYmIGcoeCk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaGFuZGxlVHJhdmVsbGVyTW92ZUtleWJvYXJkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uKHIsIGkpIHtcbiAgICAgIHZhciBvID0gdGhpcywgYSA9IHRoaXMuc3RhdGUsIHMgPSBhLnNjYWxlVmFsdWVzLCB1ID0gYS5zdGFydFgsIGMgPSBhLmVuZFgsIGYgPSB0aGlzLnN0YXRlW2ldLCBsID0gcy5pbmRleE9mKGYpO1xuICAgICAgaWYgKGwgIT09IC0xKSB7XG4gICAgICAgIHZhciBkID0gbCArIHI7XG4gICAgICAgIGlmICghKGQgPT09IC0xIHx8IGQgPj0gcy5sZW5ndGgpKSB7XG4gICAgICAgICAgdmFyIHAgPSBzW2RdO1xuICAgICAgICAgIGkgPT09IFwic3RhcnRYXCIgJiYgcCA+PSBjIHx8IGkgPT09IFwiZW5kWFwiICYmIHAgPD0gdSB8fCB0aGlzLnNldFN0YXRlKGJ0KHt9LCBpLCBwKSwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBvLnByb3BzLm9uQ2hhbmdlKG8uZ2V0SW5kZXgoe1xuICAgICAgICAgICAgICBzdGFydFg6IG8uc3RhdGUuc3RhcnRYLFxuICAgICAgICAgICAgICBlbmRYOiBvLnN0YXRlLmVuZFhcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyZW5kZXJCYWNrZ3JvdW5kXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHIgPSB0aGlzLnByb3BzLCBpID0gci54LCBvID0gci55LCBhID0gci53aWR0aCwgcyA9IHIuaGVpZ2h0LCB1ID0gci5maWxsLCBjID0gci5zdHJva2U7XG4gICAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIFAuY3JlYXRlRWxlbWVudChcInJlY3RcIiwge1xuICAgICAgICBzdHJva2U6IGMsXG4gICAgICAgIGZpbGw6IHUsXG4gICAgICAgIHg6IGksXG4gICAgICAgIHk6IG8sXG4gICAgICAgIHdpZHRoOiBhLFxuICAgICAgICBoZWlnaHQ6IHNcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyZW5kZXJQYW5vcmFtYVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciByID0gdGhpcy5wcm9wcywgaSA9IHIueCwgbyA9IHIueSwgYSA9IHIud2lkdGgsIHMgPSByLmhlaWdodCwgdSA9IHIuZGF0YSwgYyA9IHIuY2hpbGRyZW4sIGYgPSByLnBhZGRpbmcsIGwgPSAkdC5vbmx5KGMpO1xuICAgICAgcmV0dXJuIGwgPyAvKiBAX19QVVJFX18gKi8gUC5jbG9uZUVsZW1lbnQobCwge1xuICAgICAgICB4OiBpLFxuICAgICAgICB5OiBvLFxuICAgICAgICB3aWR0aDogYSxcbiAgICAgICAgaGVpZ2h0OiBzLFxuICAgICAgICBtYXJnaW46IGYsXG4gICAgICAgIGNvbXBhY3Q6ICEwLFxuICAgICAgICBkYXRhOiB1XG4gICAgICB9KSA6IG51bGw7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJlbmRlclRyYXZlbGxlckxheWVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uKHIsIGkpIHtcbiAgICAgIHZhciBvLCBhLCBzID0gdGhpcywgdSA9IHRoaXMucHJvcHMsIGMgPSB1LnksIGYgPSB1LnRyYXZlbGxlcldpZHRoLCBsID0gdS5oZWlnaHQsIGQgPSB1LnRyYXZlbGxlciwgcCA9IHUuYXJpYUxhYmVsLCBnID0gdS5kYXRhLCBoID0gdS5zdGFydEluZGV4LCB2ID0gdS5lbmRJbmRleCwgdyA9IE1hdGgubWF4KHIsIHRoaXMucHJvcHMueCksIGIgPSBuYyhuYyh7fSwgeWUodGhpcy5wcm9wcywgITEpKSwge30sIHtcbiAgICAgICAgeDogdyxcbiAgICAgICAgeTogYyxcbiAgICAgICAgd2lkdGg6IGYsXG4gICAgICAgIGhlaWdodDogbFxuICAgICAgfSksIHggPSBwIHx8IFwiTWluIHZhbHVlOiBcIi5jb25jYXQoKG8gPSBnW2hdKSA9PT0gbnVsbCB8fCBvID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvLm5hbWUsIFwiLCBNYXggdmFsdWU6IFwiKS5jb25jYXQoKGEgPSBnW3ZdKSA9PT0gbnVsbCB8fCBhID09PSB2b2lkIDAgPyB2b2lkIDAgOiBhLm5hbWUpO1xuICAgICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBQLmNyZWF0ZUVsZW1lbnQoV2UsIHtcbiAgICAgICAgdGFiSW5kZXg6IDAsXG4gICAgICAgIHJvbGU6IFwic2xpZGVyXCIsXG4gICAgICAgIFwiYXJpYS1sYWJlbFwiOiB4LFxuICAgICAgICBcImFyaWEtdmFsdWVub3dcIjogcixcbiAgICAgICAgY2xhc3NOYW1lOiBcInJlY2hhcnRzLWJydXNoLXRyYXZlbGxlclwiLFxuICAgICAgICBvbk1vdXNlRW50ZXI6IHRoaXMuaGFuZGxlRW50ZXJTbGlkZU9yVHJhdmVsbGVyLFxuICAgICAgICBvbk1vdXNlTGVhdmU6IHRoaXMuaGFuZGxlTGVhdmVTbGlkZU9yVHJhdmVsbGVyLFxuICAgICAgICBvbk1vdXNlRG93bjogdGhpcy50cmF2ZWxsZXJEcmFnU3RhcnRIYW5kbGVyc1tpXSxcbiAgICAgICAgb25Ub3VjaFN0YXJ0OiB0aGlzLnRyYXZlbGxlckRyYWdTdGFydEhhbmRsZXJzW2ldLFxuICAgICAgICBvbktleURvd246IGZ1bmN0aW9uKHkpIHtcbiAgICAgICAgICBbXCJBcnJvd0xlZnRcIiwgXCJBcnJvd1JpZ2h0XCJdLmluY2x1ZGVzKHkua2V5KSAmJiAoeS5wcmV2ZW50RGVmYXVsdCgpLCB5LnN0b3BQcm9wYWdhdGlvbigpLCBzLmhhbmRsZVRyYXZlbGxlck1vdmVLZXlib2FyZCh5LmtleSA9PT0gXCJBcnJvd1JpZ2h0XCIgPyAxIDogLTEsIGkpKTtcbiAgICAgICAgfSxcbiAgICAgICAgb25Gb2N1czogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICBpc1RyYXZlbGxlckZvY3VzZWQ6ICEwXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIG9uQmx1cjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICBpc1RyYXZlbGxlckZvY3VzZWQ6ICExXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgY3Vyc29yOiBcImNvbC1yZXNpemVcIlxuICAgICAgICB9XG4gICAgICB9LCB0LnJlbmRlclRyYXZlbGxlcihkLCBiKSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJlbmRlclNsaWRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uKHIsIGkpIHtcbiAgICAgIHZhciBvID0gdGhpcy5wcm9wcywgYSA9IG8ueSwgcyA9IG8uaGVpZ2h0LCB1ID0gby5zdHJva2UsIGMgPSBvLnRyYXZlbGxlcldpZHRoLCBmID0gTWF0aC5taW4ociwgaSkgKyBjLCBsID0gTWF0aC5tYXgoTWF0aC5hYnMoaSAtIHIpIC0gYywgMCk7XG4gICAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIFAuY3JlYXRlRWxlbWVudChcInJlY3RcIiwge1xuICAgICAgICBjbGFzc05hbWU6IFwicmVjaGFydHMtYnJ1c2gtc2xpZGVcIixcbiAgICAgICAgb25Nb3VzZUVudGVyOiB0aGlzLmhhbmRsZUVudGVyU2xpZGVPclRyYXZlbGxlcixcbiAgICAgICAgb25Nb3VzZUxlYXZlOiB0aGlzLmhhbmRsZUxlYXZlU2xpZGVPclRyYXZlbGxlcixcbiAgICAgICAgb25Nb3VzZURvd246IHRoaXMuaGFuZGxlU2xpZGVEcmFnU3RhcnQsXG4gICAgICAgIG9uVG91Y2hTdGFydDogdGhpcy5oYW5kbGVTbGlkZURyYWdTdGFydCxcbiAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICBjdXJzb3I6IFwibW92ZVwiXG4gICAgICAgIH0sXG4gICAgICAgIHN0cm9rZTogXCJub25lXCIsXG4gICAgICAgIGZpbGw6IHUsXG4gICAgICAgIGZpbGxPcGFjaXR5OiAwLjIsXG4gICAgICAgIHg6IGYsXG4gICAgICAgIHk6IGEsXG4gICAgICAgIHdpZHRoOiBsLFxuICAgICAgICBoZWlnaHQ6IHNcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyZW5kZXJUZXh0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHIgPSB0aGlzLnByb3BzLCBpID0gci5zdGFydEluZGV4LCBvID0gci5lbmRJbmRleCwgYSA9IHIueSwgcyA9IHIuaGVpZ2h0LCB1ID0gci50cmF2ZWxsZXJXaWR0aCwgYyA9IHIuc3Ryb2tlLCBmID0gdGhpcy5zdGF0ZSwgbCA9IGYuc3RhcnRYLCBkID0gZi5lbmRYLCBwID0gNSwgZyA9IHtcbiAgICAgICAgcG9pbnRlckV2ZW50czogXCJub25lXCIsXG4gICAgICAgIGZpbGw6IGNcbiAgICAgIH07XG4gICAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIFAuY3JlYXRlRWxlbWVudChXZSwge1xuICAgICAgICBjbGFzc05hbWU6IFwicmVjaGFydHMtYnJ1c2gtdGV4dHNcIlxuICAgICAgfSwgLyogQF9fUFVSRV9fICovIFAuY3JlYXRlRWxlbWVudChKYSwgU3Moe1xuICAgICAgICB0ZXh0QW5jaG9yOiBcImVuZFwiLFxuICAgICAgICB2ZXJ0aWNhbEFuY2hvcjogXCJtaWRkbGVcIixcbiAgICAgICAgeDogTWF0aC5taW4obCwgZCkgLSBwLFxuICAgICAgICB5OiBhICsgcyAvIDJcbiAgICAgIH0sIGcpLCB0aGlzLmdldFRleHRPZlRpY2soaSkpLCAvKiBAX19QVVJFX18gKi8gUC5jcmVhdGVFbGVtZW50KEphLCBTcyh7XG4gICAgICAgIHRleHRBbmNob3I6IFwic3RhcnRcIixcbiAgICAgICAgdmVydGljYWxBbmNob3I6IFwibWlkZGxlXCIsXG4gICAgICAgIHg6IE1hdGgubWF4KGwsIGQpICsgdSArIHAsXG4gICAgICAgIHk6IGEgKyBzIC8gMlxuICAgICAgfSwgZyksIHRoaXMuZ2V0VGV4dE9mVGljayhvKSkpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyZW5kZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgciA9IHRoaXMucHJvcHMsIGkgPSByLmRhdGEsIG8gPSByLmNsYXNzTmFtZSwgYSA9IHIuY2hpbGRyZW4sIHMgPSByLngsIHUgPSByLnksIGMgPSByLndpZHRoLCBmID0gci5oZWlnaHQsIGwgPSByLmFsd2F5c1Nob3dUZXh0LCBkID0gdGhpcy5zdGF0ZSwgcCA9IGQuc3RhcnRYLCBnID0gZC5lbmRYLCBoID0gZC5pc1RleHRBY3RpdmUsIHYgPSBkLmlzU2xpZGVNb3ZpbmcsIHcgPSBkLmlzVHJhdmVsbGVyTW92aW5nLCBiID0gZC5pc1RyYXZlbGxlckZvY3VzZWQ7XG4gICAgICBpZiAoIWkgfHwgIWkubGVuZ3RoIHx8ICFLKHMpIHx8ICFLKHUpIHx8ICFLKGMpIHx8ICFLKGYpIHx8IGMgPD0gMCB8fCBmIDw9IDApXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgdmFyIHggPSAkZShcInJlY2hhcnRzLWJydXNoXCIsIG8pLCBtID0gUC5DaGlsZHJlbi5jb3VudChhKSA9PT0gMSwgeSA9IGZWKFwidXNlclNlbGVjdFwiLCBcIm5vbmVcIik7XG4gICAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIFAuY3JlYXRlRWxlbWVudChXZSwge1xuICAgICAgICBjbGFzc05hbWU6IHgsXG4gICAgICAgIG9uTW91c2VMZWF2ZTogdGhpcy5oYW5kbGVMZWF2ZVdyYXBwZXIsXG4gICAgICAgIG9uVG91Y2hNb3ZlOiB0aGlzLmhhbmRsZVRvdWNoTW92ZSxcbiAgICAgICAgc3R5bGU6IHlcbiAgICAgIH0sIHRoaXMucmVuZGVyQmFja2dyb3VuZCgpLCBtICYmIHRoaXMucmVuZGVyUGFub3JhbWEoKSwgdGhpcy5yZW5kZXJTbGlkZShwLCBnKSwgdGhpcy5yZW5kZXJUcmF2ZWxsZXJMYXllcihwLCBcInN0YXJ0WFwiKSwgdGhpcy5yZW5kZXJUcmF2ZWxsZXJMYXllcihnLCBcImVuZFhcIiksIChoIHx8IHYgfHwgdyB8fCBiIHx8IGwpICYmIHRoaXMucmVuZGVyVGV4dCgpKTtcbiAgICB9XG4gIH1dLCBbe1xuICAgIGtleTogXCJyZW5kZXJEZWZhdWx0VHJhdmVsbGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uKHIpIHtcbiAgICAgIHZhciBpID0gci54LCBvID0gci55LCBhID0gci53aWR0aCwgcyA9IHIuaGVpZ2h0LCB1ID0gci5zdHJva2UsIGMgPSBNYXRoLmZsb29yKG8gKyBzIC8gMikgLSAxO1xuICAgICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBQLmNyZWF0ZUVsZW1lbnQoUC5GcmFnbWVudCwgbnVsbCwgLyogQF9fUFVSRV9fICovIFAuY3JlYXRlRWxlbWVudChcInJlY3RcIiwge1xuICAgICAgICB4OiBpLFxuICAgICAgICB5OiBvLFxuICAgICAgICB3aWR0aDogYSxcbiAgICAgICAgaGVpZ2h0OiBzLFxuICAgICAgICBmaWxsOiB1LFxuICAgICAgICBzdHJva2U6IFwibm9uZVwiXG4gICAgICB9KSwgLyogQF9fUFVSRV9fICovIFAuY3JlYXRlRWxlbWVudChcImxpbmVcIiwge1xuICAgICAgICB4MTogaSArIDEsXG4gICAgICAgIHkxOiBjLFxuICAgICAgICB4MjogaSArIGEgLSAxLFxuICAgICAgICB5MjogYyxcbiAgICAgICAgZmlsbDogXCJub25lXCIsXG4gICAgICAgIHN0cm9rZTogXCIjZmZmXCJcbiAgICAgIH0pLCAvKiBAX19QVVJFX18gKi8gUC5jcmVhdGVFbGVtZW50KFwibGluZVwiLCB7XG4gICAgICAgIHgxOiBpICsgMSxcbiAgICAgICAgeTE6IGMgKyAyLFxuICAgICAgICB4MjogaSArIGEgLSAxLFxuICAgICAgICB5MjogYyArIDIsXG4gICAgICAgIGZpbGw6IFwibm9uZVwiLFxuICAgICAgICBzdHJva2U6IFwiI2ZmZlwiXG4gICAgICB9KSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJlbmRlclRyYXZlbGxlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbihyLCBpKSB7XG4gICAgICB2YXIgbztcbiAgICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8gUC5pc1ZhbGlkRWxlbWVudChyKSA/IG8gPSAvKiBAX19QVVJFX18gKi8gUC5jbG9uZUVsZW1lbnQociwgaSkgOiBwZShyKSA/IG8gPSByKGkpIDogbyA9IHQucmVuZGVyRGVmYXVsdFRyYXZlbGxlcihpKSwgbztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uKHIsIGkpIHtcbiAgICAgIHZhciBvID0gci5kYXRhLCBhID0gci53aWR0aCwgcyA9IHIueCwgdSA9IHIudHJhdmVsbGVyV2lkdGgsIGMgPSByLnVwZGF0ZUlkLCBmID0gci5zdGFydEluZGV4LCBsID0gci5lbmRJbmRleDtcbiAgICAgIGlmIChvICE9PSBpLnByZXZEYXRhIHx8IGMgIT09IGkucHJldlVwZGF0ZUlkKVxuICAgICAgICByZXR1cm4gbmMoe1xuICAgICAgICAgIHByZXZEYXRhOiBvLFxuICAgICAgICAgIHByZXZUcmF2ZWxsZXJXaWR0aDogdSxcbiAgICAgICAgICBwcmV2VXBkYXRlSWQ6IGMsXG4gICAgICAgICAgcHJldlg6IHMsXG4gICAgICAgICAgcHJldldpZHRoOiBhXG4gICAgICAgIH0sIG8gJiYgby5sZW5ndGggPyB5Vih7XG4gICAgICAgICAgZGF0YTogbyxcbiAgICAgICAgICB3aWR0aDogYSxcbiAgICAgICAgICB4OiBzLFxuICAgICAgICAgIHRyYXZlbGxlcldpZHRoOiB1LFxuICAgICAgICAgIHN0YXJ0SW5kZXg6IGYsXG4gICAgICAgICAgZW5kSW5kZXg6IGxcbiAgICAgICAgfSkgOiB7XG4gICAgICAgICAgc2NhbGU6IG51bGwsXG4gICAgICAgICAgc2NhbGVWYWx1ZXM6IG51bGxcbiAgICAgICAgfSk7XG4gICAgICBpZiAoaS5zY2FsZSAmJiAoYSAhPT0gaS5wcmV2V2lkdGggfHwgcyAhPT0gaS5wcmV2WCB8fCB1ICE9PSBpLnByZXZUcmF2ZWxsZXJXaWR0aCkpIHtcbiAgICAgICAgaS5zY2FsZS5yYW5nZShbcywgcyArIGEgLSB1XSk7XG4gICAgICAgIHZhciBkID0gaS5zY2FsZS5kb21haW4oKS5tYXAoZnVuY3Rpb24ocCkge1xuICAgICAgICAgIHJldHVybiBpLnNjYWxlKHApO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBwcmV2RGF0YTogbyxcbiAgICAgICAgICBwcmV2VHJhdmVsbGVyV2lkdGg6IHUsXG4gICAgICAgICAgcHJldlVwZGF0ZUlkOiBjLFxuICAgICAgICAgIHByZXZYOiBzLFxuICAgICAgICAgIHByZXZXaWR0aDogYSxcbiAgICAgICAgICBzdGFydFg6IGkuc2NhbGUoci5zdGFydEluZGV4KSxcbiAgICAgICAgICBlbmRYOiBpLnNjYWxlKHIuZW5kSW5kZXgpLFxuICAgICAgICAgIHNjYWxlVmFsdWVzOiBkXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0SW5kZXhJblJhbmdlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uKHIsIGkpIHtcbiAgICAgIGZvciAodmFyIG8gPSByLmxlbmd0aCwgYSA9IDAsIHMgPSBvIC0gMTsgcyAtIGEgPiAxOyApIHtcbiAgICAgICAgdmFyIHUgPSBNYXRoLmZsb29yKChhICsgcykgLyAyKTtcbiAgICAgICAgclt1XSA+IGkgPyBzID0gdSA6IGEgPSB1O1xuICAgICAgfVxuICAgICAgcmV0dXJuIGkgPj0gcltzXSA/IHMgOiBhO1xuICAgIH1cbiAgfV0pLCB0O1xufShXbik7XG5idChYciwgXCJkaXNwbGF5TmFtZVwiLCBcIkJydXNoXCIpO1xuYnQoWHIsIFwiZGVmYXVsdFByb3BzXCIsIHtcbiAgaGVpZ2h0OiA0MCxcbiAgdHJhdmVsbGVyV2lkdGg6IDUsXG4gIGdhcDogMSxcbiAgZmlsbDogXCIjZmZmXCIsXG4gIHN0cm9rZTogXCIjNjY2XCIsXG4gIHBhZGRpbmc6IHtcbiAgICB0b3A6IDEsXG4gICAgcmlnaHQ6IDEsXG4gICAgYm90dG9tOiAxLFxuICAgIGxlZnQ6IDFcbiAgfSxcbiAgbGVhdmVUaW1lT3V0OiAxZTMsXG4gIGFsd2F5c1Nob3dUZXh0OiAhMVxufSk7XG52YXIgYlYgPSBOZjtcbmZ1bmN0aW9uIHdWKGUsIHQpIHtcbiAgdmFyIG47XG4gIHJldHVybiBiVihlLCBmdW5jdGlvbihyLCBpLCBvKSB7XG4gICAgcmV0dXJuIG4gPSB0KHIsIGksIG8pLCAhbjtcbiAgfSksICEhbjtcbn1cbnZhciB4ViA9IHdWLCBTViA9IHZiLCAkViA9IEhuLCBPViA9IHhWLCBfViA9IG10LCBBViA9IEhzO1xuZnVuY3Rpb24gUFYoZSwgdCwgbikge1xuICB2YXIgciA9IF9WKGUpID8gU1YgOiBPVjtcbiAgcmV0dXJuIG4gJiYgQVYoZSwgdCwgbikgJiYgKHQgPSB2b2lkIDApLCByKGUsICRWKHQpKTtcbn1cbnZhciBDViA9IFBWO1xuY29uc3QgRVYgPSAvKiBAX19QVVJFX18gKi8gamUoQ1YpO1xudmFyIHNuID0gZnVuY3Rpb24odCwgbikge1xuICB2YXIgciA9IHQuYWx3YXlzU2hvdywgaSA9IHQuaWZPdmVyZmxvdztcbiAgcmV0dXJuIHIgJiYgKGkgPSBcImV4dGVuZERvbWFpblwiKSwgaSA9PT0gbjtcbn0sIEV2ID0gTGI7XG5mdW5jdGlvbiBUVihlLCB0LCBuKSB7XG4gIHQgPT0gXCJfX3Byb3RvX19cIiAmJiBFdiA/IEV2KGUsIHQsIHtcbiAgICBjb25maWd1cmFibGU6ICEwLFxuICAgIGVudW1lcmFibGU6ICEwLFxuICAgIHZhbHVlOiBuLFxuICAgIHdyaXRhYmxlOiAhMFxuICB9KSA6IGVbdF0gPSBuO1xufVxudmFyIE1WID0gVFYsIFJWID0gTVYsIElWID0gTmIsIGpWID0gSG47XG5mdW5jdGlvbiBrVihlLCB0KSB7XG4gIHZhciBuID0ge307XG4gIHJldHVybiB0ID0galYodCksIElWKGUsIGZ1bmN0aW9uKHIsIGksIG8pIHtcbiAgICBSVihuLCBpLCB0KHIsIGksIG8pKTtcbiAgfSksIG47XG59XG52YXIgRFYgPSBrVjtcbmNvbnN0IE5WID0gLyogQF9fUFVSRV9fICovIGplKERWKTtcbmZ1bmN0aW9uIEZWKGUsIHQpIHtcbiAgZm9yICh2YXIgbiA9IC0xLCByID0gZSA9PSBudWxsID8gMCA6IGUubGVuZ3RoOyArK24gPCByOyApXG4gICAgaWYgKCF0KGVbbl0sIG4sIGUpKVxuICAgICAgcmV0dXJuICExO1xuICByZXR1cm4gITA7XG59XG52YXIgTFYgPSBGViwgQlYgPSBOZjtcbmZ1bmN0aW9uIHpWKGUsIHQpIHtcbiAgdmFyIG4gPSAhMDtcbiAgcmV0dXJuIEJWKGUsIGZ1bmN0aW9uKHIsIGksIG8pIHtcbiAgICByZXR1cm4gbiA9ICEhdChyLCBpLCBvKSwgbjtcbiAgfSksIG47XG59XG52YXIgVlYgPSB6ViwgR1YgPSBMViwgV1YgPSBWViwgVVYgPSBIbiwgSFYgPSBtdCwgcVYgPSBIcztcbmZ1bmN0aW9uIEtWKGUsIHQsIG4pIHtcbiAgdmFyIHIgPSBIVihlKSA/IEdWIDogV1Y7XG4gIHJldHVybiBuICYmIHFWKGUsIHQsIG4pICYmICh0ID0gdm9pZCAwKSwgcihlLCBVVih0KSk7XG59XG52YXIgWVYgPSBLVjtcbmNvbnN0IGR3ID0gLyogQF9fUFVSRV9fICovIGplKFlWKTtcbnZhciBYViA9IFtcInhcIiwgXCJ5XCJdO1xuZnVuY3Rpb24gWnIoZSkge1xuICBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7XG4gIHJldHVybiBaciA9IHR5cGVvZiBTeW1ib2wgPT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uKHQpIHtcbiAgICByZXR1cm4gdHlwZW9mIHQ7XG4gIH0gOiBmdW5jdGlvbih0KSB7XG4gICAgcmV0dXJuIHQgJiYgdHlwZW9mIFN5bWJvbCA9PSBcImZ1bmN0aW9uXCIgJiYgdC5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIHQgIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIHQ7XG4gIH0sIFpyKGUpO1xufVxuZnVuY3Rpb24gSWwoKSB7XG4gIHJldHVybiBJbCA9IE9iamVjdC5hc3NpZ24gPyBPYmplY3QuYXNzaWduLmJpbmQoKSA6IGZ1bmN0aW9uKGUpIHtcbiAgICBmb3IgKHZhciB0ID0gMTsgdCA8IGFyZ3VtZW50cy5sZW5ndGg7IHQrKykge1xuICAgICAgdmFyIG4gPSBhcmd1bWVudHNbdF07XG4gICAgICBmb3IgKHZhciByIGluIG4pXG4gICAgICAgIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChuLCByKSAmJiAoZVtyXSA9IG5bcl0pO1xuICAgIH1cbiAgICByZXR1cm4gZTtcbiAgfSwgSWwuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cbmZ1bmN0aW9uIFR2KGUsIHQpIHtcbiAgdmFyIG4gPSBPYmplY3Qua2V5cyhlKTtcbiAgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcbiAgICB2YXIgciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZSk7XG4gICAgdCAmJiAociA9IHIuZmlsdGVyKGZ1bmN0aW9uKGkpIHtcbiAgICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsIGkpLmVudW1lcmFibGU7XG4gICAgfSkpLCBuLnB1c2guYXBwbHkobiwgcik7XG4gIH1cbiAgcmV0dXJuIG47XG59XG5mdW5jdGlvbiBMaShlKSB7XG4gIGZvciAodmFyIHQgPSAxOyB0IDwgYXJndW1lbnRzLmxlbmd0aDsgdCsrKSB7XG4gICAgdmFyIG4gPSBhcmd1bWVudHNbdF0gIT0gbnVsbCA/IGFyZ3VtZW50c1t0XSA6IHt9O1xuICAgIHQgJSAyID8gVHYoT2JqZWN0KG4pLCAhMCkuZm9yRWFjaChmdW5jdGlvbihyKSB7XG4gICAgICBaVihlLCByLCBuW3JdKTtcbiAgICB9KSA6IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoZSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMobikpIDogVHYoT2JqZWN0KG4pKS5mb3JFYWNoKGZ1bmN0aW9uKHIpIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCByLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG4sIHIpKTtcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gZTtcbn1cbmZ1bmN0aW9uIFpWKGUsIHQsIG4pIHtcbiAgcmV0dXJuIHQgPSBKVih0KSwgdCBpbiBlID8gT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIHQsIHsgdmFsdWU6IG4sIGVudW1lcmFibGU6ICEwLCBjb25maWd1cmFibGU6ICEwLCB3cml0YWJsZTogITAgfSkgOiBlW3RdID0gbiwgZTtcbn1cbmZ1bmN0aW9uIEpWKGUpIHtcbiAgdmFyIHQgPSBRVihlLCBcInN0cmluZ1wiKTtcbiAgcmV0dXJuIFpyKHQpID09IFwic3ltYm9sXCIgPyB0IDogU3RyaW5nKHQpO1xufVxuZnVuY3Rpb24gUVYoZSwgdCkge1xuICBpZiAoWnIoZSkgIT0gXCJvYmplY3RcIiB8fCAhZSlcbiAgICByZXR1cm4gZTtcbiAgdmFyIG4gPSBlW1N5bWJvbC50b1ByaW1pdGl2ZV07XG4gIGlmIChuICE9PSB2b2lkIDApIHtcbiAgICB2YXIgciA9IG4uY2FsbChlLCB0IHx8IFwiZGVmYXVsdFwiKTtcbiAgICBpZiAoWnIocikgIT0gXCJvYmplY3RcIilcbiAgICAgIHJldHVybiByO1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJAQHRvUHJpbWl0aXZlIG11c3QgcmV0dXJuIGEgcHJpbWl0aXZlIHZhbHVlLlwiKTtcbiAgfVxuICByZXR1cm4gKHQgPT09IFwic3RyaW5nXCIgPyBTdHJpbmcgOiBOdW1iZXIpKGUpO1xufVxuZnVuY3Rpb24gZTUoZSwgdCkge1xuICBpZiAoZSA9PSBudWxsKVxuICAgIHJldHVybiB7fTtcbiAgdmFyIG4gPSB0NShlLCB0KSwgciwgaTtcbiAgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcbiAgICB2YXIgbyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZSk7XG4gICAgZm9yIChpID0gMDsgaSA8IG8ubGVuZ3RoOyBpKyspXG4gICAgICByID0gb1tpXSwgISh0LmluZGV4T2YocikgPj0gMCkgJiYgT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKGUsIHIpICYmIChuW3JdID0gZVtyXSk7XG4gIH1cbiAgcmV0dXJuIG47XG59XG5mdW5jdGlvbiB0NShlLCB0KSB7XG4gIGlmIChlID09IG51bGwpXG4gICAgcmV0dXJuIHt9O1xuICB2YXIgbiA9IHt9LCByID0gT2JqZWN0LmtleXMoZSksIGksIG87XG4gIGZvciAobyA9IDA7IG8gPCByLmxlbmd0aDsgbysrKVxuICAgIGkgPSByW29dLCAhKHQuaW5kZXhPZihpKSA+PSAwKSAmJiAobltpXSA9IGVbaV0pO1xuICByZXR1cm4gbjtcbn1cbmZ1bmN0aW9uIG41KGUsIHQpIHtcbiAgdmFyIG4gPSBlLngsIHIgPSBlLnksIGkgPSBlNShlLCBYViksIG8gPSBcIlwiLmNvbmNhdChuKSwgYSA9IHBhcnNlSW50KG8sIDEwKSwgcyA9IFwiXCIuY29uY2F0KHIpLCB1ID0gcGFyc2VJbnQocywgMTApLCBjID0gXCJcIi5jb25jYXQodC5oZWlnaHQgfHwgaS5oZWlnaHQpLCBmID0gcGFyc2VJbnQoYywgMTApLCBsID0gXCJcIi5jb25jYXQodC53aWR0aCB8fCBpLndpZHRoKSwgZCA9IHBhcnNlSW50KGwsIDEwKTtcbiAgcmV0dXJuIExpKExpKExpKExpKExpKHt9LCB0KSwgaSksIGEgPyB7XG4gICAgeDogYVxuICB9IDoge30pLCB1ID8ge1xuICAgIHk6IHVcbiAgfSA6IHt9KSwge30sIHtcbiAgICBoZWlnaHQ6IGYsXG4gICAgd2lkdGg6IGQsXG4gICAgbmFtZTogdC5uYW1lLFxuICAgIHJhZGl1czogdC5yYWRpdXNcbiAgfSk7XG59XG5mdW5jdGlvbiBNdihlKSB7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gUC5jcmVhdGVFbGVtZW50KEI5LCBJbCh7XG4gICAgc2hhcGVUeXBlOiBcInJlY3RhbmdsZVwiLFxuICAgIHByb3BUcmFuc2Zvcm1lcjogbjUsXG4gICAgYWN0aXZlQ2xhc3NOYW1lOiBcInJlY2hhcnRzLWFjdGl2ZS1iYXJcIlxuICB9LCBlKSk7XG59XG52YXIgcjUgPSBmdW5jdGlvbih0KSB7XG4gIHZhciBuID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB2b2lkIDAgPyBhcmd1bWVudHNbMV0gOiAwO1xuICByZXR1cm4gZnVuY3Rpb24ociwgaSkge1xuICAgIGlmICh0eXBlb2YgdCA9PSBcIm51bWJlclwiKVxuICAgICAgcmV0dXJuIHQ7XG4gICAgdmFyIG8gPSB0eXBlb2YgciA9PSBcIm51bWJlclwiO1xuICAgIHJldHVybiBvID8gdChyLCBpKSA6IChvIHx8IChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBndCghMSwgXCJtaW5Qb2ludFNpemUgY2FsbGJhY2sgZnVuY3Rpb24gcmVjZWl2ZWQgYSB2YWx1ZSB3aXRoIHR5cGUgb2YgXCIuY29uY2F0KFpyKHIpLCBcIi4gQ3VycmVudGx5IG9ubHkgbnVtYmVycyBhcmUgc3VwcG9ydGVkLlwiKSkgOiBndCgpKSwgbik7XG4gIH07XG59LCBpNSA9IFtcInZhbHVlXCIsIFwiYmFja2dyb3VuZFwiXSwgcHc7XG5mdW5jdGlvbiBKcihlKSB7XG4gIFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjtcbiAgcmV0dXJuIEpyID0gdHlwZW9mIFN5bWJvbCA9PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PSBcInN5bWJvbFwiID8gZnVuY3Rpb24odCkge1xuICAgIHJldHVybiB0eXBlb2YgdDtcbiAgfSA6IGZ1bmN0aW9uKHQpIHtcbiAgICByZXR1cm4gdCAmJiB0eXBlb2YgU3ltYm9sID09IFwiZnVuY3Rpb25cIiAmJiB0LmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgdCAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2YgdDtcbiAgfSwgSnIoZSk7XG59XG5mdW5jdGlvbiBvNShlLCB0KSB7XG4gIGlmIChlID09IG51bGwpXG4gICAgcmV0dXJuIHt9O1xuICB2YXIgbiA9IGE1KGUsIHQpLCByLCBpO1xuICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykge1xuICAgIHZhciBvID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhlKTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgby5sZW5ndGg7IGkrKylcbiAgICAgIHIgPSBvW2ldLCAhKHQuaW5kZXhPZihyKSA+PSAwKSAmJiBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwoZSwgcikgJiYgKG5bcl0gPSBlW3JdKTtcbiAgfVxuICByZXR1cm4gbjtcbn1cbmZ1bmN0aW9uIGE1KGUsIHQpIHtcbiAgaWYgKGUgPT0gbnVsbClcbiAgICByZXR1cm4ge307XG4gIHZhciBuID0ge30sIHIgPSBPYmplY3Qua2V5cyhlKSwgaSwgbztcbiAgZm9yIChvID0gMDsgbyA8IHIubGVuZ3RoOyBvKyspXG4gICAgaSA9IHJbb10sICEodC5pbmRleE9mKGkpID49IDApICYmIChuW2ldID0gZVtpXSk7XG4gIHJldHVybiBuO1xufVxuZnVuY3Rpb24gT3MoKSB7XG4gIHJldHVybiBPcyA9IE9iamVjdC5hc3NpZ24gPyBPYmplY3QuYXNzaWduLmJpbmQoKSA6IGZ1bmN0aW9uKGUpIHtcbiAgICBmb3IgKHZhciB0ID0gMTsgdCA8IGFyZ3VtZW50cy5sZW5ndGg7IHQrKykge1xuICAgICAgdmFyIG4gPSBhcmd1bWVudHNbdF07XG4gICAgICBmb3IgKHZhciByIGluIG4pXG4gICAgICAgIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChuLCByKSAmJiAoZVtyXSA9IG5bcl0pO1xuICAgIH1cbiAgICByZXR1cm4gZTtcbiAgfSwgT3MuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cbmZ1bmN0aW9uIFJ2KGUsIHQpIHtcbiAgdmFyIG4gPSBPYmplY3Qua2V5cyhlKTtcbiAgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcbiAgICB2YXIgciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZSk7XG4gICAgdCAmJiAociA9IHIuZmlsdGVyKGZ1bmN0aW9uKGkpIHtcbiAgICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsIGkpLmVudW1lcmFibGU7XG4gICAgfSkpLCBuLnB1c2guYXBwbHkobiwgcik7XG4gIH1cbiAgcmV0dXJuIG47XG59XG5mdW5jdGlvbiBKZShlKSB7XG4gIGZvciAodmFyIHQgPSAxOyB0IDwgYXJndW1lbnRzLmxlbmd0aDsgdCsrKSB7XG4gICAgdmFyIG4gPSBhcmd1bWVudHNbdF0gIT0gbnVsbCA/IGFyZ3VtZW50c1t0XSA6IHt9O1xuICAgIHQgJSAyID8gUnYoT2JqZWN0KG4pLCAhMCkuZm9yRWFjaChmdW5jdGlvbihyKSB7XG4gICAgICBEbihlLCByLCBuW3JdKTtcbiAgICB9KSA6IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoZSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMobikpIDogUnYoT2JqZWN0KG4pKS5mb3JFYWNoKGZ1bmN0aW9uKHIpIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCByLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG4sIHIpKTtcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gZTtcbn1cbmZ1bmN0aW9uIHM1KGUsIHQpIHtcbiAgaWYgKCEoZSBpbnN0YW5jZW9mIHQpKVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XG59XG5mdW5jdGlvbiBJdihlLCB0KSB7XG4gIGZvciAodmFyIG4gPSAwOyBuIDwgdC5sZW5ndGg7IG4rKykge1xuICAgIHZhciByID0gdFtuXTtcbiAgICByLmVudW1lcmFibGUgPSByLmVudW1lcmFibGUgfHwgITEsIHIuY29uZmlndXJhYmxlID0gITAsIFwidmFsdWVcIiBpbiByICYmIChyLndyaXRhYmxlID0gITApLCBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgZ3coci5rZXkpLCByKTtcbiAgfVxufVxuZnVuY3Rpb24gdTUoZSwgdCwgbikge1xuICByZXR1cm4gdCAmJiBJdihlLnByb3RvdHlwZSwgdCksIG4gJiYgSXYoZSwgbiksIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCBcInByb3RvdHlwZVwiLCB7IHdyaXRhYmxlOiAhMSB9KSwgZTtcbn1cbmZ1bmN0aW9uIGM1KGUsIHQsIG4pIHtcbiAgcmV0dXJuIHQgPSBfcyh0KSwgbDUoZSwgaHcoKSA/IFJlZmxlY3QuY29uc3RydWN0KHQsIG4gfHwgW10sIF9zKGUpLmNvbnN0cnVjdG9yKSA6IHQuYXBwbHkoZSwgbikpO1xufVxuZnVuY3Rpb24gbDUoZSwgdCkge1xuICBpZiAodCAmJiAoSnIodCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIHQgPT0gXCJmdW5jdGlvblwiKSlcbiAgICByZXR1cm4gdDtcbiAgaWYgKHQgIT09IHZvaWQgMClcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRGVyaXZlZCBjb25zdHJ1Y3RvcnMgbWF5IG9ubHkgcmV0dXJuIG9iamVjdCBvciB1bmRlZmluZWRcIik7XG4gIHJldHVybiBWaShlKTtcbn1cbmZ1bmN0aW9uIGh3KCkge1xuICB0cnkge1xuICAgIHZhciBlID0gIUJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24oKSB7XG4gICAgfSkpO1xuICB9IGNhdGNoIHtcbiAgfVxuICByZXR1cm4gKGh3ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuICEhZTtcbiAgfSkoKTtcbn1cbmZ1bmN0aW9uIF9zKGUpIHtcbiAgcmV0dXJuIF9zID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mLmJpbmQoKSA6IGZ1bmN0aW9uKG4pIHtcbiAgICByZXR1cm4gbi5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG4pO1xuICB9LCBfcyhlKTtcbn1cbmZ1bmN0aW9uIFZpKGUpIHtcbiAgaWYgKGUgPT09IHZvaWQgMClcbiAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7XG4gIHJldHVybiBlO1xufVxuZnVuY3Rpb24gZjUoZSwgdCkge1xuICBpZiAodHlwZW9mIHQgIT0gXCJmdW5jdGlvblwiICYmIHQgIT09IG51bGwpXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpO1xuICBlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUodCAmJiB0LnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogZSwgd3JpdGFibGU6ICEwLCBjb25maWd1cmFibGU6ICEwIH0gfSksIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCBcInByb3RvdHlwZVwiLCB7IHdyaXRhYmxlOiAhMSB9KSwgdCAmJiBqbChlLCB0KTtcbn1cbmZ1bmN0aW9uIGpsKGUsIHQpIHtcbiAgcmV0dXJuIGpsID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mLmJpbmQoKSA6IGZ1bmN0aW9uKHIsIGkpIHtcbiAgICByZXR1cm4gci5fX3Byb3RvX18gPSBpLCByO1xuICB9LCBqbChlLCB0KTtcbn1cbmZ1bmN0aW9uIERuKGUsIHQsIG4pIHtcbiAgcmV0dXJuIHQgPSBndyh0KSwgdCBpbiBlID8gT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIHQsIHsgdmFsdWU6IG4sIGVudW1lcmFibGU6ICEwLCBjb25maWd1cmFibGU6ICEwLCB3cml0YWJsZTogITAgfSkgOiBlW3RdID0gbiwgZTtcbn1cbmZ1bmN0aW9uIGd3KGUpIHtcbiAgdmFyIHQgPSBkNShlLCBcInN0cmluZ1wiKTtcbiAgcmV0dXJuIEpyKHQpID09IFwic3ltYm9sXCIgPyB0IDogU3RyaW5nKHQpO1xufVxuZnVuY3Rpb24gZDUoZSwgdCkge1xuICBpZiAoSnIoZSkgIT0gXCJvYmplY3RcIiB8fCAhZSlcbiAgICByZXR1cm4gZTtcbiAgdmFyIG4gPSBlW1N5bWJvbC50b1ByaW1pdGl2ZV07XG4gIGlmIChuICE9PSB2b2lkIDApIHtcbiAgICB2YXIgciA9IG4uY2FsbChlLCB0IHx8IFwiZGVmYXVsdFwiKTtcbiAgICBpZiAoSnIocikgIT0gXCJvYmplY3RcIilcbiAgICAgIHJldHVybiByO1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJAQHRvUHJpbWl0aXZlIG11c3QgcmV0dXJuIGEgcHJpbWl0aXZlIHZhbHVlLlwiKTtcbiAgfVxuICByZXR1cm4gKHQgPT09IFwic3RyaW5nXCIgPyBTdHJpbmcgOiBOdW1iZXIpKGUpO1xufVxudmFyIEpvID0gLyogQF9fUFVSRV9fICovIGZ1bmN0aW9uKGUpIHtcbiAgZjUodCwgZSk7XG4gIGZ1bmN0aW9uIHQoKSB7XG4gICAgdmFyIG47XG4gICAgczUodGhpcywgdCk7XG4gICAgZm9yICh2YXIgciA9IGFyZ3VtZW50cy5sZW5ndGgsIGkgPSBuZXcgQXJyYXkociksIG8gPSAwOyBvIDwgcjsgbysrKVxuICAgICAgaVtvXSA9IGFyZ3VtZW50c1tvXTtcbiAgICByZXR1cm4gbiA9IGM1KHRoaXMsIHQsIFtdLmNvbmNhdChpKSksIERuKFZpKG4pLCBcInN0YXRlXCIsIHtcbiAgICAgIGlzQW5pbWF0aW9uRmluaXNoZWQ6ICExXG4gICAgfSksIERuKFZpKG4pLCBcImlkXCIsIFVvKFwicmVjaGFydHMtYmFyLVwiKSksIERuKFZpKG4pLCBcImhhbmRsZUFuaW1hdGlvbkVuZFwiLCBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBhID0gbi5wcm9wcy5vbkFuaW1hdGlvbkVuZDtcbiAgICAgIG4uc2V0U3RhdGUoe1xuICAgICAgICBpc0FuaW1hdGlvbkZpbmlzaGVkOiAhMFxuICAgICAgfSksIGEgJiYgYSgpO1xuICAgIH0pLCBEbihWaShuKSwgXCJoYW5kbGVBbmltYXRpb25TdGFydFwiLCBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBhID0gbi5wcm9wcy5vbkFuaW1hdGlvblN0YXJ0O1xuICAgICAgbi5zZXRTdGF0ZSh7XG4gICAgICAgIGlzQW5pbWF0aW9uRmluaXNoZWQ6ICExXG4gICAgICB9KSwgYSAmJiBhKCk7XG4gICAgfSksIG47XG4gIH1cbiAgcmV0dXJuIHU1KHQsIFt7XG4gICAga2V5OiBcInJlbmRlclJlY3RhbmdsZXNTdGF0aWNhbGx5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uKHIpIHtcbiAgICAgIHZhciBpID0gdGhpcywgbyA9IHRoaXMucHJvcHMsIGEgPSBvLnNoYXBlLCBzID0gby5kYXRhS2V5LCB1ID0gby5hY3RpdmVJbmRleCwgYyA9IG8uYWN0aXZlQmFyLCBmID0geWUodGhpcy5wcm9wcywgITEpO1xuICAgICAgcmV0dXJuIHIgJiYgci5tYXAoZnVuY3Rpb24obCwgZCkge1xuICAgICAgICB2YXIgcCA9IGQgPT09IHUsIGcgPSBwID8gYyA6IGEsIGggPSBKZShKZShKZSh7fSwgZiksIGwpLCB7fSwge1xuICAgICAgICAgIGlzQWN0aXZlOiBwLFxuICAgICAgICAgIG9wdGlvbjogZyxcbiAgICAgICAgICBpbmRleDogZCxcbiAgICAgICAgICBkYXRhS2V5OiBzLFxuICAgICAgICAgIG9uQW5pbWF0aW9uU3RhcnQ6IGkuaGFuZGxlQW5pbWF0aW9uU3RhcnQsXG4gICAgICAgICAgb25BbmltYXRpb25FbmQ6IGkuaGFuZGxlQW5pbWF0aW9uRW5kXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIFAuY3JlYXRlRWxlbWVudChXZSwgT3Moe1xuICAgICAgICAgIGNsYXNzTmFtZTogXCJyZWNoYXJ0cy1iYXItcmVjdGFuZ2xlXCJcbiAgICAgICAgfSwgRmEoaS5wcm9wcywgbCwgZCksIHtcbiAgICAgICAgICBrZXk6IFwicmVjdGFuZ2xlLVwiLmNvbmNhdChsID09IG51bGwgPyB2b2lkIDAgOiBsLngsIFwiLVwiKS5jb25jYXQobCA9PSBudWxsID8gdm9pZCAwIDogbC55LCBcIi1cIikuY29uY2F0KGwgPT0gbnVsbCA/IHZvaWQgMCA6IGwudmFsdWUpXG4gICAgICAgIH0pLCAvKiBAX19QVVJFX18gKi8gUC5jcmVhdGVFbGVtZW50KE12LCBoKSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVuZGVyUmVjdGFuZ2xlc1dpdGhBbmltYXRpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgciA9IHRoaXMsIGkgPSB0aGlzLnByb3BzLCBvID0gaS5kYXRhLCBhID0gaS5sYXlvdXQsIHMgPSBpLmlzQW5pbWF0aW9uQWN0aXZlLCB1ID0gaS5hbmltYXRpb25CZWdpbiwgYyA9IGkuYW5pbWF0aW9uRHVyYXRpb24sIGYgPSBpLmFuaW1hdGlvbkVhc2luZywgbCA9IGkuYW5pbWF0aW9uSWQsIGQgPSB0aGlzLnN0YXRlLnByZXZEYXRhO1xuICAgICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBQLmNyZWF0ZUVsZW1lbnQoX24sIHtcbiAgICAgICAgYmVnaW46IHUsXG4gICAgICAgIGR1cmF0aW9uOiBjLFxuICAgICAgICBpc0FjdGl2ZTogcyxcbiAgICAgICAgZWFzaW5nOiBmLFxuICAgICAgICBmcm9tOiB7XG4gICAgICAgICAgdDogMFxuICAgICAgICB9LFxuICAgICAgICB0bzoge1xuICAgICAgICAgIHQ6IDFcbiAgICAgICAgfSxcbiAgICAgICAga2V5OiBcImJhci1cIi5jb25jYXQobCksXG4gICAgICAgIG9uQW5pbWF0aW9uRW5kOiB0aGlzLmhhbmRsZUFuaW1hdGlvbkVuZCxcbiAgICAgICAgb25BbmltYXRpb25TdGFydDogdGhpcy5oYW5kbGVBbmltYXRpb25TdGFydFxuICAgICAgfSwgZnVuY3Rpb24ocCkge1xuICAgICAgICB2YXIgZyA9IHAudCwgaCA9IG8ubWFwKGZ1bmN0aW9uKHYsIHcpIHtcbiAgICAgICAgICB2YXIgYiA9IGQgJiYgZFt3XTtcbiAgICAgICAgICBpZiAoYikge1xuICAgICAgICAgICAgdmFyIHggPSBIdChiLngsIHYueCksIG0gPSBIdChiLnksIHYueSksIHkgPSBIdChiLndpZHRoLCB2LndpZHRoKSwgUyA9IEh0KGIuaGVpZ2h0LCB2LmhlaWdodCk7XG4gICAgICAgICAgICByZXR1cm4gSmUoSmUoe30sIHYpLCB7fSwge1xuICAgICAgICAgICAgICB4OiB4KGcpLFxuICAgICAgICAgICAgICB5OiBtKGcpLFxuICAgICAgICAgICAgICB3aWR0aDogeShnKSxcbiAgICAgICAgICAgICAgaGVpZ2h0OiBTKGcpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGEgPT09IFwiaG9yaXpvbnRhbFwiKSB7XG4gICAgICAgICAgICB2YXIgJCA9IEh0KDAsIHYuaGVpZ2h0KSwgTyA9ICQoZyk7XG4gICAgICAgICAgICByZXR1cm4gSmUoSmUoe30sIHYpLCB7fSwge1xuICAgICAgICAgICAgICB5OiB2LnkgKyB2LmhlaWdodCAtIE8sXG4gICAgICAgICAgICAgIGhlaWdodDogT1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBUID0gSHQoMCwgdi53aWR0aCksIE0gPSBUKGcpO1xuICAgICAgICAgIHJldHVybiBKZShKZSh7fSwgdiksIHt9LCB7XG4gICAgICAgICAgICB3aWR0aDogTVxuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBQLmNyZWF0ZUVsZW1lbnQoV2UsIG51bGwsIHIucmVuZGVyUmVjdGFuZ2xlc1N0YXRpY2FsbHkoaCkpO1xuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJlbmRlclJlY3RhbmdsZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgciA9IHRoaXMucHJvcHMsIGkgPSByLmRhdGEsIG8gPSByLmlzQW5pbWF0aW9uQWN0aXZlLCBhID0gdGhpcy5zdGF0ZS5wcmV2RGF0YTtcbiAgICAgIHJldHVybiBvICYmIGkgJiYgaS5sZW5ndGggJiYgKCFhIHx8ICF0dShhLCBpKSkgPyB0aGlzLnJlbmRlclJlY3RhbmdsZXNXaXRoQW5pbWF0aW9uKCkgOiB0aGlzLnJlbmRlclJlY3RhbmdsZXNTdGF0aWNhbGx5KGkpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyZW5kZXJCYWNrZ3JvdW5kXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHIgPSB0aGlzLCBpID0gdGhpcy5wcm9wcywgbyA9IGkuZGF0YSwgYSA9IGkuZGF0YUtleSwgcyA9IGkuYWN0aXZlSW5kZXgsIHUgPSB5ZSh0aGlzLnByb3BzLmJhY2tncm91bmQsICExKTtcbiAgICAgIHJldHVybiBvLm1hcChmdW5jdGlvbihjLCBmKSB7XG4gICAgICAgIGMudmFsdWU7XG4gICAgICAgIHZhciBsID0gYy5iYWNrZ3JvdW5kLCBkID0gbzUoYywgaTUpO1xuICAgICAgICBpZiAoIWwpXG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIHZhciBwID0gSmUoSmUoSmUoSmUoSmUoe30sIGQpLCB7fSwge1xuICAgICAgICAgIGZpbGw6IFwiI2VlZVwiXG4gICAgICAgIH0sIGwpLCB1KSwgRmEoci5wcm9wcywgYywgZikpLCB7fSwge1xuICAgICAgICAgIG9uQW5pbWF0aW9uU3RhcnQ6IHIuaGFuZGxlQW5pbWF0aW9uU3RhcnQsXG4gICAgICAgICAgb25BbmltYXRpb25FbmQ6IHIuaGFuZGxlQW5pbWF0aW9uRW5kLFxuICAgICAgICAgIGRhdGFLZXk6IGEsXG4gICAgICAgICAgaW5kZXg6IGYsXG4gICAgICAgICAga2V5OiBcImJhY2tncm91bmQtYmFyLVwiLmNvbmNhdChmKSxcbiAgICAgICAgICBjbGFzc05hbWU6IFwicmVjaGFydHMtYmFyLWJhY2tncm91bmQtcmVjdGFuZ2xlXCJcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8gUC5jcmVhdGVFbGVtZW50KE12LCBPcyh7XG4gICAgICAgICAgb3B0aW9uOiByLnByb3BzLmJhY2tncm91bmQsXG4gICAgICAgICAgaXNBY3RpdmU6IGYgPT09IHNcbiAgICAgICAgfSwgcCkpO1xuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJlbmRlckVycm9yQmFyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uKHIsIGkpIHtcbiAgICAgIGlmICh0aGlzLnByb3BzLmlzQW5pbWF0aW9uQWN0aXZlICYmICF0aGlzLnN0YXRlLmlzQW5pbWF0aW9uRmluaXNoZWQpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgdmFyIG8gPSB0aGlzLnByb3BzLCBhID0gby5kYXRhLCBzID0gby54QXhpcywgdSA9IG8ueUF4aXMsIGMgPSBvLmxheW91dCwgZiA9IG8uY2hpbGRyZW4sIGwgPSBrdChmLCBabyk7XG4gICAgICBpZiAoIWwpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgdmFyIGQgPSBjID09PSBcInZlcnRpY2FsXCIgPyBhWzBdLmhlaWdodCAvIDIgOiBhWzBdLndpZHRoIC8gMiwgcCA9IGZ1bmN0aW9uKHYsIHcpIHtcbiAgICAgICAgdmFyIGIgPSBBcnJheS5pc0FycmF5KHYudmFsdWUpID8gdi52YWx1ZVsxXSA6IHYudmFsdWU7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgeDogdi54LFxuICAgICAgICAgIHk6IHYueSxcbiAgICAgICAgICB2YWx1ZTogYixcbiAgICAgICAgICBlcnJvclZhbDogQXQodiwgdylcbiAgICAgICAgfTtcbiAgICAgIH0sIGcgPSB7XG4gICAgICAgIGNsaXBQYXRoOiByID8gXCJ1cmwoI2NsaXBQYXRoLVwiLmNvbmNhdChpLCBcIilcIikgOiBudWxsXG4gICAgICB9O1xuICAgICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBQLmNyZWF0ZUVsZW1lbnQoV2UsIGcsIGwubWFwKGZ1bmN0aW9uKGgpIHtcbiAgICAgICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBQLmNsb25lRWxlbWVudChoLCB7XG4gICAgICAgICAga2V5OiBcImVycm9yLWJhci1cIi5jb25jYXQoaSwgXCItXCIpLmNvbmNhdChoLnByb3BzLmRhdGFLZXkpLFxuICAgICAgICAgIGRhdGE6IGEsXG4gICAgICAgICAgeEF4aXM6IHMsXG4gICAgICAgICAgeUF4aXM6IHUsXG4gICAgICAgICAgbGF5b3V0OiBjLFxuICAgICAgICAgIG9mZnNldDogZCxcbiAgICAgICAgICBkYXRhUG9pbnRGb3JtYXR0ZXI6IHBcbiAgICAgICAgfSk7XG4gICAgICB9KSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJlbmRlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciByID0gdGhpcy5wcm9wcywgaSA9IHIuaGlkZSwgbyA9IHIuZGF0YSwgYSA9IHIuY2xhc3NOYW1lLCBzID0gci54QXhpcywgdSA9IHIueUF4aXMsIGMgPSByLmxlZnQsIGYgPSByLnRvcCwgbCA9IHIud2lkdGgsIGQgPSByLmhlaWdodCwgcCA9IHIuaXNBbmltYXRpb25BY3RpdmUsIGcgPSByLmJhY2tncm91bmQsIGggPSByLmlkO1xuICAgICAgaWYgKGkgfHwgIW8gfHwgIW8ubGVuZ3RoKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIHZhciB2ID0gdGhpcy5zdGF0ZS5pc0FuaW1hdGlvbkZpbmlzaGVkLCB3ID0gJGUoXCJyZWNoYXJ0cy1iYXJcIiwgYSksIGIgPSBzICYmIHMuYWxsb3dEYXRhT3ZlcmZsb3csIHggPSB1ICYmIHUuYWxsb3dEYXRhT3ZlcmZsb3csIG0gPSBiIHx8IHgsIHkgPSBtZShoKSA/IHRoaXMuaWQgOiBoO1xuICAgICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBQLmNyZWF0ZUVsZW1lbnQoV2UsIHtcbiAgICAgICAgY2xhc3NOYW1lOiB3XG4gICAgICB9LCBiIHx8IHggPyAvKiBAX19QVVJFX18gKi8gUC5jcmVhdGVFbGVtZW50KFwiZGVmc1wiLCBudWxsLCAvKiBAX19QVVJFX18gKi8gUC5jcmVhdGVFbGVtZW50KFwiY2xpcFBhdGhcIiwge1xuICAgICAgICBpZDogXCJjbGlwUGF0aC1cIi5jb25jYXQoeSlcbiAgICAgIH0sIC8qIEBfX1BVUkVfXyAqLyBQLmNyZWF0ZUVsZW1lbnQoXCJyZWN0XCIsIHtcbiAgICAgICAgeDogYiA/IGMgOiBjIC0gbCAvIDIsXG4gICAgICAgIHk6IHggPyBmIDogZiAtIGQgLyAyLFxuICAgICAgICB3aWR0aDogYiA/IGwgOiBsICogMixcbiAgICAgICAgaGVpZ2h0OiB4ID8gZCA6IGQgKiAyXG4gICAgICB9KSkpIDogbnVsbCwgLyogQF9fUFVSRV9fICovIFAuY3JlYXRlRWxlbWVudChXZSwge1xuICAgICAgICBjbGFzc05hbWU6IFwicmVjaGFydHMtYmFyLXJlY3RhbmdsZXNcIixcbiAgICAgICAgY2xpcFBhdGg6IG0gPyBcInVybCgjY2xpcFBhdGgtXCIuY29uY2F0KHksIFwiKVwiKSA6IG51bGxcbiAgICAgIH0sIGcgPyB0aGlzLnJlbmRlckJhY2tncm91bmQoKSA6IG51bGwsIHRoaXMucmVuZGVyUmVjdGFuZ2xlcygpKSwgdGhpcy5yZW5kZXJFcnJvckJhcihtLCB5KSwgKCFwIHx8IHYpICYmIEJuLnJlbmRlckNhbGxCeVBhcmVudCh0aGlzLnByb3BzLCBvKSk7XG4gICAgfVxuICB9XSwgW3tcbiAgICBrZXk6IFwiZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uKHIsIGkpIHtcbiAgICAgIHJldHVybiByLmFuaW1hdGlvbklkICE9PSBpLnByZXZBbmltYXRpb25JZCA/IHtcbiAgICAgICAgcHJldkFuaW1hdGlvbklkOiByLmFuaW1hdGlvbklkLFxuICAgICAgICBjdXJEYXRhOiByLmRhdGEsXG4gICAgICAgIHByZXZEYXRhOiBpLmN1ckRhdGFcbiAgICAgIH0gOiByLmRhdGEgIT09IGkuY3VyRGF0YSA/IHtcbiAgICAgICAgY3VyRGF0YTogci5kYXRhXG4gICAgICB9IDogbnVsbDtcbiAgICB9XG4gIH1dKSwgdDtcbn0oV24pO1xucHcgPSBKbztcbkRuKEpvLCBcImRpc3BsYXlOYW1lXCIsIFwiQmFyXCIpO1xuRG4oSm8sIFwiZGVmYXVsdFByb3BzXCIsIHtcbiAgeEF4aXNJZDogMCxcbiAgeUF4aXNJZDogMCxcbiAgbGVnZW5kVHlwZTogXCJyZWN0XCIsXG4gIG1pblBvaW50U2l6ZTogMCxcbiAgaGlkZTogITEsXG4gIGRhdGE6IFtdLFxuICBsYXlvdXQ6IFwidmVydGljYWxcIixcbiAgYWN0aXZlQmFyOiAhMSxcbiAgaXNBbmltYXRpb25BY3RpdmU6ICF5bi5pc1NzcixcbiAgYW5pbWF0aW9uQmVnaW46IDAsXG4gIGFuaW1hdGlvbkR1cmF0aW9uOiA0MDAsXG4gIGFuaW1hdGlvbkVhc2luZzogXCJlYXNlXCJcbn0pO1xuRG4oSm8sIFwiZ2V0Q29tcG9zZWREYXRhXCIsIGZ1bmN0aW9uKGUpIHtcbiAgdmFyIHQgPSBlLnByb3BzLCBuID0gZS5pdGVtLCByID0gZS5iYXJQb3NpdGlvbiwgaSA9IGUuYmFuZFNpemUsIG8gPSBlLnhBeGlzLCBhID0gZS55QXhpcywgcyA9IGUueEF4aXNUaWNrcywgdSA9IGUueUF4aXNUaWNrcywgYyA9IGUuc3RhY2tlZERhdGEsIGYgPSBlLmRhdGFTdGFydEluZGV4LCBsID0gZS5kaXNwbGF5ZWREYXRhLCBkID0gZS5vZmZzZXQsIHAgPSBaNihyLCBuKTtcbiAgaWYgKCFwKVxuICAgIHJldHVybiBudWxsO1xuICB2YXIgZyA9IHQubGF5b3V0LCBoID0gbi5wcm9wcywgdiA9IGguZGF0YUtleSwgdyA9IGguY2hpbGRyZW4sIGIgPSBoLm1pblBvaW50U2l6ZSwgeCA9IGcgPT09IFwiaG9yaXpvbnRhbFwiID8gYSA6IG8sIG0gPSBjID8geC5zY2FsZS5kb21haW4oKSA6IG51bGwsIHkgPSBvOCh7XG4gICAgbnVtZXJpY0F4aXM6IHhcbiAgfSksIFMgPSBrdCh3LCBVYiksICQgPSBsLm1hcChmdW5jdGlvbihPLCBUKSB7XG4gICAgdmFyIE0sIEUsIEEsIGosIFIsIE47XG4gICAgYyA/IE0gPSBKNihjW2YgKyBUXSwgbSkgOiAoTSA9IEF0KE8sIHYpLCBBcnJheS5pc0FycmF5KE0pIHx8IChNID0gW3ksIE1dKSk7XG4gICAgdmFyIGsgPSByNShiLCBwdy5kZWZhdWx0UHJvcHMubWluUG9pbnRTaXplKShNWzFdLCBUKTtcbiAgICBpZiAoZyA9PT0gXCJob3Jpem9udGFsXCIpIHtcbiAgICAgIHZhciBGLCBWID0gW2Euc2NhbGUoTVswXSksIGEuc2NhbGUoTVsxXSldLCBMID0gVlswXSwgSSA9IFZbMV07XG4gICAgICBFID0gQWcoe1xuICAgICAgICBheGlzOiBvLFxuICAgICAgICB0aWNrczogcyxcbiAgICAgICAgYmFuZFNpemU6IGksXG4gICAgICAgIG9mZnNldDogcC5vZmZzZXQsXG4gICAgICAgIGVudHJ5OiBPLFxuICAgICAgICBpbmRleDogVFxuICAgICAgfSksIEEgPSAoRiA9IEkgPz8gTCkgIT09IG51bGwgJiYgRiAhPT0gdm9pZCAwID8gRiA6IHZvaWQgMCwgaiA9IHAuc2l6ZTtcbiAgICAgIHZhciBEID0gTCAtIEk7XG4gICAgICBpZiAoUiA9IE51bWJlci5pc05hTihEKSA/IDAgOiBELCBOID0ge1xuICAgICAgICB4OiBFLFxuICAgICAgICB5OiBhLnksXG4gICAgICAgIHdpZHRoOiBqLFxuICAgICAgICBoZWlnaHQ6IGEuaGVpZ2h0XG4gICAgICB9LCBNYXRoLmFicyhrKSA+IDAgJiYgTWF0aC5hYnMoUikgPCBNYXRoLmFicyhrKSkge1xuICAgICAgICB2YXIgRyA9IEt0KFIgfHwgaykgKiAoTWF0aC5hYnMoaykgLSBNYXRoLmFicyhSKSk7XG4gICAgICAgIEEgLT0gRywgUiArPSBHO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgcSA9IFtvLnNjYWxlKE1bMF0pLCBvLnNjYWxlKE1bMV0pXSwgSiA9IHFbMF0sIG5lID0gcVsxXTtcbiAgICAgIGlmIChFID0gSiwgQSA9IEFnKHtcbiAgICAgICAgYXhpczogYSxcbiAgICAgICAgdGlja3M6IHUsXG4gICAgICAgIGJhbmRTaXplOiBpLFxuICAgICAgICBvZmZzZXQ6IHAub2Zmc2V0LFxuICAgICAgICBlbnRyeTogTyxcbiAgICAgICAgaW5kZXg6IFRcbiAgICAgIH0pLCBqID0gbmUgLSBKLCBSID0gcC5zaXplLCBOID0ge1xuICAgICAgICB4OiBvLngsXG4gICAgICAgIHk6IEEsXG4gICAgICAgIHdpZHRoOiBvLndpZHRoLFxuICAgICAgICBoZWlnaHQ6IFJcbiAgICAgIH0sIE1hdGguYWJzKGspID4gMCAmJiBNYXRoLmFicyhqKSA8IE1hdGguYWJzKGspKSB7XG4gICAgICAgIHZhciB0ZSA9IEt0KGogfHwgaykgKiAoTWF0aC5hYnMoaykgLSBNYXRoLmFicyhqKSk7XG4gICAgICAgIGogKz0gdGU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBKZShKZShKZSh7fSwgTyksIHt9LCB7XG4gICAgICB4OiBFLFxuICAgICAgeTogQSxcbiAgICAgIHdpZHRoOiBqLFxuICAgICAgaGVpZ2h0OiBSLFxuICAgICAgdmFsdWU6IGMgPyBNIDogTVsxXSxcbiAgICAgIHBheWxvYWQ6IE8sXG4gICAgICBiYWNrZ3JvdW5kOiBOXG4gICAgfSwgUyAmJiBTW1RdICYmIFNbVF0ucHJvcHMpLCB7fSwge1xuICAgICAgdG9vbHRpcFBheWxvYWQ6IFtLMChuLCBPKV0sXG4gICAgICB0b29sdGlwUG9zaXRpb246IHtcbiAgICAgICAgeDogRSArIGogLyAyLFxuICAgICAgICB5OiBBICsgUiAvIDJcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG4gIHJldHVybiBKZSh7XG4gICAgZGF0YTogJCxcbiAgICBsYXlvdXQ6IGdcbiAgfSwgZCk7XG59KTtcbmZ1bmN0aW9uIE1vKGUpIHtcbiAgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiO1xuICByZXR1cm4gTW8gPSB0eXBlb2YgU3ltYm9sID09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09IFwic3ltYm9sXCIgPyBmdW5jdGlvbih0KSB7XG4gICAgcmV0dXJuIHR5cGVvZiB0O1xuICB9IDogZnVuY3Rpb24odCkge1xuICAgIHJldHVybiB0ICYmIHR5cGVvZiBTeW1ib2wgPT0gXCJmdW5jdGlvblwiICYmIHQuY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiB0ICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiB0O1xuICB9LCBNbyhlKTtcbn1cbmZ1bmN0aW9uIHA1KGUsIHQpIHtcbiAgaWYgKCEoZSBpbnN0YW5jZW9mIHQpKVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XG59XG5mdW5jdGlvbiBqdihlLCB0KSB7XG4gIGZvciAodmFyIG4gPSAwOyBuIDwgdC5sZW5ndGg7IG4rKykge1xuICAgIHZhciByID0gdFtuXTtcbiAgICByLmVudW1lcmFibGUgPSByLmVudW1lcmFibGUgfHwgITEsIHIuY29uZmlndXJhYmxlID0gITAsIFwidmFsdWVcIiBpbiByICYmIChyLndyaXRhYmxlID0gITApLCBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgdncoci5rZXkpLCByKTtcbiAgfVxufVxuZnVuY3Rpb24gaDUoZSwgdCwgbikge1xuICByZXR1cm4gdCAmJiBqdihlLnByb3RvdHlwZSwgdCksIG4gJiYganYoZSwgbiksIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCBcInByb3RvdHlwZVwiLCB7IHdyaXRhYmxlOiAhMSB9KSwgZTtcbn1cbmZ1bmN0aW9uIGt2KGUsIHQpIHtcbiAgdmFyIG4gPSBPYmplY3Qua2V5cyhlKTtcbiAgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcbiAgICB2YXIgciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZSk7XG4gICAgdCAmJiAociA9IHIuZmlsdGVyKGZ1bmN0aW9uKGkpIHtcbiAgICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsIGkpLmVudW1lcmFibGU7XG4gICAgfSkpLCBuLnB1c2guYXBwbHkobiwgcik7XG4gIH1cbiAgcmV0dXJuIG47XG59XG5mdW5jdGlvbiBXdChlKSB7XG4gIGZvciAodmFyIHQgPSAxOyB0IDwgYXJndW1lbnRzLmxlbmd0aDsgdCsrKSB7XG4gICAgdmFyIG4gPSBhcmd1bWVudHNbdF0gIT0gbnVsbCA/IGFyZ3VtZW50c1t0XSA6IHt9O1xuICAgIHQgJSAyID8ga3YoT2JqZWN0KG4pLCAhMCkuZm9yRWFjaChmdW5jdGlvbihyKSB7XG4gICAgICBhdShlLCByLCBuW3JdKTtcbiAgICB9KSA6IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoZSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMobikpIDoga3YoT2JqZWN0KG4pKS5mb3JFYWNoKGZ1bmN0aW9uKHIpIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCByLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG4sIHIpKTtcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gZTtcbn1cbmZ1bmN0aW9uIGF1KGUsIHQsIG4pIHtcbiAgcmV0dXJuIHQgPSB2dyh0KSwgdCBpbiBlID8gT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIHQsIHsgdmFsdWU6IG4sIGVudW1lcmFibGU6ICEwLCBjb25maWd1cmFibGU6ICEwLCB3cml0YWJsZTogITAgfSkgOiBlW3RdID0gbiwgZTtcbn1cbmZ1bmN0aW9uIHZ3KGUpIHtcbiAgdmFyIHQgPSBnNShlLCBcInN0cmluZ1wiKTtcbiAgcmV0dXJuIE1vKHQpID09IFwic3ltYm9sXCIgPyB0IDogU3RyaW5nKHQpO1xufVxuZnVuY3Rpb24gZzUoZSwgdCkge1xuICBpZiAoTW8oZSkgIT0gXCJvYmplY3RcIiB8fCAhZSlcbiAgICByZXR1cm4gZTtcbiAgdmFyIG4gPSBlW1N5bWJvbC50b1ByaW1pdGl2ZV07XG4gIGlmIChuICE9PSB2b2lkIDApIHtcbiAgICB2YXIgciA9IG4uY2FsbChlLCB0IHx8IFwiZGVmYXVsdFwiKTtcbiAgICBpZiAoTW8ocikgIT0gXCJvYmplY3RcIilcbiAgICAgIHJldHVybiByO1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJAQHRvUHJpbWl0aXZlIG11c3QgcmV0dXJuIGEgcHJpbWl0aXZlIHZhbHVlLlwiKTtcbiAgfVxuICByZXR1cm4gKHQgPT09IFwic3RyaW5nXCIgPyBTdHJpbmcgOiBOdW1iZXIpKGUpO1xufVxudmFyIHY1ID0gZnVuY3Rpb24odCwgbiwgciwgaSwgbykge1xuICB2YXIgYSA9IHQud2lkdGgsIHMgPSB0LmhlaWdodCwgdSA9IHQubGF5b3V0LCBjID0gdC5jaGlsZHJlbiwgZiA9IE9iamVjdC5rZXlzKG4pLCBsID0ge1xuICAgIGxlZnQ6IHIubGVmdCxcbiAgICBsZWZ0TWlycm9yOiByLmxlZnQsXG4gICAgcmlnaHQ6IGEgLSByLnJpZ2h0LFxuICAgIHJpZ2h0TWlycm9yOiBhIC0gci5yaWdodCxcbiAgICB0b3A6IHIudG9wLFxuICAgIHRvcE1pcnJvcjogci50b3AsXG4gICAgYm90dG9tOiBzIC0gci5ib3R0b20sXG4gICAgYm90dG9tTWlycm9yOiBzIC0gci5ib3R0b21cbiAgfSwgZCA9ICEhd3QoYywgSm8pO1xuICByZXR1cm4gZi5yZWR1Y2UoZnVuY3Rpb24ocCwgZykge1xuICAgIHZhciBoID0gbltnXSwgdiA9IGgub3JpZW50YXRpb24sIHcgPSBoLmRvbWFpbiwgYiA9IGgucGFkZGluZywgeCA9IGIgPT09IHZvaWQgMCA/IHt9IDogYiwgbSA9IGgubWlycm9yLCB5ID0gaC5yZXZlcnNlZCwgUyA9IFwiXCIuY29uY2F0KHYpLmNvbmNhdChtID8gXCJNaXJyb3JcIiA6IFwiXCIpLCAkLCBPLCBULCBNLCBFO1xuICAgIGlmIChoLnR5cGUgPT09IFwibnVtYmVyXCIgJiYgKGgucGFkZGluZyA9PT0gXCJnYXBcIiB8fCBoLnBhZGRpbmcgPT09IFwibm8tZ2FwXCIpKSB7XG4gICAgICB2YXIgQSA9IHdbMV0gLSB3WzBdLCBqID0gMSAvIDAsIFIgPSBoLmNhdGVnb3JpY2FsRG9tYWluLnNvcnQoKTtcbiAgICAgIGlmIChSLmZvckVhY2goZnVuY3Rpb24oSiwgbmUpIHtcbiAgICAgICAgbmUgPiAwICYmIChqID0gTWF0aC5taW4oKEogfHwgMCkgLSAoUltuZSAtIDFdIHx8IDApLCBqKSk7XG4gICAgICB9KSwgTnVtYmVyLmlzRmluaXRlKGopKSB7XG4gICAgICAgIHZhciBOID0gaiAvIEEsIGsgPSBoLmxheW91dCA9PT0gXCJ2ZXJ0aWNhbFwiID8gci5oZWlnaHQgOiByLndpZHRoO1xuICAgICAgICBpZiAoaC5wYWRkaW5nID09PSBcImdhcFwiICYmICgkID0gTiAqIGsgLyAyKSwgaC5wYWRkaW5nID09PSBcIm5vLWdhcFwiKSB7XG4gICAgICAgICAgdmFyIEYgPSBscih0LmJhckNhdGVnb3J5R2FwLCBOICogayksIFYgPSBOICogayAvIDI7XG4gICAgICAgICAgJCA9IFYgLSBGIC0gKFYgLSBGKSAvIGsgKiBGO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGkgPT09IFwieEF4aXNcIiA/IE8gPSBbci5sZWZ0ICsgKHgubGVmdCB8fCAwKSArICgkIHx8IDApLCByLmxlZnQgKyByLndpZHRoIC0gKHgucmlnaHQgfHwgMCkgLSAoJCB8fCAwKV0gOiBpID09PSBcInlBeGlzXCIgPyBPID0gdSA9PT0gXCJob3Jpem9udGFsXCIgPyBbci50b3AgKyByLmhlaWdodCAtICh4LmJvdHRvbSB8fCAwKSwgci50b3AgKyAoeC50b3AgfHwgMCldIDogW3IudG9wICsgKHgudG9wIHx8IDApICsgKCQgfHwgMCksIHIudG9wICsgci5oZWlnaHQgLSAoeC5ib3R0b20gfHwgMCkgLSAoJCB8fCAwKV0gOiBPID0gaC5yYW5nZSwgeSAmJiAoTyA9IFtPWzFdLCBPWzBdXSk7XG4gICAgdmFyIEwgPSBZNihoLCBvLCBkKSwgSSA9IEwuc2NhbGUsIEQgPSBMLnJlYWxTY2FsZVR5cGU7XG4gICAgSS5kb21haW4odykucmFuZ2UoTyksIFg2KEkpO1xuICAgIHZhciBHID0gaTgoSSwgV3QoV3Qoe30sIGgpLCB7fSwge1xuICAgICAgcmVhbFNjYWxlVHlwZTogRFxuICAgIH0pKTtcbiAgICBpID09PSBcInhBeGlzXCIgPyAoRSA9IHYgPT09IFwidG9wXCIgJiYgIW0gfHwgdiA9PT0gXCJib3R0b21cIiAmJiBtLCBUID0gci5sZWZ0LCBNID0gbFtTXSAtIEUgKiBoLmhlaWdodCkgOiBpID09PSBcInlBeGlzXCIgJiYgKEUgPSB2ID09PSBcImxlZnRcIiAmJiAhbSB8fCB2ID09PSBcInJpZ2h0XCIgJiYgbSwgVCA9IGxbU10gLSBFICogaC53aWR0aCwgTSA9IHIudG9wKTtcbiAgICB2YXIgcSA9IFd0KFd0KFd0KHt9LCBoKSwgRyksIHt9LCB7XG4gICAgICByZWFsU2NhbGVUeXBlOiBELFxuICAgICAgeDogVCxcbiAgICAgIHk6IE0sXG4gICAgICBzY2FsZTogSSxcbiAgICAgIHdpZHRoOiBpID09PSBcInhBeGlzXCIgPyByLndpZHRoIDogaC53aWR0aCxcbiAgICAgIGhlaWdodDogaSA9PT0gXCJ5QXhpc1wiID8gci5oZWlnaHQgOiBoLmhlaWdodFxuICAgIH0pO1xuICAgIHJldHVybiBxLmJhbmRTaXplID0gZnMocSwgRyksICFoLmhpZGUgJiYgaSA9PT0gXCJ4QXhpc1wiID8gbFtTXSArPSAoRSA/IC0xIDogMSkgKiBxLmhlaWdodCA6IGguaGlkZSB8fCAobFtTXSArPSAoRSA/IC0xIDogMSkgKiBxLndpZHRoKSwgV3QoV3Qoe30sIHApLCB7fSwgYXUoe30sIGcsIHEpKTtcbiAgfSwge30pO1xufSwgbXcgPSBmdW5jdGlvbih0LCBuKSB7XG4gIHZhciByID0gdC54LCBpID0gdC55LCBvID0gbi54LCBhID0gbi55O1xuICByZXR1cm4ge1xuICAgIHg6IE1hdGgubWluKHIsIG8pLFxuICAgIHk6IE1hdGgubWluKGksIGEpLFxuICAgIHdpZHRoOiBNYXRoLmFicyhvIC0gciksXG4gICAgaGVpZ2h0OiBNYXRoLmFicyhhIC0gaSlcbiAgfTtcbn0sIG01ID0gZnVuY3Rpb24odCkge1xuICB2YXIgbiA9IHQueDEsIHIgPSB0LnkxLCBpID0gdC54MiwgbyA9IHQueTI7XG4gIHJldHVybiBtdyh7XG4gICAgeDogbixcbiAgICB5OiByXG4gIH0sIHtcbiAgICB4OiBpLFxuICAgIHk6IG9cbiAgfSk7XG59LCB5dyA9IC8qIEBfX1BVUkVfXyAqLyBmdW5jdGlvbigpIHtcbiAgZnVuY3Rpb24gZSh0KSB7XG4gICAgcDUodGhpcywgZSksIHRoaXMuc2NhbGUgPSB0O1xuICB9XG4gIHJldHVybiBoNShlLCBbe1xuICAgIGtleTogXCJkb21haW5cIixcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuc2NhbGUuZG9tYWluO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyYW5nZVwiLFxuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5zY2FsZS5yYW5nZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmFuZ2VNaW5cIixcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMucmFuZ2UoKVswXTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmFuZ2VNYXhcIixcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMucmFuZ2UoKVsxXTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYmFuZHdpZHRoXCIsXG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLnNjYWxlLmJhbmR3aWR0aDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYXBwbHlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24obikge1xuICAgICAgdmFyIHIgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHZvaWQgMCA/IGFyZ3VtZW50c1sxXSA6IHt9LCBpID0gci5iYW5kQXdhcmUsIG8gPSByLnBvc2l0aW9uO1xuICAgICAgaWYgKG4gIT09IHZvaWQgMCkge1xuICAgICAgICBpZiAobylcbiAgICAgICAgICBzd2l0Y2ggKG8pIHtcbiAgICAgICAgICAgIGNhc2UgXCJzdGFydFwiOlxuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zY2FsZShuKTtcbiAgICAgICAgICAgIGNhc2UgXCJtaWRkbGVcIjoge1xuICAgICAgICAgICAgICB2YXIgYSA9IHRoaXMuYmFuZHdpZHRoID8gdGhpcy5iYW5kd2lkdGgoKSAvIDIgOiAwO1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zY2FsZShuKSArIGE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFwiZW5kXCI6IHtcbiAgICAgICAgICAgICAgdmFyIHMgPSB0aGlzLmJhbmR3aWR0aCA/IHRoaXMuYmFuZHdpZHRoKCkgOiAwO1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zY2FsZShuKSArIHM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zY2FsZShuKTtcbiAgICAgICAgICB9XG4gICAgICAgIGlmIChpKSB7XG4gICAgICAgICAgdmFyIHUgPSB0aGlzLmJhbmR3aWR0aCA/IHRoaXMuYmFuZHdpZHRoKCkgLyAyIDogMDtcbiAgICAgICAgICByZXR1cm4gdGhpcy5zY2FsZShuKSArIHU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuc2NhbGUobik7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImlzSW5SYW5nZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbihuKSB7XG4gICAgICB2YXIgciA9IHRoaXMucmFuZ2UoKSwgaSA9IHJbMF0sIG8gPSByW3IubGVuZ3RoIC0gMV07XG4gICAgICByZXR1cm4gaSA8PSBvID8gbiA+PSBpICYmIG4gPD0gbyA6IG4gPj0gbyAmJiBuIDw9IGk7XG4gICAgfVxuICB9XSwgW3tcbiAgICBrZXk6IFwiY3JlYXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uKG4pIHtcbiAgICAgIHJldHVybiBuZXcgZShuKTtcbiAgICB9XG4gIH1dKSwgZTtcbn0oKTtcbmF1KHl3LCBcIkVQU1wiLCAxZS00KTtcbnZhciBoZCA9IGZ1bmN0aW9uKHQpIHtcbiAgdmFyIG4gPSBPYmplY3Qua2V5cyh0KS5yZWR1Y2UoZnVuY3Rpb24ociwgaSkge1xuICAgIHJldHVybiBXdChXdCh7fSwgciksIHt9LCBhdSh7fSwgaSwgeXcuY3JlYXRlKHRbaV0pKSk7XG4gIH0sIHt9KTtcbiAgcmV0dXJuIFd0KFd0KHt9LCBuKSwge30sIHtcbiAgICBhcHBseTogZnVuY3Rpb24oaSkge1xuICAgICAgdmFyIG8gPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHZvaWQgMCA/IGFyZ3VtZW50c1sxXSA6IHt9LCBhID0gby5iYW5kQXdhcmUsIHMgPSBvLnBvc2l0aW9uO1xuICAgICAgcmV0dXJuIE5WKGksIGZ1bmN0aW9uKHUsIGMpIHtcbiAgICAgICAgcmV0dXJuIG5bY10uYXBwbHkodSwge1xuICAgICAgICAgIGJhbmRBd2FyZTogYSxcbiAgICAgICAgICBwb3NpdGlvbjogc1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgaXNJblJhbmdlOiBmdW5jdGlvbihpKSB7XG4gICAgICByZXR1cm4gZHcoaSwgZnVuY3Rpb24obywgYSkge1xuICAgICAgICByZXR1cm4gblthXS5pc0luUmFuZ2Uobyk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xufTtcbmZ1bmN0aW9uIHk1KGUpIHtcbiAgcmV0dXJuIChlICUgMTgwICsgMTgwKSAlIDE4MDtcbn1cbnZhciBiNSA9IGZ1bmN0aW9uKHQpIHtcbiAgdmFyIG4gPSB0LndpZHRoLCByID0gdC5oZWlnaHQsIGkgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHZvaWQgMCA/IGFyZ3VtZW50c1sxXSA6IDAsIG8gPSB5NShpKSwgYSA9IG8gKiBNYXRoLlBJIC8gMTgwLCBzID0gTWF0aC5hdGFuKHIgLyBuKSwgdSA9IGEgPiBzICYmIGEgPCBNYXRoLlBJIC0gcyA/IHIgLyBNYXRoLnNpbihhKSA6IG4gLyBNYXRoLmNvcyhhKTtcbiAgcmV0dXJuIE1hdGguYWJzKHUpO1xufSwgdzUgPSBIbiwgeDUgPSBIbywgUzUgPSBXcztcbmZ1bmN0aW9uICQ1KGUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHQsIG4sIHIpIHtcbiAgICB2YXIgaSA9IE9iamVjdCh0KTtcbiAgICBpZiAoIXg1KHQpKSB7XG4gICAgICB2YXIgbyA9IHc1KG4pO1xuICAgICAgdCA9IFM1KHQpLCBuID0gZnVuY3Rpb24ocykge1xuICAgICAgICByZXR1cm4gbyhpW3NdLCBzLCBpKTtcbiAgICAgIH07XG4gICAgfVxuICAgIHZhciBhID0gZSh0LCBuLCByKTtcbiAgICByZXR1cm4gYSA+IC0xID8gaVtvID8gdFthXSA6IGFdIDogdm9pZCAwO1xuICB9O1xufVxudmFyIE81ID0gJDUsIF81ID0gdXc7XG5mdW5jdGlvbiBBNShlKSB7XG4gIHZhciB0ID0gXzUoZSksIG4gPSB0ICUgMTtcbiAgcmV0dXJuIHQgPT09IHQgPyBuID8gdCAtIG4gOiB0IDogMDtcbn1cbnZhciBQNSA9IEE1LCBDNSA9IFRiLCBFNSA9IEhuLCBUNSA9IFA1LCBNNSA9IE1hdGgubWF4O1xuZnVuY3Rpb24gUjUoZSwgdCwgbikge1xuICB2YXIgciA9IGUgPT0gbnVsbCA/IDAgOiBlLmxlbmd0aDtcbiAgaWYgKCFyKVxuICAgIHJldHVybiAtMTtcbiAgdmFyIGkgPSBuID09IG51bGwgPyAwIDogVDUobik7XG4gIHJldHVybiBpIDwgMCAmJiAoaSA9IE01KHIgKyBpLCAwKSksIEM1KGUsIEU1KHQpLCBpKTtcbn1cbnZhciBJNSA9IFI1LCBqNSA9IE81LCBrNSA9IEk1LCBENSA9IGo1KGs1KSwgTjUgPSBENTtcbmNvbnN0IEY1ID0gLyogQF9fUFVSRV9fICovIGplKE41KTtcbnZhciBMNSA9IFpQKGZ1bmN0aW9uKGUpIHtcbiAgcmV0dXJuIHtcbiAgICB4OiBlLmxlZnQsXG4gICAgeTogZS50b3AsXG4gICAgd2lkdGg6IGUud2lkdGgsXG4gICAgaGVpZ2h0OiBlLmhlaWdodFxuICB9O1xufSwgZnVuY3Rpb24oZSkge1xuICByZXR1cm4gW1wibFwiLCBlLmxlZnQsIFwidFwiLCBlLnRvcCwgXCJ3XCIsIGUud2lkdGgsIFwiaFwiLCBlLmhlaWdodF0uam9pbihcIlwiKTtcbn0pO1xuZnVuY3Rpb24gQXMoZSkge1xuICBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7XG4gIHJldHVybiBBcyA9IHR5cGVvZiBTeW1ib2wgPT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uKHQpIHtcbiAgICByZXR1cm4gdHlwZW9mIHQ7XG4gIH0gOiBmdW5jdGlvbih0KSB7XG4gICAgcmV0dXJuIHQgJiYgdHlwZW9mIFN5bWJvbCA9PSBcImZ1bmN0aW9uXCIgJiYgdC5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIHQgIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIHQ7XG4gIH0sIEFzKGUpO1xufVxudmFyIGdkID0gLyogQF9fUFVSRV9fICovIFp0KHZvaWQgMCksIHZkID0gLyogQF9fUFVSRV9fICovIFp0KHZvaWQgMCksIGJ3ID0gLyogQF9fUFVSRV9fICovIFp0KHZvaWQgMCksIHd3ID0gLyogQF9fUFVSRV9fICovIFp0KHt9KSwgeHcgPSAvKiBAX19QVVJFX18gKi8gWnQodm9pZCAwKSwgU3cgPSAvKiBAX19QVVJFX18gKi8gWnQoMCksICR3ID0gLyogQF9fUFVSRV9fICovIFp0KDApLCBEdiA9IGZ1bmN0aW9uKHQpIHtcbiAgdmFyIG4gPSB0LnN0YXRlLCByID0gbi54QXhpc01hcCwgaSA9IG4ueUF4aXNNYXAsIG8gPSBuLm9mZnNldCwgYSA9IHQuY2xpcFBhdGhJZCwgcyA9IHQuY2hpbGRyZW4sIHUgPSB0LndpZHRoLCBjID0gdC5oZWlnaHQsIGYgPSBMNShvKTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBQLmNyZWF0ZUVsZW1lbnQoZ2QuUHJvdmlkZXIsIHtcbiAgICB2YWx1ZTogclxuICB9LCAvKiBAX19QVVJFX18gKi8gUC5jcmVhdGVFbGVtZW50KHZkLlByb3ZpZGVyLCB7XG4gICAgdmFsdWU6IGlcbiAgfSwgLyogQF9fUFVSRV9fICovIFAuY3JlYXRlRWxlbWVudCh3dy5Qcm92aWRlciwge1xuICAgIHZhbHVlOiBvXG4gIH0sIC8qIEBfX1BVUkVfXyAqLyBQLmNyZWF0ZUVsZW1lbnQoYncuUHJvdmlkZXIsIHtcbiAgICB2YWx1ZTogZlxuICB9LCAvKiBAX19QVVJFX18gKi8gUC5jcmVhdGVFbGVtZW50KHh3LlByb3ZpZGVyLCB7XG4gICAgdmFsdWU6IGFcbiAgfSwgLyogQF9fUFVSRV9fICovIFAuY3JlYXRlRWxlbWVudChTdy5Qcm92aWRlciwge1xuICAgIHZhbHVlOiBjXG4gIH0sIC8qIEBfX1BVUkVfXyAqLyBQLmNyZWF0ZUVsZW1lbnQoJHcuUHJvdmlkZXIsIHtcbiAgICB2YWx1ZTogdVxuICB9LCBzKSkpKSkpKTtcbn0sIEI1ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBOdCh4dyk7XG59O1xuZnVuY3Rpb24gT3coZSkge1xuICB2YXIgdCA9IE9iamVjdC5rZXlzKGUpO1xuICByZXR1cm4gdC5sZW5ndGggPT09IDAgPyBcIlRoZXJlIGFyZSBubyBhdmFpbGFibGUgaWRzLlwiIDogXCJBdmFpbGFibGUgaWRzIGFyZTogXCIuY29uY2F0KHQsIFwiLlwiKTtcbn1cbnZhciBfdyA9IGZ1bmN0aW9uKHQpIHtcbiAgdmFyIG4gPSBOdChnZCk7XG4gIG4gPT0gbnVsbCAmJiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gZ3QoITEsIFwiQ291bGQgbm90IGZpbmQgUmVjaGFydHMgY29udGV4dDsgYXJlIHlvdSBzdXJlIHRoaXMgaXMgcmVuZGVyZWQgaW5zaWRlIGEgUmVjaGFydHMgd3JhcHBlciBjb21wb25lbnQ/XCIpIDogZ3QoKSk7XG4gIHZhciByID0gblt0XTtcbiAgcmV0dXJuIHIgPT0gbnVsbCAmJiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gZ3QoITEsICdDb3VsZCBub3QgZmluZCB4QXhpcyBieSBpZCBcIicuY29uY2F0KHQsICdcIiBbJykuY29uY2F0KEFzKHQpLCBcIl0uIFwiKS5jb25jYXQoT3cobikpKSA6IGd0KCkpLCByO1xufSwgejUgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHQgPSBOdChnZCk7XG4gIHJldHVybiBrbih0KTtcbn0sIFY1ID0gZnVuY3Rpb24oKSB7XG4gIHZhciB0ID0gTnQodmQpLCBuID0gRjUodCwgZnVuY3Rpb24ocikge1xuICAgIHJldHVybiBkdyhyLmRvbWFpbiwgTnVtYmVyLmlzRmluaXRlKTtcbiAgfSk7XG4gIHJldHVybiBuIHx8IGtuKHQpO1xufSwgQXcgPSBmdW5jdGlvbih0KSB7XG4gIHZhciBuID0gTnQodmQpO1xuICBuID09IG51bGwgJiYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGd0KCExLCBcIkNvdWxkIG5vdCBmaW5kIFJlY2hhcnRzIGNvbnRleHQ7IGFyZSB5b3Ugc3VyZSB0aGlzIGlzIHJlbmRlcmVkIGluc2lkZSBhIFJlY2hhcnRzIHdyYXBwZXIgY29tcG9uZW50P1wiKSA6IGd0KCkpO1xuICB2YXIgciA9IG5bdF07XG4gIHJldHVybiByID09IG51bGwgJiYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGd0KCExLCAnQ291bGQgbm90IGZpbmQgeUF4aXMgYnkgaWQgXCInLmNvbmNhdCh0LCAnXCIgWycpLmNvbmNhdChBcyh0KSwgXCJdLiBcIikuY29uY2F0KE93KG4pKSkgOiBndCgpKSwgcjtcbn0sIEc1ID0gZnVuY3Rpb24oKSB7XG4gIHZhciB0ID0gTnQoYncpO1xuICByZXR1cm4gdDtcbn0sIFc1ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBOdCh3dyk7XG59LCBtZCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gTnQoJHcpO1xufSwgeWQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIE50KFN3KTtcbn07XG5mdW5jdGlvbiBSbyhlKSB7XG4gIFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjtcbiAgcmV0dXJuIFJvID0gdHlwZW9mIFN5bWJvbCA9PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PSBcInN5bWJvbFwiID8gZnVuY3Rpb24odCkge1xuICAgIHJldHVybiB0eXBlb2YgdDtcbiAgfSA6IGZ1bmN0aW9uKHQpIHtcbiAgICByZXR1cm4gdCAmJiB0eXBlb2YgU3ltYm9sID09IFwiZnVuY3Rpb25cIiAmJiB0LmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgdCAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2YgdDtcbiAgfSwgUm8oZSk7XG59XG5mdW5jdGlvbiBOdihlLCB0KSB7XG4gIHZhciBuID0gT2JqZWN0LmtleXMoZSk7XG4gIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gICAgdmFyIHIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGUpO1xuICAgIHQgJiYgKHIgPSByLmZpbHRlcihmdW5jdGlvbihpKSB7XG4gICAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLCBpKS5lbnVtZXJhYmxlO1xuICAgIH0pKSwgbi5wdXNoLmFwcGx5KG4sIHIpO1xuICB9XG4gIHJldHVybiBuO1xufVxuZnVuY3Rpb24gRnYoZSkge1xuICBmb3IgKHZhciB0ID0gMTsgdCA8IGFyZ3VtZW50cy5sZW5ndGg7IHQrKykge1xuICAgIHZhciBuID0gYXJndW1lbnRzW3RdICE9IG51bGwgPyBhcmd1bWVudHNbdF0gOiB7fTtcbiAgICB0ICUgMiA/IE52KE9iamVjdChuKSwgITApLmZvckVhY2goZnVuY3Rpb24ocikge1xuICAgICAgVTUoZSwgciwgbltyXSk7XG4gICAgfSkgOiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGUsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKG4pKSA6IE52KE9iamVjdChuKSkuZm9yRWFjaChmdW5jdGlvbihyKSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgciwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihuLCByKSk7XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIGU7XG59XG5mdW5jdGlvbiBVNShlLCB0LCBuKSB7XG4gIHJldHVybiB0ID0gSDUodCksIHQgaW4gZSA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCB0LCB7IHZhbHVlOiBuLCBlbnVtZXJhYmxlOiAhMCwgY29uZmlndXJhYmxlOiAhMCwgd3JpdGFibGU6ICEwIH0pIDogZVt0XSA9IG4sIGU7XG59XG5mdW5jdGlvbiBINShlKSB7XG4gIHZhciB0ID0gcTUoZSwgXCJzdHJpbmdcIik7XG4gIHJldHVybiBSbyh0KSA9PSBcInN5bWJvbFwiID8gdCA6IFN0cmluZyh0KTtcbn1cbmZ1bmN0aW9uIHE1KGUsIHQpIHtcbiAgaWYgKFJvKGUpICE9IFwib2JqZWN0XCIgfHwgIWUpXG4gICAgcmV0dXJuIGU7XG4gIHZhciBuID0gZVtTeW1ib2wudG9QcmltaXRpdmVdO1xuICBpZiAobiAhPT0gdm9pZCAwKSB7XG4gICAgdmFyIHIgPSBuLmNhbGwoZSwgdCB8fCBcImRlZmF1bHRcIik7XG4gICAgaWYgKFJvKHIpICE9IFwib2JqZWN0XCIpXG4gICAgICByZXR1cm4gcjtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQEB0b1ByaW1pdGl2ZSBtdXN0IHJldHVybiBhIHByaW1pdGl2ZSB2YWx1ZS5cIik7XG4gIH1cbiAgcmV0dXJuICh0ID09PSBcInN0cmluZ1wiID8gU3RyaW5nIDogTnVtYmVyKShlKTtcbn1cbmZ1bmN0aW9uIEs1KGUsIHQpIHtcbiAgcmV0dXJuIEo1KGUpIHx8IFo1KGUsIHQpIHx8IFg1KGUsIHQpIHx8IFk1KCk7XG59XG5mdW5jdGlvbiBZNSgpIHtcbiAgdGhyb3cgbmV3IFR5cGVFcnJvcihgSW52YWxpZCBhdHRlbXB0IHRvIGRlc3RydWN0dXJlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5gKTtcbn1cbmZ1bmN0aW9uIFg1KGUsIHQpIHtcbiAgaWYgKGUpIHtcbiAgICBpZiAodHlwZW9mIGUgPT0gXCJzdHJpbmdcIilcbiAgICAgIHJldHVybiBMdihlLCB0KTtcbiAgICB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChlKS5zbGljZSg4LCAtMSk7XG4gICAgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgZS5jb25zdHJ1Y3RvciAmJiAobiA9IGUuY29uc3RydWN0b3IubmFtZSksIG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIilcbiAgICAgIHJldHVybiBBcnJheS5mcm9tKGUpO1xuICAgIGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKVxuICAgICAgcmV0dXJuIEx2KGUsIHQpO1xuICB9XG59XG5mdW5jdGlvbiBMdihlLCB0KSB7XG4gICh0ID09IG51bGwgfHwgdCA+IGUubGVuZ3RoKSAmJiAodCA9IGUubGVuZ3RoKTtcbiAgZm9yICh2YXIgbiA9IDAsIHIgPSBuZXcgQXJyYXkodCk7IG4gPCB0OyBuKyspXG4gICAgcltuXSA9IGVbbl07XG4gIHJldHVybiByO1xufVxuZnVuY3Rpb24gWjUoZSwgdCkge1xuICB2YXIgbiA9IGUgPT0gbnVsbCA/IG51bGwgOiB0eXBlb2YgU3ltYm9sIDwgXCJ1XCIgJiYgZVtTeW1ib2wuaXRlcmF0b3JdIHx8IGVbXCJAQGl0ZXJhdG9yXCJdO1xuICBpZiAobiAhPSBudWxsKSB7XG4gICAgdmFyIHIsIGksIG8sIGEsIHMgPSBbXSwgdSA9ICEwLCBjID0gITE7XG4gICAgdHJ5IHtcbiAgICAgIGlmIChvID0gKG4gPSBuLmNhbGwoZSkpLm5leHQsIHQgIT09IDApXG4gICAgICAgIGZvciAoOyAhKHUgPSAociA9IG8uY2FsbChuKSkuZG9uZSkgJiYgKHMucHVzaChyLnZhbHVlKSwgcy5sZW5ndGggIT09IHQpOyB1ID0gITApXG4gICAgICAgICAgO1xuICAgIH0gY2F0Y2ggKGYpIHtcbiAgICAgIGMgPSAhMCwgaSA9IGY7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmICghdSAmJiBuLnJldHVybiAhPSBudWxsICYmIChhID0gbi5yZXR1cm4oKSwgT2JqZWN0KGEpICE9PSBhKSlcbiAgICAgICAgICByZXR1cm47XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBpZiAoYylcbiAgICAgICAgICB0aHJvdyBpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcztcbiAgfVxufVxuZnVuY3Rpb24gSjUoZSkge1xuICBpZiAoQXJyYXkuaXNBcnJheShlKSlcbiAgICByZXR1cm4gZTtcbn1cbmZ1bmN0aW9uIGtsKCkge1xuICByZXR1cm4ga2wgPSBPYmplY3QuYXNzaWduID8gT2JqZWN0LmFzc2lnbi5iaW5kKCkgOiBmdW5jdGlvbihlKSB7XG4gICAgZm9yICh2YXIgdCA9IDE7IHQgPCBhcmd1bWVudHMubGVuZ3RoOyB0KyspIHtcbiAgICAgIHZhciBuID0gYXJndW1lbnRzW3RdO1xuICAgICAgZm9yICh2YXIgciBpbiBuKVxuICAgICAgICBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobiwgcikgJiYgKGVbcl0gPSBuW3JdKTtcbiAgICB9XG4gICAgcmV0dXJuIGU7XG4gIH0sIGtsLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG52YXIgUTUgPSBmdW5jdGlvbih0LCBuKSB7XG4gIHZhciByO1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIFAuaXNWYWxpZEVsZW1lbnQodCkgPyByID0gLyogQF9fUFVSRV9fICovIFAuY2xvbmVFbGVtZW50KHQsIG4pIDogcGUodCkgPyByID0gdChuKSA6IHIgPSAvKiBAX19QVVJFX18gKi8gUC5jcmVhdGVFbGVtZW50KFwibGluZVwiLCBrbCh7fSwgbiwge1xuICAgIGNsYXNzTmFtZTogXCJyZWNoYXJ0cy1yZWZlcmVuY2UtbGluZS1saW5lXCJcbiAgfSkpLCByO1xufSwgZUcgPSBmdW5jdGlvbih0LCBuLCByLCBpLCBvLCBhLCBzLCB1LCBjKSB7XG4gIHZhciBmID0gby54LCBsID0gby55LCBkID0gby53aWR0aCwgcCA9IG8uaGVpZ2h0O1xuICBpZiAocikge1xuICAgIHZhciBnID0gYy55LCBoID0gdC55LmFwcGx5KGcsIHtcbiAgICAgIHBvc2l0aW9uOiBhXG4gICAgfSk7XG4gICAgaWYgKHNuKGMsIFwiZGlzY2FyZFwiKSAmJiAhdC55LmlzSW5SYW5nZShoKSlcbiAgICAgIHJldHVybiBudWxsO1xuICAgIHZhciB2ID0gW3tcbiAgICAgIHg6IGYgKyBkLFxuICAgICAgeTogaFxuICAgIH0sIHtcbiAgICAgIHg6IGYsXG4gICAgICB5OiBoXG4gICAgfV07XG4gICAgcmV0dXJuIHUgPT09IFwibGVmdFwiID8gdi5yZXZlcnNlKCkgOiB2O1xuICB9XG4gIGlmIChuKSB7XG4gICAgdmFyIHcgPSBjLngsIGIgPSB0LnguYXBwbHkodywge1xuICAgICAgcG9zaXRpb246IGFcbiAgICB9KTtcbiAgICBpZiAoc24oYywgXCJkaXNjYXJkXCIpICYmICF0LnguaXNJblJhbmdlKGIpKVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgdmFyIHggPSBbe1xuICAgICAgeDogYixcbiAgICAgIHk6IGwgKyBwXG4gICAgfSwge1xuICAgICAgeDogYixcbiAgICAgIHk6IGxcbiAgICB9XTtcbiAgICByZXR1cm4gcyA9PT0gXCJ0b3BcIiA/IHgucmV2ZXJzZSgpIDogeDtcbiAgfVxuICBpZiAoaSkge1xuICAgIHZhciBtID0gYy5zZWdtZW50LCB5ID0gbS5tYXAoZnVuY3Rpb24oUykge1xuICAgICAgcmV0dXJuIHQuYXBwbHkoUywge1xuICAgICAgICBwb3NpdGlvbjogYVxuICAgICAgfSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHNuKGMsIFwiZGlzY2FyZFwiKSAmJiBFVih5LCBmdW5jdGlvbihTKSB7XG4gICAgICByZXR1cm4gIXQuaXNJblJhbmdlKFMpO1xuICAgIH0pID8gbnVsbCA6IHk7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59O1xuZnVuY3Rpb24gYmQoZSkge1xuICB2YXIgdCA9IGUueCwgbiA9IGUueSwgciA9IGUuc2VnbWVudCwgaSA9IGUueEF4aXNJZCwgbyA9IGUueUF4aXNJZCwgYSA9IGUuc2hhcGUsIHMgPSBlLmNsYXNzTmFtZSwgdSA9IGUuYWx3YXlzU2hvdywgYyA9IEI1KCksIGYgPSBfdyhpKSwgbCA9IEF3KG8pLCBkID0gRzUoKTtcbiAgaWYgKCFjIHx8ICFkKVxuICAgIHJldHVybiBudWxsO1xuICBGcih1ID09PSB2b2lkIDAsICdUaGUgYWx3YXlzU2hvdyBwcm9wIGlzIGRlcHJlY2F0ZWQuIFBsZWFzZSB1c2UgaWZPdmVyZmxvdz1cImV4dGVuZERvbWFpblwiIGluc3RlYWQuJyk7XG4gIHZhciBwID0gaGQoe1xuICAgIHg6IGYuc2NhbGUsXG4gICAgeTogbC5zY2FsZVxuICB9KSwgZyA9IEtlKHQpLCBoID0gS2UobiksIHYgPSByICYmIHIubGVuZ3RoID09PSAyLCB3ID0gZUcocCwgZywgaCwgdiwgZCwgZS5wb3NpdGlvbiwgZi5vcmllbnRhdGlvbiwgbC5vcmllbnRhdGlvbiwgZSk7XG4gIGlmICghdylcbiAgICByZXR1cm4gbnVsbDtcbiAgdmFyIGIgPSBLNSh3LCAyKSwgeCA9IGJbMF0sIG0gPSB4LngsIHkgPSB4LnksIFMgPSBiWzFdLCAkID0gUy54LCBPID0gUy55LCBUID0gc24oZSwgXCJoaWRkZW5cIikgPyBcInVybCgjXCIuY29uY2F0KGMsIFwiKVwiKSA6IHZvaWQgMCwgTSA9IEZ2KEZ2KHtcbiAgICBjbGlwUGF0aDogVFxuICB9LCB5ZShlLCAhMCkpLCB7fSwge1xuICAgIHgxOiBtLFxuICAgIHkxOiB5LFxuICAgIHgyOiAkLFxuICAgIHkyOiBPXG4gIH0pO1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIFAuY3JlYXRlRWxlbWVudChXZSwge1xuICAgIGNsYXNzTmFtZTogJGUoXCJyZWNoYXJ0cy1yZWZlcmVuY2UtbGluZVwiLCBzKVxuICB9LCBRNShhLCBNKSwgYXQucmVuZGVyQ2FsbEJ5UGFyZW50KGUsIG01KHtcbiAgICB4MTogbSxcbiAgICB5MTogeSxcbiAgICB4MjogJCxcbiAgICB5MjogT1xuICB9KSkpO1xufVxuYmQuZGlzcGxheU5hbWUgPSBcIlJlZmVyZW5jZUxpbmVcIjtcbmJkLmRlZmF1bHRQcm9wcyA9IHtcbiAgaXNGcm9udDogITEsXG4gIGlmT3ZlcmZsb3c6IFwiZGlzY2FyZFwiLFxuICB4QXhpc0lkOiAwLFxuICB5QXhpc0lkOiAwLFxuICBmaWxsOiBcIm5vbmVcIixcbiAgc3Ryb2tlOiBcIiNjY2NcIixcbiAgZmlsbE9wYWNpdHk6IDEsXG4gIHN0cm9rZVdpZHRoOiAxLFxuICBwb3NpdGlvbjogXCJtaWRkbGVcIlxufTtcbmZ1bmN0aW9uIElvKGUpIHtcbiAgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiO1xuICByZXR1cm4gSW8gPSB0eXBlb2YgU3ltYm9sID09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09IFwic3ltYm9sXCIgPyBmdW5jdGlvbih0KSB7XG4gICAgcmV0dXJuIHR5cGVvZiB0O1xuICB9IDogZnVuY3Rpb24odCkge1xuICAgIHJldHVybiB0ICYmIHR5cGVvZiBTeW1ib2wgPT0gXCJmdW5jdGlvblwiICYmIHQuY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiB0ICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiB0O1xuICB9LCBJbyhlKTtcbn1cbmZ1bmN0aW9uIERsKCkge1xuICByZXR1cm4gRGwgPSBPYmplY3QuYXNzaWduID8gT2JqZWN0LmFzc2lnbi5iaW5kKCkgOiBmdW5jdGlvbihlKSB7XG4gICAgZm9yICh2YXIgdCA9IDE7IHQgPCBhcmd1bWVudHMubGVuZ3RoOyB0KyspIHtcbiAgICAgIHZhciBuID0gYXJndW1lbnRzW3RdO1xuICAgICAgZm9yICh2YXIgciBpbiBuKVxuICAgICAgICBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobiwgcikgJiYgKGVbcl0gPSBuW3JdKTtcbiAgICB9XG4gICAgcmV0dXJuIGU7XG4gIH0sIERsLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5mdW5jdGlvbiBCdihlLCB0KSB7XG4gIHZhciBuID0gT2JqZWN0LmtleXMoZSk7XG4gIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gICAgdmFyIHIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGUpO1xuICAgIHQgJiYgKHIgPSByLmZpbHRlcihmdW5jdGlvbihpKSB7XG4gICAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLCBpKS5lbnVtZXJhYmxlO1xuICAgIH0pKSwgbi5wdXNoLmFwcGx5KG4sIHIpO1xuICB9XG4gIHJldHVybiBuO1xufVxuZnVuY3Rpb24genYoZSkge1xuICBmb3IgKHZhciB0ID0gMTsgdCA8IGFyZ3VtZW50cy5sZW5ndGg7IHQrKykge1xuICAgIHZhciBuID0gYXJndW1lbnRzW3RdICE9IG51bGwgPyBhcmd1bWVudHNbdF0gOiB7fTtcbiAgICB0ICUgMiA/IEJ2KE9iamVjdChuKSwgITApLmZvckVhY2goZnVuY3Rpb24ocikge1xuICAgICAgdEcoZSwgciwgbltyXSk7XG4gICAgfSkgOiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGUsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKG4pKSA6IEJ2KE9iamVjdChuKSkuZm9yRWFjaChmdW5jdGlvbihyKSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgciwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihuLCByKSk7XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIGU7XG59XG5mdW5jdGlvbiB0RyhlLCB0LCBuKSB7XG4gIHJldHVybiB0ID0gbkcodCksIHQgaW4gZSA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCB0LCB7IHZhbHVlOiBuLCBlbnVtZXJhYmxlOiAhMCwgY29uZmlndXJhYmxlOiAhMCwgd3JpdGFibGU6ICEwIH0pIDogZVt0XSA9IG4sIGU7XG59XG5mdW5jdGlvbiBuRyhlKSB7XG4gIHZhciB0ID0gckcoZSwgXCJzdHJpbmdcIik7XG4gIHJldHVybiBJbyh0KSA9PSBcInN5bWJvbFwiID8gdCA6IFN0cmluZyh0KTtcbn1cbmZ1bmN0aW9uIHJHKGUsIHQpIHtcbiAgaWYgKElvKGUpICE9IFwib2JqZWN0XCIgfHwgIWUpXG4gICAgcmV0dXJuIGU7XG4gIHZhciBuID0gZVtTeW1ib2wudG9QcmltaXRpdmVdO1xuICBpZiAobiAhPT0gdm9pZCAwKSB7XG4gICAgdmFyIHIgPSBuLmNhbGwoZSwgdCB8fCBcImRlZmF1bHRcIik7XG4gICAgaWYgKElvKHIpICE9IFwib2JqZWN0XCIpXG4gICAgICByZXR1cm4gcjtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQEB0b1ByaW1pdGl2ZSBtdXN0IHJldHVybiBhIHByaW1pdGl2ZSB2YWx1ZS5cIik7XG4gIH1cbiAgcmV0dXJuICh0ID09PSBcInN0cmluZ1wiID8gU3RyaW5nIDogTnVtYmVyKShlKTtcbn1cbnZhciBpRyA9IGZ1bmN0aW9uKHQpIHtcbiAgdmFyIG4gPSB0LngsIHIgPSB0LnksIGkgPSB0LnhBeGlzLCBvID0gdC55QXhpcywgYSA9IGhkKHtcbiAgICB4OiBpLnNjYWxlLFxuICAgIHk6IG8uc2NhbGVcbiAgfSksIHMgPSBhLmFwcGx5KHtcbiAgICB4OiBuLFxuICAgIHk6IHJcbiAgfSwge1xuICAgIGJhbmRBd2FyZTogITBcbiAgfSk7XG4gIHJldHVybiBzbih0LCBcImRpc2NhcmRcIikgJiYgIWEuaXNJblJhbmdlKHMpID8gbnVsbCA6IHM7XG59O1xuZnVuY3Rpb24gUW8oZSkge1xuICB2YXIgdCA9IGUueCwgbiA9IGUueSwgciA9IGUuciwgaSA9IGUuYWx3YXlzU2hvdywgbyA9IGUuY2xpcFBhdGhJZCwgYSA9IEtlKHQpLCBzID0gS2Uobik7XG4gIGlmIChGcihpID09PSB2b2lkIDAsICdUaGUgYWx3YXlzU2hvdyBwcm9wIGlzIGRlcHJlY2F0ZWQuIFBsZWFzZSB1c2UgaWZPdmVyZmxvdz1cImV4dGVuZERvbWFpblwiIGluc3RlYWQuJyksICFhIHx8ICFzKVxuICAgIHJldHVybiBudWxsO1xuICB2YXIgdSA9IGlHKGUpO1xuICBpZiAoIXUpXG4gICAgcmV0dXJuIG51bGw7XG4gIHZhciBjID0gdS54LCBmID0gdS55LCBsID0gZS5zaGFwZSwgZCA9IGUuY2xhc3NOYW1lLCBwID0gc24oZSwgXCJoaWRkZW5cIikgPyBcInVybCgjXCIuY29uY2F0KG8sIFwiKVwiKSA6IHZvaWQgMCwgZyA9IHp2KHp2KHtcbiAgICBjbGlwUGF0aDogcFxuICB9LCB5ZShlLCAhMCkpLCB7fSwge1xuICAgIGN4OiBjLFxuICAgIGN5OiBmXG4gIH0pO1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIFAuY3JlYXRlRWxlbWVudChXZSwge1xuICAgIGNsYXNzTmFtZTogJGUoXCJyZWNoYXJ0cy1yZWZlcmVuY2UtZG90XCIsIGQpXG4gIH0sIFFvLnJlbmRlckRvdChsLCBnKSwgYXQucmVuZGVyQ2FsbEJ5UGFyZW50KGUsIHtcbiAgICB4OiBjIC0gcixcbiAgICB5OiBmIC0gcixcbiAgICB3aWR0aDogMiAqIHIsXG4gICAgaGVpZ2h0OiAyICogclxuICB9KSk7XG59XG5Rby5kaXNwbGF5TmFtZSA9IFwiUmVmZXJlbmNlRG90XCI7XG5Rby5kZWZhdWx0UHJvcHMgPSB7XG4gIGlzRnJvbnQ6ICExLFxuICBpZk92ZXJmbG93OiBcImRpc2NhcmRcIixcbiAgeEF4aXNJZDogMCxcbiAgeUF4aXNJZDogMCxcbiAgcjogMTAsXG4gIGZpbGw6IFwiI2ZmZlwiLFxuICBzdHJva2U6IFwiI2NjY1wiLFxuICBmaWxsT3BhY2l0eTogMSxcbiAgc3Ryb2tlV2lkdGg6IDFcbn07XG5Rby5yZW5kZXJEb3QgPSBmdW5jdGlvbihlLCB0KSB7XG4gIHZhciBuO1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIFAuaXNWYWxpZEVsZW1lbnQoZSkgPyBuID0gLyogQF9fUFVSRV9fICovIFAuY2xvbmVFbGVtZW50KGUsIHQpIDogcGUoZSkgPyBuID0gZSh0KSA6IG4gPSAvKiBAX19QVVJFX18gKi8gUC5jcmVhdGVFbGVtZW50KHBkLCBEbCh7fSwgdCwge1xuICAgIGN4OiB0LmN4LFxuICAgIGN5OiB0LmN5LFxuICAgIGNsYXNzTmFtZTogXCJyZWNoYXJ0cy1yZWZlcmVuY2UtZG90LWRvdFwiXG4gIH0pKSwgbjtcbn07XG5mdW5jdGlvbiBqbyhlKSB7XG4gIFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjtcbiAgcmV0dXJuIGpvID0gdHlwZW9mIFN5bWJvbCA9PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PSBcInN5bWJvbFwiID8gZnVuY3Rpb24odCkge1xuICAgIHJldHVybiB0eXBlb2YgdDtcbiAgfSA6IGZ1bmN0aW9uKHQpIHtcbiAgICByZXR1cm4gdCAmJiB0eXBlb2YgU3ltYm9sID09IFwiZnVuY3Rpb25cIiAmJiB0LmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgdCAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2YgdDtcbiAgfSwgam8oZSk7XG59XG5mdW5jdGlvbiBObCgpIHtcbiAgcmV0dXJuIE5sID0gT2JqZWN0LmFzc2lnbiA/IE9iamVjdC5hc3NpZ24uYmluZCgpIDogZnVuY3Rpb24oZSkge1xuICAgIGZvciAodmFyIHQgPSAxOyB0IDwgYXJndW1lbnRzLmxlbmd0aDsgdCsrKSB7XG4gICAgICB2YXIgbiA9IGFyZ3VtZW50c1t0XTtcbiAgICAgIGZvciAodmFyIHIgaW4gbilcbiAgICAgICAgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG4sIHIpICYmIChlW3JdID0gbltyXSk7XG4gICAgfVxuICAgIHJldHVybiBlO1xuICB9LCBObC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuZnVuY3Rpb24gVnYoZSwgdCkge1xuICB2YXIgbiA9IE9iamVjdC5rZXlzKGUpO1xuICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykge1xuICAgIHZhciByID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhlKTtcbiAgICB0ICYmIChyID0gci5maWx0ZXIoZnVuY3Rpb24oaSkge1xuICAgICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSwgaSkuZW51bWVyYWJsZTtcbiAgICB9KSksIG4ucHVzaC5hcHBseShuLCByKTtcbiAgfVxuICByZXR1cm4gbjtcbn1cbmZ1bmN0aW9uIEd2KGUpIHtcbiAgZm9yICh2YXIgdCA9IDE7IHQgPCBhcmd1bWVudHMubGVuZ3RoOyB0KyspIHtcbiAgICB2YXIgbiA9IGFyZ3VtZW50c1t0XSAhPSBudWxsID8gYXJndW1lbnRzW3RdIDoge307XG4gICAgdCAlIDIgPyBWdihPYmplY3QobiksICEwKS5mb3JFYWNoKGZ1bmN0aW9uKHIpIHtcbiAgICAgIG9HKGUsIHIsIG5bcl0pO1xuICAgIH0pIDogT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhlLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhuKSkgOiBWdihPYmplY3QobikpLmZvckVhY2goZnVuY3Rpb24ocikge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIHIsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobiwgcikpO1xuICAgIH0pO1xuICB9XG4gIHJldHVybiBlO1xufVxuZnVuY3Rpb24gb0coZSwgdCwgbikge1xuICByZXR1cm4gdCA9IGFHKHQpLCB0IGluIGUgPyBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgdCwgeyB2YWx1ZTogbiwgZW51bWVyYWJsZTogITAsIGNvbmZpZ3VyYWJsZTogITAsIHdyaXRhYmxlOiAhMCB9KSA6IGVbdF0gPSBuLCBlO1xufVxuZnVuY3Rpb24gYUcoZSkge1xuICB2YXIgdCA9IHNHKGUsIFwic3RyaW5nXCIpO1xuICByZXR1cm4gam8odCkgPT0gXCJzeW1ib2xcIiA/IHQgOiBTdHJpbmcodCk7XG59XG5mdW5jdGlvbiBzRyhlLCB0KSB7XG4gIGlmIChqbyhlKSAhPSBcIm9iamVjdFwiIHx8ICFlKVxuICAgIHJldHVybiBlO1xuICB2YXIgbiA9IGVbU3ltYm9sLnRvUHJpbWl0aXZlXTtcbiAgaWYgKG4gIT09IHZvaWQgMCkge1xuICAgIHZhciByID0gbi5jYWxsKGUsIHQgfHwgXCJkZWZhdWx0XCIpO1xuICAgIGlmIChqbyhyKSAhPSBcIm9iamVjdFwiKVxuICAgICAgcmV0dXJuIHI7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkBAdG9QcmltaXRpdmUgbXVzdCByZXR1cm4gYSBwcmltaXRpdmUgdmFsdWUuXCIpO1xuICB9XG4gIHJldHVybiAodCA9PT0gXCJzdHJpbmdcIiA/IFN0cmluZyA6IE51bWJlcikoZSk7XG59XG52YXIgdUcgPSBmdW5jdGlvbih0LCBuLCByLCBpLCBvKSB7XG4gIHZhciBhID0gby54MSwgcyA9IG8ueDIsIHUgPSBvLnkxLCBjID0gby55MiwgZiA9IG8ueEF4aXMsIGwgPSBvLnlBeGlzO1xuICBpZiAoIWYgfHwgIWwpXG4gICAgcmV0dXJuIG51bGw7XG4gIHZhciBkID0gaGQoe1xuICAgIHg6IGYuc2NhbGUsXG4gICAgeTogbC5zY2FsZVxuICB9KSwgcCA9IHtcbiAgICB4OiB0ID8gZC54LmFwcGx5KGEsIHtcbiAgICAgIHBvc2l0aW9uOiBcInN0YXJ0XCJcbiAgICB9KSA6IGQueC5yYW5nZU1pbixcbiAgICB5OiByID8gZC55LmFwcGx5KHUsIHtcbiAgICAgIHBvc2l0aW9uOiBcInN0YXJ0XCJcbiAgICB9KSA6IGQueS5yYW5nZU1pblxuICB9LCBnID0ge1xuICAgIHg6IG4gPyBkLnguYXBwbHkocywge1xuICAgICAgcG9zaXRpb246IFwiZW5kXCJcbiAgICB9KSA6IGQueC5yYW5nZU1heCxcbiAgICB5OiBpID8gZC55LmFwcGx5KGMsIHtcbiAgICAgIHBvc2l0aW9uOiBcImVuZFwiXG4gICAgfSkgOiBkLnkucmFuZ2VNYXhcbiAgfTtcbiAgcmV0dXJuIHNuKG8sIFwiZGlzY2FyZFwiKSAmJiAoIWQuaXNJblJhbmdlKHApIHx8ICFkLmlzSW5SYW5nZShnKSkgPyBudWxsIDogbXcocCwgZyk7XG59O1xuZnVuY3Rpb24gZWEoZSkge1xuICB2YXIgdCA9IGUueDEsIG4gPSBlLngyLCByID0gZS55MSwgaSA9IGUueTIsIG8gPSBlLmNsYXNzTmFtZSwgYSA9IGUuYWx3YXlzU2hvdywgcyA9IGUuY2xpcFBhdGhJZDtcbiAgRnIoYSA9PT0gdm9pZCAwLCAnVGhlIGFsd2F5c1Nob3cgcHJvcCBpcyBkZXByZWNhdGVkLiBQbGVhc2UgdXNlIGlmT3ZlcmZsb3c9XCJleHRlbmREb21haW5cIiBpbnN0ZWFkLicpO1xuICB2YXIgdSA9IEtlKHQpLCBjID0gS2UobiksIGYgPSBLZShyKSwgbCA9IEtlKGkpLCBkID0gZS5zaGFwZTtcbiAgaWYgKCF1ICYmICFjICYmICFmICYmICFsICYmICFkKVxuICAgIHJldHVybiBudWxsO1xuICB2YXIgcCA9IHVHKHUsIGMsIGYsIGwsIGUpO1xuICBpZiAoIXAgJiYgIWQpXG4gICAgcmV0dXJuIG51bGw7XG4gIHZhciBnID0gc24oZSwgXCJoaWRkZW5cIikgPyBcInVybCgjXCIuY29uY2F0KHMsIFwiKVwiKSA6IHZvaWQgMDtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBQLmNyZWF0ZUVsZW1lbnQoV2UsIHtcbiAgICBjbGFzc05hbWU6ICRlKFwicmVjaGFydHMtcmVmZXJlbmNlLWFyZWFcIiwgbylcbiAgfSwgZWEucmVuZGVyUmVjdChkLCBHdihHdih7XG4gICAgY2xpcFBhdGg6IGdcbiAgfSwgeWUoZSwgITApKSwgcCkpLCBhdC5yZW5kZXJDYWxsQnlQYXJlbnQoZSwgcCkpO1xufVxuZWEuZGlzcGxheU5hbWUgPSBcIlJlZmVyZW5jZUFyZWFcIjtcbmVhLmRlZmF1bHRQcm9wcyA9IHtcbiAgaXNGcm9udDogITEsXG4gIGlmT3ZlcmZsb3c6IFwiZGlzY2FyZFwiLFxuICB4QXhpc0lkOiAwLFxuICB5QXhpc0lkOiAwLFxuICByOiAxMCxcbiAgZmlsbDogXCIjY2NjXCIsXG4gIGZpbGxPcGFjaXR5OiAwLjUsXG4gIHN0cm9rZTogXCJub25lXCIsXG4gIHN0cm9rZVdpZHRoOiAxXG59O1xuZWEucmVuZGVyUmVjdCA9IGZ1bmN0aW9uKGUsIHQpIHtcbiAgdmFyIG47XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gUC5pc1ZhbGlkRWxlbWVudChlKSA/IG4gPSAvKiBAX19QVVJFX18gKi8gUC5jbG9uZUVsZW1lbnQoZSwgdCkgOiBwZShlKSA/IG4gPSBlKHQpIDogbiA9IC8qIEBfX1BVUkVfXyAqLyBQLmNyZWF0ZUVsZW1lbnQoZGQsIE5sKHt9LCB0LCB7XG4gICAgY2xhc3NOYW1lOiBcInJlY2hhcnRzLXJlZmVyZW5jZS1hcmVhLXJlY3RcIlxuICB9KSksIG47XG59O1xuZnVuY3Rpb24gUHcoZSwgdCwgbikge1xuICBpZiAodCA8IDEpXG4gICAgcmV0dXJuIFtdO1xuICBpZiAodCA9PT0gMSAmJiBuID09PSB2b2lkIDApXG4gICAgcmV0dXJuIGU7XG4gIGZvciAodmFyIHIgPSBbXSwgaSA9IDA7IGkgPCBlLmxlbmd0aDsgaSArPSB0KVxuICAgIHIucHVzaChlW2ldKTtcbiAgcmV0dXJuIHI7XG59XG5mdW5jdGlvbiBjRyhlLCB0LCBuKSB7XG4gIHZhciByID0ge1xuICAgIHdpZHRoOiBlLndpZHRoICsgdC53aWR0aCxcbiAgICBoZWlnaHQ6IGUuaGVpZ2h0ICsgdC5oZWlnaHRcbiAgfTtcbiAgcmV0dXJuIGI1KHIsIG4pO1xufVxuZnVuY3Rpb24gbEcoZSwgdCwgbikge1xuICB2YXIgciA9IG4gPT09IFwid2lkdGhcIiwgaSA9IGUueCwgbyA9IGUueSwgYSA9IGUud2lkdGgsIHMgPSBlLmhlaWdodDtcbiAgcmV0dXJuIHQgPT09IDEgPyB7XG4gICAgc3RhcnQ6IHIgPyBpIDogbyxcbiAgICBlbmQ6IHIgPyBpICsgYSA6IG8gKyBzXG4gIH0gOiB7XG4gICAgc3RhcnQ6IHIgPyBpICsgYSA6IG8gKyBzLFxuICAgIGVuZDogciA/IGkgOiBvXG4gIH07XG59XG5mdW5jdGlvbiBQcyhlLCB0LCBuLCByLCBpKSB7XG4gIGlmIChlICogdCA8IGUgKiByIHx8IGUgKiB0ID4gZSAqIGkpXG4gICAgcmV0dXJuICExO1xuICB2YXIgbyA9IG4oKTtcbiAgcmV0dXJuIGUgKiAodCAtIGUgKiBvIC8gMiAtIHIpID49IDAgJiYgZSAqICh0ICsgZSAqIG8gLyAyIC0gaSkgPD0gMDtcbn1cbmZ1bmN0aW9uIGZHKGUsIHQpIHtcbiAgcmV0dXJuIFB3KGUsIHQgKyAxKTtcbn1cbmZ1bmN0aW9uIGRHKGUsIHQsIG4sIHIsIGkpIHtcbiAgZm9yICh2YXIgbyA9IChyIHx8IFtdKS5zbGljZSgpLCBhID0gdC5zdGFydCwgcyA9IHQuZW5kLCB1ID0gMCwgYyA9IDEsIGYgPSBhLCBsID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGcgPSByID09IG51bGwgPyB2b2lkIDAgOiByW3VdO1xuICAgIGlmIChnID09PSB2b2lkIDApXG4gICAgICByZXR1cm4ge1xuICAgICAgICB2OiBQdyhyLCBjKVxuICAgICAgfTtcbiAgICB2YXIgaCA9IHUsIHYsIHcgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB2ID09PSB2b2lkIDAgJiYgKHYgPSBuKGcsIGgpKSwgdjtcbiAgICB9LCBiID0gZy5jb29yZGluYXRlLCB4ID0gdSA9PT0gMCB8fCBQcyhlLCBiLCB3LCBmLCBzKTtcbiAgICB4IHx8ICh1ID0gMCwgZiA9IGEsIGMgKz0gMSksIHggJiYgKGYgPSBiICsgZSAqICh3KCkgLyAyICsgaSksIHUgKz0gYyk7XG4gIH0sIGQ7IGMgPD0gby5sZW5ndGg7IClcbiAgICBpZiAoZCA9IGwoKSwgZClcbiAgICAgIHJldHVybiBkLnY7XG4gIHJldHVybiBbXTtcbn1cbmZ1bmN0aW9uIGtvKGUpIHtcbiAgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiO1xuICByZXR1cm4ga28gPSB0eXBlb2YgU3ltYm9sID09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09IFwic3ltYm9sXCIgPyBmdW5jdGlvbih0KSB7XG4gICAgcmV0dXJuIHR5cGVvZiB0O1xuICB9IDogZnVuY3Rpb24odCkge1xuICAgIHJldHVybiB0ICYmIHR5cGVvZiBTeW1ib2wgPT0gXCJmdW5jdGlvblwiICYmIHQuY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiB0ICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiB0O1xuICB9LCBrbyhlKTtcbn1cbmZ1bmN0aW9uIFd2KGUsIHQpIHtcbiAgdmFyIG4gPSBPYmplY3Qua2V5cyhlKTtcbiAgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcbiAgICB2YXIgciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZSk7XG4gICAgdCAmJiAociA9IHIuZmlsdGVyKGZ1bmN0aW9uKGkpIHtcbiAgICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsIGkpLmVudW1lcmFibGU7XG4gICAgfSkpLCBuLnB1c2guYXBwbHkobiwgcik7XG4gIH1cbiAgcmV0dXJuIG47XG59XG5mdW5jdGlvbiBvdChlKSB7XG4gIGZvciAodmFyIHQgPSAxOyB0IDwgYXJndW1lbnRzLmxlbmd0aDsgdCsrKSB7XG4gICAgdmFyIG4gPSBhcmd1bWVudHNbdF0gIT0gbnVsbCA/IGFyZ3VtZW50c1t0XSA6IHt9O1xuICAgIHQgJSAyID8gV3YoT2JqZWN0KG4pLCAhMCkuZm9yRWFjaChmdW5jdGlvbihyKSB7XG4gICAgICBwRyhlLCByLCBuW3JdKTtcbiAgICB9KSA6IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoZSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMobikpIDogV3YoT2JqZWN0KG4pKS5mb3JFYWNoKGZ1bmN0aW9uKHIpIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCByLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG4sIHIpKTtcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gZTtcbn1cbmZ1bmN0aW9uIHBHKGUsIHQsIG4pIHtcbiAgcmV0dXJuIHQgPSBoRyh0KSwgdCBpbiBlID8gT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIHQsIHsgdmFsdWU6IG4sIGVudW1lcmFibGU6ICEwLCBjb25maWd1cmFibGU6ICEwLCB3cml0YWJsZTogITAgfSkgOiBlW3RdID0gbiwgZTtcbn1cbmZ1bmN0aW9uIGhHKGUpIHtcbiAgdmFyIHQgPSBnRyhlLCBcInN0cmluZ1wiKTtcbiAgcmV0dXJuIGtvKHQpID09IFwic3ltYm9sXCIgPyB0IDogU3RyaW5nKHQpO1xufVxuZnVuY3Rpb24gZ0coZSwgdCkge1xuICBpZiAoa28oZSkgIT0gXCJvYmplY3RcIiB8fCAhZSlcbiAgICByZXR1cm4gZTtcbiAgdmFyIG4gPSBlW1N5bWJvbC50b1ByaW1pdGl2ZV07XG4gIGlmIChuICE9PSB2b2lkIDApIHtcbiAgICB2YXIgciA9IG4uY2FsbChlLCB0IHx8IFwiZGVmYXVsdFwiKTtcbiAgICBpZiAoa28ocikgIT0gXCJvYmplY3RcIilcbiAgICAgIHJldHVybiByO1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJAQHRvUHJpbWl0aXZlIG11c3QgcmV0dXJuIGEgcHJpbWl0aXZlIHZhbHVlLlwiKTtcbiAgfVxuICByZXR1cm4gKHQgPT09IFwic3RyaW5nXCIgPyBTdHJpbmcgOiBOdW1iZXIpKGUpO1xufVxuZnVuY3Rpb24gdkcoZSwgdCwgbiwgciwgaSkge1xuICBmb3IgKHZhciBvID0gKHIgfHwgW10pLnNsaWNlKCksIGEgPSBvLmxlbmd0aCwgcyA9IHQuc3RhcnQsIHUgPSB0LmVuZCwgYyA9IGZ1bmN0aW9uKGQpIHtcbiAgICB2YXIgcCA9IG9bZF0sIGcsIGggPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBnID09PSB2b2lkIDAgJiYgKGcgPSBuKHAsIGQpKSwgZztcbiAgICB9O1xuICAgIGlmIChkID09PSBhIC0gMSkge1xuICAgICAgdmFyIHYgPSBlICogKHAuY29vcmRpbmF0ZSArIGUgKiBoKCkgLyAyIC0gdSk7XG4gICAgICBvW2RdID0gcCA9IG90KG90KHt9LCBwKSwge30sIHtcbiAgICAgICAgdGlja0Nvb3JkOiB2ID4gMCA/IHAuY29vcmRpbmF0ZSAtIHYgKiBlIDogcC5jb29yZGluYXRlXG4gICAgICB9KTtcbiAgICB9IGVsc2VcbiAgICAgIG9bZF0gPSBwID0gb3Qob3Qoe30sIHApLCB7fSwge1xuICAgICAgICB0aWNrQ29vcmQ6IHAuY29vcmRpbmF0ZVxuICAgICAgfSk7XG4gICAgdmFyIHcgPSBQcyhlLCBwLnRpY2tDb29yZCwgaCwgcywgdSk7XG4gICAgdyAmJiAodSA9IHAudGlja0Nvb3JkIC0gZSAqIChoKCkgLyAyICsgaSksIG9bZF0gPSBvdChvdCh7fSwgcCksIHt9LCB7XG4gICAgICBpc1Nob3c6ICEwXG4gICAgfSkpO1xuICB9LCBmID0gYSAtIDE7IGYgPj0gMDsgZi0tKVxuICAgIGMoZik7XG4gIHJldHVybiBvO1xufVxuZnVuY3Rpb24gbUcoZSwgdCwgbiwgciwgaSwgbykge1xuICB2YXIgYSA9IChyIHx8IFtdKS5zbGljZSgpLCBzID0gYS5sZW5ndGgsIHUgPSB0LnN0YXJ0LCBjID0gdC5lbmQ7XG4gIGlmIChvKSB7XG4gICAgdmFyIGYgPSByW3MgLSAxXSwgbCA9IG4oZiwgcyAtIDEpLCBkID0gZSAqIChmLmNvb3JkaW5hdGUgKyBlICogbCAvIDIgLSBjKTtcbiAgICBhW3MgLSAxXSA9IGYgPSBvdChvdCh7fSwgZiksIHt9LCB7XG4gICAgICB0aWNrQ29vcmQ6IGQgPiAwID8gZi5jb29yZGluYXRlIC0gZCAqIGUgOiBmLmNvb3JkaW5hdGVcbiAgICB9KTtcbiAgICB2YXIgcCA9IFBzKGUsIGYudGlja0Nvb3JkLCBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBsO1xuICAgIH0sIHUsIGMpO1xuICAgIHAgJiYgKGMgPSBmLnRpY2tDb29yZCAtIGUgKiAobCAvIDIgKyBpKSwgYVtzIC0gMV0gPSBvdChvdCh7fSwgZiksIHt9LCB7XG4gICAgICBpc1Nob3c6ICEwXG4gICAgfSkpO1xuICB9XG4gIGZvciAodmFyIGcgPSBvID8gcyAtIDEgOiBzLCBoID0gZnVuY3Rpb24oYikge1xuICAgIHZhciB4ID0gYVtiXSwgbSwgeSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIG0gPT09IHZvaWQgMCAmJiAobSA9IG4oeCwgYikpLCBtO1xuICAgIH07XG4gICAgaWYgKGIgPT09IDApIHtcbiAgICAgIHZhciBTID0gZSAqICh4LmNvb3JkaW5hdGUgLSBlICogeSgpIC8gMiAtIHUpO1xuICAgICAgYVtiXSA9IHggPSBvdChvdCh7fSwgeCksIHt9LCB7XG4gICAgICAgIHRpY2tDb29yZDogUyA8IDAgPyB4LmNvb3JkaW5hdGUgLSBTICogZSA6IHguY29vcmRpbmF0ZVxuICAgICAgfSk7XG4gICAgfSBlbHNlXG4gICAgICBhW2JdID0geCA9IG90KG90KHt9LCB4KSwge30sIHtcbiAgICAgICAgdGlja0Nvb3JkOiB4LmNvb3JkaW5hdGVcbiAgICAgIH0pO1xuICAgIHZhciAkID0gUHMoZSwgeC50aWNrQ29vcmQsIHksIHUsIGMpO1xuICAgICQgJiYgKHUgPSB4LnRpY2tDb29yZCArIGUgKiAoeSgpIC8gMiArIGkpLCBhW2JdID0gb3Qob3Qoe30sIHgpLCB7fSwge1xuICAgICAgaXNTaG93OiAhMFxuICAgIH0pKTtcbiAgfSwgdiA9IDA7IHYgPCBnOyB2KyspXG4gICAgaCh2KTtcbiAgcmV0dXJuIGE7XG59XG5mdW5jdGlvbiB3ZChlLCB0LCBuKSB7XG4gIHZhciByID0gZS50aWNrLCBpID0gZS50aWNrcywgbyA9IGUudmlld0JveCwgYSA9IGUubWluVGlja0dhcCwgcyA9IGUub3JpZW50YXRpb24sIHUgPSBlLmludGVydmFsLCBjID0gZS50aWNrRm9ybWF0dGVyLCBmID0gZS51bml0LCBsID0gZS5hbmdsZTtcbiAgaWYgKCFpIHx8ICFpLmxlbmd0aCB8fCAhcilcbiAgICByZXR1cm4gW107XG4gIGlmIChLKHUpIHx8IHluLmlzU3NyKVxuICAgIHJldHVybiBmRyhpLCB0eXBlb2YgdSA9PSBcIm51bWJlclwiICYmIEsodSkgPyB1IDogMCk7XG4gIHZhciBkID0gW10sIHAgPSBzID09PSBcInRvcFwiIHx8IHMgPT09IFwiYm90dG9tXCIgPyBcIndpZHRoXCIgOiBcImhlaWdodFwiLCBnID0gZiAmJiBwID09PSBcIndpZHRoXCIgPyBHaShmLCB7XG4gICAgZm9udFNpemU6IHQsXG4gICAgbGV0dGVyU3BhY2luZzogblxuICB9KSA6IHtcbiAgICB3aWR0aDogMCxcbiAgICBoZWlnaHQ6IDBcbiAgfSwgaCA9IGZ1bmN0aW9uKHgsIG0pIHtcbiAgICB2YXIgeSA9IHBlKGMpID8gYyh4LnZhbHVlLCBtKSA6IHgudmFsdWU7XG4gICAgcmV0dXJuIHAgPT09IFwid2lkdGhcIiA/IGNHKEdpKHksIHtcbiAgICAgIGZvbnRTaXplOiB0LFxuICAgICAgbGV0dGVyU3BhY2luZzogblxuICAgIH0pLCBnLCBsKSA6IEdpKHksIHtcbiAgICAgIGZvbnRTaXplOiB0LFxuICAgICAgbGV0dGVyU3BhY2luZzogblxuICAgIH0pW3BdO1xuICB9LCB2ID0gaS5sZW5ndGggPj0gMiA/IEt0KGlbMV0uY29vcmRpbmF0ZSAtIGlbMF0uY29vcmRpbmF0ZSkgOiAxLCB3ID0gbEcobywgdiwgcCk7XG4gIHJldHVybiB1ID09PSBcImVxdWlkaXN0YW50UHJlc2VydmVTdGFydFwiID8gZEcodiwgdywgaCwgaSwgYSkgOiAodSA9PT0gXCJwcmVzZXJ2ZVN0YXJ0XCIgfHwgdSA9PT0gXCJwcmVzZXJ2ZVN0YXJ0RW5kXCIgPyBkID0gbUcodiwgdywgaCwgaSwgYSwgdSA9PT0gXCJwcmVzZXJ2ZVN0YXJ0RW5kXCIpIDogZCA9IHZHKHYsIHcsIGgsIGksIGEpLCBkLmZpbHRlcihmdW5jdGlvbihiKSB7XG4gICAgcmV0dXJuIGIuaXNTaG93O1xuICB9KSk7XG59XG52YXIgeUcgPSBbXCJ2aWV3Qm94XCJdLCBiRyA9IFtcInZpZXdCb3hcIl0sIHdHID0gW1widGlja3NcIl07XG5mdW5jdGlvbiBRcihlKSB7XG4gIFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjtcbiAgcmV0dXJuIFFyID0gdHlwZW9mIFN5bWJvbCA9PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PSBcInN5bWJvbFwiID8gZnVuY3Rpb24odCkge1xuICAgIHJldHVybiB0eXBlb2YgdDtcbiAgfSA6IGZ1bmN0aW9uKHQpIHtcbiAgICByZXR1cm4gdCAmJiB0eXBlb2YgU3ltYm9sID09IFwiZnVuY3Rpb25cIiAmJiB0LmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgdCAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2YgdDtcbiAgfSwgUXIoZSk7XG59XG5mdW5jdGlvbiBFcigpIHtcbiAgcmV0dXJuIEVyID0gT2JqZWN0LmFzc2lnbiA/IE9iamVjdC5hc3NpZ24uYmluZCgpIDogZnVuY3Rpb24oZSkge1xuICAgIGZvciAodmFyIHQgPSAxOyB0IDwgYXJndW1lbnRzLmxlbmd0aDsgdCsrKSB7XG4gICAgICB2YXIgbiA9IGFyZ3VtZW50c1t0XTtcbiAgICAgIGZvciAodmFyIHIgaW4gbilcbiAgICAgICAgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG4sIHIpICYmIChlW3JdID0gbltyXSk7XG4gICAgfVxuICAgIHJldHVybiBlO1xuICB9LCBFci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuZnVuY3Rpb24gVXYoZSwgdCkge1xuICB2YXIgbiA9IE9iamVjdC5rZXlzKGUpO1xuICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykge1xuICAgIHZhciByID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhlKTtcbiAgICB0ICYmIChyID0gci5maWx0ZXIoZnVuY3Rpb24oaSkge1xuICAgICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSwgaSkuZW51bWVyYWJsZTtcbiAgICB9KSksIG4ucHVzaC5hcHBseShuLCByKTtcbiAgfVxuICByZXR1cm4gbjtcbn1cbmZ1bmN0aW9uIGx0KGUpIHtcbiAgZm9yICh2YXIgdCA9IDE7IHQgPCBhcmd1bWVudHMubGVuZ3RoOyB0KyspIHtcbiAgICB2YXIgbiA9IGFyZ3VtZW50c1t0XSAhPSBudWxsID8gYXJndW1lbnRzW3RdIDoge307XG4gICAgdCAlIDIgPyBVdihPYmplY3QobiksICEwKS5mb3JFYWNoKGZ1bmN0aW9uKHIpIHtcbiAgICAgIHhkKGUsIHIsIG5bcl0pO1xuICAgIH0pIDogT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhlLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhuKSkgOiBVdihPYmplY3QobikpLmZvckVhY2goZnVuY3Rpb24ocikge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIHIsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobiwgcikpO1xuICAgIH0pO1xuICB9XG4gIHJldHVybiBlO1xufVxuZnVuY3Rpb24gcmMoZSwgdCkge1xuICBpZiAoZSA9PSBudWxsKVxuICAgIHJldHVybiB7fTtcbiAgdmFyIG4gPSB4RyhlLCB0KSwgciwgaTtcbiAgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcbiAgICB2YXIgbyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZSk7XG4gICAgZm9yIChpID0gMDsgaSA8IG8ubGVuZ3RoOyBpKyspXG4gICAgICByID0gb1tpXSwgISh0LmluZGV4T2YocikgPj0gMCkgJiYgT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKGUsIHIpICYmIChuW3JdID0gZVtyXSk7XG4gIH1cbiAgcmV0dXJuIG47XG59XG5mdW5jdGlvbiB4RyhlLCB0KSB7XG4gIGlmIChlID09IG51bGwpXG4gICAgcmV0dXJuIHt9O1xuICB2YXIgbiA9IHt9LCByID0gT2JqZWN0LmtleXMoZSksIGksIG87XG4gIGZvciAobyA9IDA7IG8gPCByLmxlbmd0aDsgbysrKVxuICAgIGkgPSByW29dLCAhKHQuaW5kZXhPZihpKSA+PSAwKSAmJiAobltpXSA9IGVbaV0pO1xuICByZXR1cm4gbjtcbn1cbmZ1bmN0aW9uIFNHKGUsIHQpIHtcbiAgaWYgKCEoZSBpbnN0YW5jZW9mIHQpKVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XG59XG5mdW5jdGlvbiBIdihlLCB0KSB7XG4gIGZvciAodmFyIG4gPSAwOyBuIDwgdC5sZW5ndGg7IG4rKykge1xuICAgIHZhciByID0gdFtuXTtcbiAgICByLmVudW1lcmFibGUgPSByLmVudW1lcmFibGUgfHwgITEsIHIuY29uZmlndXJhYmxlID0gITAsIFwidmFsdWVcIiBpbiByICYmIChyLndyaXRhYmxlID0gITApLCBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgRXcoci5rZXkpLCByKTtcbiAgfVxufVxuZnVuY3Rpb24gJEcoZSwgdCwgbikge1xuICByZXR1cm4gdCAmJiBIdihlLnByb3RvdHlwZSwgdCksIG4gJiYgSHYoZSwgbiksIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCBcInByb3RvdHlwZVwiLCB7IHdyaXRhYmxlOiAhMSB9KSwgZTtcbn1cbmZ1bmN0aW9uIE9HKGUsIHQsIG4pIHtcbiAgcmV0dXJuIHQgPSBDcyh0KSwgX0coZSwgQ3coKSA/IFJlZmxlY3QuY29uc3RydWN0KHQsIG4gfHwgW10sIENzKGUpLmNvbnN0cnVjdG9yKSA6IHQuYXBwbHkoZSwgbikpO1xufVxuZnVuY3Rpb24gX0coZSwgdCkge1xuICBpZiAodCAmJiAoUXIodCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIHQgPT0gXCJmdW5jdGlvblwiKSlcbiAgICByZXR1cm4gdDtcbiAgaWYgKHQgIT09IHZvaWQgMClcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRGVyaXZlZCBjb25zdHJ1Y3RvcnMgbWF5IG9ubHkgcmV0dXJuIG9iamVjdCBvciB1bmRlZmluZWRcIik7XG4gIHJldHVybiBBRyhlKTtcbn1cbmZ1bmN0aW9uIEFHKGUpIHtcbiAgaWYgKGUgPT09IHZvaWQgMClcbiAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7XG4gIHJldHVybiBlO1xufVxuZnVuY3Rpb24gQ3coKSB7XG4gIHRyeSB7XG4gICAgdmFyIGUgPSAhQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbigpIHtcbiAgICB9KSk7XG4gIH0gY2F0Y2gge1xuICB9XG4gIHJldHVybiAoQ3cgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gISFlO1xuICB9KSgpO1xufVxuZnVuY3Rpb24gQ3MoZSkge1xuICByZXR1cm4gQ3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YuYmluZCgpIDogZnVuY3Rpb24obikge1xuICAgIHJldHVybiBuLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobik7XG4gIH0sIENzKGUpO1xufVxuZnVuY3Rpb24gUEcoZSwgdCkge1xuICBpZiAodHlwZW9mIHQgIT0gXCJmdW5jdGlvblwiICYmIHQgIT09IG51bGwpXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpO1xuICBlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUodCAmJiB0LnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogZSwgd3JpdGFibGU6ICEwLCBjb25maWd1cmFibGU6ICEwIH0gfSksIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCBcInByb3RvdHlwZVwiLCB7IHdyaXRhYmxlOiAhMSB9KSwgdCAmJiBGbChlLCB0KTtcbn1cbmZ1bmN0aW9uIEZsKGUsIHQpIHtcbiAgcmV0dXJuIEZsID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mLmJpbmQoKSA6IGZ1bmN0aW9uKHIsIGkpIHtcbiAgICByZXR1cm4gci5fX3Byb3RvX18gPSBpLCByO1xuICB9LCBGbChlLCB0KTtcbn1cbmZ1bmN0aW9uIHhkKGUsIHQsIG4pIHtcbiAgcmV0dXJuIHQgPSBFdyh0KSwgdCBpbiBlID8gT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIHQsIHsgdmFsdWU6IG4sIGVudW1lcmFibGU6ICEwLCBjb25maWd1cmFibGU6ICEwLCB3cml0YWJsZTogITAgfSkgOiBlW3RdID0gbiwgZTtcbn1cbmZ1bmN0aW9uIEV3KGUpIHtcbiAgdmFyIHQgPSBDRyhlLCBcInN0cmluZ1wiKTtcbiAgcmV0dXJuIFFyKHQpID09IFwic3ltYm9sXCIgPyB0IDogU3RyaW5nKHQpO1xufVxuZnVuY3Rpb24gQ0coZSwgdCkge1xuICBpZiAoUXIoZSkgIT0gXCJvYmplY3RcIiB8fCAhZSlcbiAgICByZXR1cm4gZTtcbiAgdmFyIG4gPSBlW1N5bWJvbC50b1ByaW1pdGl2ZV07XG4gIGlmIChuICE9PSB2b2lkIDApIHtcbiAgICB2YXIgciA9IG4uY2FsbChlLCB0IHx8IFwiZGVmYXVsdFwiKTtcbiAgICBpZiAoUXIocikgIT0gXCJvYmplY3RcIilcbiAgICAgIHJldHVybiByO1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJAQHRvUHJpbWl0aXZlIG11c3QgcmV0dXJuIGEgcHJpbWl0aXZlIHZhbHVlLlwiKTtcbiAgfVxuICByZXR1cm4gKHQgPT09IFwic3RyaW5nXCIgPyBTdHJpbmcgOiBOdW1iZXIpKGUpO1xufVxudmFyIHdpID0gLyogQF9fUFVSRV9fICovIGZ1bmN0aW9uKGUpIHtcbiAgUEcodCwgZSk7XG4gIGZ1bmN0aW9uIHQobikge1xuICAgIHZhciByO1xuICAgIHJldHVybiBTRyh0aGlzLCB0KSwgciA9IE9HKHRoaXMsIHQsIFtuXSksIHIuc3RhdGUgPSB7XG4gICAgICBmb250U2l6ZTogXCJcIixcbiAgICAgIGxldHRlclNwYWNpbmc6IFwiXCJcbiAgICB9LCByO1xuICB9XG4gIHJldHVybiAkRyh0LCBbe1xuICAgIGtleTogXCJzaG91bGRDb21wb25lbnRVcGRhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24ociwgaSkge1xuICAgICAgdmFyIG8gPSByLnZpZXdCb3gsIGEgPSByYyhyLCB5RyksIHMgPSB0aGlzLnByb3BzLCB1ID0gcy52aWV3Qm94LCBjID0gcmMocywgYkcpO1xuICAgICAgcmV0dXJuICFScihvLCB1KSB8fCAhUnIoYSwgYykgfHwgIVJyKGksIHRoaXMuc3RhdGUpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjb21wb25lbnREaWRNb3VudFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciByID0gdGhpcy5sYXllclJlZmVyZW5jZTtcbiAgICAgIGlmIChyKSB7XG4gICAgICAgIHZhciBpID0gci5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKFwicmVjaGFydHMtY2FydGVzaWFuLWF4aXMtdGljay12YWx1ZVwiKVswXTtcbiAgICAgICAgaSAmJiB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICBmb250U2l6ZTogd2luZG93LmdldENvbXB1dGVkU3R5bGUoaSkuZm9udFNpemUsXG4gICAgICAgICAgbGV0dGVyU3BhY2luZzogd2luZG93LmdldENvbXB1dGVkU3R5bGUoaSkubGV0dGVyU3BhY2luZ1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlIHRoZSBjb29yZGluYXRlcyBvZiBlbmRwb2ludHMgaW4gdGlja3NcbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9IGRhdGEgVGhlIGRhdGEgb2YgYSBzaW1wbGUgdGlja1xuICAgICAqIEByZXR1cm4ge09iamVjdH0gKHgxLCB5MSk6IFRoZSBjb29yZGluYXRlIG9mIGVuZHBvaW50IGNsb3NlIHRvIHRpY2sgdGV4dFxuICAgICAqICAoeDIsIHkyKTogVGhlIGNvb3JkaW5hdGUgb2YgZW5kcG9pbnQgY2xvc2UgdG8gYXhpc1xuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImdldFRpY2tMaW5lQ29vcmRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24ocikge1xuICAgICAgdmFyIGkgPSB0aGlzLnByb3BzLCBvID0gaS54LCBhID0gaS55LCBzID0gaS53aWR0aCwgdSA9IGkuaGVpZ2h0LCBjID0gaS5vcmllbnRhdGlvbiwgZiA9IGkudGlja1NpemUsIGwgPSBpLm1pcnJvciwgZCA9IGkudGlja01hcmdpbiwgcCwgZywgaCwgdiwgdywgYiwgeCA9IGwgPyAtMSA6IDEsIG0gPSByLnRpY2tTaXplIHx8IGYsIHkgPSBLKHIudGlja0Nvb3JkKSA/IHIudGlja0Nvb3JkIDogci5jb29yZGluYXRlO1xuICAgICAgc3dpdGNoIChjKSB7XG4gICAgICAgIGNhc2UgXCJ0b3BcIjpcbiAgICAgICAgICBwID0gZyA9IHIuY29vcmRpbmF0ZSwgdiA9IGEgKyArIWwgKiB1LCBoID0gdiAtIHggKiBtLCBiID0gaCAtIHggKiBkLCB3ID0geTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImxlZnRcIjpcbiAgICAgICAgICBoID0gdiA9IHIuY29vcmRpbmF0ZSwgZyA9IG8gKyArIWwgKiBzLCBwID0gZyAtIHggKiBtLCB3ID0gcCAtIHggKiBkLCBiID0geTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcInJpZ2h0XCI6XG4gICAgICAgICAgaCA9IHYgPSByLmNvb3JkaW5hdGUsIGcgPSBvICsgK2wgKiBzLCBwID0gZyArIHggKiBtLCB3ID0gcCArIHggKiBkLCBiID0geTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBwID0gZyA9IHIuY29vcmRpbmF0ZSwgdiA9IGEgKyArbCAqIHUsIGggPSB2ICsgeCAqIG0sIGIgPSBoICsgeCAqIGQsIHcgPSB5O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbGluZToge1xuICAgICAgICAgIHgxOiBwLFxuICAgICAgICAgIHkxOiBoLFxuICAgICAgICAgIHgyOiBnLFxuICAgICAgICAgIHkyOiB2XG4gICAgICAgIH0sXG4gICAgICAgIHRpY2s6IHtcbiAgICAgICAgICB4OiB3LFxuICAgICAgICAgIHk6IGJcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0VGlja1RleHRBbmNob3JcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgciA9IHRoaXMucHJvcHMsIGkgPSByLm9yaWVudGF0aW9uLCBvID0gci5taXJyb3IsIGE7XG4gICAgICBzd2l0Y2ggKGkpIHtcbiAgICAgICAgY2FzZSBcImxlZnRcIjpcbiAgICAgICAgICBhID0gbyA/IFwic3RhcnRcIiA6IFwiZW5kXCI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJyaWdodFwiOlxuICAgICAgICAgIGEgPSBvID8gXCJlbmRcIiA6IFwic3RhcnRcIjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBhID0gXCJtaWRkbGVcIjtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHJldHVybiBhO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRUaWNrVmVydGljYWxBbmNob3JcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgciA9IHRoaXMucHJvcHMsIGkgPSByLm9yaWVudGF0aW9uLCBvID0gci5taXJyb3IsIGEgPSBcImVuZFwiO1xuICAgICAgc3dpdGNoIChpKSB7XG4gICAgICAgIGNhc2UgXCJsZWZ0XCI6XG4gICAgICAgIGNhc2UgXCJyaWdodFwiOlxuICAgICAgICAgIGEgPSBcIm1pZGRsZVwiO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwidG9wXCI6XG4gICAgICAgICAgYSA9IG8gPyBcInN0YXJ0XCIgOiBcImVuZFwiO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGEgPSBvID8gXCJlbmRcIiA6IFwic3RhcnRcIjtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHJldHVybiBhO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyZW5kZXJBeGlzTGluZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciByID0gdGhpcy5wcm9wcywgaSA9IHIueCwgbyA9IHIueSwgYSA9IHIud2lkdGgsIHMgPSByLmhlaWdodCwgdSA9IHIub3JpZW50YXRpb24sIGMgPSByLm1pcnJvciwgZiA9IHIuYXhpc0xpbmUsIGwgPSBsdChsdChsdCh7fSwgeWUodGhpcy5wcm9wcywgITEpKSwgeWUoZiwgITEpKSwge30sIHtcbiAgICAgICAgZmlsbDogXCJub25lXCJcbiAgICAgIH0pO1xuICAgICAgaWYgKHUgPT09IFwidG9wXCIgfHwgdSA9PT0gXCJib3R0b21cIikge1xuICAgICAgICB2YXIgZCA9ICsodSA9PT0gXCJ0b3BcIiAmJiAhYyB8fCB1ID09PSBcImJvdHRvbVwiICYmIGMpO1xuICAgICAgICBsID0gbHQobHQoe30sIGwpLCB7fSwge1xuICAgICAgICAgIHgxOiBpLFxuICAgICAgICAgIHkxOiBvICsgZCAqIHMsXG4gICAgICAgICAgeDI6IGkgKyBhLFxuICAgICAgICAgIHkyOiBvICsgZCAqIHNcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgcCA9ICsodSA9PT0gXCJsZWZ0XCIgJiYgIWMgfHwgdSA9PT0gXCJyaWdodFwiICYmIGMpO1xuICAgICAgICBsID0gbHQobHQoe30sIGwpLCB7fSwge1xuICAgICAgICAgIHgxOiBpICsgcCAqIGEsXG4gICAgICAgICAgeTE6IG8sXG4gICAgICAgICAgeDI6IGkgKyBwICogYSxcbiAgICAgICAgICB5MjogbyArIHNcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIFAuY3JlYXRlRWxlbWVudChcImxpbmVcIiwgRXIoe30sIGwsIHtcbiAgICAgICAgY2xhc3NOYW1lOiAkZShcInJlY2hhcnRzLWNhcnRlc2lhbi1heGlzLWxpbmVcIiwganQoZiwgXCJjbGFzc05hbWVcIikpXG4gICAgICB9KSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJlbmRlclRpY2tzXCIsXG4gICAgdmFsdWU6IChcbiAgICAgIC8qKlxuICAgICAgICogcmVuZGVyIHRoZSB0aWNrc1xuICAgICAgICogQHBhcmFtIHtBcnJheX0gdGlja3MgVGhlIHRpY2tzIHRvIGFjdHVhbGx5IHJlbmRlciAob3ZlcnJpZGVzIHdoYXQgd2FzIHBhc3NlZCBpbiBwcm9wcylcbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBmb250U2l6ZSBGb250c2l6ZSB0byBjb25zaWRlciBmb3IgdGljayBzcGFjaW5nXG4gICAgICAgKiBAcGFyYW0ge3N0cmluZ30gbGV0dGVyU3BhY2luZyBMZXR0ZXJzcGFjaW5nIHRvIGNvbnNpZGVyIGZvciB0aWNrIHNwYWNpbmdcbiAgICAgICAqIEByZXR1cm4ge1JlYWN0Q29tcG9uZW50fSByZW5kZXJlZFRpY2tzXG4gICAgICAgKi9cbiAgICAgIGZ1bmN0aW9uKHIsIGksIG8pIHtcbiAgICAgICAgdmFyIGEgPSB0aGlzLCBzID0gdGhpcy5wcm9wcywgdSA9IHMudGlja0xpbmUsIGMgPSBzLnN0cm9rZSwgZiA9IHMudGljaywgbCA9IHMudGlja0Zvcm1hdHRlciwgZCA9IHMudW5pdCwgcCA9IHdkKGx0KGx0KHt9LCB0aGlzLnByb3BzKSwge30sIHtcbiAgICAgICAgICB0aWNrczogclxuICAgICAgICB9KSwgaSwgbyksIGcgPSB0aGlzLmdldFRpY2tUZXh0QW5jaG9yKCksIGggPSB0aGlzLmdldFRpY2tWZXJ0aWNhbEFuY2hvcigpLCB2ID0geWUodGhpcy5wcm9wcywgITEpLCB3ID0geWUoZiwgITEpLCBiID0gbHQobHQoe30sIHYpLCB7fSwge1xuICAgICAgICAgIGZpbGw6IFwibm9uZVwiXG4gICAgICAgIH0sIHllKHUsICExKSksIHggPSBwLm1hcChmdW5jdGlvbihtLCB5KSB7XG4gICAgICAgICAgdmFyIFMgPSBhLmdldFRpY2tMaW5lQ29vcmQobSksICQgPSBTLmxpbmUsIE8gPSBTLnRpY2ssIFQgPSBsdChsdChsdChsdCh7XG4gICAgICAgICAgICB0ZXh0QW5jaG9yOiBnLFxuICAgICAgICAgICAgdmVydGljYWxBbmNob3I6IGhcbiAgICAgICAgICB9LCB2KSwge30sIHtcbiAgICAgICAgICAgIHN0cm9rZTogXCJub25lXCIsXG4gICAgICAgICAgICBmaWxsOiBjXG4gICAgICAgICAgfSwgdyksIE8pLCB7fSwge1xuICAgICAgICAgICAgaW5kZXg6IHksXG4gICAgICAgICAgICBwYXlsb2FkOiBtLFxuICAgICAgICAgICAgdmlzaWJsZVRpY2tzQ291bnQ6IHAubGVuZ3RoLFxuICAgICAgICAgICAgdGlja0Zvcm1hdHRlcjogbFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8gUC5jcmVhdGVFbGVtZW50KFdlLCBFcih7XG4gICAgICAgICAgICBjbGFzc05hbWU6IFwicmVjaGFydHMtY2FydGVzaWFuLWF4aXMtdGlja1wiLFxuICAgICAgICAgICAga2V5OiBcInRpY2stXCIuY29uY2F0KG0udmFsdWUsIFwiLVwiKS5jb25jYXQobS5jb29yZGluYXRlLCBcIi1cIikuY29uY2F0KG0udGlja0Nvb3JkKVxuICAgICAgICAgIH0sIEZhKGEucHJvcHMsIG0sIHkpKSwgdSAmJiAvKiBAX19QVVJFX18gKi8gUC5jcmVhdGVFbGVtZW50KFwibGluZVwiLCBFcih7fSwgYiwgJCwge1xuICAgICAgICAgICAgY2xhc3NOYW1lOiAkZShcInJlY2hhcnRzLWNhcnRlc2lhbi1heGlzLXRpY2stbGluZVwiLCBqdCh1LCBcImNsYXNzTmFtZVwiKSlcbiAgICAgICAgICB9KSksIGYgJiYgdC5yZW5kZXJUaWNrSXRlbShmLCBULCBcIlwiLmNvbmNhdChwZShsKSA/IGwobS52YWx1ZSwgeSkgOiBtLnZhbHVlKS5jb25jYXQoZCB8fCBcIlwiKSkpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBQLmNyZWF0ZUVsZW1lbnQoXCJnXCIsIHtcbiAgICAgICAgICBjbGFzc05hbWU6IFwicmVjaGFydHMtY2FydGVzaWFuLWF4aXMtdGlja3NcIlxuICAgICAgICB9LCB4KTtcbiAgICAgIH1cbiAgICApXG4gIH0sIHtcbiAgICBrZXk6IFwicmVuZGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHIgPSB0aGlzLCBpID0gdGhpcy5wcm9wcywgbyA9IGkuYXhpc0xpbmUsIGEgPSBpLndpZHRoLCBzID0gaS5oZWlnaHQsIHUgPSBpLnRpY2tzR2VuZXJhdG9yLCBjID0gaS5jbGFzc05hbWUsIGYgPSBpLmhpZGU7XG4gICAgICBpZiAoZilcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB2YXIgbCA9IHRoaXMucHJvcHMsIGQgPSBsLnRpY2tzLCBwID0gcmMobCwgd0cpLCBnID0gZDtcbiAgICAgIHJldHVybiBwZSh1KSAmJiAoZyA9IGQgJiYgZC5sZW5ndGggPiAwID8gdSh0aGlzLnByb3BzKSA6IHUocCkpLCBhIDw9IDAgfHwgcyA8PSAwIHx8ICFnIHx8ICFnLmxlbmd0aCA/IG51bGwgOiAvKiBAX19QVVJFX18gKi8gUC5jcmVhdGVFbGVtZW50KFdlLCB7XG4gICAgICAgIGNsYXNzTmFtZTogJGUoXCJyZWNoYXJ0cy1jYXJ0ZXNpYW4tYXhpc1wiLCBjKSxcbiAgICAgICAgcmVmOiBmdW5jdGlvbih2KSB7XG4gICAgICAgICAgci5sYXllclJlZmVyZW5jZSA9IHY7XG4gICAgICAgIH1cbiAgICAgIH0sIG8gJiYgdGhpcy5yZW5kZXJBeGlzTGluZSgpLCB0aGlzLnJlbmRlclRpY2tzKGcsIHRoaXMuc3RhdGUuZm9udFNpemUsIHRoaXMuc3RhdGUubGV0dGVyU3BhY2luZyksIGF0LnJlbmRlckNhbGxCeVBhcmVudCh0aGlzLnByb3BzKSk7XG4gICAgfVxuICB9XSwgW3tcbiAgICBrZXk6IFwicmVuZGVyVGlja0l0ZW1cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24ociwgaSwgbykge1xuICAgICAgdmFyIGE7XG4gICAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIFAuaXNWYWxpZEVsZW1lbnQocikgPyBhID0gLyogQF9fUFVSRV9fICovIFAuY2xvbmVFbGVtZW50KHIsIGkpIDogcGUocikgPyBhID0gcihpKSA6IGEgPSAvKiBAX19QVVJFX18gKi8gUC5jcmVhdGVFbGVtZW50KEphLCBFcih7fSwgaSwge1xuICAgICAgICBjbGFzc05hbWU6IFwicmVjaGFydHMtY2FydGVzaWFuLWF4aXMtdGljay12YWx1ZVwiXG4gICAgICB9KSwgbyksIGE7XG4gICAgfVxuICB9XSksIHQ7XG59KGxtKTtcbnhkKHdpLCBcImRpc3BsYXlOYW1lXCIsIFwiQ2FydGVzaWFuQXhpc1wiKTtcbnhkKHdpLCBcImRlZmF1bHRQcm9wc1wiLCB7XG4gIHg6IDAsXG4gIHk6IDAsXG4gIHdpZHRoOiAwLFxuICBoZWlnaHQ6IDAsXG4gIHZpZXdCb3g6IHtcbiAgICB4OiAwLFxuICAgIHk6IDAsXG4gICAgd2lkdGg6IDAsXG4gICAgaGVpZ2h0OiAwXG4gIH0sXG4gIC8vIFRoZSBvcmllbnRhdGlvbiBvZiBheGlzXG4gIG9yaWVudGF0aW9uOiBcImJvdHRvbVwiLFxuICAvLyBUaGUgdGlja3NcbiAgdGlja3M6IFtdLFxuICBzdHJva2U6IFwiIzY2NlwiLFxuICB0aWNrTGluZTogITAsXG4gIGF4aXNMaW5lOiAhMCxcbiAgdGljazogITAsXG4gIG1pcnJvcjogITEsXG4gIG1pblRpY2tHYXA6IDUsXG4gIC8vIFRoZSB3aWR0aCBvciBoZWlnaHQgb2YgdGlja1xuICB0aWNrU2l6ZTogNixcbiAgdGlja01hcmdpbjogMixcbiAgaW50ZXJ2YWw6IFwicHJlc2VydmVFbmRcIlxufSk7XG52YXIgRUcgPSBbXCJ4MVwiLCBcInkxXCIsIFwieDJcIiwgXCJ5MlwiLCBcImtleVwiXSwgVEcgPSBbXCJvZmZzZXRcIl07XG5mdW5jdGlvbiBkcihlKSB7XG4gIFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjtcbiAgcmV0dXJuIGRyID0gdHlwZW9mIFN5bWJvbCA9PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PSBcInN5bWJvbFwiID8gZnVuY3Rpb24odCkge1xuICAgIHJldHVybiB0eXBlb2YgdDtcbiAgfSA6IGZ1bmN0aW9uKHQpIHtcbiAgICByZXR1cm4gdCAmJiB0eXBlb2YgU3ltYm9sID09IFwiZnVuY3Rpb25cIiAmJiB0LmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgdCAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2YgdDtcbiAgfSwgZHIoZSk7XG59XG5mdW5jdGlvbiBxdihlLCB0KSB7XG4gIHZhciBuID0gT2JqZWN0LmtleXMoZSk7XG4gIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gICAgdmFyIHIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGUpO1xuICAgIHQgJiYgKHIgPSByLmZpbHRlcihmdW5jdGlvbihpKSB7XG4gICAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLCBpKS5lbnVtZXJhYmxlO1xuICAgIH0pKSwgbi5wdXNoLmFwcGx5KG4sIHIpO1xuICB9XG4gIHJldHVybiBuO1xufVxuZnVuY3Rpb24gc3QoZSkge1xuICBmb3IgKHZhciB0ID0gMTsgdCA8IGFyZ3VtZW50cy5sZW5ndGg7IHQrKykge1xuICAgIHZhciBuID0gYXJndW1lbnRzW3RdICE9IG51bGwgPyBhcmd1bWVudHNbdF0gOiB7fTtcbiAgICB0ICUgMiA/IHF2KE9iamVjdChuKSwgITApLmZvckVhY2goZnVuY3Rpb24ocikge1xuICAgICAgTUcoZSwgciwgbltyXSk7XG4gICAgfSkgOiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGUsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKG4pKSA6IHF2KE9iamVjdChuKSkuZm9yRWFjaChmdW5jdGlvbihyKSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgciwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihuLCByKSk7XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIGU7XG59XG5mdW5jdGlvbiBNRyhlLCB0LCBuKSB7XG4gIHJldHVybiB0ID0gUkcodCksIHQgaW4gZSA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCB0LCB7IHZhbHVlOiBuLCBlbnVtZXJhYmxlOiAhMCwgY29uZmlndXJhYmxlOiAhMCwgd3JpdGFibGU6ICEwIH0pIDogZVt0XSA9IG4sIGU7XG59XG5mdW5jdGlvbiBSRyhlKSB7XG4gIHZhciB0ID0gSUcoZSwgXCJzdHJpbmdcIik7XG4gIHJldHVybiBkcih0KSA9PSBcInN5bWJvbFwiID8gdCA6IFN0cmluZyh0KTtcbn1cbmZ1bmN0aW9uIElHKGUsIHQpIHtcbiAgaWYgKGRyKGUpICE9IFwib2JqZWN0XCIgfHwgIWUpXG4gICAgcmV0dXJuIGU7XG4gIHZhciBuID0gZVtTeW1ib2wudG9QcmltaXRpdmVdO1xuICBpZiAobiAhPT0gdm9pZCAwKSB7XG4gICAgdmFyIHIgPSBuLmNhbGwoZSwgdCB8fCBcImRlZmF1bHRcIik7XG4gICAgaWYgKGRyKHIpICE9IFwib2JqZWN0XCIpXG4gICAgICByZXR1cm4gcjtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQEB0b1ByaW1pdGl2ZSBtdXN0IHJldHVybiBhIHByaW1pdGl2ZSB2YWx1ZS5cIik7XG4gIH1cbiAgcmV0dXJuICh0ID09PSBcInN0cmluZ1wiID8gU3RyaW5nIDogTnVtYmVyKShlKTtcbn1cbmZ1bmN0aW9uIG9yKCkge1xuICByZXR1cm4gb3IgPSBPYmplY3QuYXNzaWduID8gT2JqZWN0LmFzc2lnbi5iaW5kKCkgOiBmdW5jdGlvbihlKSB7XG4gICAgZm9yICh2YXIgdCA9IDE7IHQgPCBhcmd1bWVudHMubGVuZ3RoOyB0KyspIHtcbiAgICAgIHZhciBuID0gYXJndW1lbnRzW3RdO1xuICAgICAgZm9yICh2YXIgciBpbiBuKVxuICAgICAgICBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobiwgcikgJiYgKGVbcl0gPSBuW3JdKTtcbiAgICB9XG4gICAgcmV0dXJuIGU7XG4gIH0sIG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5mdW5jdGlvbiBLdihlLCB0KSB7XG4gIGlmIChlID09IG51bGwpXG4gICAgcmV0dXJuIHt9O1xuICB2YXIgbiA9IGpHKGUsIHQpLCByLCBpO1xuICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykge1xuICAgIHZhciBvID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhlKTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgby5sZW5ndGg7IGkrKylcbiAgICAgIHIgPSBvW2ldLCAhKHQuaW5kZXhPZihyKSA+PSAwKSAmJiBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwoZSwgcikgJiYgKG5bcl0gPSBlW3JdKTtcbiAgfVxuICByZXR1cm4gbjtcbn1cbmZ1bmN0aW9uIGpHKGUsIHQpIHtcbiAgaWYgKGUgPT0gbnVsbClcbiAgICByZXR1cm4ge307XG4gIHZhciBuID0ge30sIHIgPSBPYmplY3Qua2V5cyhlKSwgaSwgbztcbiAgZm9yIChvID0gMDsgbyA8IHIubGVuZ3RoOyBvKyspXG4gICAgaSA9IHJbb10sICEodC5pbmRleE9mKGkpID49IDApICYmIChuW2ldID0gZVtpXSk7XG4gIHJldHVybiBuO1xufVxudmFyIGtHID0gZnVuY3Rpb24odCkge1xuICB2YXIgbiA9IHQuZmlsbDtcbiAgaWYgKCFuIHx8IG4gPT09IFwibm9uZVwiKVxuICAgIHJldHVybiBudWxsO1xuICB2YXIgciA9IHQuZmlsbE9wYWNpdHksIGkgPSB0LngsIG8gPSB0LnksIGEgPSB0LndpZHRoLCBzID0gdC5oZWlnaHQ7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gUC5jcmVhdGVFbGVtZW50KFwicmVjdFwiLCB7XG4gICAgeDogaSxcbiAgICB5OiBvLFxuICAgIHdpZHRoOiBhLFxuICAgIGhlaWdodDogcyxcbiAgICBzdHJva2U6IFwibm9uZVwiLFxuICAgIGZpbGw6IG4sXG4gICAgZmlsbE9wYWNpdHk6IHIsXG4gICAgY2xhc3NOYW1lOiBcInJlY2hhcnRzLWNhcnRlc2lhbi1ncmlkLWJnXCJcbiAgfSk7XG59O1xuZnVuY3Rpb24gVHcoZSwgdCkge1xuICB2YXIgbjtcbiAgaWYgKC8qIEBfX1BVUkVfXyAqLyBQLmlzVmFsaWRFbGVtZW50KGUpKVxuICAgIG4gPSAvKiBAX19QVVJFX18gKi8gUC5jbG9uZUVsZW1lbnQoZSwgdCk7XG4gIGVsc2UgaWYgKHBlKGUpKVxuICAgIG4gPSBlKHQpO1xuICBlbHNlIHtcbiAgICB2YXIgciA9IHQueDEsIGkgPSB0LnkxLCBvID0gdC54MiwgYSA9IHQueTIsIHMgPSB0LmtleSwgdSA9IEt2KHQsIEVHKSwgYyA9IHllKHUsICExKTtcbiAgICBjLm9mZnNldDtcbiAgICB2YXIgZiA9IEt2KGMsIFRHKTtcbiAgICBuID0gLyogQF9fUFVSRV9fICovIFAuY3JlYXRlRWxlbWVudChcImxpbmVcIiwgb3Ioe30sIGYsIHtcbiAgICAgIHgxOiByLFxuICAgICAgeTE6IGksXG4gICAgICB4MjogbyxcbiAgICAgIHkyOiBhLFxuICAgICAgZmlsbDogXCJub25lXCIsXG4gICAgICBrZXk6IHNcbiAgICB9KSk7XG4gIH1cbiAgcmV0dXJuIG47XG59XG5mdW5jdGlvbiBERyhlKSB7XG4gIHZhciB0ID0gZS54LCBuID0gZS53aWR0aCwgciA9IGUuaG9yaXpvbnRhbCwgaSA9IHIgPT09IHZvaWQgMCA/ICEwIDogciwgbyA9IGUuaG9yaXpvbnRhbFBvaW50cztcbiAgaWYgKCFpIHx8ICFvIHx8ICFvLmxlbmd0aClcbiAgICByZXR1cm4gbnVsbDtcbiAgdmFyIGEgPSBvLm1hcChmdW5jdGlvbihzLCB1KSB7XG4gICAgdmFyIGMgPSBzdChzdCh7fSwgZSksIHt9LCB7XG4gICAgICB4MTogdCxcbiAgICAgIHkxOiBzLFxuICAgICAgeDI6IHQgKyBuLFxuICAgICAgeTI6IHMsXG4gICAgICBrZXk6IFwibGluZS1cIi5jb25jYXQodSksXG4gICAgICBpbmRleDogdVxuICAgIH0pO1xuICAgIHJldHVybiBUdyhpLCBjKTtcbiAgfSk7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gUC5jcmVhdGVFbGVtZW50KFwiZ1wiLCB7XG4gICAgY2xhc3NOYW1lOiBcInJlY2hhcnRzLWNhcnRlc2lhbi1ncmlkLWhvcml6b250YWxcIlxuICB9LCBhKTtcbn1cbmZ1bmN0aW9uIE5HKGUpIHtcbiAgdmFyIHQgPSBlLnksIG4gPSBlLmhlaWdodCwgciA9IGUudmVydGljYWwsIGkgPSByID09PSB2b2lkIDAgPyAhMCA6IHIsIG8gPSBlLnZlcnRpY2FsUG9pbnRzO1xuICBpZiAoIWkgfHwgIW8gfHwgIW8ubGVuZ3RoKVxuICAgIHJldHVybiBudWxsO1xuICB2YXIgYSA9IG8ubWFwKGZ1bmN0aW9uKHMsIHUpIHtcbiAgICB2YXIgYyA9IHN0KHN0KHt9LCBlKSwge30sIHtcbiAgICAgIHgxOiBzLFxuICAgICAgeTE6IHQsXG4gICAgICB4MjogcyxcbiAgICAgIHkyOiB0ICsgbixcbiAgICAgIGtleTogXCJsaW5lLVwiLmNvbmNhdCh1KSxcbiAgICAgIGluZGV4OiB1XG4gICAgfSk7XG4gICAgcmV0dXJuIFR3KGksIGMpO1xuICB9KTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBQLmNyZWF0ZUVsZW1lbnQoXCJnXCIsIHtcbiAgICBjbGFzc05hbWU6IFwicmVjaGFydHMtY2FydGVzaWFuLWdyaWQtdmVydGljYWxcIlxuICB9LCBhKTtcbn1cbmZ1bmN0aW9uIEZHKGUpIHtcbiAgdmFyIHQgPSBlLmhvcml6b250YWxGaWxsLCBuID0gZS5maWxsT3BhY2l0eSwgciA9IGUueCwgaSA9IGUueSwgbyA9IGUud2lkdGgsIGEgPSBlLmhlaWdodCwgcyA9IGUuaG9yaXpvbnRhbFBvaW50cywgdSA9IGUuaG9yaXpvbnRhbCwgYyA9IHUgPT09IHZvaWQgMCA/ICEwIDogdTtcbiAgaWYgKCFjIHx8ICF0IHx8ICF0Lmxlbmd0aClcbiAgICByZXR1cm4gbnVsbDtcbiAgdmFyIGYgPSBzLm1hcChmdW5jdGlvbihkKSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQoZCArIGkgLSBpKTtcbiAgfSkuc29ydChmdW5jdGlvbihkLCBwKSB7XG4gICAgcmV0dXJuIGQgLSBwO1xuICB9KTtcbiAgaSAhPT0gZlswXSAmJiBmLnVuc2hpZnQoMCk7XG4gIHZhciBsID0gZi5tYXAoZnVuY3Rpb24oZCwgcCkge1xuICAgIHZhciBnID0gIWZbcCArIDFdLCBoID0gZyA/IGkgKyBhIC0gZCA6IGZbcCArIDFdIC0gZDtcbiAgICBpZiAoaCA8PSAwKVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgdmFyIHYgPSBwICUgdC5sZW5ndGg7XG4gICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBQLmNyZWF0ZUVsZW1lbnQoXCJyZWN0XCIsIHtcbiAgICAgIGtleTogXCJyZWFjdC1cIi5jb25jYXQocCksXG4gICAgICB5OiBkLFxuICAgICAgeDogcixcbiAgICAgIGhlaWdodDogaCxcbiAgICAgIHdpZHRoOiBvLFxuICAgICAgc3Ryb2tlOiBcIm5vbmVcIixcbiAgICAgIGZpbGw6IHRbdl0sXG4gICAgICBmaWxsT3BhY2l0eTogbixcbiAgICAgIGNsYXNzTmFtZTogXCJyZWNoYXJ0cy1jYXJ0ZXNpYW4tZ3JpZC1iZ1wiXG4gICAgfSk7XG4gIH0pO1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIFAuY3JlYXRlRWxlbWVudChcImdcIiwge1xuICAgIGNsYXNzTmFtZTogXCJyZWNoYXJ0cy1jYXJ0ZXNpYW4tZ3JpZHN0cmlwZXMtaG9yaXpvbnRhbFwiXG4gIH0sIGwpO1xufVxuZnVuY3Rpb24gTEcoZSkge1xuICB2YXIgdCA9IGUudmVydGljYWwsIG4gPSB0ID09PSB2b2lkIDAgPyAhMCA6IHQsIHIgPSBlLnZlcnRpY2FsRmlsbCwgaSA9IGUuZmlsbE9wYWNpdHksIG8gPSBlLngsIGEgPSBlLnksIHMgPSBlLndpZHRoLCB1ID0gZS5oZWlnaHQsIGMgPSBlLnZlcnRpY2FsUG9pbnRzO1xuICBpZiAoIW4gfHwgIXIgfHwgIXIubGVuZ3RoKVxuICAgIHJldHVybiBudWxsO1xuICB2YXIgZiA9IGMubWFwKGZ1bmN0aW9uKGQpIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZChkICsgbyAtIG8pO1xuICB9KS5zb3J0KGZ1bmN0aW9uKGQsIHApIHtcbiAgICByZXR1cm4gZCAtIHA7XG4gIH0pO1xuICBvICE9PSBmWzBdICYmIGYudW5zaGlmdCgwKTtcbiAgdmFyIGwgPSBmLm1hcChmdW5jdGlvbihkLCBwKSB7XG4gICAgdmFyIGcgPSAhZltwICsgMV0sIGggPSBnID8gbyArIHMgLSBkIDogZltwICsgMV0gLSBkO1xuICAgIGlmIChoIDw9IDApXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB2YXIgdiA9IHAgJSByLmxlbmd0aDtcbiAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIFAuY3JlYXRlRWxlbWVudChcInJlY3RcIiwge1xuICAgICAga2V5OiBcInJlYWN0LVwiLmNvbmNhdChwKSxcbiAgICAgIHg6IGQsXG4gICAgICB5OiBhLFxuICAgICAgd2lkdGg6IGgsXG4gICAgICBoZWlnaHQ6IHUsXG4gICAgICBzdHJva2U6IFwibm9uZVwiLFxuICAgICAgZmlsbDogclt2XSxcbiAgICAgIGZpbGxPcGFjaXR5OiBpLFxuICAgICAgY2xhc3NOYW1lOiBcInJlY2hhcnRzLWNhcnRlc2lhbi1ncmlkLWJnXCJcbiAgICB9KTtcbiAgfSk7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gUC5jcmVhdGVFbGVtZW50KFwiZ1wiLCB7XG4gICAgY2xhc3NOYW1lOiBcInJlY2hhcnRzLWNhcnRlc2lhbi1ncmlkc3RyaXBlcy12ZXJ0aWNhbFwiXG4gIH0sIGwpO1xufVxudmFyIEJHID0gZnVuY3Rpb24odCwgbikge1xuICB2YXIgciA9IHQueEF4aXMsIGkgPSB0LndpZHRoLCBvID0gdC5oZWlnaHQsIGEgPSB0Lm9mZnNldDtcbiAgcmV0dXJuIEgwKHdkKHN0KHN0KHN0KHt9LCB3aS5kZWZhdWx0UHJvcHMpLCByKSwge30sIHtcbiAgICB0aWNrczogbW4ociwgITApLFxuICAgIHZpZXdCb3g6IHtcbiAgICAgIHg6IDAsXG4gICAgICB5OiAwLFxuICAgICAgd2lkdGg6IGksXG4gICAgICBoZWlnaHQ6IG9cbiAgICB9XG4gIH0pKSwgYS5sZWZ0LCBhLmxlZnQgKyBhLndpZHRoLCBuKTtcbn0sIHpHID0gZnVuY3Rpb24odCwgbikge1xuICB2YXIgciA9IHQueUF4aXMsIGkgPSB0LndpZHRoLCBvID0gdC5oZWlnaHQsIGEgPSB0Lm9mZnNldDtcbiAgcmV0dXJuIEgwKHdkKHN0KHN0KHN0KHt9LCB3aS5kZWZhdWx0UHJvcHMpLCByKSwge30sIHtcbiAgICB0aWNrczogbW4ociwgITApLFxuICAgIHZpZXdCb3g6IHtcbiAgICAgIHg6IDAsXG4gICAgICB5OiAwLFxuICAgICAgd2lkdGg6IGksXG4gICAgICBoZWlnaHQ6IG9cbiAgICB9XG4gIH0pKSwgYS50b3AsIGEudG9wICsgYS5oZWlnaHQsIG4pO1xufSwgQXIgPSB7XG4gIGhvcml6b250YWw6ICEwLFxuICB2ZXJ0aWNhbDogITAsXG4gIC8vIFRoZSBvcmRpbmF0ZXMgb2YgaG9yaXpvbnRhbCBncmlkIGxpbmVzXG4gIGhvcml6b250YWxQb2ludHM6IFtdLFxuICAvLyBUaGUgYWJzY2lzc2FzIG9mIHZlcnRpY2FsIGdyaWQgbGluZXNcbiAgdmVydGljYWxQb2ludHM6IFtdLFxuICBzdHJva2U6IFwiI2NjY1wiLFxuICBmaWxsOiBcIm5vbmVcIixcbiAgLy8gVGhlIGZpbGwgb2YgY29sb3JzIG9mIGdyaWQgbGluZXNcbiAgdmVydGljYWxGaWxsOiBbXSxcbiAgaG9yaXpvbnRhbEZpbGw6IFtdXG59O1xuZnVuY3Rpb24gTXcoZSkge1xuICB2YXIgdCwgbiwgciwgaSwgbywgYSwgcyA9IG1kKCksIHUgPSB5ZCgpLCBjID0gVzUoKSwgZiA9IHN0KHN0KHt9LCBlKSwge30sIHtcbiAgICBzdHJva2U6ICh0ID0gZS5zdHJva2UpICE9PSBudWxsICYmIHQgIT09IHZvaWQgMCA/IHQgOiBBci5zdHJva2UsXG4gICAgZmlsbDogKG4gPSBlLmZpbGwpICE9PSBudWxsICYmIG4gIT09IHZvaWQgMCA/IG4gOiBBci5maWxsLFxuICAgIGhvcml6b250YWw6IChyID0gZS5ob3Jpem9udGFsKSAhPT0gbnVsbCAmJiByICE9PSB2b2lkIDAgPyByIDogQXIuaG9yaXpvbnRhbCxcbiAgICBob3Jpem9udGFsRmlsbDogKGkgPSBlLmhvcml6b250YWxGaWxsKSAhPT0gbnVsbCAmJiBpICE9PSB2b2lkIDAgPyBpIDogQXIuaG9yaXpvbnRhbEZpbGwsXG4gICAgdmVydGljYWw6IChvID0gZS52ZXJ0aWNhbCkgIT09IG51bGwgJiYgbyAhPT0gdm9pZCAwID8gbyA6IEFyLnZlcnRpY2FsLFxuICAgIHZlcnRpY2FsRmlsbDogKGEgPSBlLnZlcnRpY2FsRmlsbCkgIT09IG51bGwgJiYgYSAhPT0gdm9pZCAwID8gYSA6IEFyLnZlcnRpY2FsRmlsbCxcbiAgICB4OiBLKGUueCkgPyBlLnggOiBjLmxlZnQsXG4gICAgeTogSyhlLnkpID8gZS55IDogYy50b3AsXG4gICAgd2lkdGg6IEsoZS53aWR0aCkgPyBlLndpZHRoIDogYy53aWR0aCxcbiAgICBoZWlnaHQ6IEsoZS5oZWlnaHQpID8gZS5oZWlnaHQgOiBjLmhlaWdodFxuICB9KSwgbCA9IGYueCwgZCA9IGYueSwgcCA9IGYud2lkdGgsIGcgPSBmLmhlaWdodCwgaCA9IGYuc3luY1dpdGhUaWNrcywgdiA9IGYuaG9yaXpvbnRhbFZhbHVlcywgdyA9IGYudmVydGljYWxWYWx1ZXMsIGIgPSB6NSgpLCB4ID0gVjUoKTtcbiAgaWYgKCFLKHApIHx8IHAgPD0gMCB8fCAhSyhnKSB8fCBnIDw9IDAgfHwgIUsobCkgfHwgbCAhPT0gK2wgfHwgIUsoZCkgfHwgZCAhPT0gK2QpXG4gICAgcmV0dXJuIG51bGw7XG4gIHZhciBtID0gZi52ZXJ0aWNhbENvb3JkaW5hdGVzR2VuZXJhdG9yIHx8IEJHLCB5ID0gZi5ob3Jpem9udGFsQ29vcmRpbmF0ZXNHZW5lcmF0b3IgfHwgekcsIFMgPSBmLmhvcml6b250YWxQb2ludHMsICQgPSBmLnZlcnRpY2FsUG9pbnRzO1xuICBpZiAoKCFTIHx8ICFTLmxlbmd0aCkgJiYgcGUoeSkpIHtcbiAgICB2YXIgTyA9IHYgJiYgdi5sZW5ndGgsIFQgPSB5KHtcbiAgICAgIHlBeGlzOiB4ID8gc3Qoc3Qoe30sIHgpLCB7fSwge1xuICAgICAgICB0aWNrczogTyA/IHYgOiB4LnRpY2tzXG4gICAgICB9KSA6IHZvaWQgMCxcbiAgICAgIHdpZHRoOiBzLFxuICAgICAgaGVpZ2h0OiB1LFxuICAgICAgb2Zmc2V0OiBjXG4gICAgfSwgTyA/ICEwIDogaCk7XG4gICAgRnIoQXJyYXkuaXNBcnJheShUKSwgXCJob3Jpem9udGFsQ29vcmRpbmF0ZXNHZW5lcmF0b3Igc2hvdWxkIHJldHVybiBBcnJheSBidXQgaW5zdGVhZCBpdCByZXR1cm5lZCBbXCIuY29uY2F0KGRyKFQpLCBcIl1cIikpLCBBcnJheS5pc0FycmF5KFQpICYmIChTID0gVCk7XG4gIH1cbiAgaWYgKCghJCB8fCAhJC5sZW5ndGgpICYmIHBlKG0pKSB7XG4gICAgdmFyIE0gPSB3ICYmIHcubGVuZ3RoLCBFID0gbSh7XG4gICAgICB4QXhpczogYiA/IHN0KHN0KHt9LCBiKSwge30sIHtcbiAgICAgICAgdGlja3M6IE0gPyB3IDogYi50aWNrc1xuICAgICAgfSkgOiB2b2lkIDAsXG4gICAgICB3aWR0aDogcyxcbiAgICAgIGhlaWdodDogdSxcbiAgICAgIG9mZnNldDogY1xuICAgIH0sIE0gPyAhMCA6IGgpO1xuICAgIEZyKEFycmF5LmlzQXJyYXkoRSksIFwidmVydGljYWxDb29yZGluYXRlc0dlbmVyYXRvciBzaG91bGQgcmV0dXJuIEFycmF5IGJ1dCBpbnN0ZWFkIGl0IHJldHVybmVkIFtcIi5jb25jYXQoZHIoRSksIFwiXVwiKSksIEFycmF5LmlzQXJyYXkoRSkgJiYgKCQgPSBFKTtcbiAgfVxuICByZXR1cm4gLyogQF9fUFVSRV9fICovIFAuY3JlYXRlRWxlbWVudChcImdcIiwge1xuICAgIGNsYXNzTmFtZTogXCJyZWNoYXJ0cy1jYXJ0ZXNpYW4tZ3JpZFwiXG4gIH0sIC8qIEBfX1BVUkVfXyAqLyBQLmNyZWF0ZUVsZW1lbnQoa0csIHtcbiAgICBmaWxsOiBmLmZpbGwsXG4gICAgZmlsbE9wYWNpdHk6IGYuZmlsbE9wYWNpdHksXG4gICAgeDogZi54LFxuICAgIHk6IGYueSxcbiAgICB3aWR0aDogZi53aWR0aCxcbiAgICBoZWlnaHQ6IGYuaGVpZ2h0XG4gIH0pLCAvKiBAX19QVVJFX18gKi8gUC5jcmVhdGVFbGVtZW50KERHLCBvcih7fSwgZiwge1xuICAgIG9mZnNldDogYyxcbiAgICBob3Jpem9udGFsUG9pbnRzOiBTLFxuICAgIHhBeGlzOiBiLFxuICAgIHlBeGlzOiB4XG4gIH0pKSwgLyogQF9fUFVSRV9fICovIFAuY3JlYXRlRWxlbWVudChORywgb3Ioe30sIGYsIHtcbiAgICBvZmZzZXQ6IGMsXG4gICAgdmVydGljYWxQb2ludHM6ICQsXG4gICAgeEF4aXM6IGIsXG4gICAgeUF4aXM6IHhcbiAgfSkpLCAvKiBAX19QVVJFX18gKi8gUC5jcmVhdGVFbGVtZW50KEZHLCBvcih7fSwgZiwge1xuICAgIGhvcml6b250YWxQb2ludHM6IFNcbiAgfSkpLCAvKiBAX19QVVJFX18gKi8gUC5jcmVhdGVFbGVtZW50KExHLCBvcih7fSwgZiwge1xuICAgIHZlcnRpY2FsUG9pbnRzOiAkXG4gIH0pKSk7XG59XG5Ndy5kaXNwbGF5TmFtZSA9IFwiQ2FydGVzaWFuR3JpZFwiO1xudmFyIFZHID0gW1widHlwZVwiLCBcImxheW91dFwiLCBcImNvbm5lY3ROdWxsc1wiLCBcInJlZlwiXTtcbmZ1bmN0aW9uIGVpKGUpIHtcbiAgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiO1xuICByZXR1cm4gZWkgPSB0eXBlb2YgU3ltYm9sID09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09IFwic3ltYm9sXCIgPyBmdW5jdGlvbih0KSB7XG4gICAgcmV0dXJuIHR5cGVvZiB0O1xuICB9IDogZnVuY3Rpb24odCkge1xuICAgIHJldHVybiB0ICYmIHR5cGVvZiBTeW1ib2wgPT0gXCJmdW5jdGlvblwiICYmIHQuY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiB0ICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiB0O1xuICB9LCBlaShlKTtcbn1cbmZ1bmN0aW9uIEdHKGUsIHQpIHtcbiAgaWYgKGUgPT0gbnVsbClcbiAgICByZXR1cm4ge307XG4gIHZhciBuID0gV0coZSwgdCksIHIsIGk7XG4gIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gICAgdmFyIG8gPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGUpO1xuICAgIGZvciAoaSA9IDA7IGkgPCBvLmxlbmd0aDsgaSsrKVxuICAgICAgciA9IG9baV0sICEodC5pbmRleE9mKHIpID49IDApICYmIE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChlLCByKSAmJiAobltyXSA9IGVbcl0pO1xuICB9XG4gIHJldHVybiBuO1xufVxuZnVuY3Rpb24gV0coZSwgdCkge1xuICBpZiAoZSA9PSBudWxsKVxuICAgIHJldHVybiB7fTtcbiAgdmFyIG4gPSB7fSwgciA9IE9iamVjdC5rZXlzKGUpLCBpLCBvO1xuICBmb3IgKG8gPSAwOyBvIDwgci5sZW5ndGg7IG8rKylcbiAgICBpID0gcltvXSwgISh0LmluZGV4T2YoaSkgPj0gMCkgJiYgKG5baV0gPSBlW2ldKTtcbiAgcmV0dXJuIG47XG59XG5mdW5jdGlvbiBxaSgpIHtcbiAgcmV0dXJuIHFpID0gT2JqZWN0LmFzc2lnbiA/IE9iamVjdC5hc3NpZ24uYmluZCgpIDogZnVuY3Rpb24oZSkge1xuICAgIGZvciAodmFyIHQgPSAxOyB0IDwgYXJndW1lbnRzLmxlbmd0aDsgdCsrKSB7XG4gICAgICB2YXIgbiA9IGFyZ3VtZW50c1t0XTtcbiAgICAgIGZvciAodmFyIHIgaW4gbilcbiAgICAgICAgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG4sIHIpICYmIChlW3JdID0gbltyXSk7XG4gICAgfVxuICAgIHJldHVybiBlO1xuICB9LCBxaS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuZnVuY3Rpb24gWXYoZSwgdCkge1xuICB2YXIgbiA9IE9iamVjdC5rZXlzKGUpO1xuICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykge1xuICAgIHZhciByID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhlKTtcbiAgICB0ICYmIChyID0gci5maWx0ZXIoZnVuY3Rpb24oaSkge1xuICAgICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSwgaSkuZW51bWVyYWJsZTtcbiAgICB9KSksIG4ucHVzaC5hcHBseShuLCByKTtcbiAgfVxuICByZXR1cm4gbjtcbn1cbmZ1bmN0aW9uIHl0KGUpIHtcbiAgZm9yICh2YXIgdCA9IDE7IHQgPCBhcmd1bWVudHMubGVuZ3RoOyB0KyspIHtcbiAgICB2YXIgbiA9IGFyZ3VtZW50c1t0XSAhPSBudWxsID8gYXJndW1lbnRzW3RdIDoge307XG4gICAgdCAlIDIgPyBZdihPYmplY3QobiksICEwKS5mb3JFYWNoKGZ1bmN0aW9uKHIpIHtcbiAgICAgIFV0KGUsIHIsIG5bcl0pO1xuICAgIH0pIDogT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhlLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhuKSkgOiBZdihPYmplY3QobikpLmZvckVhY2goZnVuY3Rpb24ocikge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIHIsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobiwgcikpO1xuICAgIH0pO1xuICB9XG4gIHJldHVybiBlO1xufVxuZnVuY3Rpb24gUHIoZSkge1xuICByZXR1cm4gS0coZSkgfHwgcUcoZSkgfHwgSEcoZSkgfHwgVUcoKTtcbn1cbmZ1bmN0aW9uIFVHKCkge1xuICB0aHJvdyBuZXcgVHlwZUVycm9yKGBJbnZhbGlkIGF0dGVtcHQgdG8gc3ByZWFkIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5gKTtcbn1cbmZ1bmN0aW9uIEhHKGUsIHQpIHtcbiAgaWYgKGUpIHtcbiAgICBpZiAodHlwZW9mIGUgPT0gXCJzdHJpbmdcIilcbiAgICAgIHJldHVybiBMbChlLCB0KTtcbiAgICB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChlKS5zbGljZSg4LCAtMSk7XG4gICAgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgZS5jb25zdHJ1Y3RvciAmJiAobiA9IGUuY29uc3RydWN0b3IubmFtZSksIG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIilcbiAgICAgIHJldHVybiBBcnJheS5mcm9tKGUpO1xuICAgIGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKVxuICAgICAgcmV0dXJuIExsKGUsIHQpO1xuICB9XG59XG5mdW5jdGlvbiBxRyhlKSB7XG4gIGlmICh0eXBlb2YgU3ltYm9sIDwgXCJ1XCIgJiYgZVtTeW1ib2wuaXRlcmF0b3JdICE9IG51bGwgfHwgZVtcIkBAaXRlcmF0b3JcIl0gIT0gbnVsbClcbiAgICByZXR1cm4gQXJyYXkuZnJvbShlKTtcbn1cbmZ1bmN0aW9uIEtHKGUpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoZSkpXG4gICAgcmV0dXJuIExsKGUpO1xufVxuZnVuY3Rpb24gTGwoZSwgdCkge1xuICAodCA9PSBudWxsIHx8IHQgPiBlLmxlbmd0aCkgJiYgKHQgPSBlLmxlbmd0aCk7XG4gIGZvciAodmFyIG4gPSAwLCByID0gbmV3IEFycmF5KHQpOyBuIDwgdDsgbisrKVxuICAgIHJbbl0gPSBlW25dO1xuICByZXR1cm4gcjtcbn1cbmZ1bmN0aW9uIFlHKGUsIHQpIHtcbiAgaWYgKCEoZSBpbnN0YW5jZW9mIHQpKVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XG59XG5mdW5jdGlvbiBYdihlLCB0KSB7XG4gIGZvciAodmFyIG4gPSAwOyBuIDwgdC5sZW5ndGg7IG4rKykge1xuICAgIHZhciByID0gdFtuXTtcbiAgICByLmVudW1lcmFibGUgPSByLmVudW1lcmFibGUgfHwgITEsIHIuY29uZmlndXJhYmxlID0gITAsIFwidmFsdWVcIiBpbiByICYmIChyLndyaXRhYmxlID0gITApLCBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgSXcoci5rZXkpLCByKTtcbiAgfVxufVxuZnVuY3Rpb24gWEcoZSwgdCwgbikge1xuICByZXR1cm4gdCAmJiBYdihlLnByb3RvdHlwZSwgdCksIG4gJiYgWHYoZSwgbiksIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCBcInByb3RvdHlwZVwiLCB7IHdyaXRhYmxlOiAhMSB9KSwgZTtcbn1cbmZ1bmN0aW9uIFpHKGUsIHQsIG4pIHtcbiAgcmV0dXJuIHQgPSBFcyh0KSwgSkcoZSwgUncoKSA/IFJlZmxlY3QuY29uc3RydWN0KHQsIG4gfHwgW10sIEVzKGUpLmNvbnN0cnVjdG9yKSA6IHQuYXBwbHkoZSwgbikpO1xufVxuZnVuY3Rpb24gSkcoZSwgdCkge1xuICBpZiAodCAmJiAoZWkodCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIHQgPT0gXCJmdW5jdGlvblwiKSlcbiAgICByZXR1cm4gdDtcbiAgaWYgKHQgIT09IHZvaWQgMClcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRGVyaXZlZCBjb25zdHJ1Y3RvcnMgbWF5IG9ubHkgcmV0dXJuIG9iamVjdCBvciB1bmRlZmluZWRcIik7XG4gIHJldHVybiBJbihlKTtcbn1cbmZ1bmN0aW9uIFJ3KCkge1xuICB0cnkge1xuICAgIHZhciBlID0gIUJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24oKSB7XG4gICAgfSkpO1xuICB9IGNhdGNoIHtcbiAgfVxuICByZXR1cm4gKFJ3ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuICEhZTtcbiAgfSkoKTtcbn1cbmZ1bmN0aW9uIEVzKGUpIHtcbiAgcmV0dXJuIEVzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mLmJpbmQoKSA6IGZ1bmN0aW9uKG4pIHtcbiAgICByZXR1cm4gbi5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG4pO1xuICB9LCBFcyhlKTtcbn1cbmZ1bmN0aW9uIEluKGUpIHtcbiAgaWYgKGUgPT09IHZvaWQgMClcbiAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7XG4gIHJldHVybiBlO1xufVxuZnVuY3Rpb24gUUcoZSwgdCkge1xuICBpZiAodHlwZW9mIHQgIT0gXCJmdW5jdGlvblwiICYmIHQgIT09IG51bGwpXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpO1xuICBlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUodCAmJiB0LnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogZSwgd3JpdGFibGU6ICEwLCBjb25maWd1cmFibGU6ICEwIH0gfSksIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCBcInByb3RvdHlwZVwiLCB7IHdyaXRhYmxlOiAhMSB9KSwgdCAmJiBCbChlLCB0KTtcbn1cbmZ1bmN0aW9uIEJsKGUsIHQpIHtcbiAgcmV0dXJuIEJsID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mLmJpbmQoKSA6IGZ1bmN0aW9uKHIsIGkpIHtcbiAgICByZXR1cm4gci5fX3Byb3RvX18gPSBpLCByO1xuICB9LCBCbChlLCB0KTtcbn1cbmZ1bmN0aW9uIFV0KGUsIHQsIG4pIHtcbiAgcmV0dXJuIHQgPSBJdyh0KSwgdCBpbiBlID8gT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIHQsIHsgdmFsdWU6IG4sIGVudW1lcmFibGU6ICEwLCBjb25maWd1cmFibGU6ICEwLCB3cml0YWJsZTogITAgfSkgOiBlW3RdID0gbiwgZTtcbn1cbmZ1bmN0aW9uIEl3KGUpIHtcbiAgdmFyIHQgPSBlVyhlLCBcInN0cmluZ1wiKTtcbiAgcmV0dXJuIGVpKHQpID09IFwic3ltYm9sXCIgPyB0IDogU3RyaW5nKHQpO1xufVxuZnVuY3Rpb24gZVcoZSwgdCkge1xuICBpZiAoZWkoZSkgIT0gXCJvYmplY3RcIiB8fCAhZSlcbiAgICByZXR1cm4gZTtcbiAgdmFyIG4gPSBlW1N5bWJvbC50b1ByaW1pdGl2ZV07XG4gIGlmIChuICE9PSB2b2lkIDApIHtcbiAgICB2YXIgciA9IG4uY2FsbChlLCB0IHx8IFwiZGVmYXVsdFwiKTtcbiAgICBpZiAoZWkocikgIT0gXCJvYmplY3RcIilcbiAgICAgIHJldHVybiByO1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJAQHRvUHJpbWl0aXZlIG11c3QgcmV0dXJuIGEgcHJpbWl0aXZlIHZhbHVlLlwiKTtcbiAgfVxuICByZXR1cm4gKHQgPT09IFwic3RyaW5nXCIgPyBTdHJpbmcgOiBOdW1iZXIpKGUpO1xufVxudmFyIHRpID0gLyogQF9fUFVSRV9fICovIGZ1bmN0aW9uKGUpIHtcbiAgUUcodCwgZSk7XG4gIGZ1bmN0aW9uIHQoKSB7XG4gICAgdmFyIG47XG4gICAgWUcodGhpcywgdCk7XG4gICAgZm9yICh2YXIgciA9IGFyZ3VtZW50cy5sZW5ndGgsIGkgPSBuZXcgQXJyYXkociksIG8gPSAwOyBvIDwgcjsgbysrKVxuICAgICAgaVtvXSA9IGFyZ3VtZW50c1tvXTtcbiAgICByZXR1cm4gbiA9IFpHKHRoaXMsIHQsIFtdLmNvbmNhdChpKSksIFV0KEluKG4pLCBcInN0YXRlXCIsIHtcbiAgICAgIGlzQW5pbWF0aW9uRmluaXNoZWQ6ICEwLFxuICAgICAgdG90YWxMZW5ndGg6IDBcbiAgICB9KSwgVXQoSW4obiksIFwiZ2VuZXJhdGVTaW1wbGVTdHJva2VEYXNoYXJyYXlcIiwgZnVuY3Rpb24oYSwgcykge1xuICAgICAgcmV0dXJuIFwiXCIuY29uY2F0KHMsIFwicHggXCIpLmNvbmNhdChhIC0gcywgXCJweFwiKTtcbiAgICB9KSwgVXQoSW4obiksIFwiZ2V0U3Ryb2tlRGFzaGFycmF5XCIsIGZ1bmN0aW9uKGEsIHMsIHUpIHtcbiAgICAgIHZhciBjID0gdS5yZWR1Y2UoZnVuY3Rpb24odywgYikge1xuICAgICAgICByZXR1cm4gdyArIGI7XG4gICAgICB9KTtcbiAgICAgIGlmICghYylcbiAgICAgICAgcmV0dXJuIG4uZ2VuZXJhdGVTaW1wbGVTdHJva2VEYXNoYXJyYXkocywgYSk7XG4gICAgICBmb3IgKHZhciBmID0gTWF0aC5mbG9vcihhIC8gYyksIGwgPSBhICUgYywgZCA9IHMgLSBhLCBwID0gW10sIGcgPSAwLCBoID0gMDsgZyA8IHUubGVuZ3RoOyBoICs9IHVbZ10sICsrZylcbiAgICAgICAgaWYgKGggKyB1W2ddID4gbCkge1xuICAgICAgICAgIHAgPSBbXS5jb25jYXQoUHIodS5zbGljZSgwLCBnKSksIFtsIC0gaF0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB2YXIgdiA9IHAubGVuZ3RoICUgMiA9PT0gMCA/IFswLCBkXSA6IFtkXTtcbiAgICAgIHJldHVybiBbXS5jb25jYXQoUHIodC5yZXBlYXQodSwgZikpLCBQcihwKSwgdikubWFwKGZ1bmN0aW9uKHcpIHtcbiAgICAgICAgcmV0dXJuIFwiXCIuY29uY2F0KHcsIFwicHhcIik7XG4gICAgICB9KS5qb2luKFwiLCBcIik7XG4gICAgfSksIFV0KEluKG4pLCBcImlkXCIsIFVvKFwicmVjaGFydHMtbGluZS1cIikpLCBVdChJbihuKSwgXCJwYXRoUmVmXCIsIGZ1bmN0aW9uKGEpIHtcbiAgICAgIG4ubWFpbkN1cnZlID0gYTtcbiAgICB9KSwgVXQoSW4obiksIFwiaGFuZGxlQW5pbWF0aW9uRW5kXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgbi5zZXRTdGF0ZSh7XG4gICAgICAgIGlzQW5pbWF0aW9uRmluaXNoZWQ6ICEwXG4gICAgICB9KSwgbi5wcm9wcy5vbkFuaW1hdGlvbkVuZCAmJiBuLnByb3BzLm9uQW5pbWF0aW9uRW5kKCk7XG4gICAgfSksIFV0KEluKG4pLCBcImhhbmRsZUFuaW1hdGlvblN0YXJ0XCIsIGZ1bmN0aW9uKCkge1xuICAgICAgbi5zZXRTdGF0ZSh7XG4gICAgICAgIGlzQW5pbWF0aW9uRmluaXNoZWQ6ICExXG4gICAgICB9KSwgbi5wcm9wcy5vbkFuaW1hdGlvblN0YXJ0ICYmIG4ucHJvcHMub25BbmltYXRpb25TdGFydCgpO1xuICAgIH0pLCBuO1xuICB9XG4gIHJldHVybiBYRyh0LCBbe1xuICAgIGtleTogXCJjb21wb25lbnREaWRNb3VudFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICh0aGlzLnByb3BzLmlzQW5pbWF0aW9uQWN0aXZlKSB7XG4gICAgICAgIHZhciByID0gdGhpcy5nZXRUb3RhbExlbmd0aCgpO1xuICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICB0b3RhbExlbmd0aDogclxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY29tcG9uZW50RGlkVXBkYXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHRoaXMucHJvcHMuaXNBbmltYXRpb25BY3RpdmUpIHtcbiAgICAgICAgdmFyIHIgPSB0aGlzLmdldFRvdGFsTGVuZ3RoKCk7XG4gICAgICAgIHIgIT09IHRoaXMuc3RhdGUudG90YWxMZW5ndGggJiYgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgdG90YWxMZW5ndGg6IHJcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldFRvdGFsTGVuZ3RoXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHIgPSB0aGlzLm1haW5DdXJ2ZTtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiByICYmIHIuZ2V0VG90YWxMZW5ndGggJiYgci5nZXRUb3RhbExlbmd0aCgpIHx8IDA7XG4gICAgICB9IGNhdGNoIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJlbmRlckVycm9yQmFyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uKHIsIGkpIHtcbiAgICAgIGlmICh0aGlzLnByb3BzLmlzQW5pbWF0aW9uQWN0aXZlICYmICF0aGlzLnN0YXRlLmlzQW5pbWF0aW9uRmluaXNoZWQpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgdmFyIG8gPSB0aGlzLnByb3BzLCBhID0gby5wb2ludHMsIHMgPSBvLnhBeGlzLCB1ID0gby55QXhpcywgYyA9IG8ubGF5b3V0LCBmID0gby5jaGlsZHJlbiwgbCA9IGt0KGYsIFpvKTtcbiAgICAgIGlmICghbClcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB2YXIgZCA9IGZ1bmN0aW9uKGgsIHYpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB4OiBoLngsXG4gICAgICAgICAgeTogaC55LFxuICAgICAgICAgIHZhbHVlOiBoLnZhbHVlLFxuICAgICAgICAgIGVycm9yVmFsOiBBdChoLnBheWxvYWQsIHYpXG4gICAgICAgIH07XG4gICAgICB9LCBwID0ge1xuICAgICAgICBjbGlwUGF0aDogciA/IFwidXJsKCNjbGlwUGF0aC1cIi5jb25jYXQoaSwgXCIpXCIpIDogbnVsbFxuICAgICAgfTtcbiAgICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8gUC5jcmVhdGVFbGVtZW50KFdlLCBwLCBsLm1hcChmdW5jdGlvbihnKSB7XG4gICAgICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8gUC5jbG9uZUVsZW1lbnQoZywge1xuICAgICAgICAgIGtleTogXCJiYXItXCIuY29uY2F0KGcucHJvcHMuZGF0YUtleSksXG4gICAgICAgICAgZGF0YTogYSxcbiAgICAgICAgICB4QXhpczogcyxcbiAgICAgICAgICB5QXhpczogdSxcbiAgICAgICAgICBsYXlvdXQ6IGMsXG4gICAgICAgICAgZGF0YVBvaW50Rm9ybWF0dGVyOiBkXG4gICAgICAgIH0pO1xuICAgICAgfSkpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyZW5kZXJEb3RzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uKHIsIGksIG8pIHtcbiAgICAgIHZhciBhID0gdGhpcy5wcm9wcy5pc0FuaW1hdGlvbkFjdGl2ZTtcbiAgICAgIGlmIChhICYmICF0aGlzLnN0YXRlLmlzQW5pbWF0aW9uRmluaXNoZWQpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgdmFyIHMgPSB0aGlzLnByb3BzLCB1ID0gcy5kb3QsIGMgPSBzLnBvaW50cywgZiA9IHMuZGF0YUtleSwgbCA9IHllKHRoaXMucHJvcHMsICExKSwgZCA9IHllKHUsICEwKSwgcCA9IGMubWFwKGZ1bmN0aW9uKGgsIHYpIHtcbiAgICAgICAgdmFyIHcgPSB5dCh5dCh5dCh7XG4gICAgICAgICAga2V5OiBcImRvdC1cIi5jb25jYXQodiksXG4gICAgICAgICAgcjogM1xuICAgICAgICB9LCBsKSwgZCksIHt9LCB7XG4gICAgICAgICAgdmFsdWU6IGgudmFsdWUsXG4gICAgICAgICAgZGF0YUtleTogZixcbiAgICAgICAgICBjeDogaC54LFxuICAgICAgICAgIGN5OiBoLnksXG4gICAgICAgICAgaW5kZXg6IHYsXG4gICAgICAgICAgcGF5bG9hZDogaC5wYXlsb2FkXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdC5yZW5kZXJEb3RJdGVtKHUsIHcpO1xuICAgICAgfSksIGcgPSB7XG4gICAgICAgIGNsaXBQYXRoOiByID8gXCJ1cmwoI2NsaXBQYXRoLVwiLmNvbmNhdChpID8gXCJcIiA6IFwiZG90cy1cIikuY29uY2F0KG8sIFwiKVwiKSA6IG51bGxcbiAgICAgIH07XG4gICAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIFAuY3JlYXRlRWxlbWVudChXZSwgcWkoe1xuICAgICAgICBjbGFzc05hbWU6IFwicmVjaGFydHMtbGluZS1kb3RzXCIsXG4gICAgICAgIGtleTogXCJkb3RzXCJcbiAgICAgIH0sIGcpLCBwKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVuZGVyQ3VydmVTdGF0aWNhbGx5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uKHIsIGksIG8sIGEpIHtcbiAgICAgIHZhciBzID0gdGhpcy5wcm9wcywgdSA9IHMudHlwZSwgYyA9IHMubGF5b3V0LCBmID0gcy5jb25uZWN0TnVsbHM7XG4gICAgICBzLnJlZjtcbiAgICAgIHZhciBsID0gR0cocywgVkcpLCBkID0geXQoeXQoeXQoe30sIHllKGwsICEwKSksIHt9LCB7XG4gICAgICAgIGZpbGw6IFwibm9uZVwiLFxuICAgICAgICBjbGFzc05hbWU6IFwicmVjaGFydHMtbGluZS1jdXJ2ZVwiLFxuICAgICAgICBjbGlwUGF0aDogaSA/IFwidXJsKCNjbGlwUGF0aC1cIi5jb25jYXQobywgXCIpXCIpIDogbnVsbCxcbiAgICAgICAgcG9pbnRzOiByXG4gICAgICB9LCBhKSwge30sIHtcbiAgICAgICAgdHlwZTogdSxcbiAgICAgICAgbGF5b3V0OiBjLFxuICAgICAgICBjb25uZWN0TnVsbHM6IGZcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBQLmNyZWF0ZUVsZW1lbnQoYmwsIHFpKHt9LCBkLCB7XG4gICAgICAgIHBhdGhSZWY6IHRoaXMucGF0aFJlZlxuICAgICAgfSkpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyZW5kZXJDdXJ2ZVdpdGhBbmltYXRpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24ociwgaSkge1xuICAgICAgdmFyIG8gPSB0aGlzLCBhID0gdGhpcy5wcm9wcywgcyA9IGEucG9pbnRzLCB1ID0gYS5zdHJva2VEYXNoYXJyYXksIGMgPSBhLmlzQW5pbWF0aW9uQWN0aXZlLCBmID0gYS5hbmltYXRpb25CZWdpbiwgbCA9IGEuYW5pbWF0aW9uRHVyYXRpb24sIGQgPSBhLmFuaW1hdGlvbkVhc2luZywgcCA9IGEuYW5pbWF0aW9uSWQsIGcgPSBhLmFuaW1hdGVOZXdWYWx1ZXMsIGggPSBhLndpZHRoLCB2ID0gYS5oZWlnaHQsIHcgPSB0aGlzLnN0YXRlLCBiID0gdy5wcmV2UG9pbnRzLCB4ID0gdy50b3RhbExlbmd0aDtcbiAgICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8gUC5jcmVhdGVFbGVtZW50KF9uLCB7XG4gICAgICAgIGJlZ2luOiBmLFxuICAgICAgICBkdXJhdGlvbjogbCxcbiAgICAgICAgaXNBY3RpdmU6IGMsXG4gICAgICAgIGVhc2luZzogZCxcbiAgICAgICAgZnJvbToge1xuICAgICAgICAgIHQ6IDBcbiAgICAgICAgfSxcbiAgICAgICAgdG86IHtcbiAgICAgICAgICB0OiAxXG4gICAgICAgIH0sXG4gICAgICAgIGtleTogXCJsaW5lLVwiLmNvbmNhdChwKSxcbiAgICAgICAgb25BbmltYXRpb25FbmQ6IHRoaXMuaGFuZGxlQW5pbWF0aW9uRW5kLFxuICAgICAgICBvbkFuaW1hdGlvblN0YXJ0OiB0aGlzLmhhbmRsZUFuaW1hdGlvblN0YXJ0XG4gICAgICB9LCBmdW5jdGlvbihtKSB7XG4gICAgICAgIHZhciB5ID0gbS50O1xuICAgICAgICBpZiAoYikge1xuICAgICAgICAgIHZhciBTID0gYi5sZW5ndGggLyBzLmxlbmd0aCwgJCA9IHMubWFwKGZ1bmN0aW9uKEEsIGopIHtcbiAgICAgICAgICAgIHZhciBSID0gTWF0aC5mbG9vcihqICogUyk7XG4gICAgICAgICAgICBpZiAoYltSXSkge1xuICAgICAgICAgICAgICB2YXIgTiA9IGJbUl0sIGsgPSBIdChOLngsIEEueCksIEYgPSBIdChOLnksIEEueSk7XG4gICAgICAgICAgICAgIHJldHVybiB5dCh5dCh7fSwgQSksIHt9LCB7XG4gICAgICAgICAgICAgICAgeDogayh5KSxcbiAgICAgICAgICAgICAgICB5OiBGKHkpXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGcpIHtcbiAgICAgICAgICAgICAgdmFyIFYgPSBIdChoICogMiwgQS54KSwgTCA9IEh0KHYgLyAyLCBBLnkpO1xuICAgICAgICAgICAgICByZXR1cm4geXQoeXQoe30sIEEpLCB7fSwge1xuICAgICAgICAgICAgICAgIHg6IFYoeSksXG4gICAgICAgICAgICAgICAgeTogTCh5KVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB5dCh5dCh7fSwgQSksIHt9LCB7XG4gICAgICAgICAgICAgIHg6IEEueCxcbiAgICAgICAgICAgICAgeTogQS55XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm4gby5yZW5kZXJDdXJ2ZVN0YXRpY2FsbHkoJCwgciwgaSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIE8gPSBIdCgwLCB4KSwgVCA9IE8oeSksIE07XG4gICAgICAgIGlmICh1KSB7XG4gICAgICAgICAgdmFyIEUgPSBcIlwiLmNvbmNhdCh1KS5zcGxpdCgvWyxcXHNdKy9naW0pLm1hcChmdW5jdGlvbihBKSB7XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VGbG9hdChBKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBNID0gby5nZXRTdHJva2VEYXNoYXJyYXkoVCwgeCwgRSk7XG4gICAgICAgIH0gZWxzZVxuICAgICAgICAgIE0gPSBvLmdlbmVyYXRlU2ltcGxlU3Ryb2tlRGFzaGFycmF5KHgsIFQpO1xuICAgICAgICByZXR1cm4gby5yZW5kZXJDdXJ2ZVN0YXRpY2FsbHkocywgciwgaSwge1xuICAgICAgICAgIHN0cm9rZURhc2hhcnJheTogTVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyZW5kZXJDdXJ2ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbihyLCBpKSB7XG4gICAgICB2YXIgbyA9IHRoaXMucHJvcHMsIGEgPSBvLnBvaW50cywgcyA9IG8uaXNBbmltYXRpb25BY3RpdmUsIHUgPSB0aGlzLnN0YXRlLCBjID0gdS5wcmV2UG9pbnRzLCBmID0gdS50b3RhbExlbmd0aDtcbiAgICAgIHJldHVybiBzICYmIGEgJiYgYS5sZW5ndGggJiYgKCFjICYmIGYgPiAwIHx8ICF0dShjLCBhKSkgPyB0aGlzLnJlbmRlckN1cnZlV2l0aEFuaW1hdGlvbihyLCBpKSA6IHRoaXMucmVuZGVyQ3VydmVTdGF0aWNhbGx5KGEsIHIsIGkpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyZW5kZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgciwgaSA9IHRoaXMucHJvcHMsIG8gPSBpLmhpZGUsIGEgPSBpLmRvdCwgcyA9IGkucG9pbnRzLCB1ID0gaS5jbGFzc05hbWUsIGMgPSBpLnhBeGlzLCBmID0gaS55QXhpcywgbCA9IGkudG9wLCBkID0gaS5sZWZ0LCBwID0gaS53aWR0aCwgZyA9IGkuaGVpZ2h0LCBoID0gaS5pc0FuaW1hdGlvbkFjdGl2ZSwgdiA9IGkuaWQ7XG4gICAgICBpZiAobyB8fCAhcyB8fCAhcy5sZW5ndGgpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgdmFyIHcgPSB0aGlzLnN0YXRlLmlzQW5pbWF0aW9uRmluaXNoZWQsIGIgPSBzLmxlbmd0aCA9PT0gMSwgeCA9ICRlKFwicmVjaGFydHMtbGluZVwiLCB1KSwgbSA9IGMgJiYgYy5hbGxvd0RhdGFPdmVyZmxvdywgeSA9IGYgJiYgZi5hbGxvd0RhdGFPdmVyZmxvdywgUyA9IG0gfHwgeSwgJCA9IG1lKHYpID8gdGhpcy5pZCA6IHYsIE8gPSAociA9IHllKGEsICExKSkgIT09IG51bGwgJiYgciAhPT0gdm9pZCAwID8gciA6IHtcbiAgICAgICAgcjogMyxcbiAgICAgICAgc3Ryb2tlV2lkdGg6IDJcbiAgICAgIH0sIFQgPSBPLnIsIE0gPSBUID09PSB2b2lkIDAgPyAzIDogVCwgRSA9IE8uc3Ryb2tlV2lkdGgsIEEgPSBFID09PSB2b2lkIDAgPyAyIDogRSwgaiA9IG5FKGEpID8gYSA6IHt9LCBSID0gai5jbGlwRG90LCBOID0gUiA9PT0gdm9pZCAwID8gITAgOiBSLCBrID0gTSAqIDIgKyBBO1xuICAgICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBQLmNyZWF0ZUVsZW1lbnQoV2UsIHtcbiAgICAgICAgY2xhc3NOYW1lOiB4XG4gICAgICB9LCBtIHx8IHkgPyAvKiBAX19QVVJFX18gKi8gUC5jcmVhdGVFbGVtZW50KFwiZGVmc1wiLCBudWxsLCAvKiBAX19QVVJFX18gKi8gUC5jcmVhdGVFbGVtZW50KFwiY2xpcFBhdGhcIiwge1xuICAgICAgICBpZDogXCJjbGlwUGF0aC1cIi5jb25jYXQoJClcbiAgICAgIH0sIC8qIEBfX1BVUkVfXyAqLyBQLmNyZWF0ZUVsZW1lbnQoXCJyZWN0XCIsIHtcbiAgICAgICAgeDogbSA/IGQgOiBkIC0gcCAvIDIsXG4gICAgICAgIHk6IHkgPyBsIDogbCAtIGcgLyAyLFxuICAgICAgICB3aWR0aDogbSA/IHAgOiBwICogMixcbiAgICAgICAgaGVpZ2h0OiB5ID8gZyA6IGcgKiAyXG4gICAgICB9KSksICFOICYmIC8qIEBfX1BVUkVfXyAqLyBQLmNyZWF0ZUVsZW1lbnQoXCJjbGlwUGF0aFwiLCB7XG4gICAgICAgIGlkOiBcImNsaXBQYXRoLWRvdHMtXCIuY29uY2F0KCQpXG4gICAgICB9LCAvKiBAX19QVVJFX18gKi8gUC5jcmVhdGVFbGVtZW50KFwicmVjdFwiLCB7XG4gICAgICAgIHg6IGQgLSBrIC8gMixcbiAgICAgICAgeTogbCAtIGsgLyAyLFxuICAgICAgICB3aWR0aDogcCArIGssXG4gICAgICAgIGhlaWdodDogZyArIGtcbiAgICAgIH0pKSkgOiBudWxsLCAhYiAmJiB0aGlzLnJlbmRlckN1cnZlKFMsICQpLCB0aGlzLnJlbmRlckVycm9yQmFyKFMsICQpLCAoYiB8fCBhKSAmJiB0aGlzLnJlbmRlckRvdHMoUywgTiwgJCksICghaCB8fCB3KSAmJiBCbi5yZW5kZXJDYWxsQnlQYXJlbnQodGhpcy5wcm9wcywgcykpO1xuICAgIH1cbiAgfV0sIFt7XG4gICAga2V5OiBcImdldERlcml2ZWRTdGF0ZUZyb21Qcm9wc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbihyLCBpKSB7XG4gICAgICByZXR1cm4gci5hbmltYXRpb25JZCAhPT0gaS5wcmV2QW5pbWF0aW9uSWQgPyB7XG4gICAgICAgIHByZXZBbmltYXRpb25JZDogci5hbmltYXRpb25JZCxcbiAgICAgICAgY3VyUG9pbnRzOiByLnBvaW50cyxcbiAgICAgICAgcHJldlBvaW50czogaS5jdXJQb2ludHNcbiAgICAgIH0gOiByLnBvaW50cyAhPT0gaS5jdXJQb2ludHMgPyB7XG4gICAgICAgIGN1clBvaW50czogci5wb2ludHNcbiAgICAgIH0gOiBudWxsO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyZXBlYXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24ociwgaSkge1xuICAgICAgZm9yICh2YXIgbyA9IHIubGVuZ3RoICUgMiAhPT0gMCA/IFtdLmNvbmNhdChQcihyKSwgWzBdKSA6IHIsIGEgPSBbXSwgcyA9IDA7IHMgPCBpOyArK3MpXG4gICAgICAgIGEgPSBbXS5jb25jYXQoUHIoYSksIFByKG8pKTtcbiAgICAgIHJldHVybiBhO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyZW5kZXJEb3RJdGVtXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uKHIsIGkpIHtcbiAgICAgIHZhciBvO1xuICAgICAgaWYgKC8qIEBfX1BVUkVfXyAqLyBQLmlzVmFsaWRFbGVtZW50KHIpKVxuICAgICAgICBvID0gLyogQF9fUFVSRV9fICovIFAuY2xvbmVFbGVtZW50KHIsIGkpO1xuICAgICAgZWxzZSBpZiAocGUocikpXG4gICAgICAgIG8gPSByKGkpO1xuICAgICAgZWxzZSB7XG4gICAgICAgIHZhciBhID0gJGUoXCJyZWNoYXJ0cy1saW5lLWRvdFwiLCB0eXBlb2YgciAhPSBcImJvb2xlYW5cIiA/IHIuY2xhc3NOYW1lIDogXCJcIik7XG4gICAgICAgIG8gPSAvKiBAX19QVVJFX18gKi8gUC5jcmVhdGVFbGVtZW50KHBkLCBxaSh7fSwgaSwge1xuICAgICAgICAgIGNsYXNzTmFtZTogYVxuICAgICAgICB9KSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbztcbiAgICB9XG4gIH1dKSwgdDtcbn0oV24pO1xuVXQodGksIFwiZGlzcGxheU5hbWVcIiwgXCJMaW5lXCIpO1xuVXQodGksIFwiZGVmYXVsdFByb3BzXCIsIHtcbiAgeEF4aXNJZDogMCxcbiAgeUF4aXNJZDogMCxcbiAgY29ubmVjdE51bGxzOiAhMSxcbiAgYWN0aXZlRG90OiAhMCxcbiAgZG90OiAhMCxcbiAgbGVnZW5kVHlwZTogXCJsaW5lXCIsXG4gIHN0cm9rZTogXCIjMzE4MmJkXCIsXG4gIHN0cm9rZVdpZHRoOiAxLFxuICBmaWxsOiBcIiNmZmZcIixcbiAgcG9pbnRzOiBbXSxcbiAgaXNBbmltYXRpb25BY3RpdmU6ICF5bi5pc1NzcixcbiAgYW5pbWF0ZU5ld1ZhbHVlczogITAsXG4gIGFuaW1hdGlvbkJlZ2luOiAwLFxuICBhbmltYXRpb25EdXJhdGlvbjogMTUwMCxcbiAgYW5pbWF0aW9uRWFzaW5nOiBcImVhc2VcIixcbiAgaGlkZTogITEsXG4gIGxhYmVsOiAhMVxufSk7XG5VdCh0aSwgXCJnZXRDb21wb3NlZERhdGFcIiwgZnVuY3Rpb24oZSkge1xuICB2YXIgdCA9IGUucHJvcHMsIG4gPSBlLnhBeGlzLCByID0gZS55QXhpcywgaSA9IGUueEF4aXNUaWNrcywgbyA9IGUueUF4aXNUaWNrcywgYSA9IGUuZGF0YUtleSwgcyA9IGUuYmFuZFNpemUsIHUgPSBlLmRpc3BsYXllZERhdGEsIGMgPSBlLm9mZnNldCwgZiA9IHQubGF5b3V0LCBsID0gdS5tYXAoZnVuY3Rpb24oZCwgcCkge1xuICAgIHZhciBnID0gQXQoZCwgYSk7XG4gICAgcmV0dXJuIGYgPT09IFwiaG9yaXpvbnRhbFwiID8ge1xuICAgICAgeDogX2coe1xuICAgICAgICBheGlzOiBuLFxuICAgICAgICB0aWNrczogaSxcbiAgICAgICAgYmFuZFNpemU6IHMsXG4gICAgICAgIGVudHJ5OiBkLFxuICAgICAgICBpbmRleDogcFxuICAgICAgfSksXG4gICAgICB5OiBtZShnKSA/IG51bGwgOiByLnNjYWxlKGcpLFxuICAgICAgdmFsdWU6IGcsXG4gICAgICBwYXlsb2FkOiBkXG4gICAgfSA6IHtcbiAgICAgIHg6IG1lKGcpID8gbnVsbCA6IG4uc2NhbGUoZyksXG4gICAgICB5OiBfZyh7XG4gICAgICAgIGF4aXM6IHIsXG4gICAgICAgIHRpY2tzOiBvLFxuICAgICAgICBiYW5kU2l6ZTogcyxcbiAgICAgICAgZW50cnk6IGQsXG4gICAgICAgIGluZGV4OiBwXG4gICAgICB9KSxcbiAgICAgIHZhbHVlOiBnLFxuICAgICAgcGF5bG9hZDogZFxuICAgIH07XG4gIH0pO1xuICByZXR1cm4geXQoe1xuICAgIHBvaW50czogbCxcbiAgICBsYXlvdXQ6IGZcbiAgfSwgYyk7XG59KTtcbmZ1bmN0aW9uIHpsKCkge1xuICByZXR1cm4gemwgPSBPYmplY3QuYXNzaWduID8gT2JqZWN0LmFzc2lnbi5iaW5kKCkgOiBmdW5jdGlvbihlKSB7XG4gICAgZm9yICh2YXIgdCA9IDE7IHQgPCBhcmd1bWVudHMubGVuZ3RoOyB0KyspIHtcbiAgICAgIHZhciBuID0gYXJndW1lbnRzW3RdO1xuICAgICAgZm9yICh2YXIgciBpbiBuKVxuICAgICAgICBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobiwgcikgJiYgKGVbcl0gPSBuW3JdKTtcbiAgICB9XG4gICAgcmV0dXJuIGU7XG4gIH0sIHpsLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG52YXIgc3UgPSBmdW5jdGlvbih0KSB7XG4gIHZhciBuID0gdC54QXhpc0lkLCByID0gbWQoKSwgaSA9IHlkKCksIG8gPSBfdyhuKTtcbiAgcmV0dXJuIG8gPT0gbnVsbCA/IG51bGwgOiAoXG4gICAgLy8gQHRzLWV4cGVjdC1lcnJvciB0aGUgYXhpc09wdGlvbnMgdHlwZSBpcyBub3QgZXhhY3RseSB3aGF0IENhcnRlc2lhbkF4aXMgaXMgZXhwZWN0aW5nLlxuICAgIC8qIEBfX1BVUkVfXyAqLyBQLmNyZWF0ZUVsZW1lbnQod2ksIHpsKHt9LCBvLCB7XG4gICAgICBjbGFzc05hbWU6ICRlKFwicmVjaGFydHMtXCIuY29uY2F0KG8uYXhpc1R5cGUsIFwiIFwiKS5jb25jYXQoby5heGlzVHlwZSksIG8uY2xhc3NOYW1lKSxcbiAgICAgIHZpZXdCb3g6IHtcbiAgICAgICAgeDogMCxcbiAgICAgICAgeTogMCxcbiAgICAgICAgd2lkdGg6IHIsXG4gICAgICAgIGhlaWdodDogaVxuICAgICAgfSxcbiAgICAgIHRpY2tzR2VuZXJhdG9yOiBmdW5jdGlvbihzKSB7XG4gICAgICAgIHJldHVybiBtbihzLCAhMCk7XG4gICAgICB9XG4gICAgfSkpXG4gICk7XG59O1xuc3UuZGlzcGxheU5hbWUgPSBcIlhBeGlzXCI7XG5zdS5kZWZhdWx0UHJvcHMgPSB7XG4gIGFsbG93RGVjaW1hbHM6ICEwLFxuICBoaWRlOiAhMSxcbiAgb3JpZW50YXRpb246IFwiYm90dG9tXCIsXG4gIHdpZHRoOiAwLFxuICBoZWlnaHQ6IDMwLFxuICBtaXJyb3I6ICExLFxuICB4QXhpc0lkOiAwLFxuICB0aWNrQ291bnQ6IDUsXG4gIHR5cGU6IFwiY2F0ZWdvcnlcIixcbiAgcGFkZGluZzoge1xuICAgIGxlZnQ6IDAsXG4gICAgcmlnaHQ6IDBcbiAgfSxcbiAgYWxsb3dEYXRhT3ZlcmZsb3c6ICExLFxuICBzY2FsZTogXCJhdXRvXCIsXG4gIHJldmVyc2VkOiAhMSxcbiAgYWxsb3dEdXBsaWNhdGVkQ2F0ZWdvcnk6ICEwXG59O1xuZnVuY3Rpb24gVmwoKSB7XG4gIHJldHVybiBWbCA9IE9iamVjdC5hc3NpZ24gPyBPYmplY3QuYXNzaWduLmJpbmQoKSA6IGZ1bmN0aW9uKGUpIHtcbiAgICBmb3IgKHZhciB0ID0gMTsgdCA8IGFyZ3VtZW50cy5sZW5ndGg7IHQrKykge1xuICAgICAgdmFyIG4gPSBhcmd1bWVudHNbdF07XG4gICAgICBmb3IgKHZhciByIGluIG4pXG4gICAgICAgIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChuLCByKSAmJiAoZVtyXSA9IG5bcl0pO1xuICAgIH1cbiAgICByZXR1cm4gZTtcbiAgfSwgVmwuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cbnZhciB1dSA9IGZ1bmN0aW9uKHQpIHtcbiAgdmFyIG4gPSB0LnlBeGlzSWQsIHIgPSBtZCgpLCBpID0geWQoKSwgbyA9IEF3KG4pO1xuICByZXR1cm4gbyA9PSBudWxsID8gbnVsbCA6IChcbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yIHRoZSBheGlzT3B0aW9ucyB0eXBlIGlzIG5vdCBleGFjdGx5IHdoYXQgQ2FydGVzaWFuQXhpcyBpcyBleHBlY3RpbmcuXG4gICAgLyogQF9fUFVSRV9fICovIFAuY3JlYXRlRWxlbWVudCh3aSwgVmwoe30sIG8sIHtcbiAgICAgIGNsYXNzTmFtZTogJGUoXCJyZWNoYXJ0cy1cIi5jb25jYXQoby5heGlzVHlwZSwgXCIgXCIpLmNvbmNhdChvLmF4aXNUeXBlKSwgby5jbGFzc05hbWUpLFxuICAgICAgdmlld0JveDoge1xuICAgICAgICB4OiAwLFxuICAgICAgICB5OiAwLFxuICAgICAgICB3aWR0aDogcixcbiAgICAgICAgaGVpZ2h0OiBpXG4gICAgICB9LFxuICAgICAgdGlja3NHZW5lcmF0b3I6IGZ1bmN0aW9uKHMpIHtcbiAgICAgICAgcmV0dXJuIG1uKHMsICEwKTtcbiAgICAgIH1cbiAgICB9KSlcbiAgKTtcbn07XG51dS5kaXNwbGF5TmFtZSA9IFwiWUF4aXNcIjtcbnV1LmRlZmF1bHRQcm9wcyA9IHtcbiAgYWxsb3dEdXBsaWNhdGVkQ2F0ZWdvcnk6ICEwLFxuICBhbGxvd0RlY2ltYWxzOiAhMCxcbiAgaGlkZTogITEsXG4gIG9yaWVudGF0aW9uOiBcImxlZnRcIixcbiAgd2lkdGg6IDYwLFxuICBoZWlnaHQ6IDAsXG4gIG1pcnJvcjogITEsXG4gIHlBeGlzSWQ6IDAsXG4gIHRpY2tDb3VudDogNSxcbiAgdHlwZTogXCJudW1iZXJcIixcbiAgcGFkZGluZzoge1xuICAgIHRvcDogMCxcbiAgICBib3R0b206IDBcbiAgfSxcbiAgYWxsb3dEYXRhT3ZlcmZsb3c6ICExLFxuICBzY2FsZTogXCJhdXRvXCIsXG4gIHJldmVyc2VkOiAhMVxufTtcbmZ1bmN0aW9uIFp2KGUpIHtcbiAgcmV0dXJuIGlXKGUpIHx8IHJXKGUpIHx8IG5XKGUpIHx8IHRXKCk7XG59XG5mdW5jdGlvbiB0VygpIHtcbiAgdGhyb3cgbmV3IFR5cGVFcnJvcihgSW52YWxpZCBhdHRlbXB0IHRvIHNwcmVhZCBub24taXRlcmFibGUgaW5zdGFuY2UuXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuYCk7XG59XG5mdW5jdGlvbiBuVyhlLCB0KSB7XG4gIGlmIChlKSB7XG4gICAgaWYgKHR5cGVvZiBlID09IFwic3RyaW5nXCIpXG4gICAgICByZXR1cm4gR2woZSwgdCk7XG4gICAgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoZSkuc2xpY2UoOCwgLTEpO1xuICAgIGlmIChuID09PSBcIk9iamVjdFwiICYmIGUuY29uc3RydWN0b3IgJiYgKG4gPSBlLmNvbnN0cnVjdG9yLm5hbWUpLCBuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpXG4gICAgICByZXR1cm4gQXJyYXkuZnJvbShlKTtcbiAgICBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSlcbiAgICAgIHJldHVybiBHbChlLCB0KTtcbiAgfVxufVxuZnVuY3Rpb24gclcoZSkge1xuICBpZiAodHlwZW9mIFN5bWJvbCA8IFwidVwiICYmIGVbU3ltYm9sLml0ZXJhdG9yXSAhPSBudWxsIHx8IGVbXCJAQGl0ZXJhdG9yXCJdICE9IG51bGwpXG4gICAgcmV0dXJuIEFycmF5LmZyb20oZSk7XG59XG5mdW5jdGlvbiBpVyhlKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGUpKVxuICAgIHJldHVybiBHbChlKTtcbn1cbmZ1bmN0aW9uIEdsKGUsIHQpIHtcbiAgKHQgPT0gbnVsbCB8fCB0ID4gZS5sZW5ndGgpICYmICh0ID0gZS5sZW5ndGgpO1xuICBmb3IgKHZhciBuID0gMCwgciA9IG5ldyBBcnJheSh0KTsgbiA8IHQ7IG4rKylcbiAgICByW25dID0gZVtuXTtcbiAgcmV0dXJuIHI7XG59XG52YXIgV2wgPSBmdW5jdGlvbih0LCBuLCByLCBpLCBvKSB7XG4gIHZhciBhID0ga3QodCwgYmQpLCBzID0ga3QodCwgUW8pLCB1ID0gW10uY29uY2F0KFp2KGEpLCBadihzKSksIGMgPSBrdCh0LCBlYSksIGYgPSBcIlwiLmNvbmNhdChpLCBcIklkXCIpLCBsID0gaVswXSwgZCA9IG47XG4gIGlmICh1Lmxlbmd0aCAmJiAoZCA9IHUucmVkdWNlKGZ1bmN0aW9uKGgsIHYpIHtcbiAgICBpZiAodi5wcm9wc1tmXSA9PT0gciAmJiBzbih2LnByb3BzLCBcImV4dGVuZERvbWFpblwiKSAmJiBLKHYucHJvcHNbbF0pKSB7XG4gICAgICB2YXIgdyA9IHYucHJvcHNbbF07XG4gICAgICByZXR1cm4gW01hdGgubWluKGhbMF0sIHcpLCBNYXRoLm1heChoWzFdLCB3KV07XG4gICAgfVxuICAgIHJldHVybiBoO1xuICB9LCBkKSksIGMubGVuZ3RoKSB7XG4gICAgdmFyIHAgPSBcIlwiLmNvbmNhdChsLCBcIjFcIiksIGcgPSBcIlwiLmNvbmNhdChsLCBcIjJcIik7XG4gICAgZCA9IGMucmVkdWNlKGZ1bmN0aW9uKGgsIHYpIHtcbiAgICAgIGlmICh2LnByb3BzW2ZdID09PSByICYmIHNuKHYucHJvcHMsIFwiZXh0ZW5kRG9tYWluXCIpICYmIEsodi5wcm9wc1twXSkgJiYgSyh2LnByb3BzW2ddKSkge1xuICAgICAgICB2YXIgdyA9IHYucHJvcHNbcF0sIGIgPSB2LnByb3BzW2ddO1xuICAgICAgICByZXR1cm4gW01hdGgubWluKGhbMF0sIHcsIGIpLCBNYXRoLm1heChoWzFdLCB3LCBiKV07XG4gICAgICB9XG4gICAgICByZXR1cm4gaDtcbiAgICB9LCBkKTtcbiAgfVxuICByZXR1cm4gbyAmJiBvLmxlbmd0aCAmJiAoZCA9IG8ucmVkdWNlKGZ1bmN0aW9uKGgsIHYpIHtcbiAgICByZXR1cm4gSyh2KSA/IFtNYXRoLm1pbihoWzBdLCB2KSwgTWF0aC5tYXgoaFsxXSwgdildIDogaDtcbiAgfSwgZCkpLCBkO1xufSwgancgPSB7IGV4cG9ydHM6IHt9IH07XG4oZnVuY3Rpb24oZSkge1xuICB2YXIgdCA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHksIG4gPSBcIn5cIjtcbiAgZnVuY3Rpb24gcigpIHtcbiAgfVxuICBPYmplY3QuY3JlYXRlICYmIChyLnByb3RvdHlwZSA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpLCBuZXcgcigpLl9fcHJvdG9fXyB8fCAobiA9ICExKSk7XG4gIGZ1bmN0aW9uIGkodSwgYywgZikge1xuICAgIHRoaXMuZm4gPSB1LCB0aGlzLmNvbnRleHQgPSBjLCB0aGlzLm9uY2UgPSBmIHx8ICExO1xuICB9XG4gIGZ1bmN0aW9uIG8odSwgYywgZiwgbCwgZCkge1xuICAgIGlmICh0eXBlb2YgZiAhPSBcImZ1bmN0aW9uXCIpXG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiVGhlIGxpc3RlbmVyIG11c3QgYmUgYSBmdW5jdGlvblwiKTtcbiAgICB2YXIgcCA9IG5ldyBpKGYsIGwgfHwgdSwgZCksIGcgPSBuID8gbiArIGMgOiBjO1xuICAgIHJldHVybiB1Ll9ldmVudHNbZ10gPyB1Ll9ldmVudHNbZ10uZm4gPyB1Ll9ldmVudHNbZ10gPSBbdS5fZXZlbnRzW2ddLCBwXSA6IHUuX2V2ZW50c1tnXS5wdXNoKHApIDogKHUuX2V2ZW50c1tnXSA9IHAsIHUuX2V2ZW50c0NvdW50KyspLCB1O1xuICB9XG4gIGZ1bmN0aW9uIGEodSwgYykge1xuICAgIC0tdS5fZXZlbnRzQ291bnQgPT09IDAgPyB1Ll9ldmVudHMgPSBuZXcgcigpIDogZGVsZXRlIHUuX2V2ZW50c1tjXTtcbiAgfVxuICBmdW5jdGlvbiBzKCkge1xuICAgIHRoaXMuX2V2ZW50cyA9IG5ldyByKCksIHRoaXMuX2V2ZW50c0NvdW50ID0gMDtcbiAgfVxuICBzLnByb3RvdHlwZS5ldmVudE5hbWVzID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGMgPSBbXSwgZiwgbDtcbiAgICBpZiAodGhpcy5fZXZlbnRzQ291bnQgPT09IDApXG4gICAgICByZXR1cm4gYztcbiAgICBmb3IgKGwgaW4gZiA9IHRoaXMuX2V2ZW50cylcbiAgICAgIHQuY2FsbChmLCBsKSAmJiBjLnB1c2gobiA/IGwuc2xpY2UoMSkgOiBsKTtcbiAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyA/IGMuY29uY2F0KE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZikpIDogYztcbiAgfSwgcy5wcm90b3R5cGUubGlzdGVuZXJzID0gZnVuY3Rpb24oYykge1xuICAgIHZhciBmID0gbiA/IG4gKyBjIDogYywgbCA9IHRoaXMuX2V2ZW50c1tmXTtcbiAgICBpZiAoIWwpXG4gICAgICByZXR1cm4gW107XG4gICAgaWYgKGwuZm4pXG4gICAgICByZXR1cm4gW2wuZm5dO1xuICAgIGZvciAodmFyIGQgPSAwLCBwID0gbC5sZW5ndGgsIGcgPSBuZXcgQXJyYXkocCk7IGQgPCBwOyBkKyspXG4gICAgICBnW2RdID0gbFtkXS5mbjtcbiAgICByZXR1cm4gZztcbiAgfSwgcy5wcm90b3R5cGUubGlzdGVuZXJDb3VudCA9IGZ1bmN0aW9uKGMpIHtcbiAgICB2YXIgZiA9IG4gPyBuICsgYyA6IGMsIGwgPSB0aGlzLl9ldmVudHNbZl07XG4gICAgcmV0dXJuIGwgPyBsLmZuID8gMSA6IGwubGVuZ3RoIDogMDtcbiAgfSwgcy5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uKGMsIGYsIGwsIGQsIHAsIGcpIHtcbiAgICB2YXIgaCA9IG4gPyBuICsgYyA6IGM7XG4gICAgaWYgKCF0aGlzLl9ldmVudHNbaF0pXG4gICAgICByZXR1cm4gITE7XG4gICAgdmFyIHYgPSB0aGlzLl9ldmVudHNbaF0sIHcgPSBhcmd1bWVudHMubGVuZ3RoLCBiLCB4O1xuICAgIGlmICh2LmZuKSB7XG4gICAgICBzd2l0Y2ggKHYub25jZSAmJiB0aGlzLnJlbW92ZUxpc3RlbmVyKGMsIHYuZm4sIHZvaWQgMCwgITApLCB3KSB7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICByZXR1cm4gdi5mbi5jYWxsKHYuY29udGV4dCksICEwO1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgcmV0dXJuIHYuZm4uY2FsbCh2LmNvbnRleHQsIGYpLCAhMDtcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIHJldHVybiB2LmZuLmNhbGwodi5jb250ZXh0LCBmLCBsKSwgITA7XG4gICAgICAgIGNhc2UgNDpcbiAgICAgICAgICByZXR1cm4gdi5mbi5jYWxsKHYuY29udGV4dCwgZiwgbCwgZCksICEwO1xuICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgcmV0dXJuIHYuZm4uY2FsbCh2LmNvbnRleHQsIGYsIGwsIGQsIHApLCAhMDtcbiAgICAgICAgY2FzZSA2OlxuICAgICAgICAgIHJldHVybiB2LmZuLmNhbGwodi5jb250ZXh0LCBmLCBsLCBkLCBwLCBnKSwgITA7XG4gICAgICB9XG4gICAgICBmb3IgKHggPSAxLCBiID0gbmV3IEFycmF5KHcgLSAxKTsgeCA8IHc7IHgrKylcbiAgICAgICAgYlt4IC0gMV0gPSBhcmd1bWVudHNbeF07XG4gICAgICB2LmZuLmFwcGx5KHYuY29udGV4dCwgYik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBtID0gdi5sZW5ndGgsIHk7XG4gICAgICBmb3IgKHggPSAwOyB4IDwgbTsgeCsrKVxuICAgICAgICBzd2l0Y2ggKHZbeF0ub25jZSAmJiB0aGlzLnJlbW92ZUxpc3RlbmVyKGMsIHZbeF0uZm4sIHZvaWQgMCwgITApLCB3KSB7XG4gICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgdlt4XS5mbi5jYWxsKHZbeF0uY29udGV4dCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICB2W3hdLmZuLmNhbGwodlt4XS5jb250ZXh0LCBmKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIHZbeF0uZm4uY2FsbCh2W3hdLmNvbnRleHQsIGYsIGwpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgdlt4XS5mbi5jYWxsKHZbeF0uY29udGV4dCwgZiwgbCwgZCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgaWYgKCFiKVxuICAgICAgICAgICAgICBmb3IgKHkgPSAxLCBiID0gbmV3IEFycmF5KHcgLSAxKTsgeSA8IHc7IHkrKylcbiAgICAgICAgICAgICAgICBiW3kgLSAxXSA9IGFyZ3VtZW50c1t5XTtcbiAgICAgICAgICAgIHZbeF0uZm4uYXBwbHkodlt4XS5jb250ZXh0LCBiKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gITA7XG4gIH0sIHMucHJvdG90eXBlLm9uID0gZnVuY3Rpb24oYywgZiwgbCkge1xuICAgIHJldHVybiBvKHRoaXMsIGMsIGYsIGwsICExKTtcbiAgfSwgcy5wcm90b3R5cGUub25jZSA9IGZ1bmN0aW9uKGMsIGYsIGwpIHtcbiAgICByZXR1cm4gbyh0aGlzLCBjLCBmLCBsLCAhMCk7XG4gIH0sIHMucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyID0gZnVuY3Rpb24oYywgZiwgbCwgZCkge1xuICAgIHZhciBwID0gbiA/IG4gKyBjIDogYztcbiAgICBpZiAoIXRoaXMuX2V2ZW50c1twXSlcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIGlmICghZilcbiAgICAgIHJldHVybiBhKHRoaXMsIHApLCB0aGlzO1xuICAgIHZhciBnID0gdGhpcy5fZXZlbnRzW3BdO1xuICAgIGlmIChnLmZuKVxuICAgICAgZy5mbiA9PT0gZiAmJiAoIWQgfHwgZy5vbmNlKSAmJiAoIWwgfHwgZy5jb250ZXh0ID09PSBsKSAmJiBhKHRoaXMsIHApO1xuICAgIGVsc2Uge1xuICAgICAgZm9yICh2YXIgaCA9IDAsIHYgPSBbXSwgdyA9IGcubGVuZ3RoOyBoIDwgdzsgaCsrKVxuICAgICAgICAoZ1toXS5mbiAhPT0gZiB8fCBkICYmICFnW2hdLm9uY2UgfHwgbCAmJiBnW2hdLmNvbnRleHQgIT09IGwpICYmIHYucHVzaChnW2hdKTtcbiAgICAgIHYubGVuZ3RoID8gdGhpcy5fZXZlbnRzW3BdID0gdi5sZW5ndGggPT09IDEgPyB2WzBdIDogdiA6IGEodGhpcywgcCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9LCBzLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBmdW5jdGlvbihjKSB7XG4gICAgdmFyIGY7XG4gICAgcmV0dXJuIGMgPyAoZiA9IG4gPyBuICsgYyA6IGMsIHRoaXMuX2V2ZW50c1tmXSAmJiBhKHRoaXMsIGYpKSA6ICh0aGlzLl9ldmVudHMgPSBuZXcgcigpLCB0aGlzLl9ldmVudHNDb3VudCA9IDApLCB0aGlzO1xuICB9LCBzLnByb3RvdHlwZS5vZmYgPSBzLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciwgcy5wcm90b3R5cGUuYWRkTGlzdGVuZXIgPSBzLnByb3RvdHlwZS5vbiwgcy5wcmVmaXhlZCA9IG4sIHMuRXZlbnRFbWl0dGVyID0gcywgZS5leHBvcnRzID0gcztcbn0pKGp3KTtcbnZhciBvVyA9IGp3LmV4cG9ydHM7XG5jb25zdCBhVyA9IC8qIEBfX1BVUkVfXyAqLyBqZShvVyk7XG52YXIgaWMgPSBuZXcgYVcoKSwgb2MgPSBcInJlY2hhcnRzLnN5bmNNb3VzZUV2ZW50c1wiO1xuZnVuY3Rpb24gRG8oZSkge1xuICBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7XG4gIHJldHVybiBEbyA9IHR5cGVvZiBTeW1ib2wgPT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uKHQpIHtcbiAgICByZXR1cm4gdHlwZW9mIHQ7XG4gIH0gOiBmdW5jdGlvbih0KSB7XG4gICAgcmV0dXJuIHQgJiYgdHlwZW9mIFN5bWJvbCA9PSBcImZ1bmN0aW9uXCIgJiYgdC5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIHQgIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIHQ7XG4gIH0sIERvKGUpO1xufVxuZnVuY3Rpb24gc1coZSwgdCkge1xuICBpZiAoIShlIGluc3RhbmNlb2YgdCkpXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcbn1cbmZ1bmN0aW9uIHVXKGUsIHQpIHtcbiAgZm9yICh2YXIgbiA9IDA7IG4gPCB0Lmxlbmd0aDsgbisrKSB7XG4gICAgdmFyIHIgPSB0W25dO1xuICAgIHIuZW51bWVyYWJsZSA9IHIuZW51bWVyYWJsZSB8fCAhMSwgci5jb25maWd1cmFibGUgPSAhMCwgXCJ2YWx1ZVwiIGluIHIgJiYgKHIud3JpdGFibGUgPSAhMCksIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCBrdyhyLmtleSksIHIpO1xuICB9XG59XG5mdW5jdGlvbiBjVyhlLCB0LCBuKSB7XG4gIHJldHVybiB0ICYmIHVXKGUucHJvdG90eXBlLCB0KSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIFwicHJvdG90eXBlXCIsIHsgd3JpdGFibGU6ICExIH0pLCBlO1xufVxuZnVuY3Rpb24gYWMoZSwgdCwgbikge1xuICByZXR1cm4gdCA9IGt3KHQpLCB0IGluIGUgPyBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgdCwgeyB2YWx1ZTogbiwgZW51bWVyYWJsZTogITAsIGNvbmZpZ3VyYWJsZTogITAsIHdyaXRhYmxlOiAhMCB9KSA6IGVbdF0gPSBuLCBlO1xufVxuZnVuY3Rpb24ga3coZSkge1xuICB2YXIgdCA9IGxXKGUsIFwic3RyaW5nXCIpO1xuICByZXR1cm4gRG8odCkgPT0gXCJzeW1ib2xcIiA/IHQgOiBTdHJpbmcodCk7XG59XG5mdW5jdGlvbiBsVyhlLCB0KSB7XG4gIGlmIChEbyhlKSAhPSBcIm9iamVjdFwiIHx8ICFlKVxuICAgIHJldHVybiBlO1xuICB2YXIgbiA9IGVbU3ltYm9sLnRvUHJpbWl0aXZlXTtcbiAgaWYgKG4gIT09IHZvaWQgMCkge1xuICAgIHZhciByID0gbi5jYWxsKGUsIHQgfHwgXCJkZWZhdWx0XCIpO1xuICAgIGlmIChEbyhyKSAhPSBcIm9iamVjdFwiKVxuICAgICAgcmV0dXJuIHI7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkBAdG9QcmltaXRpdmUgbXVzdCByZXR1cm4gYSBwcmltaXRpdmUgdmFsdWUuXCIpO1xuICB9XG4gIHJldHVybiAodCA9PT0gXCJzdHJpbmdcIiA/IFN0cmluZyA6IE51bWJlcikoZSk7XG59XG52YXIgZlcgPSAvKiBAX19QVVJFX18gKi8gZnVuY3Rpb24oKSB7XG4gIGZ1bmN0aW9uIGUoKSB7XG4gICAgc1codGhpcywgZSksIGFjKHRoaXMsIFwiYWN0aXZlSW5kZXhcIiwgMCksIGFjKHRoaXMsIFwiY29vcmRpbmF0ZUxpc3RcIiwgW10pLCBhYyh0aGlzLCBcImxheW91dFwiLCBcImhvcml6b250YWxcIik7XG4gIH1cbiAgcmV0dXJuIGNXKGUsIFt7XG4gICAga2V5OiBcInNldERldGFpbHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24obikge1xuICAgICAgdmFyIHIsIGkgPSBuLmNvb3JkaW5hdGVMaXN0LCBvID0gaSA9PT0gdm9pZCAwID8gbnVsbCA6IGksIGEgPSBuLmNvbnRhaW5lciwgcyA9IGEgPT09IHZvaWQgMCA/IG51bGwgOiBhLCB1ID0gbi5sYXlvdXQsIGMgPSB1ID09PSB2b2lkIDAgPyBudWxsIDogdSwgZiA9IG4ub2Zmc2V0LCBsID0gZiA9PT0gdm9pZCAwID8gbnVsbCA6IGYsIGQgPSBuLm1vdXNlSGFuZGxlckNhbGxiYWNrLCBwID0gZCA9PT0gdm9pZCAwID8gbnVsbCA6IGQ7XG4gICAgICB0aGlzLmNvb3JkaW5hdGVMaXN0ID0gKHIgPSBvID8/IHRoaXMuY29vcmRpbmF0ZUxpc3QpICE9PSBudWxsICYmIHIgIT09IHZvaWQgMCA/IHIgOiBbXSwgdGhpcy5jb250YWluZXIgPSBzID8/IHRoaXMuY29udGFpbmVyLCB0aGlzLmxheW91dCA9IGMgPz8gdGhpcy5sYXlvdXQsIHRoaXMub2Zmc2V0ID0gbCA/PyB0aGlzLm9mZnNldCwgdGhpcy5tb3VzZUhhbmRsZXJDYWxsYmFjayA9IHAgPz8gdGhpcy5tb3VzZUhhbmRsZXJDYWxsYmFjaywgdGhpcy5hY3RpdmVJbmRleCA9IE1hdGgubWluKE1hdGgubWF4KHRoaXMuYWN0aXZlSW5kZXgsIDApLCB0aGlzLmNvb3JkaW5hdGVMaXN0Lmxlbmd0aCAtIDEpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJmb2N1c1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuc3Bvb2ZNb3VzZSgpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJrZXlib2FyZEV2ZW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uKG4pIHtcbiAgICAgIGlmICh0aGlzLmNvb3JkaW5hdGVMaXN0Lmxlbmd0aCAhPT0gMClcbiAgICAgICAgc3dpdGNoIChuLmtleSkge1xuICAgICAgICAgIGNhc2UgXCJBcnJvd1JpZ2h0XCI6IHtcbiAgICAgICAgICAgIGlmICh0aGlzLmxheW91dCAhPT0gXCJob3Jpem9udGFsXCIpXG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIHRoaXMuYWN0aXZlSW5kZXggPSBNYXRoLm1pbih0aGlzLmFjdGl2ZUluZGV4ICsgMSwgdGhpcy5jb29yZGluYXRlTGlzdC5sZW5ndGggLSAxKSwgdGhpcy5zcG9vZk1vdXNlKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSBcIkFycm93TGVmdFwiOiB7XG4gICAgICAgICAgICBpZiAodGhpcy5sYXlvdXQgIT09IFwiaG9yaXpvbnRhbFwiKVxuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB0aGlzLmFjdGl2ZUluZGV4ID0gTWF0aC5tYXgodGhpcy5hY3RpdmVJbmRleCAtIDEsIDApLCB0aGlzLnNwb29mTW91c2UoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzZXRJbmRleFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbihuKSB7XG4gICAgICB0aGlzLmFjdGl2ZUluZGV4ID0gbjtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic3Bvb2ZNb3VzZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBuLCByO1xuICAgICAgaWYgKHRoaXMubGF5b3V0ID09PSBcImhvcml6b250YWxcIiAmJiB0aGlzLmNvb3JkaW5hdGVMaXN0Lmxlbmd0aCAhPT0gMCkge1xuICAgICAgICB2YXIgaSA9IHRoaXMuY29udGFpbmVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLCBvID0gaS54LCBhID0gaS55LCBzID0gaS5oZWlnaHQsIHUgPSB0aGlzLmNvb3JkaW5hdGVMaXN0W3RoaXMuYWN0aXZlSW5kZXhdLmNvb3JkaW5hdGUsIGMgPSAoKG4gPSB3aW5kb3cpID09PSBudWxsIHx8IG4gPT09IHZvaWQgMCA/IHZvaWQgMCA6IG4uc2Nyb2xsWCkgfHwgMCwgZiA9ICgociA9IHdpbmRvdykgPT09IG51bGwgfHwgciA9PT0gdm9pZCAwID8gdm9pZCAwIDogci5zY3JvbGxZKSB8fCAwLCBsID0gbyArIHUgKyBjLCBkID0gYSArIHRoaXMub2Zmc2V0LnRvcCArIHMgLyAyICsgZjtcbiAgICAgICAgdGhpcy5tb3VzZUhhbmRsZXJDYWxsYmFjayh7XG4gICAgICAgICAgcGFnZVg6IGwsXG4gICAgICAgICAgcGFnZVk6IGRcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9XSksIGU7XG59KCk7XG5mdW5jdGlvbiBkVyhlLCB0LCBuKSB7XG4gIGlmIChuID09PSBcIm51bWJlclwiICYmIHQgPT09ICEwICYmIEFycmF5LmlzQXJyYXkoZSkpIHtcbiAgICB2YXIgciA9IGUgPT0gbnVsbCA/IHZvaWQgMCA6IGVbMF0sIGkgPSBlID09IG51bGwgPyB2b2lkIDAgOiBlWzFdO1xuICAgIGlmIChyICYmIGkgJiYgSyhyKSAmJiBLKGkpKVxuICAgICAgcmV0dXJuICEwO1xuICB9XG4gIHJldHVybiAhMTtcbn1cbmZ1bmN0aW9uIHBXKGUsIHQsIG4sIHIpIHtcbiAgdmFyIGkgPSByIC8gMjtcbiAgcmV0dXJuIHtcbiAgICBzdHJva2U6IFwibm9uZVwiLFxuICAgIGZpbGw6IFwiI2NjY1wiLFxuICAgIHg6IGUgPT09IFwiaG9yaXpvbnRhbFwiID8gdC54IC0gaSA6IG4ubGVmdCArIDAuNSxcbiAgICB5OiBlID09PSBcImhvcml6b250YWxcIiA/IG4udG9wICsgMC41IDogdC55IC0gaSxcbiAgICB3aWR0aDogZSA9PT0gXCJob3Jpem9udGFsXCIgPyByIDogbi53aWR0aCAtIDEsXG4gICAgaGVpZ2h0OiBlID09PSBcImhvcml6b250YWxcIiA/IG4uaGVpZ2h0IC0gMSA6IHJcbiAgfTtcbn1cbmZ1bmN0aW9uIER3KGUpIHtcbiAgdmFyIHQgPSBlLmN4LCBuID0gZS5jeSwgciA9IGUucmFkaXVzLCBpID0gZS5zdGFydEFuZ2xlLCBvID0gZS5lbmRBbmdsZSwgYSA9IG50KHQsIG4sIHIsIGkpLCBzID0gbnQodCwgbiwgciwgbyk7XG4gIHJldHVybiB7XG4gICAgcG9pbnRzOiBbYSwgc10sXG4gICAgY3g6IHQsXG4gICAgY3k6IG4sXG4gICAgcmFkaXVzOiByLFxuICAgIHN0YXJ0QW5nbGU6IGksXG4gICAgZW5kQW5nbGU6IG9cbiAgfTtcbn1cbmZ1bmN0aW9uIGhXKGUsIHQsIG4pIHtcbiAgdmFyIHIsIGksIG8sIGE7XG4gIGlmIChlID09PSBcImhvcml6b250YWxcIilcbiAgICByID0gdC54LCBvID0gciwgaSA9IG4udG9wLCBhID0gbi50b3AgKyBuLmhlaWdodDtcbiAgZWxzZSBpZiAoZSA9PT0gXCJ2ZXJ0aWNhbFwiKVxuICAgIGkgPSB0LnksIGEgPSBpLCByID0gbi5sZWZ0LCBvID0gbi5sZWZ0ICsgbi53aWR0aDtcbiAgZWxzZSBpZiAodC5jeCAhPSBudWxsICYmIHQuY3kgIT0gbnVsbClcbiAgICBpZiAoZSA9PT0gXCJjZW50cmljXCIpIHtcbiAgICAgIHZhciBzID0gdC5jeCwgdSA9IHQuY3ksIGMgPSB0LmlubmVyUmFkaXVzLCBmID0gdC5vdXRlclJhZGl1cywgbCA9IHQuYW5nbGUsIGQgPSBudChzLCB1LCBjLCBsKSwgcCA9IG50KHMsIHUsIGYsIGwpO1xuICAgICAgciA9IGQueCwgaSA9IGQueSwgbyA9IHAueCwgYSA9IHAueTtcbiAgICB9IGVsc2VcbiAgICAgIHJldHVybiBEdyh0KTtcbiAgcmV0dXJuIFt7XG4gICAgeDogcixcbiAgICB5OiBpXG4gIH0sIHtcbiAgICB4OiBvLFxuICAgIHk6IGFcbiAgfV07XG59XG5mdW5jdGlvbiBObyhlKSB7XG4gIFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjtcbiAgcmV0dXJuIE5vID0gdHlwZW9mIFN5bWJvbCA9PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PSBcInN5bWJvbFwiID8gZnVuY3Rpb24odCkge1xuICAgIHJldHVybiB0eXBlb2YgdDtcbiAgfSA6IGZ1bmN0aW9uKHQpIHtcbiAgICByZXR1cm4gdCAmJiB0eXBlb2YgU3ltYm9sID09IFwiZnVuY3Rpb25cIiAmJiB0LmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgdCAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2YgdDtcbiAgfSwgTm8oZSk7XG59XG5mdW5jdGlvbiBKdihlLCB0KSB7XG4gIHZhciBuID0gT2JqZWN0LmtleXMoZSk7XG4gIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gICAgdmFyIHIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGUpO1xuICAgIHQgJiYgKHIgPSByLmZpbHRlcihmdW5jdGlvbihpKSB7XG4gICAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLCBpKS5lbnVtZXJhYmxlO1xuICAgIH0pKSwgbi5wdXNoLmFwcGx5KG4sIHIpO1xuICB9XG4gIHJldHVybiBuO1xufVxuZnVuY3Rpb24geGEoZSkge1xuICBmb3IgKHZhciB0ID0gMTsgdCA8IGFyZ3VtZW50cy5sZW5ndGg7IHQrKykge1xuICAgIHZhciBuID0gYXJndW1lbnRzW3RdICE9IG51bGwgPyBhcmd1bWVudHNbdF0gOiB7fTtcbiAgICB0ICUgMiA/IEp2KE9iamVjdChuKSwgITApLmZvckVhY2goZnVuY3Rpb24ocikge1xuICAgICAgZ1coZSwgciwgbltyXSk7XG4gICAgfSkgOiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGUsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKG4pKSA6IEp2KE9iamVjdChuKSkuZm9yRWFjaChmdW5jdGlvbihyKSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgciwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihuLCByKSk7XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIGU7XG59XG5mdW5jdGlvbiBnVyhlLCB0LCBuKSB7XG4gIHJldHVybiB0ID0gdlcodCksIHQgaW4gZSA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCB0LCB7IHZhbHVlOiBuLCBlbnVtZXJhYmxlOiAhMCwgY29uZmlndXJhYmxlOiAhMCwgd3JpdGFibGU6ICEwIH0pIDogZVt0XSA9IG4sIGU7XG59XG5mdW5jdGlvbiB2VyhlKSB7XG4gIHZhciB0ID0gbVcoZSwgXCJzdHJpbmdcIik7XG4gIHJldHVybiBObyh0KSA9PSBcInN5bWJvbFwiID8gdCA6IFN0cmluZyh0KTtcbn1cbmZ1bmN0aW9uIG1XKGUsIHQpIHtcbiAgaWYgKE5vKGUpICE9IFwib2JqZWN0XCIgfHwgIWUpXG4gICAgcmV0dXJuIGU7XG4gIHZhciBuID0gZVtTeW1ib2wudG9QcmltaXRpdmVdO1xuICBpZiAobiAhPT0gdm9pZCAwKSB7XG4gICAgdmFyIHIgPSBuLmNhbGwoZSwgdCB8fCBcImRlZmF1bHRcIik7XG4gICAgaWYgKE5vKHIpICE9IFwib2JqZWN0XCIpXG4gICAgICByZXR1cm4gcjtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQEB0b1ByaW1pdGl2ZSBtdXN0IHJldHVybiBhIHByaW1pdGl2ZSB2YWx1ZS5cIik7XG4gIH1cbiAgcmV0dXJuICh0ID09PSBcInN0cmluZ1wiID8gU3RyaW5nIDogTnVtYmVyKShlKTtcbn1cbmZ1bmN0aW9uIHlXKGUpIHtcbiAgdmFyIHQgPSBlLmVsZW1lbnQsIG4gPSBlLnRvb2x0aXBFdmVudFR5cGUsIHIgPSBlLmlzQWN0aXZlLCBpID0gZS5hY3RpdmVDb29yZGluYXRlLCBvID0gZS5hY3RpdmVQYXlsb2FkLCBhID0gZS5vZmZzZXQsIHMgPSBlLmFjdGl2ZVRvb2x0aXBJbmRleCwgdSA9IGUudG9vbHRpcEF4aXNCYW5kU2l6ZSwgYyA9IGUubGF5b3V0LCBmID0gZS5jaGFydE5hbWU7XG4gIGlmICghdCB8fCAhdC5wcm9wcy5jdXJzb3IgfHwgIXIgfHwgIWkgfHwgZiAhPT0gXCJTY2F0dGVyQ2hhcnRcIiAmJiBuICE9PSBcImF4aXNcIilcbiAgICByZXR1cm4gbnVsbDtcbiAgdmFyIGwsIGQgPSBibDtcbiAgaWYgKGYgPT09IFwiU2NhdHRlckNoYXJ0XCIpXG4gICAgbCA9IGksIGQgPSBlOTtcbiAgZWxzZSBpZiAoZiA9PT0gXCJCYXJDaGFydFwiKVxuICAgIGwgPSBwVyhjLCBpLCBhLCB1KSwgZCA9IGRkO1xuICBlbHNlIGlmIChjID09PSBcInJhZGlhbFwiKSB7XG4gICAgdmFyIHAgPSBEdyhpKSwgZyA9IHAuY3gsIGggPSBwLmN5LCB2ID0gcC5yYWRpdXMsIHcgPSBwLnN0YXJ0QW5nbGUsIGIgPSBwLmVuZEFuZ2xlO1xuICAgIGwgPSB7XG4gICAgICBjeDogZyxcbiAgICAgIGN5OiBoLFxuICAgICAgc3RhcnRBbmdsZTogdyxcbiAgICAgIGVuZEFuZ2xlOiBiLFxuICAgICAgaW5uZXJSYWRpdXM6IHYsXG4gICAgICBvdXRlclJhZGl1czogdlxuICAgIH0sIGQgPSBaMDtcbiAgfSBlbHNlXG4gICAgbCA9IHtcbiAgICAgIHBvaW50czogaFcoYywgaSwgYSlcbiAgICB9LCBkID0gYmw7XG4gIHZhciB4ID0geGEoeGEoeGEoeGEoe1xuICAgIHN0cm9rZTogXCIjY2NjXCIsXG4gICAgcG9pbnRlckV2ZW50czogXCJub25lXCJcbiAgfSwgYSksIGwpLCB5ZSh0LnByb3BzLmN1cnNvciwgITEpKSwge30sIHtcbiAgICBwYXlsb2FkOiBvLFxuICAgIHBheWxvYWRJbmRleDogcyxcbiAgICBjbGFzc05hbWU6ICRlKFwicmVjaGFydHMtdG9vbHRpcC1jdXJzb3JcIiwgdC5wcm9wcy5jdXJzb3IuY2xhc3NOYW1lKVxuICB9KTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyB2dCh0LnByb3BzLmN1cnNvcikgPyAvKiBAX19QVVJFX18gKi8gR2UodC5wcm9wcy5jdXJzb3IsIHgpIDogLyogQF9fUFVSRV9fICovIFkoZCwgeCk7XG59XG52YXIgYlcgPSBbXCJpdGVtXCJdLCB3VyA9IFtcImNoaWxkcmVuXCIsIFwiY2xhc3NOYW1lXCIsIFwid2lkdGhcIiwgXCJoZWlnaHRcIiwgXCJzdHlsZVwiLCBcImNvbXBhY3RcIiwgXCJ0aXRsZVwiLCBcImRlc2NcIl07XG5mdW5jdGlvbiBuaShlKSB7XG4gIFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjtcbiAgcmV0dXJuIG5pID0gdHlwZW9mIFN5bWJvbCA9PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PSBcInN5bWJvbFwiID8gZnVuY3Rpb24odCkge1xuICAgIHJldHVybiB0eXBlb2YgdDtcbiAgfSA6IGZ1bmN0aW9uKHQpIHtcbiAgICByZXR1cm4gdCAmJiB0eXBlb2YgU3ltYm9sID09IFwiZnVuY3Rpb25cIiAmJiB0LmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgdCAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2YgdDtcbiAgfSwgbmkoZSk7XG59XG5mdW5jdGlvbiBLaSgpIHtcbiAgcmV0dXJuIEtpID0gT2JqZWN0LmFzc2lnbiA/IE9iamVjdC5hc3NpZ24uYmluZCgpIDogZnVuY3Rpb24oZSkge1xuICAgIGZvciAodmFyIHQgPSAxOyB0IDwgYXJndW1lbnRzLmxlbmd0aDsgdCsrKSB7XG4gICAgICB2YXIgbiA9IGFyZ3VtZW50c1t0XTtcbiAgICAgIGZvciAodmFyIHIgaW4gbilcbiAgICAgICAgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG4sIHIpICYmIChlW3JdID0gbltyXSk7XG4gICAgfVxuICAgIHJldHVybiBlO1xuICB9LCBLaS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuZnVuY3Rpb24gUXYoZSwgdCkge1xuICByZXR1cm4gJFcoZSkgfHwgU1coZSwgdCkgfHwgRncoZSwgdCkgfHwgeFcoKTtcbn1cbmZ1bmN0aW9uIHhXKCkge1xuICB0aHJvdyBuZXcgVHlwZUVycm9yKGBJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLmApO1xufVxuZnVuY3Rpb24gU1coZSwgdCkge1xuICB2YXIgbiA9IGUgPT0gbnVsbCA/IG51bGwgOiB0eXBlb2YgU3ltYm9sIDwgXCJ1XCIgJiYgZVtTeW1ib2wuaXRlcmF0b3JdIHx8IGVbXCJAQGl0ZXJhdG9yXCJdO1xuICBpZiAobiAhPSBudWxsKSB7XG4gICAgdmFyIHIsIGksIG8sIGEsIHMgPSBbXSwgdSA9ICEwLCBjID0gITE7XG4gICAgdHJ5IHtcbiAgICAgIGlmIChvID0gKG4gPSBuLmNhbGwoZSkpLm5leHQsIHQgIT09IDApXG4gICAgICAgIGZvciAoOyAhKHUgPSAociA9IG8uY2FsbChuKSkuZG9uZSkgJiYgKHMucHVzaChyLnZhbHVlKSwgcy5sZW5ndGggIT09IHQpOyB1ID0gITApXG4gICAgICAgICAgO1xuICAgIH0gY2F0Y2ggKGYpIHtcbiAgICAgIGMgPSAhMCwgaSA9IGY7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmICghdSAmJiBuLnJldHVybiAhPSBudWxsICYmIChhID0gbi5yZXR1cm4oKSwgT2JqZWN0KGEpICE9PSBhKSlcbiAgICAgICAgICByZXR1cm47XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBpZiAoYylcbiAgICAgICAgICB0aHJvdyBpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcztcbiAgfVxufVxuZnVuY3Rpb24gJFcoZSkge1xuICBpZiAoQXJyYXkuaXNBcnJheShlKSlcbiAgICByZXR1cm4gZTtcbn1cbmZ1bmN0aW9uIGVtKGUsIHQpIHtcbiAgaWYgKGUgPT0gbnVsbClcbiAgICByZXR1cm4ge307XG4gIHZhciBuID0gT1coZSwgdCksIHIsIGk7XG4gIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gICAgdmFyIG8gPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGUpO1xuICAgIGZvciAoaSA9IDA7IGkgPCBvLmxlbmd0aDsgaSsrKVxuICAgICAgciA9IG9baV0sICEodC5pbmRleE9mKHIpID49IDApICYmIE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChlLCByKSAmJiAobltyXSA9IGVbcl0pO1xuICB9XG4gIHJldHVybiBuO1xufVxuZnVuY3Rpb24gT1coZSwgdCkge1xuICBpZiAoZSA9PSBudWxsKVxuICAgIHJldHVybiB7fTtcbiAgdmFyIG4gPSB7fSwgciA9IE9iamVjdC5rZXlzKGUpLCBpLCBvO1xuICBmb3IgKG8gPSAwOyBvIDwgci5sZW5ndGg7IG8rKylcbiAgICBpID0gcltvXSwgISh0LmluZGV4T2YoaSkgPj0gMCkgJiYgKG5baV0gPSBlW2ldKTtcbiAgcmV0dXJuIG47XG59XG5mdW5jdGlvbiBfVyhlLCB0KSB7XG4gIGlmICghKGUgaW5zdGFuY2VvZiB0KSlcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xufVxuZnVuY3Rpb24gQVcoZSwgdCkge1xuICBmb3IgKHZhciBuID0gMDsgbiA8IHQubGVuZ3RoOyBuKyspIHtcbiAgICB2YXIgciA9IHRbbl07XG4gICAgci5lbnVtZXJhYmxlID0gci5lbnVtZXJhYmxlIHx8ICExLCByLmNvbmZpZ3VyYWJsZSA9ICEwLCBcInZhbHVlXCIgaW4gciAmJiAoci53cml0YWJsZSA9ICEwKSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIEx3KHIua2V5KSwgcik7XG4gIH1cbn1cbmZ1bmN0aW9uIFBXKGUsIHQsIG4pIHtcbiAgcmV0dXJuIHQgJiYgQVcoZS5wcm90b3R5cGUsIHQpLCBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgXCJwcm90b3R5cGVcIiwgeyB3cml0YWJsZTogITEgfSksIGU7XG59XG5mdW5jdGlvbiBDVyhlLCB0LCBuKSB7XG4gIHJldHVybiB0ID0gVHModCksIEVXKGUsIE53KCkgPyBSZWZsZWN0LmNvbnN0cnVjdCh0LCBuIHx8IFtdLCBUcyhlKS5jb25zdHJ1Y3RvcikgOiB0LmFwcGx5KGUsIG4pKTtcbn1cbmZ1bmN0aW9uIEVXKGUsIHQpIHtcbiAgaWYgKHQgJiYgKG5pKHQpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiB0ID09IFwiZnVuY3Rpb25cIikpXG4gICAgcmV0dXJuIHQ7XG4gIGlmICh0ICE9PSB2b2lkIDApXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkRlcml2ZWQgY29uc3RydWN0b3JzIG1heSBvbmx5IHJldHVybiBvYmplY3Qgb3IgdW5kZWZpbmVkXCIpO1xuICByZXR1cm4gU2UoZSk7XG59XG5mdW5jdGlvbiBOdygpIHtcbiAgdHJ5IHtcbiAgICB2YXIgZSA9ICFCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uKCkge1xuICAgIH0pKTtcbiAgfSBjYXRjaCB7XG4gIH1cbiAgcmV0dXJuIChOdyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiAhIWU7XG4gIH0pKCk7XG59XG5mdW5jdGlvbiBUcyhlKSB7XG4gIHJldHVybiBUcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZi5iaW5kKCkgOiBmdW5jdGlvbihuKSB7XG4gICAgcmV0dXJuIG4uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihuKTtcbiAgfSwgVHMoZSk7XG59XG5mdW5jdGlvbiBTZShlKSB7XG4gIGlmIChlID09PSB2b2lkIDApXG4gICAgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpO1xuICByZXR1cm4gZTtcbn1cbmZ1bmN0aW9uIFRXKGUsIHQpIHtcbiAgaWYgKHR5cGVvZiB0ICE9IFwiZnVuY3Rpb25cIiAmJiB0ICE9PSBudWxsKVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTtcbiAgZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHQgJiYgdC5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IGUsIHdyaXRhYmxlOiAhMCwgY29uZmlndXJhYmxlOiAhMCB9IH0pLCBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgXCJwcm90b3R5cGVcIiwgeyB3cml0YWJsZTogITEgfSksIHQgJiYgVWwoZSwgdCk7XG59XG5mdW5jdGlvbiBVbChlLCB0KSB7XG4gIHJldHVybiBVbCA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZi5iaW5kKCkgOiBmdW5jdGlvbihyLCBpKSB7XG4gICAgcmV0dXJuIHIuX19wcm90b19fID0gaSwgcjtcbiAgfSwgVWwoZSwgdCk7XG59XG5mdW5jdGlvbiByaShlKSB7XG4gIHJldHVybiBJVyhlKSB8fCBSVyhlKSB8fCBGdyhlKSB8fCBNVygpO1xufVxuZnVuY3Rpb24gTVcoKSB7XG4gIHRocm93IG5ldyBUeXBlRXJyb3IoYEludmFsaWQgYXR0ZW1wdCB0byBzcHJlYWQgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLmApO1xufVxuZnVuY3Rpb24gRncoZSwgdCkge1xuICBpZiAoZSkge1xuICAgIGlmICh0eXBlb2YgZSA9PSBcInN0cmluZ1wiKVxuICAgICAgcmV0dXJuIEhsKGUsIHQpO1xuICAgIHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGUpLnNsaWNlKDgsIC0xKTtcbiAgICBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBlLmNvbnN0cnVjdG9yICYmIChuID0gZS5jb25zdHJ1Y3Rvci5uYW1lKSwgbiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKVxuICAgICAgcmV0dXJuIEFycmF5LmZyb20oZSk7XG4gICAgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpXG4gICAgICByZXR1cm4gSGwoZSwgdCk7XG4gIH1cbn1cbmZ1bmN0aW9uIFJXKGUpIHtcbiAgaWYgKHR5cGVvZiBTeW1ib2wgPCBcInVcIiAmJiBlW1N5bWJvbC5pdGVyYXRvcl0gIT0gbnVsbCB8fCBlW1wiQEBpdGVyYXRvclwiXSAhPSBudWxsKVxuICAgIHJldHVybiBBcnJheS5mcm9tKGUpO1xufVxuZnVuY3Rpb24gSVcoZSkge1xuICBpZiAoQXJyYXkuaXNBcnJheShlKSlcbiAgICByZXR1cm4gSGwoZSk7XG59XG5mdW5jdGlvbiBIbChlLCB0KSB7XG4gICh0ID09IG51bGwgfHwgdCA+IGUubGVuZ3RoKSAmJiAodCA9IGUubGVuZ3RoKTtcbiAgZm9yICh2YXIgbiA9IDAsIHIgPSBuZXcgQXJyYXkodCk7IG4gPCB0OyBuKyspXG4gICAgcltuXSA9IGVbbl07XG4gIHJldHVybiByO1xufVxuZnVuY3Rpb24gdG0oZSwgdCkge1xuICB2YXIgbiA9IE9iamVjdC5rZXlzKGUpO1xuICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykge1xuICAgIHZhciByID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhlKTtcbiAgICB0ICYmIChyID0gci5maWx0ZXIoZnVuY3Rpb24oaSkge1xuICAgICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSwgaSkuZW51bWVyYWJsZTtcbiAgICB9KSksIG4ucHVzaC5hcHBseShuLCByKTtcbiAgfVxuICByZXR1cm4gbjtcbn1cbmZ1bmN0aW9uIHooZSkge1xuICBmb3IgKHZhciB0ID0gMTsgdCA8IGFyZ3VtZW50cy5sZW5ndGg7IHQrKykge1xuICAgIHZhciBuID0gYXJndW1lbnRzW3RdICE9IG51bGwgPyBhcmd1bWVudHNbdF0gOiB7fTtcbiAgICB0ICUgMiA/IHRtKE9iamVjdChuKSwgITApLmZvckVhY2goZnVuY3Rpb24ocikge1xuICAgICAgc2UoZSwgciwgbltyXSk7XG4gICAgfSkgOiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGUsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKG4pKSA6IHRtKE9iamVjdChuKSkuZm9yRWFjaChmdW5jdGlvbihyKSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgciwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihuLCByKSk7XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIGU7XG59XG5mdW5jdGlvbiBzZShlLCB0LCBuKSB7XG4gIHJldHVybiB0ID0gTHcodCksIHQgaW4gZSA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCB0LCB7IHZhbHVlOiBuLCBlbnVtZXJhYmxlOiAhMCwgY29uZmlndXJhYmxlOiAhMCwgd3JpdGFibGU6ICEwIH0pIDogZVt0XSA9IG4sIGU7XG59XG5mdW5jdGlvbiBMdyhlKSB7XG4gIHZhciB0ID0galcoZSwgXCJzdHJpbmdcIik7XG4gIHJldHVybiBuaSh0KSA9PSBcInN5bWJvbFwiID8gdCA6IFN0cmluZyh0KTtcbn1cbmZ1bmN0aW9uIGpXKGUsIHQpIHtcbiAgaWYgKG5pKGUpICE9IFwib2JqZWN0XCIgfHwgIWUpXG4gICAgcmV0dXJuIGU7XG4gIHZhciBuID0gZVtTeW1ib2wudG9QcmltaXRpdmVdO1xuICBpZiAobiAhPT0gdm9pZCAwKSB7XG4gICAgdmFyIHIgPSBuLmNhbGwoZSwgdCB8fCBcImRlZmF1bHRcIik7XG4gICAgaWYgKG5pKHIpICE9IFwib2JqZWN0XCIpXG4gICAgICByZXR1cm4gcjtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQEB0b1ByaW1pdGl2ZSBtdXN0IHJldHVybiBhIHByaW1pdGl2ZSB2YWx1ZS5cIik7XG4gIH1cbiAgcmV0dXJuICh0ID09PSBcInN0cmluZ1wiID8gU3RyaW5nIDogTnVtYmVyKShlKTtcbn1cbnZhciBrVyA9IHtcbiAgeEF4aXM6IFtcImJvdHRvbVwiLCBcInRvcFwiXSxcbiAgeUF4aXM6IFtcImxlZnRcIiwgXCJyaWdodFwiXVxufSwgRFcgPSB7XG4gIHdpZHRoOiBcIjEwMCVcIixcbiAgaGVpZ2h0OiBcIjEwMCVcIlxufSwgQncgPSB7XG4gIHg6IDAsXG4gIHk6IDBcbn07XG5mdW5jdGlvbiBTYShlKSB7XG4gIHJldHVybiBlO1xufVxudmFyIE5XID0gZnVuY3Rpb24odCwgbikge1xuICByZXR1cm4gbiA9PT0gXCJob3Jpem9udGFsXCIgPyB0LnggOiBuID09PSBcInZlcnRpY2FsXCIgPyB0LnkgOiBuID09PSBcImNlbnRyaWNcIiA/IHQuYW5nbGUgOiB0LnJhZGl1cztcbn0sIEZXID0gZnVuY3Rpb24odCwgbiwgciwgaSkge1xuICB2YXIgbyA9IG4uZmluZChmdW5jdGlvbihmKSB7XG4gICAgcmV0dXJuIGYgJiYgZi5pbmRleCA9PT0gcjtcbiAgfSk7XG4gIGlmIChvKSB7XG4gICAgaWYgKHQgPT09IFwiaG9yaXpvbnRhbFwiKVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeDogby5jb29yZGluYXRlLFxuICAgICAgICB5OiBpLnlcbiAgICAgIH07XG4gICAgaWYgKHQgPT09IFwidmVydGljYWxcIilcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHg6IGkueCxcbiAgICAgICAgeTogby5jb29yZGluYXRlXG4gICAgICB9O1xuICAgIGlmICh0ID09PSBcImNlbnRyaWNcIikge1xuICAgICAgdmFyIGEgPSBvLmNvb3JkaW5hdGUsIHMgPSBpLnJhZGl1cztcbiAgICAgIHJldHVybiB6KHooeih7fSwgaSksIG50KGkuY3gsIGkuY3ksIHMsIGEpKSwge30sIHtcbiAgICAgICAgYW5nbGU6IGEsXG4gICAgICAgIHJhZGl1czogc1xuICAgICAgfSk7XG4gICAgfVxuICAgIHZhciB1ID0gby5jb29yZGluYXRlLCBjID0gaS5hbmdsZTtcbiAgICByZXR1cm4geih6KHooe30sIGkpLCBudChpLmN4LCBpLmN5LCB1LCBjKSksIHt9LCB7XG4gICAgICBhbmdsZTogYyxcbiAgICAgIHJhZGl1czogdVxuICAgIH0pO1xuICB9XG4gIHJldHVybiBCdztcbn0sIGN1ID0gZnVuY3Rpb24odCwgbikge1xuICB2YXIgciA9IG4uZ3JhcGhpY2FsSXRlbXMsIGkgPSBuLmRhdGFTdGFydEluZGV4LCBvID0gbi5kYXRhRW5kSW5kZXgsIGEgPSAociA/PyBbXSkucmVkdWNlKGZ1bmN0aW9uKHMsIHUpIHtcbiAgICB2YXIgYyA9IHUucHJvcHMuZGF0YTtcbiAgICByZXR1cm4gYyAmJiBjLmxlbmd0aCA/IFtdLmNvbmNhdChyaShzKSwgcmkoYykpIDogcztcbiAgfSwgW10pO1xuICByZXR1cm4gYS5sZW5ndGggPiAwID8gYSA6IHQgJiYgdC5sZW5ndGggJiYgSyhpKSAmJiBLKG8pID8gdC5zbGljZShpLCBvICsgMSkgOiBbXTtcbn07XG5mdW5jdGlvbiB6dyhlKSB7XG4gIHJldHVybiBlID09PSBcIm51bWJlclwiID8gWzAsIFwiYXV0b1wiXSA6IHZvaWQgMDtcbn1cbnZhciBxbCA9IGZ1bmN0aW9uKHQsIG4sIHIsIGkpIHtcbiAgdmFyIG8gPSB0LmdyYXBoaWNhbEl0ZW1zLCBhID0gdC50b29sdGlwQXhpcywgcyA9IGN1KG4sIHQpO1xuICByZXR1cm4gciA8IDAgfHwgIW8gfHwgIW8ubGVuZ3RoIHx8IHIgPj0gcy5sZW5ndGggPyBudWxsIDogby5yZWR1Y2UoZnVuY3Rpb24odSwgYykge1xuICAgIHZhciBmLCBsID0gKGYgPSBjLnByb3BzLmRhdGEpICE9PSBudWxsICYmIGYgIT09IHZvaWQgMCA/IGYgOiBuO1xuICAgIGwgJiYgdC5kYXRhU3RhcnRJbmRleCArIHQuZGF0YUVuZEluZGV4ICE9PSAwICYmIChsID0gbC5zbGljZSh0LmRhdGFTdGFydEluZGV4LCB0LmRhdGFFbmRJbmRleCArIDEpKTtcbiAgICB2YXIgZDtcbiAgICBpZiAoYS5kYXRhS2V5ICYmICFhLmFsbG93RHVwbGljYXRlZENhdGVnb3J5KSB7XG4gICAgICB2YXIgcCA9IGwgPT09IHZvaWQgMCA/IHMgOiBsO1xuICAgICAgZCA9IERhKHAsIGEuZGF0YUtleSwgaSk7XG4gICAgfSBlbHNlXG4gICAgICBkID0gbCAmJiBsW3JdIHx8IHNbcl07XG4gICAgcmV0dXJuIGQgPyBbXS5jb25jYXQocmkodSksIFtLMChjLCBkKV0pIDogdTtcbiAgfSwgW10pO1xufSwgbm0gPSBmdW5jdGlvbih0LCBuLCByLCBpKSB7XG4gIHZhciBvID0gaSB8fCB7XG4gICAgeDogdC5jaGFydFgsXG4gICAgeTogdC5jaGFydFlcbiAgfSwgYSA9IE5XKG8sIHIpLCBzID0gdC5vcmRlcmVkVG9vbHRpcFRpY2tzLCB1ID0gdC50b29sdGlwQXhpcywgYyA9IHQudG9vbHRpcFRpY2tzLCBmID0gRzYoYSwgcywgYywgdSk7XG4gIGlmIChmID49IDAgJiYgYykge1xuICAgIHZhciBsID0gY1tmXSAmJiBjW2ZdLnZhbHVlLCBkID0gcWwodCwgbiwgZiwgbCksIHAgPSBGVyhyLCBzLCBmLCBvKTtcbiAgICByZXR1cm4ge1xuICAgICAgYWN0aXZlVG9vbHRpcEluZGV4OiBmLFxuICAgICAgYWN0aXZlTGFiZWw6IGwsXG4gICAgICBhY3RpdmVQYXlsb2FkOiBkLFxuICAgICAgYWN0aXZlQ29vcmRpbmF0ZTogcFxuICAgIH07XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59LCBMVyA9IGZ1bmN0aW9uKHQsIG4pIHtcbiAgdmFyIHIgPSBuLmF4ZXMsIGkgPSBuLmdyYXBoaWNhbEl0ZW1zLCBvID0gbi5heGlzVHlwZSwgYSA9IG4uYXhpc0lkS2V5LCBzID0gbi5zdGFja0dyb3VwcywgdSA9IG4uZGF0YVN0YXJ0SW5kZXgsIGMgPSBuLmRhdGFFbmRJbmRleCwgZiA9IHQubGF5b3V0LCBsID0gdC5jaGlsZHJlbiwgZCA9IHQuc3RhY2tPZmZzZXQsIHAgPSBVMChmLCBvKTtcbiAgcmV0dXJuIHIucmVkdWNlKGZ1bmN0aW9uKGcsIGgpIHtcbiAgICB2YXIgdiwgdyA9IGgucHJvcHMsIGIgPSB3LnR5cGUsIHggPSB3LmRhdGFLZXksIG0gPSB3LmFsbG93RGF0YU92ZXJmbG93LCB5ID0gdy5hbGxvd0R1cGxpY2F0ZWRDYXRlZ29yeSwgUyA9IHcuc2NhbGUsICQgPSB3LnRpY2tzLCBPID0gdy5pbmNsdWRlSGlkZGVuLCBUID0gaC5wcm9wc1thXTtcbiAgICBpZiAoZ1tUXSlcbiAgICAgIHJldHVybiBnO1xuICAgIHZhciBNID0gY3UodC5kYXRhLCB7XG4gICAgICBncmFwaGljYWxJdGVtczogaS5maWx0ZXIoZnVuY3Rpb24oRykge1xuICAgICAgICByZXR1cm4gRy5wcm9wc1thXSA9PT0gVDtcbiAgICAgIH0pLFxuICAgICAgZGF0YVN0YXJ0SW5kZXg6IHUsXG4gICAgICBkYXRhRW5kSW5kZXg6IGNcbiAgICB9KSwgRSA9IE0ubGVuZ3RoLCBBLCBqLCBSO1xuICAgIGRXKGgucHJvcHMuZG9tYWluLCBtLCBiKSAmJiAoQSA9IGhsKGgucHJvcHMuZG9tYWluLCBudWxsLCBtKSwgcCAmJiAoYiA9PT0gXCJudW1iZXJcIiB8fCBTICE9PSBcImF1dG9cIikgJiYgKFIgPSBVaShNLCB4LCBcImNhdGVnb3J5XCIpKSk7XG4gICAgdmFyIE4gPSB6dyhiKTtcbiAgICBpZiAoIUEgfHwgQS5sZW5ndGggPT09IDApIHtcbiAgICAgIHZhciBrLCBGID0gKGsgPSBoLnByb3BzLmRvbWFpbikgIT09IG51bGwgJiYgayAhPT0gdm9pZCAwID8gayA6IE47XG4gICAgICBpZiAoeCkge1xuICAgICAgICBpZiAoQSA9IFVpKE0sIHgsIGIpLCBiID09PSBcImNhdGVnb3J5XCIgJiYgcCkge1xuICAgICAgICAgIHZhciBWID0gcUMoQSk7XG4gICAgICAgICAgeSAmJiBWID8gKGogPSBBLCBBID0geHMoMCwgRSkpIDogeSB8fCAoQSA9IEVnKEYsIEEsIGgpLnJlZHVjZShmdW5jdGlvbihHLCBxKSB7XG4gICAgICAgICAgICByZXR1cm4gRy5pbmRleE9mKHEpID49IDAgPyBHIDogW10uY29uY2F0KHJpKEcpLCBbcV0pO1xuICAgICAgICAgIH0sIFtdKSk7XG4gICAgICAgIH0gZWxzZSBpZiAoYiA9PT0gXCJjYXRlZ29yeVwiKVxuICAgICAgICAgIHkgPyBBID0gQS5maWx0ZXIoZnVuY3Rpb24oRykge1xuICAgICAgICAgICAgcmV0dXJuIEcgIT09IFwiXCIgJiYgIW1lKEcpO1xuICAgICAgICAgIH0pIDogQSA9IEVnKEYsIEEsIGgpLnJlZHVjZShmdW5jdGlvbihHLCBxKSB7XG4gICAgICAgICAgICByZXR1cm4gRy5pbmRleE9mKHEpID49IDAgfHwgcSA9PT0gXCJcIiB8fCBtZShxKSA/IEcgOiBbXS5jb25jYXQocmkoRyksIFtxXSk7XG4gICAgICAgICAgfSwgW10pO1xuICAgICAgICBlbHNlIGlmIChiID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgdmFyIEwgPSBLNihNLCBpLmZpbHRlcihmdW5jdGlvbihHKSB7XG4gICAgICAgICAgICByZXR1cm4gRy5wcm9wc1thXSA9PT0gVCAmJiAoTyB8fCAhRy5wcm9wcy5oaWRlKTtcbiAgICAgICAgICB9KSwgeCwgbywgZik7XG4gICAgICAgICAgTCAmJiAoQSA9IEwpO1xuICAgICAgICB9XG4gICAgICAgIHAgJiYgKGIgPT09IFwibnVtYmVyXCIgfHwgUyAhPT0gXCJhdXRvXCIpICYmIChSID0gVWkoTSwgeCwgXCJjYXRlZ29yeVwiKSk7XG4gICAgICB9IGVsc2VcbiAgICAgICAgcCA/IEEgPSB4cygwLCBFKSA6IHMgJiYgc1tUXSAmJiBzW1RdLmhhc1N0YWNrICYmIGIgPT09IFwibnVtYmVyXCIgPyBBID0gZCA9PT0gXCJleHBhbmRcIiA/IFswLCAxXSA6IHEwKHNbVF0uc3RhY2tHcm91cHMsIHUsIGMpIDogQSA9IFcwKE0sIGkuZmlsdGVyKGZ1bmN0aW9uKEcpIHtcbiAgICAgICAgICByZXR1cm4gRy5wcm9wc1thXSA9PT0gVCAmJiAoTyB8fCAhRy5wcm9wcy5oaWRlKTtcbiAgICAgICAgfSksIGIsIGYsICEwKTtcbiAgICAgIGlmIChiID09PSBcIm51bWJlclwiKVxuICAgICAgICBBID0gV2wobCwgQSwgVCwgbywgJCksIEYgJiYgKEEgPSBobChGLCBBLCBtKSk7XG4gICAgICBlbHNlIGlmIChiID09PSBcImNhdGVnb3J5XCIgJiYgRikge1xuICAgICAgICB2YXIgSSA9IEYsIEQgPSBBLmV2ZXJ5KGZ1bmN0aW9uKEcpIHtcbiAgICAgICAgICByZXR1cm4gSS5pbmRleE9mKEcpID49IDA7XG4gICAgICAgIH0pO1xuICAgICAgICBEICYmIChBID0gSSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB6KHooe30sIGcpLCB7fSwgc2Uoe30sIFQsIHooeih7fSwgaC5wcm9wcyksIHt9LCB7XG4gICAgICBheGlzVHlwZTogbyxcbiAgICAgIGRvbWFpbjogQSxcbiAgICAgIGNhdGVnb3JpY2FsRG9tYWluOiBSLFxuICAgICAgZHVwbGljYXRlRG9tYWluOiBqLFxuICAgICAgb3JpZ2luYWxEb21haW46ICh2ID0gaC5wcm9wcy5kb21haW4pICE9PSBudWxsICYmIHYgIT09IHZvaWQgMCA/IHYgOiBOLFxuICAgICAgaXNDYXRlZ29yaWNhbDogcCxcbiAgICAgIGxheW91dDogZlxuICAgIH0pKSk7XG4gIH0sIHt9KTtcbn0sIEJXID0gZnVuY3Rpb24odCwgbikge1xuICB2YXIgciA9IG4uZ3JhcGhpY2FsSXRlbXMsIGkgPSBuLkF4aXMsIG8gPSBuLmF4aXNUeXBlLCBhID0gbi5heGlzSWRLZXksIHMgPSBuLnN0YWNrR3JvdXBzLCB1ID0gbi5kYXRhU3RhcnRJbmRleCwgYyA9IG4uZGF0YUVuZEluZGV4LCBmID0gdC5sYXlvdXQsIGwgPSB0LmNoaWxkcmVuLCBkID0gY3UodC5kYXRhLCB7XG4gICAgZ3JhcGhpY2FsSXRlbXM6IHIsXG4gICAgZGF0YVN0YXJ0SW5kZXg6IHUsXG4gICAgZGF0YUVuZEluZGV4OiBjXG4gIH0pLCBwID0gZC5sZW5ndGgsIGcgPSBVMChmLCBvKSwgaCA9IC0xO1xuICByZXR1cm4gci5yZWR1Y2UoZnVuY3Rpb24odiwgdykge1xuICAgIHZhciBiID0gdy5wcm9wc1thXSwgeCA9IHp3KFwibnVtYmVyXCIpO1xuICAgIGlmICghdltiXSkge1xuICAgICAgaCsrO1xuICAgICAgdmFyIG07XG4gICAgICByZXR1cm4gZyA/IG0gPSB4cygwLCBwKSA6IHMgJiYgc1tiXSAmJiBzW2JdLmhhc1N0YWNrID8gKG0gPSBxMChzW2JdLnN0YWNrR3JvdXBzLCB1LCBjKSwgbSA9IFdsKGwsIG0sIGIsIG8pKSA6IChtID0gaGwoeCwgVzAoZCwgci5maWx0ZXIoZnVuY3Rpb24oeSkge1xuICAgICAgICByZXR1cm4geS5wcm9wc1thXSA9PT0gYiAmJiAheS5wcm9wcy5oaWRlO1xuICAgICAgfSksIFwibnVtYmVyXCIsIGYpLCBpLmRlZmF1bHRQcm9wcy5hbGxvd0RhdGFPdmVyZmxvdyksIG0gPSBXbChsLCBtLCBiLCBvKSksIHooeih7fSwgdiksIHt9LCBzZSh7fSwgYiwgeih6KHtcbiAgICAgICAgYXhpc1R5cGU6IG9cbiAgICAgIH0sIGkuZGVmYXVsdFByb3BzKSwge30sIHtcbiAgICAgICAgaGlkZTogITAsXG4gICAgICAgIG9yaWVudGF0aW9uOiBqdChrVywgXCJcIi5jb25jYXQobywgXCIuXCIpLmNvbmNhdChoICUgMiksIG51bGwpLFxuICAgICAgICBkb21haW46IG0sXG4gICAgICAgIG9yaWdpbmFsRG9tYWluOiB4LFxuICAgICAgICBpc0NhdGVnb3JpY2FsOiBnLFxuICAgICAgICBsYXlvdXQ6IGZcbiAgICAgICAgLy8gc3BlY2lmeSBzY2FsZSB3aGVuIG5vIEF4aXNcbiAgICAgICAgLy8gc2NhbGU6IGlzQ2F0ZWdvcmljYWwgPyAnYmFuZCcgOiAnbGluZWFyJyxcbiAgICAgIH0pKSk7XG4gICAgfVxuICAgIHJldHVybiB2O1xuICB9LCB7fSk7XG59LCB6VyA9IGZ1bmN0aW9uKHQsIG4pIHtcbiAgdmFyIHIgPSBuLmF4aXNUeXBlLCBpID0gciA9PT0gdm9pZCAwID8gXCJ4QXhpc1wiIDogciwgbyA9IG4uQXhpc0NvbXAsIGEgPSBuLmdyYXBoaWNhbEl0ZW1zLCBzID0gbi5zdGFja0dyb3VwcywgdSA9IG4uZGF0YVN0YXJ0SW5kZXgsIGMgPSBuLmRhdGFFbmRJbmRleCwgZiA9IHQuY2hpbGRyZW4sIGwgPSBcIlwiLmNvbmNhdChpLCBcIklkXCIpLCBkID0ga3QoZiwgbyksIHAgPSB7fTtcbiAgcmV0dXJuIGQgJiYgZC5sZW5ndGggPyBwID0gTFcodCwge1xuICAgIGF4ZXM6IGQsXG4gICAgZ3JhcGhpY2FsSXRlbXM6IGEsXG4gICAgYXhpc1R5cGU6IGksXG4gICAgYXhpc0lkS2V5OiBsLFxuICAgIHN0YWNrR3JvdXBzOiBzLFxuICAgIGRhdGFTdGFydEluZGV4OiB1LFxuICAgIGRhdGFFbmRJbmRleDogY1xuICB9KSA6IGEgJiYgYS5sZW5ndGggJiYgKHAgPSBCVyh0LCB7XG4gICAgQXhpczogbyxcbiAgICBncmFwaGljYWxJdGVtczogYSxcbiAgICBheGlzVHlwZTogaSxcbiAgICBheGlzSWRLZXk6IGwsXG4gICAgc3RhY2tHcm91cHM6IHMsXG4gICAgZGF0YVN0YXJ0SW5kZXg6IHUsXG4gICAgZGF0YUVuZEluZGV4OiBjXG4gIH0pKSwgcDtcbn0sIFZXID0gZnVuY3Rpb24odCkge1xuICB2YXIgbiA9IGtuKHQpLCByID0gbW4obiwgITEsICEwKTtcbiAgcmV0dXJuIHtcbiAgICB0b29sdGlwVGlja3M6IHIsXG4gICAgb3JkZXJlZFRvb2x0aXBUaWNrczogRmYociwgZnVuY3Rpb24oaSkge1xuICAgICAgcmV0dXJuIGkuY29vcmRpbmF0ZTtcbiAgICB9KSxcbiAgICB0b29sdGlwQXhpczogbixcbiAgICB0b29sdGlwQXhpc0JhbmRTaXplOiBmcyhuLCByKVxuICB9O1xufSwgcm0gPSBmdW5jdGlvbih0KSB7XG4gIHZhciBuID0gdC5jaGlsZHJlbiwgciA9IHQuZGVmYXVsdFNob3dUb29sdGlwLCBpID0gd3QobiwgWHIpLCBvID0gMCwgYSA9IDA7XG4gIHJldHVybiB0LmRhdGEgJiYgdC5kYXRhLmxlbmd0aCAhPT0gMCAmJiAoYSA9IHQuZGF0YS5sZW5ndGggLSAxKSwgaSAmJiBpLnByb3BzICYmIChpLnByb3BzLnN0YXJ0SW5kZXggPj0gMCAmJiAobyA9IGkucHJvcHMuc3RhcnRJbmRleCksIGkucHJvcHMuZW5kSW5kZXggPj0gMCAmJiAoYSA9IGkucHJvcHMuZW5kSW5kZXgpKSwge1xuICAgIGNoYXJ0WDogMCxcbiAgICBjaGFydFk6IDAsXG4gICAgZGF0YVN0YXJ0SW5kZXg6IG8sXG4gICAgZGF0YUVuZEluZGV4OiBhLFxuICAgIGFjdGl2ZVRvb2x0aXBJbmRleDogLTEsXG4gICAgaXNUb29sdGlwQWN0aXZlOiAhIXJcbiAgfTtcbn0sIEdXID0gZnVuY3Rpb24odCkge1xuICByZXR1cm4gIXQgfHwgIXQubGVuZ3RoID8gITEgOiB0LnNvbWUoZnVuY3Rpb24obikge1xuICAgIHZhciByID0gRm4obiAmJiBuLnR5cGUpO1xuICAgIHJldHVybiByICYmIHIuaW5kZXhPZihcIkJhclwiKSA+PSAwO1xuICB9KTtcbn0sIGltID0gZnVuY3Rpb24odCkge1xuICByZXR1cm4gdCA9PT0gXCJob3Jpem9udGFsXCIgPyB7XG4gICAgbnVtZXJpY0F4aXNOYW1lOiBcInlBeGlzXCIsXG4gICAgY2F0ZUF4aXNOYW1lOiBcInhBeGlzXCJcbiAgfSA6IHQgPT09IFwidmVydGljYWxcIiA/IHtcbiAgICBudW1lcmljQXhpc05hbWU6IFwieEF4aXNcIixcbiAgICBjYXRlQXhpc05hbWU6IFwieUF4aXNcIlxuICB9IDogdCA9PT0gXCJjZW50cmljXCIgPyB7XG4gICAgbnVtZXJpY0F4aXNOYW1lOiBcInJhZGl1c0F4aXNcIixcbiAgICBjYXRlQXhpc05hbWU6IFwiYW5nbGVBeGlzXCJcbiAgfSA6IHtcbiAgICBudW1lcmljQXhpc05hbWU6IFwiYW5nbGVBeGlzXCIsXG4gICAgY2F0ZUF4aXNOYW1lOiBcInJhZGl1c0F4aXNcIlxuICB9O1xufSwgV1cgPSBmdW5jdGlvbih0LCBuKSB7XG4gIHZhciByID0gdC5wcm9wcywgaSA9IHQuZ3JhcGhpY2FsSXRlbXMsIG8gPSB0LnhBeGlzTWFwLCBhID0gbyA9PT0gdm9pZCAwID8ge30gOiBvLCBzID0gdC55QXhpc01hcCwgdSA9IHMgPT09IHZvaWQgMCA/IHt9IDogcywgYyA9IHIud2lkdGgsIGYgPSByLmhlaWdodCwgbCA9IHIuY2hpbGRyZW4sIGQgPSByLm1hcmdpbiB8fCB7fSwgcCA9IHd0KGwsIFhyKSwgZyA9IHd0KGwsIFZyKSwgaCA9IE9iamVjdC5rZXlzKHUpLnJlZHVjZShmdW5jdGlvbih5LCBTKSB7XG4gICAgdmFyICQgPSB1W1NdLCBPID0gJC5vcmllbnRhdGlvbjtcbiAgICByZXR1cm4gISQubWlycm9yICYmICEkLmhpZGUgPyB6KHooe30sIHkpLCB7fSwgc2Uoe30sIE8sIHlbT10gKyAkLndpZHRoKSkgOiB5O1xuICB9LCB7XG4gICAgbGVmdDogZC5sZWZ0IHx8IDAsXG4gICAgcmlnaHQ6IGQucmlnaHQgfHwgMFxuICB9KSwgdiA9IE9iamVjdC5rZXlzKGEpLnJlZHVjZShmdW5jdGlvbih5LCBTKSB7XG4gICAgdmFyICQgPSBhW1NdLCBPID0gJC5vcmllbnRhdGlvbjtcbiAgICByZXR1cm4gISQubWlycm9yICYmICEkLmhpZGUgPyB6KHooe30sIHkpLCB7fSwgc2Uoe30sIE8sIGp0KHksIFwiXCIuY29uY2F0KE8pKSArICQuaGVpZ2h0KSkgOiB5O1xuICB9LCB7XG4gICAgdG9wOiBkLnRvcCB8fCAwLFxuICAgIGJvdHRvbTogZC5ib3R0b20gfHwgMFxuICB9KSwgdyA9IHooeih7fSwgdiksIGgpLCBiID0gdy5ib3R0b207XG4gIHAgJiYgKHcuYm90dG9tICs9IHAucHJvcHMuaGVpZ2h0IHx8IFhyLmRlZmF1bHRQcm9wcy5oZWlnaHQpLCBnICYmIG4gJiYgKHcgPSBINih3LCBpLCByLCBuKSk7XG4gIHZhciB4ID0gYyAtIHcubGVmdCAtIHcucmlnaHQsIG0gPSBmIC0gdy50b3AgLSB3LmJvdHRvbTtcbiAgcmV0dXJuIHooeih7XG4gICAgYnJ1c2hCb3R0b206IGJcbiAgfSwgdyksIHt9LCB7XG4gICAgLy8gbmV2ZXIgcmV0dXJuIG5lZ2F0aXZlIHZhbHVlcyBmb3IgaGVpZ2h0IGFuZCB3aWR0aFxuICAgIHdpZHRoOiBNYXRoLm1heCh4LCAwKSxcbiAgICBoZWlnaHQ6IE1hdGgubWF4KG0sIDApXG4gIH0pO1xufSwgVVcgPSBmdW5jdGlvbih0LCBuKSB7XG4gIGlmIChuID09PSBcInhBeGlzXCIpXG4gICAgcmV0dXJuIHRbbl0ud2lkdGg7XG4gIGlmIChuID09PSBcInlBeGlzXCIpXG4gICAgcmV0dXJuIHRbbl0uaGVpZ2h0O1xufSwgSFcgPSBmdW5jdGlvbih0KSB7XG4gIHZhciBuLCByID0gdC5jaGFydE5hbWUsIGkgPSB0LkdyYXBoaWNhbENoaWxkLCBvID0gdC5kZWZhdWx0VG9vbHRpcEV2ZW50VHlwZSwgYSA9IG8gPT09IHZvaWQgMCA/IFwiYXhpc1wiIDogbywgcyA9IHQudmFsaWRhdGVUb29sdGlwRXZlbnRUeXBlcywgdSA9IHMgPT09IHZvaWQgMCA/IFtcImF4aXNcIl0gOiBzLCBjID0gdC5heGlzQ29tcG9uZW50cywgZiA9IHQubGVnZW5kQ29udGVudCwgbCA9IHQuZm9ybWF0QXhpc01hcCwgZCA9IHQuZGVmYXVsdFByb3BzLCBwID0gZnVuY3Rpb24odiwgdykge1xuICAgIHZhciBiID0gdy5ncmFwaGljYWxJdGVtcywgeCA9IHcuc3RhY2tHcm91cHMsIG0gPSB3Lm9mZnNldCwgeSA9IHcudXBkYXRlSWQsIFMgPSB3LmRhdGFTdGFydEluZGV4LCAkID0gdy5kYXRhRW5kSW5kZXgsIE8gPSB2LmJhclNpemUsIFQgPSB2LmxheW91dCwgTSA9IHYuYmFyR2FwLCBFID0gdi5iYXJDYXRlZ29yeUdhcCwgQSA9IHYubWF4QmFyU2l6ZSwgaiA9IGltKFQpLCBSID0gai5udW1lcmljQXhpc05hbWUsIE4gPSBqLmNhdGVBeGlzTmFtZSwgayA9IEdXKGIpLCBGID0gW107XG4gICAgcmV0dXJuIGIuZm9yRWFjaChmdW5jdGlvbihWLCBMKSB7XG4gICAgICB2YXIgSSA9IGN1KHYuZGF0YSwge1xuICAgICAgICBncmFwaGljYWxJdGVtczogW1ZdLFxuICAgICAgICBkYXRhU3RhcnRJbmRleDogUyxcbiAgICAgICAgZGF0YUVuZEluZGV4OiAkXG4gICAgICB9KSwgRCA9IFYucHJvcHMsIEcgPSBELmRhdGFLZXksIHEgPSBELm1heEJhclNpemUsIEogPSBWLnByb3BzW1wiXCIuY29uY2F0KFIsIFwiSWRcIildLCBuZSA9IFYucHJvcHNbXCJcIi5jb25jYXQoTiwgXCJJZFwiKV0sIHRlID0ge30sIGVlID0gYy5yZWR1Y2UoZnVuY3Rpb24oVnQsIHJ0KSB7XG4gICAgICAgIHZhciBYbiwgeGksIFNpID0gd1tcIlwiLmNvbmNhdChydC5heGlzVHlwZSwgXCJNYXBcIildLCAkaSA9IFYucHJvcHNbXCJcIi5jb25jYXQocnQuYXhpc1R5cGUsIFwiSWRcIildO1xuICAgICAgICBTaSAmJiBTaVskaV0gfHwgcnQuYXhpc1R5cGUgPT09IFwiekF4aXNcIiB8fCAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gZ3QoITEsIFwiU3BlY2lmeWluZyBhKG4pIFwiLmNvbmNhdChydC5heGlzVHlwZSwgXCJJZCByZXF1aXJlcyBhIGNvcnJlc3BvbmRpbmcgXCIpLmNvbmNhdChcbiAgICAgICAgICBydC5heGlzVHlwZSxcbiAgICAgICAgICBcIklkIG9uIHRoZSB0YXJnZXRlZCBncmFwaGljYWwgY29tcG9uZW50IFwiXG4gICAgICAgICkuY29uY2F0KChYbiA9IFYgPT0gbnVsbCB8fCAoeGkgPSBWLnR5cGUpID09PSBudWxsIHx8IHhpID09PSB2b2lkIDAgPyB2b2lkIDAgOiB4aS5kaXNwbGF5TmFtZSkgIT09IG51bGwgJiYgWG4gIT09IHZvaWQgMCA/IFhuIDogXCJcIikpIDogZ3QoKSk7XG4gICAgICAgIHZhciBPaSA9IFNpWyRpXTtcbiAgICAgICAgcmV0dXJuIHooeih7fSwgVnQpLCB7fSwgc2Uoc2Uoe30sIHJ0LmF4aXNUeXBlLCBPaSksIFwiXCIuY29uY2F0KHJ0LmF4aXNUeXBlLCBcIlRpY2tzXCIpLCBtbihPaSkpKTtcbiAgICAgIH0sIHRlKSwgaWUgPSBlZVtOXSwgQiA9IGVlW1wiXCIuY29uY2F0KE4sIFwiVGlja3NcIildLCBVID0geCAmJiB4W0pdICYmIHhbSl0uaGFzU3RhY2sgJiYgYTgoViwgeFtKXS5zdGFja0dyb3VwcyksIHJlID0gRm4oVi50eXBlKS5pbmRleE9mKFwiQmFyXCIpID49IDAsIEMgPSBmcyhpZSwgQiksIGdlID0gW10sIGxlID0gayAmJiBXNih7XG4gICAgICAgIGJhclNpemU6IE8sXG4gICAgICAgIHN0YWNrR3JvdXBzOiB4LFxuICAgICAgICB0b3RhbFNpemU6IFVXKGVlLCBOKVxuICAgICAgfSk7XG4gICAgICBpZiAocmUpIHtcbiAgICAgICAgdmFyIHhlLCBFZSwgWmUgPSBtZShxKSA/IEEgOiBxLCBkdCA9ICh4ZSA9IChFZSA9IGZzKGllLCBCLCAhMCkpICE9PSBudWxsICYmIEVlICE9PSB2b2lkIDAgPyBFZSA6IFplKSAhPT0gbnVsbCAmJiB4ZSAhPT0gdm9pZCAwID8geGUgOiAwO1xuICAgICAgICBnZSA9IFU2KHtcbiAgICAgICAgICBiYXJHYXA6IE0sXG4gICAgICAgICAgYmFyQ2F0ZWdvcnlHYXA6IEUsXG4gICAgICAgICAgYmFuZFNpemU6IGR0ICE9PSBDID8gZHQgOiBDLFxuICAgICAgICAgIHNpemVMaXN0OiBsZVtuZV0sXG4gICAgICAgICAgbWF4QmFyU2l6ZTogWmVcbiAgICAgICAgfSksIGR0ICE9PSBDICYmIChnZSA9IGdlLm1hcChmdW5jdGlvbihWdCkge1xuICAgICAgICAgIHJldHVybiB6KHooe30sIFZ0KSwge30sIHtcbiAgICAgICAgICAgIHBvc2l0aW9uOiB6KHooe30sIFZ0LnBvc2l0aW9uKSwge30sIHtcbiAgICAgICAgICAgICAgb2Zmc2V0OiBWdC5wb3NpdGlvbi5vZmZzZXQgLSBkdCAvIDJcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pKTtcbiAgICAgIH1cbiAgICAgIHZhciB6dCA9IFYgJiYgVi50eXBlICYmIFYudHlwZS5nZXRDb21wb3NlZERhdGE7XG4gICAgICB6dCAmJiBGLnB1c2goe1xuICAgICAgICBwcm9wczogeih6KHt9LCB6dCh6KHooe30sIGVlKSwge30sIHtcbiAgICAgICAgICBkaXNwbGF5ZWREYXRhOiBJLFxuICAgICAgICAgIHByb3BzOiB2LFxuICAgICAgICAgIGRhdGFLZXk6IEcsXG4gICAgICAgICAgaXRlbTogVixcbiAgICAgICAgICBiYW5kU2l6ZTogQyxcbiAgICAgICAgICBiYXJQb3NpdGlvbjogZ2UsXG4gICAgICAgICAgb2Zmc2V0OiBtLFxuICAgICAgICAgIHN0YWNrZWREYXRhOiBVLFxuICAgICAgICAgIGxheW91dDogVCxcbiAgICAgICAgICBkYXRhU3RhcnRJbmRleDogUyxcbiAgICAgICAgICBkYXRhRW5kSW5kZXg6ICRcbiAgICAgICAgfSkpKSwge30sIHNlKHNlKHNlKHtcbiAgICAgICAgICBrZXk6IFYua2V5IHx8IFwiaXRlbS1cIi5jb25jYXQoTClcbiAgICAgICAgfSwgUiwgZWVbUl0pLCBOLCBlZVtOXSksIFwiYW5pbWF0aW9uSWRcIiwgeSkpLFxuICAgICAgICBjaGlsZEluZGV4OiBvRShWLCB2LmNoaWxkcmVuKSxcbiAgICAgICAgaXRlbTogVlxuICAgICAgfSk7XG4gICAgfSksIEY7XG4gIH0sIGcgPSBmdW5jdGlvbih2LCB3KSB7XG4gICAgdmFyIGIgPSB2LnByb3BzLCB4ID0gdi5kYXRhU3RhcnRJbmRleCwgbSA9IHYuZGF0YUVuZEluZGV4LCB5ID0gdi51cGRhdGVJZDtcbiAgICBpZiAoIU9wKHtcbiAgICAgIHByb3BzOiBiXG4gICAgfSkpXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB2YXIgUyA9IGIuY2hpbGRyZW4sICQgPSBiLmxheW91dCwgTyA9IGIuc3RhY2tPZmZzZXQsIFQgPSBiLmRhdGEsIE0gPSBiLnJldmVyc2VTdGFja09yZGVyLCBFID0gaW0oJCksIEEgPSBFLm51bWVyaWNBeGlzTmFtZSwgaiA9IEUuY2F0ZUF4aXNOYW1lLCBSID0ga3QoUywgaSksIE4gPSByOChULCBSLCBcIlwiLmNvbmNhdChBLCBcIklkXCIpLCBcIlwiLmNvbmNhdChqLCBcIklkXCIpLCBPLCBNKSwgayA9IGMucmVkdWNlKGZ1bmN0aW9uKEQsIEcpIHtcbiAgICAgIHZhciBxID0gXCJcIi5jb25jYXQoRy5heGlzVHlwZSwgXCJNYXBcIik7XG4gICAgICByZXR1cm4geih6KHt9LCBEKSwge30sIHNlKHt9LCBxLCB6VyhiLCB6KHooe30sIEcpLCB7fSwge1xuICAgICAgICBncmFwaGljYWxJdGVtczogUixcbiAgICAgICAgc3RhY2tHcm91cHM6IEcuYXhpc1R5cGUgPT09IEEgJiYgTixcbiAgICAgICAgZGF0YVN0YXJ0SW5kZXg6IHgsXG4gICAgICAgIGRhdGFFbmRJbmRleDogbVxuICAgICAgfSkpKSk7XG4gICAgfSwge30pLCBGID0gV1coeih6KHt9LCBrKSwge30sIHtcbiAgICAgIHByb3BzOiBiLFxuICAgICAgZ3JhcGhpY2FsSXRlbXM6IFJcbiAgICB9KSwgdyA9PSBudWxsID8gdm9pZCAwIDogdy5sZWdlbmRCQm94KTtcbiAgICBPYmplY3Qua2V5cyhrKS5mb3JFYWNoKGZ1bmN0aW9uKEQpIHtcbiAgICAgIGtbRF0gPSBsKGIsIGtbRF0sIEYsIEQucmVwbGFjZShcIk1hcFwiLCBcIlwiKSwgcik7XG4gICAgfSk7XG4gICAgdmFyIFYgPSBrW1wiXCIuY29uY2F0KGosIFwiTWFwXCIpXSwgTCA9IFZXKFYpLCBJID0gcChiLCB6KHooe30sIGspLCB7fSwge1xuICAgICAgZGF0YVN0YXJ0SW5kZXg6IHgsXG4gICAgICBkYXRhRW5kSW5kZXg6IG0sXG4gICAgICB1cGRhdGVJZDogeSxcbiAgICAgIGdyYXBoaWNhbEl0ZW1zOiBSLFxuICAgICAgc3RhY2tHcm91cHM6IE4sXG4gICAgICBvZmZzZXQ6IEZcbiAgICB9KSk7XG4gICAgcmV0dXJuIHooeih7XG4gICAgICBmb3JtYXR0ZWRHcmFwaGljYWxJdGVtczogSSxcbiAgICAgIGdyYXBoaWNhbEl0ZW1zOiBSLFxuICAgICAgb2Zmc2V0OiBGLFxuICAgICAgc3RhY2tHcm91cHM6IE5cbiAgICB9LCBMKSwgayk7XG4gIH07XG4gIHJldHVybiBuID0gLyogQF9fUFVSRV9fICovIGZ1bmN0aW9uKGgpIHtcbiAgICBUVyh2LCBoKTtcbiAgICBmdW5jdGlvbiB2KHcpIHtcbiAgICAgIHZhciBiLCB4LCBtO1xuICAgICAgcmV0dXJuIF9XKHRoaXMsIHYpLCBtID0gQ1codGhpcywgdiwgW3ddKSwgc2UoU2UobSksIFwiZXZlbnRFbWl0dGVyU3ltYm9sXCIsIFN5bWJvbChcInJlY2hhcnRzRXZlbnRFbWl0dGVyXCIpKSwgc2UoU2UobSksIFwiYWNjZXNzaWJpbGl0eU1hbmFnZXJcIiwgbmV3IGZXKCkpLCBzZShTZShtKSwgXCJoYW5kbGVMZWdlbmRCQm94VXBkYXRlXCIsIGZ1bmN0aW9uKHkpIHtcbiAgICAgICAgaWYgKHkpIHtcbiAgICAgICAgICB2YXIgUyA9IG0uc3RhdGUsICQgPSBTLmRhdGFTdGFydEluZGV4LCBPID0gUy5kYXRhRW5kSW5kZXgsIFQgPSBTLnVwZGF0ZUlkO1xuICAgICAgICAgIG0uc2V0U3RhdGUoeih7XG4gICAgICAgICAgICBsZWdlbmRCQm94OiB5XG4gICAgICAgICAgfSwgZyh7XG4gICAgICAgICAgICBwcm9wczogbS5wcm9wcyxcbiAgICAgICAgICAgIGRhdGFTdGFydEluZGV4OiAkLFxuICAgICAgICAgICAgZGF0YUVuZEluZGV4OiBPLFxuICAgICAgICAgICAgdXBkYXRlSWQ6IFRcbiAgICAgICAgICB9LCB6KHooe30sIG0uc3RhdGUpLCB7fSwge1xuICAgICAgICAgICAgbGVnZW5kQkJveDogeVxuICAgICAgICAgIH0pKSkpO1xuICAgICAgICB9XG4gICAgICB9KSwgc2UoU2UobSksIFwiaGFuZGxlUmVjZWl2ZVN5bmNFdmVudFwiLCBmdW5jdGlvbih5LCBTLCAkKSB7XG4gICAgICAgIGlmIChtLnByb3BzLnN5bmNJZCA9PT0geSkge1xuICAgICAgICAgIGlmICgkID09PSBtLmV2ZW50RW1pdHRlclN5bWJvbCAmJiB0eXBlb2YgbS5wcm9wcy5zeW5jTWV0aG9kICE9IFwiZnVuY3Rpb25cIilcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICBtLmFwcGx5U3luY0V2ZW50KFMpO1xuICAgICAgICB9XG4gICAgICB9KSwgc2UoU2UobSksIFwiaGFuZGxlQnJ1c2hDaGFuZ2VcIiwgZnVuY3Rpb24oeSkge1xuICAgICAgICB2YXIgUyA9IHkuc3RhcnRJbmRleCwgJCA9IHkuZW5kSW5kZXg7XG4gICAgICAgIGlmIChTICE9PSBtLnN0YXRlLmRhdGFTdGFydEluZGV4IHx8ICQgIT09IG0uc3RhdGUuZGF0YUVuZEluZGV4KSB7XG4gICAgICAgICAgdmFyIE8gPSBtLnN0YXRlLnVwZGF0ZUlkO1xuICAgICAgICAgIG0uc2V0U3RhdGUoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4geih7XG4gICAgICAgICAgICAgIGRhdGFTdGFydEluZGV4OiBTLFxuICAgICAgICAgICAgICBkYXRhRW5kSW5kZXg6ICRcbiAgICAgICAgICAgIH0sIGcoe1xuICAgICAgICAgICAgICBwcm9wczogbS5wcm9wcyxcbiAgICAgICAgICAgICAgZGF0YVN0YXJ0SW5kZXg6IFMsXG4gICAgICAgICAgICAgIGRhdGFFbmRJbmRleDogJCxcbiAgICAgICAgICAgICAgdXBkYXRlSWQ6IE9cbiAgICAgICAgICAgIH0sIG0uc3RhdGUpKTtcbiAgICAgICAgICB9KSwgbS50cmlnZ2VyU3luY0V2ZW50KHtcbiAgICAgICAgICAgIGRhdGFTdGFydEluZGV4OiBTLFxuICAgICAgICAgICAgZGF0YUVuZEluZGV4OiAkXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pLCBzZShTZShtKSwgXCJoYW5kbGVNb3VzZUVudGVyXCIsIGZ1bmN0aW9uKHkpIHtcbiAgICAgICAgdmFyIFMgPSBtLmdldE1vdXNlSW5mbyh5KTtcbiAgICAgICAgaWYgKFMpIHtcbiAgICAgICAgICB2YXIgJCA9IHooeih7fSwgUyksIHt9LCB7XG4gICAgICAgICAgICBpc1Rvb2x0aXBBY3RpdmU6ICEwXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgbS5zZXRTdGF0ZSgkKSwgbS50cmlnZ2VyU3luY0V2ZW50KCQpO1xuICAgICAgICAgIHZhciBPID0gbS5wcm9wcy5vbk1vdXNlRW50ZXI7XG4gICAgICAgICAgcGUoTykgJiYgTygkLCB5KTtcbiAgICAgICAgfVxuICAgICAgfSksIHNlKFNlKG0pLCBcInRyaWdnZXJlZEFmdGVyTW91c2VNb3ZlXCIsIGZ1bmN0aW9uKHkpIHtcbiAgICAgICAgdmFyIFMgPSBtLmdldE1vdXNlSW5mbyh5KSwgJCA9IFMgPyB6KHooe30sIFMpLCB7fSwge1xuICAgICAgICAgIGlzVG9vbHRpcEFjdGl2ZTogITBcbiAgICAgICAgfSkgOiB7XG4gICAgICAgICAgaXNUb29sdGlwQWN0aXZlOiAhMVxuICAgICAgICB9O1xuICAgICAgICBtLnNldFN0YXRlKCQpLCBtLnRyaWdnZXJTeW5jRXZlbnQoJCk7XG4gICAgICAgIHZhciBPID0gbS5wcm9wcy5vbk1vdXNlTW92ZTtcbiAgICAgICAgcGUoTykgJiYgTygkLCB5KTtcbiAgICAgIH0pLCBzZShTZShtKSwgXCJoYW5kbGVJdGVtTW91c2VFbnRlclwiLCBmdW5jdGlvbih5KSB7XG4gICAgICAgIG0uc2V0U3RhdGUoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGlzVG9vbHRpcEFjdGl2ZTogITAsXG4gICAgICAgICAgICBhY3RpdmVJdGVtOiB5LFxuICAgICAgICAgICAgYWN0aXZlUGF5bG9hZDogeS50b29sdGlwUGF5bG9hZCxcbiAgICAgICAgICAgIGFjdGl2ZUNvb3JkaW5hdGU6IHkudG9vbHRpcFBvc2l0aW9uIHx8IHtcbiAgICAgICAgICAgICAgeDogeS5jeCxcbiAgICAgICAgICAgICAgeTogeS5jeVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgICAgfSksIHNlKFNlKG0pLCBcImhhbmRsZUl0ZW1Nb3VzZUxlYXZlXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICBtLnNldFN0YXRlKGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBpc1Rvb2x0aXBBY3RpdmU6ICExXG4gICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgICB9KSwgc2UoU2UobSksIFwiaGFuZGxlTW91c2VNb3ZlXCIsIGZ1bmN0aW9uKHkpIHtcbiAgICAgICAgeS5wZXJzaXN0KCksIG0udGhyb3R0bGVUcmlnZ2VyZWRBZnRlck1vdXNlTW92ZSh5KTtcbiAgICAgIH0pLCBzZShTZShtKSwgXCJoYW5kbGVNb3VzZUxlYXZlXCIsIGZ1bmN0aW9uKHkpIHtcbiAgICAgICAgbS50aHJvdHRsZVRyaWdnZXJlZEFmdGVyTW91c2VNb3ZlLmNhbmNlbCgpO1xuICAgICAgICB2YXIgUyA9IHtcbiAgICAgICAgICBpc1Rvb2x0aXBBY3RpdmU6ICExXG4gICAgICAgIH07XG4gICAgICAgIG0uc2V0U3RhdGUoUyksIG0udHJpZ2dlclN5bmNFdmVudChTKTtcbiAgICAgICAgdmFyICQgPSBtLnByb3BzLm9uTW91c2VMZWF2ZTtcbiAgICAgICAgcGUoJCkgJiYgJChTLCB5KTtcbiAgICAgIH0pLCBzZShTZShtKSwgXCJoYW5kbGVPdXRlckV2ZW50XCIsIGZ1bmN0aW9uKHkpIHtcbiAgICAgICAgdmFyIFMgPSBpRSh5KSwgJCA9IGp0KG0ucHJvcHMsIFwiXCIuY29uY2F0KFMpKTtcbiAgICAgICAgaWYgKFMgJiYgcGUoJCkpIHtcbiAgICAgICAgICB2YXIgTywgVDtcbiAgICAgICAgICAvLip0b3VjaC4qL2kudGVzdChTKSA/IFQgPSBtLmdldE1vdXNlSW5mbyh5LmNoYW5nZWRUb3VjaGVzWzBdKSA6IFQgPSBtLmdldE1vdXNlSW5mbyh5KSwgJCgoTyA9IFQpICE9PSBudWxsICYmIE8gIT09IHZvaWQgMCA/IE8gOiB7fSwgeSk7XG4gICAgICAgIH1cbiAgICAgIH0pLCBzZShTZShtKSwgXCJoYW5kbGVDbGlja1wiLCBmdW5jdGlvbih5KSB7XG4gICAgICAgIHZhciBTID0gbS5nZXRNb3VzZUluZm8oeSk7XG4gICAgICAgIGlmIChTKSB7XG4gICAgICAgICAgdmFyICQgPSB6KHooe30sIFMpLCB7fSwge1xuICAgICAgICAgICAgaXNUb29sdGlwQWN0aXZlOiAhMFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIG0uc2V0U3RhdGUoJCksIG0udHJpZ2dlclN5bmNFdmVudCgkKTtcbiAgICAgICAgICB2YXIgTyA9IG0ucHJvcHMub25DbGljaztcbiAgICAgICAgICBwZShPKSAmJiBPKCQsIHkpO1xuICAgICAgICB9XG4gICAgICB9KSwgc2UoU2UobSksIFwiaGFuZGxlTW91c2VEb3duXCIsIGZ1bmN0aW9uKHkpIHtcbiAgICAgICAgdmFyIFMgPSBtLnByb3BzLm9uTW91c2VEb3duO1xuICAgICAgICBpZiAocGUoUykpIHtcbiAgICAgICAgICB2YXIgJCA9IG0uZ2V0TW91c2VJbmZvKHkpO1xuICAgICAgICAgIFMoJCwgeSk7XG4gICAgICAgIH1cbiAgICAgIH0pLCBzZShTZShtKSwgXCJoYW5kbGVNb3VzZVVwXCIsIGZ1bmN0aW9uKHkpIHtcbiAgICAgICAgdmFyIFMgPSBtLnByb3BzLm9uTW91c2VVcDtcbiAgICAgICAgaWYgKHBlKFMpKSB7XG4gICAgICAgICAgdmFyICQgPSBtLmdldE1vdXNlSW5mbyh5KTtcbiAgICAgICAgICBTKCQsIHkpO1xuICAgICAgICB9XG4gICAgICB9KSwgc2UoU2UobSksIFwiaGFuZGxlVG91Y2hNb3ZlXCIsIGZ1bmN0aW9uKHkpIHtcbiAgICAgICAgeS5jaGFuZ2VkVG91Y2hlcyAhPSBudWxsICYmIHkuY2hhbmdlZFRvdWNoZXMubGVuZ3RoID4gMCAmJiBtLnRocm90dGxlVHJpZ2dlcmVkQWZ0ZXJNb3VzZU1vdmUoeS5jaGFuZ2VkVG91Y2hlc1swXSk7XG4gICAgICB9KSwgc2UoU2UobSksIFwiaGFuZGxlVG91Y2hTdGFydFwiLCBmdW5jdGlvbih5KSB7XG4gICAgICAgIHkuY2hhbmdlZFRvdWNoZXMgIT0gbnVsbCAmJiB5LmNoYW5nZWRUb3VjaGVzLmxlbmd0aCA+IDAgJiYgbS5oYW5kbGVNb3VzZURvd24oeS5jaGFuZ2VkVG91Y2hlc1swXSk7XG4gICAgICB9KSwgc2UoU2UobSksIFwiaGFuZGxlVG91Y2hFbmRcIiwgZnVuY3Rpb24oeSkge1xuICAgICAgICB5LmNoYW5nZWRUb3VjaGVzICE9IG51bGwgJiYgeS5jaGFuZ2VkVG91Y2hlcy5sZW5ndGggPiAwICYmIG0uaGFuZGxlTW91c2VVcCh5LmNoYW5nZWRUb3VjaGVzWzBdKTtcbiAgICAgIH0pLCBzZShTZShtKSwgXCJ0cmlnZ2VyU3luY0V2ZW50XCIsIGZ1bmN0aW9uKHkpIHtcbiAgICAgICAgbS5wcm9wcy5zeW5jSWQgIT09IHZvaWQgMCAmJiBpYy5lbWl0KG9jLCBtLnByb3BzLnN5bmNJZCwgeSwgbS5ldmVudEVtaXR0ZXJTeW1ib2wpO1xuICAgICAgfSksIHNlKFNlKG0pLCBcImFwcGx5U3luY0V2ZW50XCIsIGZ1bmN0aW9uKHkpIHtcbiAgICAgICAgdmFyIFMgPSBtLnByb3BzLCAkID0gUy5sYXlvdXQsIE8gPSBTLnN5bmNNZXRob2QsIFQgPSBtLnN0YXRlLnVwZGF0ZUlkLCBNID0geS5kYXRhU3RhcnRJbmRleCwgRSA9IHkuZGF0YUVuZEluZGV4O1xuICAgICAgICBpZiAoeS5kYXRhU3RhcnRJbmRleCAhPT0gdm9pZCAwIHx8IHkuZGF0YUVuZEluZGV4ICE9PSB2b2lkIDApXG4gICAgICAgICAgbS5zZXRTdGF0ZSh6KHtcbiAgICAgICAgICAgIGRhdGFTdGFydEluZGV4OiBNLFxuICAgICAgICAgICAgZGF0YUVuZEluZGV4OiBFXG4gICAgICAgICAgfSwgZyh7XG4gICAgICAgICAgICBwcm9wczogbS5wcm9wcyxcbiAgICAgICAgICAgIGRhdGFTdGFydEluZGV4OiBNLFxuICAgICAgICAgICAgZGF0YUVuZEluZGV4OiBFLFxuICAgICAgICAgICAgdXBkYXRlSWQ6IFRcbiAgICAgICAgICB9LCBtLnN0YXRlKSkpO1xuICAgICAgICBlbHNlIGlmICh5LmFjdGl2ZVRvb2x0aXBJbmRleCAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgdmFyIEEgPSB5LmNoYXJ0WCwgaiA9IHkuY2hhcnRZLCBSID0geS5hY3RpdmVUb29sdGlwSW5kZXgsIE4gPSBtLnN0YXRlLCBrID0gTi5vZmZzZXQsIEYgPSBOLnRvb2x0aXBUaWNrcztcbiAgICAgICAgICBpZiAoIWspXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgaWYgKHR5cGVvZiBPID09IFwiZnVuY3Rpb25cIilcbiAgICAgICAgICAgIFIgPSBPKEYsIHkpO1xuICAgICAgICAgIGVsc2UgaWYgKE8gPT09IFwidmFsdWVcIikge1xuICAgICAgICAgICAgUiA9IC0xO1xuICAgICAgICAgICAgZm9yICh2YXIgViA9IDA7IFYgPCBGLmxlbmd0aDsgVisrKVxuICAgICAgICAgICAgICBpZiAoRltWXS52YWx1ZSA9PT0geS5hY3RpdmVMYWJlbCkge1xuICAgICAgICAgICAgICAgIFIgPSBWO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBMID0geih6KHt9LCBrKSwge30sIHtcbiAgICAgICAgICAgIHg6IGsubGVmdCxcbiAgICAgICAgICAgIHk6IGsudG9wXG4gICAgICAgICAgfSksIEkgPSBNYXRoLm1pbihBLCBMLnggKyBMLndpZHRoKSwgRCA9IE1hdGgubWluKGosIEwueSArIEwuaGVpZ2h0KSwgRyA9IEZbUl0gJiYgRltSXS52YWx1ZSwgcSA9IHFsKG0uc3RhdGUsIG0ucHJvcHMuZGF0YSwgUiksIEogPSBGW1JdID8ge1xuICAgICAgICAgICAgeDogJCA9PT0gXCJob3Jpem9udGFsXCIgPyBGW1JdLmNvb3JkaW5hdGUgOiBJLFxuICAgICAgICAgICAgeTogJCA9PT0gXCJob3Jpem9udGFsXCIgPyBEIDogRltSXS5jb29yZGluYXRlXG4gICAgICAgICAgfSA6IEJ3O1xuICAgICAgICAgIG0uc2V0U3RhdGUoeih6KHt9LCB5KSwge30sIHtcbiAgICAgICAgICAgIGFjdGl2ZUxhYmVsOiBHLFxuICAgICAgICAgICAgYWN0aXZlQ29vcmRpbmF0ZTogSixcbiAgICAgICAgICAgIGFjdGl2ZVBheWxvYWQ6IHEsXG4gICAgICAgICAgICBhY3RpdmVUb29sdGlwSW5kZXg6IFJcbiAgICAgICAgICB9KSk7XG4gICAgICAgIH0gZWxzZVxuICAgICAgICAgIG0uc2V0U3RhdGUoeSk7XG4gICAgICB9KSwgc2UoU2UobSksIFwicmVuZGVyQ3Vyc29yXCIsIGZ1bmN0aW9uKHkpIHtcbiAgICAgICAgdmFyIFMsICQgPSBtLnN0YXRlLCBPID0gJC5pc1Rvb2x0aXBBY3RpdmUsIFQgPSAkLmFjdGl2ZUNvb3JkaW5hdGUsIE0gPSAkLmFjdGl2ZVBheWxvYWQsIEUgPSAkLm9mZnNldCwgQSA9ICQuYWN0aXZlVG9vbHRpcEluZGV4LCBqID0gJC50b29sdGlwQXhpc0JhbmRTaXplLCBSID0gbS5nZXRUb29sdGlwRXZlbnRUeXBlKCksIE4gPSAoUyA9IHkucHJvcHMuYWN0aXZlKSAhPT0gbnVsbCAmJiBTICE9PSB2b2lkIDAgPyBTIDogTywgayA9IG0ucHJvcHMubGF5b3V0LCBGID0geS5rZXkgfHwgXCJfcmVjaGFydHMtY3Vyc29yXCI7XG4gICAgICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8gUC5jcmVhdGVFbGVtZW50KHlXLCB7XG4gICAgICAgICAga2V5OiBGLFxuICAgICAgICAgIGFjdGl2ZUNvb3JkaW5hdGU6IFQsXG4gICAgICAgICAgYWN0aXZlUGF5bG9hZDogTSxcbiAgICAgICAgICBhY3RpdmVUb29sdGlwSW5kZXg6IEEsXG4gICAgICAgICAgY2hhcnROYW1lOiByLFxuICAgICAgICAgIGVsZW1lbnQ6IHksXG4gICAgICAgICAgaXNBY3RpdmU6IE4sXG4gICAgICAgICAgbGF5b3V0OiBrLFxuICAgICAgICAgIG9mZnNldDogRSxcbiAgICAgICAgICB0b29sdGlwQXhpc0JhbmRTaXplOiBqLFxuICAgICAgICAgIHRvb2x0aXBFdmVudFR5cGU6IFJcbiAgICAgICAgfSk7XG4gICAgICB9KSwgc2UoU2UobSksIFwicmVuZGVyUG9sYXJBeGlzXCIsIGZ1bmN0aW9uKHksIFMsICQpIHtcbiAgICAgICAgdmFyIE8gPSBqdCh5LCBcInR5cGUuYXhpc1R5cGVcIiksIFQgPSBqdChtLnN0YXRlLCBcIlwiLmNvbmNhdChPLCBcIk1hcFwiKSksIE0gPSBUICYmIFRbeS5wcm9wc1tcIlwiLmNvbmNhdChPLCBcIklkXCIpXV07XG4gICAgICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8gR2UoeSwgeih6KHt9LCBNKSwge30sIHtcbiAgICAgICAgICBjbGFzc05hbWU6ICRlKE8sIE0uY2xhc3NOYW1lKSxcbiAgICAgICAgICBrZXk6IHkua2V5IHx8IFwiXCIuY29uY2F0KFMsIFwiLVwiKS5jb25jYXQoJCksXG4gICAgICAgICAgdGlja3M6IG1uKE0sICEwKVxuICAgICAgICB9KSk7XG4gICAgICB9KSwgc2UoU2UobSksIFwicmVuZGVyUG9sYXJHcmlkXCIsIGZ1bmN0aW9uKHkpIHtcbiAgICAgICAgdmFyIFMgPSB5LnByb3BzLCAkID0gUy5yYWRpYWxMaW5lcywgTyA9IFMucG9sYXJBbmdsZXMsIFQgPSBTLnBvbGFyUmFkaXVzLCBNID0gbS5zdGF0ZSwgRSA9IE0ucmFkaXVzQXhpc01hcCwgQSA9IE0uYW5nbGVBeGlzTWFwLCBqID0ga24oRSksIFIgPSBrbihBKSwgTiA9IFIuY3gsIGsgPSBSLmN5LCBGID0gUi5pbm5lclJhZGl1cywgViA9IFIub3V0ZXJSYWRpdXM7XG4gICAgICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8gR2UoeSwge1xuICAgICAgICAgIHBvbGFyQW5nbGVzOiBBcnJheS5pc0FycmF5KE8pID8gTyA6IG1uKFIsICEwKS5tYXAoZnVuY3Rpb24oTCkge1xuICAgICAgICAgICAgcmV0dXJuIEwuY29vcmRpbmF0ZTtcbiAgICAgICAgICB9KSxcbiAgICAgICAgICBwb2xhclJhZGl1czogQXJyYXkuaXNBcnJheShUKSA/IFQgOiBtbihqLCAhMCkubWFwKGZ1bmN0aW9uKEwpIHtcbiAgICAgICAgICAgIHJldHVybiBMLmNvb3JkaW5hdGU7XG4gICAgICAgICAgfSksXG4gICAgICAgICAgY3g6IE4sXG4gICAgICAgICAgY3k6IGssXG4gICAgICAgICAgaW5uZXJSYWRpdXM6IEYsXG4gICAgICAgICAgb3V0ZXJSYWRpdXM6IFYsXG4gICAgICAgICAga2V5OiB5LmtleSB8fCBcInBvbGFyLWdyaWRcIixcbiAgICAgICAgICByYWRpYWxMaW5lczogJFxuICAgICAgICB9KTtcbiAgICAgIH0pLCBzZShTZShtKSwgXCJyZW5kZXJMZWdlbmRcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciB5ID0gbS5zdGF0ZS5mb3JtYXR0ZWRHcmFwaGljYWxJdGVtcywgUyA9IG0ucHJvcHMsICQgPSBTLmNoaWxkcmVuLCBPID0gUy53aWR0aCwgVCA9IFMuaGVpZ2h0LCBNID0gbS5wcm9wcy5tYXJnaW4gfHwge30sIEUgPSBPIC0gKE0ubGVmdCB8fCAwKSAtIChNLnJpZ2h0IHx8IDApLCBBID0gVjAoe1xuICAgICAgICAgIGNoaWxkcmVuOiAkLFxuICAgICAgICAgIGZvcm1hdHRlZEdyYXBoaWNhbEl0ZW1zOiB5LFxuICAgICAgICAgIGxlZ2VuZFdpZHRoOiBFLFxuICAgICAgICAgIGxlZ2VuZENvbnRlbnQ6IGZcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICghQSlcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgdmFyIGogPSBBLml0ZW0sIFIgPSBlbShBLCBiVyk7XG4gICAgICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8gR2Uoaiwgeih6KHt9LCBSKSwge30sIHtcbiAgICAgICAgICBjaGFydFdpZHRoOiBPLFxuICAgICAgICAgIGNoYXJ0SGVpZ2h0OiBULFxuICAgICAgICAgIG1hcmdpbjogTSxcbiAgICAgICAgICBvbkJCb3hVcGRhdGU6IG0uaGFuZGxlTGVnZW5kQkJveFVwZGF0ZVxuICAgICAgICB9KSk7XG4gICAgICB9KSwgc2UoU2UobSksIFwicmVuZGVyVG9vbHRpcFwiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHksIFMgPSBtLnByb3BzLCAkID0gUy5jaGlsZHJlbiwgTyA9IFMuYWNjZXNzaWJpbGl0eUxheWVyLCBUID0gd3QoJCwgdG4pO1xuICAgICAgICBpZiAoIVQpXG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIHZhciBNID0gbS5zdGF0ZSwgRSA9IE0uaXNUb29sdGlwQWN0aXZlLCBBID0gTS5hY3RpdmVDb29yZGluYXRlLCBqID0gTS5hY3RpdmVQYXlsb2FkLCBSID0gTS5hY3RpdmVMYWJlbCwgTiA9IE0ub2Zmc2V0LCBrID0gKHkgPSBULnByb3BzLmFjdGl2ZSkgIT09IG51bGwgJiYgeSAhPT0gdm9pZCAwID8geSA6IEU7XG4gICAgICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8gR2UoVCwge1xuICAgICAgICAgIHZpZXdCb3g6IHooeih7fSwgTiksIHt9LCB7XG4gICAgICAgICAgICB4OiBOLmxlZnQsXG4gICAgICAgICAgICB5OiBOLnRvcFxuICAgICAgICAgIH0pLFxuICAgICAgICAgIGFjdGl2ZTogayxcbiAgICAgICAgICBsYWJlbDogUixcbiAgICAgICAgICBwYXlsb2FkOiBrID8gaiA6IFtdLFxuICAgICAgICAgIGNvb3JkaW5hdGU6IEEsXG4gICAgICAgICAgYWNjZXNzaWJpbGl0eUxheWVyOiBPXG4gICAgICAgIH0pO1xuICAgICAgfSksIHNlKFNlKG0pLCBcInJlbmRlckJydXNoXCIsIGZ1bmN0aW9uKHkpIHtcbiAgICAgICAgdmFyIFMgPSBtLnByb3BzLCAkID0gUy5tYXJnaW4sIE8gPSBTLmRhdGEsIFQgPSBtLnN0YXRlLCBNID0gVC5vZmZzZXQsIEUgPSBULmRhdGFTdGFydEluZGV4LCBBID0gVC5kYXRhRW5kSW5kZXgsIGogPSBULnVwZGF0ZUlkO1xuICAgICAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIEdlKHksIHtcbiAgICAgICAgICBrZXk6IHkua2V5IHx8IFwiX3JlY2hhcnRzLWJydXNoXCIsXG4gICAgICAgICAgb25DaGFuZ2U6IG1hKG0uaGFuZGxlQnJ1c2hDaGFuZ2UsIHkucHJvcHMub25DaGFuZ2UpLFxuICAgICAgICAgIGRhdGE6IE8sXG4gICAgICAgICAgeDogSyh5LnByb3BzLngpID8geS5wcm9wcy54IDogTS5sZWZ0LFxuICAgICAgICAgIHk6IEsoeS5wcm9wcy55KSA/IHkucHJvcHMueSA6IE0udG9wICsgTS5oZWlnaHQgKyBNLmJydXNoQm90dG9tIC0gKCQuYm90dG9tIHx8IDApLFxuICAgICAgICAgIHdpZHRoOiBLKHkucHJvcHMud2lkdGgpID8geS5wcm9wcy53aWR0aCA6IE0ud2lkdGgsXG4gICAgICAgICAgc3RhcnRJbmRleDogRSxcbiAgICAgICAgICBlbmRJbmRleDogQSxcbiAgICAgICAgICB1cGRhdGVJZDogXCJicnVzaC1cIi5jb25jYXQoailcbiAgICAgICAgfSk7XG4gICAgICB9KSwgc2UoU2UobSksIFwicmVuZGVyUmVmZXJlbmNlRWxlbWVudFwiLCBmdW5jdGlvbih5LCBTLCAkKSB7XG4gICAgICAgIGlmICgheSlcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgdmFyIE8gPSBTZShtKSwgVCA9IE8uY2xpcFBhdGhJZCwgTSA9IG0uc3RhdGUsIEUgPSBNLnhBeGlzTWFwLCBBID0gTS55QXhpc01hcCwgaiA9IE0ub2Zmc2V0LCBSID0geS5wcm9wcywgTiA9IFIueEF4aXNJZCwgayA9IFIueUF4aXNJZDtcbiAgICAgICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBHZSh5LCB7XG4gICAgICAgICAga2V5OiB5LmtleSB8fCBcIlwiLmNvbmNhdChTLCBcIi1cIikuY29uY2F0KCQpLFxuICAgICAgICAgIHhBeGlzOiBFW05dLFxuICAgICAgICAgIHlBeGlzOiBBW2tdLFxuICAgICAgICAgIHZpZXdCb3g6IHtcbiAgICAgICAgICAgIHg6IGoubGVmdCxcbiAgICAgICAgICAgIHk6IGoudG9wLFxuICAgICAgICAgICAgd2lkdGg6IGoud2lkdGgsXG4gICAgICAgICAgICBoZWlnaHQ6IGouaGVpZ2h0XG4gICAgICAgICAgfSxcbiAgICAgICAgICBjbGlwUGF0aElkOiBUXG4gICAgICAgIH0pO1xuICAgICAgfSksIHNlKFNlKG0pLCBcInJlbmRlckFjdGl2ZVBvaW50c1wiLCBmdW5jdGlvbih5KSB7XG4gICAgICAgIHZhciBTID0geS5pdGVtLCAkID0geS5hY3RpdmVQb2ludCwgTyA9IHkuYmFzZVBvaW50LCBUID0geS5jaGlsZEluZGV4LCBNID0geS5pc1JhbmdlLCBFID0gW10sIEEgPSBTLnByb3BzLmtleSwgaiA9IFMuaXRlbS5wcm9wcywgUiA9IGouYWN0aXZlRG90LCBOID0gai5kYXRhS2V5LCBrID0geih6KHtcbiAgICAgICAgICBpbmRleDogVCxcbiAgICAgICAgICBkYXRhS2V5OiBOLFxuICAgICAgICAgIGN4OiAkLngsXG4gICAgICAgICAgY3k6ICQueSxcbiAgICAgICAgICByOiA0LFxuICAgICAgICAgIGZpbGw6IGxkKFMuaXRlbSksXG4gICAgICAgICAgc3Ryb2tlV2lkdGg6IDIsXG4gICAgICAgICAgc3Ryb2tlOiBcIiNmZmZcIixcbiAgICAgICAgICBwYXlsb2FkOiAkLnBheWxvYWQsXG4gICAgICAgICAgdmFsdWU6ICQudmFsdWUsXG4gICAgICAgICAga2V5OiBcIlwiLmNvbmNhdChBLCBcIi1hY3RpdmVQb2ludC1cIikuY29uY2F0KFQpXG4gICAgICAgIH0sIHllKFIsICExKSksIE5hKFIpKTtcbiAgICAgICAgcmV0dXJuIEUucHVzaCh2LnJlbmRlckFjdGl2ZURvdChSLCBrKSksIE8gPyBFLnB1c2godi5yZW5kZXJBY3RpdmVEb3QoUiwgeih6KHt9LCBrKSwge30sIHtcbiAgICAgICAgICBjeDogTy54LFxuICAgICAgICAgIGN5OiBPLnksXG4gICAgICAgICAga2V5OiBcIlwiLmNvbmNhdChBLCBcIi1iYXNlUG9pbnQtXCIpLmNvbmNhdChUKVxuICAgICAgICB9KSkpIDogTSAmJiBFLnB1c2gobnVsbCksIEU7XG4gICAgICB9KSwgc2UoU2UobSksIFwicmVuZGVyR3JhcGhpY0NoaWxkXCIsIGZ1bmN0aW9uKHksIFMsICQpIHtcbiAgICAgICAgdmFyIE8gPSBtLmZpbHRlckZvcm1hdEl0ZW0oeSwgUywgJCk7XG4gICAgICAgIGlmICghTylcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgdmFyIFQgPSBtLmdldFRvb2x0aXBFdmVudFR5cGUoKSwgTSA9IG0uc3RhdGUsIEUgPSBNLmlzVG9vbHRpcEFjdGl2ZSwgQSA9IE0udG9vbHRpcEF4aXMsIGogPSBNLmFjdGl2ZVRvb2x0aXBJbmRleCwgUiA9IE0uYWN0aXZlTGFiZWwsIE4gPSBtLnByb3BzLmNoaWxkcmVuLCBrID0gd3QoTiwgdG4pLCBGID0gTy5wcm9wcywgViA9IEYucG9pbnRzLCBMID0gRi5pc1JhbmdlLCBJID0gRi5iYXNlTGluZSwgRCA9IE8uaXRlbS5wcm9wcywgRyA9IEQuYWN0aXZlRG90LCBxID0gRC5oaWRlLCBKID0gRC5hY3RpdmVCYXIsIG5lID0gRC5hY3RpdmVTaGFwZSwgdGUgPSAhISghcSAmJiBFICYmIGsgJiYgKEcgfHwgSiB8fCBuZSkpLCBlZSA9IHt9O1xuICAgICAgICBUICE9PSBcImF4aXNcIiAmJiBrICYmIGsucHJvcHMudHJpZ2dlciA9PT0gXCJjbGlja1wiID8gZWUgPSB7XG4gICAgICAgICAgb25DbGljazogbWEobS5oYW5kbGVJdGVtTW91c2VFbnRlciwgeS5wcm9wcy5vbkNsaWNrKVxuICAgICAgICB9IDogVCAhPT0gXCJheGlzXCIgJiYgKGVlID0ge1xuICAgICAgICAgIG9uTW91c2VMZWF2ZTogbWEobS5oYW5kbGVJdGVtTW91c2VMZWF2ZSwgeS5wcm9wcy5vbk1vdXNlTGVhdmUpLFxuICAgICAgICAgIG9uTW91c2VFbnRlcjogbWEobS5oYW5kbGVJdGVtTW91c2VFbnRlciwgeS5wcm9wcy5vbk1vdXNlRW50ZXIpXG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgaWUgPSAvKiBAX19QVVJFX18gKi8gR2UoeSwgeih6KHt9LCBPLnByb3BzKSwgZWUpKTtcbiAgICAgICAgZnVuY3Rpb24gQihydCkge1xuICAgICAgICAgIHJldHVybiB0eXBlb2YgQS5kYXRhS2V5ID09IFwiZnVuY3Rpb25cIiA/IEEuZGF0YUtleShydC5wYXlsb2FkKSA6IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRlKVxuICAgICAgICAgIGlmIChqID49IDApIHtcbiAgICAgICAgICAgIHZhciBVLCByZTtcbiAgICAgICAgICAgIGlmIChBLmRhdGFLZXkgJiYgIUEuYWxsb3dEdXBsaWNhdGVkQ2F0ZWdvcnkpIHtcbiAgICAgICAgICAgICAgdmFyIEMgPSB0eXBlb2YgQS5kYXRhS2V5ID09IFwiZnVuY3Rpb25cIiA/IEIgOiBcInBheWxvYWQuXCIuY29uY2F0KEEuZGF0YUtleS50b1N0cmluZygpKTtcbiAgICAgICAgICAgICAgVSA9IERhKFYsIEMsIFIpLCByZSA9IEwgJiYgSSAmJiBEYShJLCBDLCBSKTtcbiAgICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgICBVID0gViA9PSBudWxsID8gdm9pZCAwIDogVltqXSwgcmUgPSBMICYmIEkgJiYgSVtqXTtcbiAgICAgICAgICAgIGlmIChuZSB8fCBKKSB7XG4gICAgICAgICAgICAgIHZhciBnZSA9IHkucHJvcHMuYWN0aXZlSW5kZXggIT09IHZvaWQgMCA/IHkucHJvcHMuYWN0aXZlSW5kZXggOiBqO1xuICAgICAgICAgICAgICByZXR1cm4gWy8qIEBfX1BVUkVfXyAqLyBHZSh5LCB6KHooeih7fSwgTy5wcm9wcyksIGVlKSwge30sIHtcbiAgICAgICAgICAgICAgICBhY3RpdmVJbmRleDogZ2VcbiAgICAgICAgICAgICAgfSkpLCBudWxsLCBudWxsXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghbWUoVSkpXG4gICAgICAgICAgICAgIHJldHVybiBbaWVdLmNvbmNhdChyaShtLnJlbmRlckFjdGl2ZVBvaW50cyh7XG4gICAgICAgICAgICAgICAgaXRlbTogTyxcbiAgICAgICAgICAgICAgICBhY3RpdmVQb2ludDogVSxcbiAgICAgICAgICAgICAgICBiYXNlUG9pbnQ6IHJlLFxuICAgICAgICAgICAgICAgIGNoaWxkSW5kZXg6IGosXG4gICAgICAgICAgICAgICAgaXNSYW5nZTogTFxuICAgICAgICAgICAgICB9KSkpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgbGUsIHhlID0gKGxlID0gbS5nZXRJdGVtQnlYWShtLnN0YXRlLmFjdGl2ZUNvb3JkaW5hdGUpKSAhPT0gbnVsbCAmJiBsZSAhPT0gdm9pZCAwID8gbGUgOiB7XG4gICAgICAgICAgICAgIGdyYXBoaWNhbEl0ZW06IGllXG4gICAgICAgICAgICB9LCBFZSA9IHhlLmdyYXBoaWNhbEl0ZW0sIFplID0gRWUuaXRlbSwgZHQgPSBaZSA9PT0gdm9pZCAwID8geSA6IFplLCB6dCA9IEVlLmNoaWxkSW5kZXgsIFZ0ID0geih6KHooe30sIE8ucHJvcHMpLCBlZSksIHt9LCB7XG4gICAgICAgICAgICAgIGFjdGl2ZUluZGV4OiB6dFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gWy8qIEBfX1BVUkVfXyAqLyBHZShkdCwgVnQpLCBudWxsLCBudWxsXTtcbiAgICAgICAgICB9XG4gICAgICAgIHJldHVybiBMID8gW2llLCBudWxsLCBudWxsXSA6IFtpZSwgbnVsbF07XG4gICAgICB9KSwgc2UoU2UobSksIFwicmVuZGVyQ3VzdG9taXplZFwiLCBmdW5jdGlvbih5LCBTLCAkKSB7XG4gICAgICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8gR2UoeSwgeih6KHtcbiAgICAgICAgICBrZXk6IFwicmVjaGFydHMtY3VzdG9taXplZC1cIi5jb25jYXQoJClcbiAgICAgICAgfSwgbS5wcm9wcyksIG0uc3RhdGUpKTtcbiAgICAgIH0pLCBzZShTZShtKSwgXCJyZW5kZXJNYXBcIiwge1xuICAgICAgICBDYXJ0ZXNpYW5HcmlkOiB7XG4gICAgICAgICAgaGFuZGxlcjogU2EsXG4gICAgICAgICAgb25jZTogITBcbiAgICAgICAgfSxcbiAgICAgICAgUmVmZXJlbmNlQXJlYToge1xuICAgICAgICAgIGhhbmRsZXI6IG0ucmVuZGVyUmVmZXJlbmNlRWxlbWVudFxuICAgICAgICB9LFxuICAgICAgICBSZWZlcmVuY2VMaW5lOiB7XG4gICAgICAgICAgaGFuZGxlcjogU2FcbiAgICAgICAgfSxcbiAgICAgICAgUmVmZXJlbmNlRG90OiB7XG4gICAgICAgICAgaGFuZGxlcjogbS5yZW5kZXJSZWZlcmVuY2VFbGVtZW50XG4gICAgICAgIH0sXG4gICAgICAgIFhBeGlzOiB7XG4gICAgICAgICAgaGFuZGxlcjogU2FcbiAgICAgICAgfSxcbiAgICAgICAgWUF4aXM6IHtcbiAgICAgICAgICBoYW5kbGVyOiBTYVxuICAgICAgICB9LFxuICAgICAgICBCcnVzaDoge1xuICAgICAgICAgIGhhbmRsZXI6IG0ucmVuZGVyQnJ1c2gsXG4gICAgICAgICAgb25jZTogITBcbiAgICAgICAgfSxcbiAgICAgICAgQmFyOiB7XG4gICAgICAgICAgaGFuZGxlcjogbS5yZW5kZXJHcmFwaGljQ2hpbGRcbiAgICAgICAgfSxcbiAgICAgICAgTGluZToge1xuICAgICAgICAgIGhhbmRsZXI6IG0ucmVuZGVyR3JhcGhpY0NoaWxkXG4gICAgICAgIH0sXG4gICAgICAgIEFyZWE6IHtcbiAgICAgICAgICBoYW5kbGVyOiBtLnJlbmRlckdyYXBoaWNDaGlsZFxuICAgICAgICB9LFxuICAgICAgICBSYWRhcjoge1xuICAgICAgICAgIGhhbmRsZXI6IG0ucmVuZGVyR3JhcGhpY0NoaWxkXG4gICAgICAgIH0sXG4gICAgICAgIFJhZGlhbEJhcjoge1xuICAgICAgICAgIGhhbmRsZXI6IG0ucmVuZGVyR3JhcGhpY0NoaWxkXG4gICAgICAgIH0sXG4gICAgICAgIFNjYXR0ZXI6IHtcbiAgICAgICAgICBoYW5kbGVyOiBtLnJlbmRlckdyYXBoaWNDaGlsZFxuICAgICAgICB9LFxuICAgICAgICBQaWU6IHtcbiAgICAgICAgICBoYW5kbGVyOiBtLnJlbmRlckdyYXBoaWNDaGlsZFxuICAgICAgICB9LFxuICAgICAgICBGdW5uZWw6IHtcbiAgICAgICAgICBoYW5kbGVyOiBtLnJlbmRlckdyYXBoaWNDaGlsZFxuICAgICAgICB9LFxuICAgICAgICBUb29sdGlwOiB7XG4gICAgICAgICAgaGFuZGxlcjogbS5yZW5kZXJDdXJzb3IsXG4gICAgICAgICAgb25jZTogITBcbiAgICAgICAgfSxcbiAgICAgICAgUG9sYXJHcmlkOiB7XG4gICAgICAgICAgaGFuZGxlcjogbS5yZW5kZXJQb2xhckdyaWQsXG4gICAgICAgICAgb25jZTogITBcbiAgICAgICAgfSxcbiAgICAgICAgUG9sYXJBbmdsZUF4aXM6IHtcbiAgICAgICAgICBoYW5kbGVyOiBtLnJlbmRlclBvbGFyQXhpc1xuICAgICAgICB9LFxuICAgICAgICBQb2xhclJhZGl1c0F4aXM6IHtcbiAgICAgICAgICBoYW5kbGVyOiBtLnJlbmRlclBvbGFyQXhpc1xuICAgICAgICB9LFxuICAgICAgICBDdXN0b21pemVkOiB7XG4gICAgICAgICAgaGFuZGxlcjogbS5yZW5kZXJDdXN0b21pemVkXG4gICAgICAgIH1cbiAgICAgIH0pLCBtLmNsaXBQYXRoSWQgPSBcIlwiLmNvbmNhdCgoYiA9IHcuaWQpICE9PSBudWxsICYmIGIgIT09IHZvaWQgMCA/IGIgOiBVbyhcInJlY2hhcnRzXCIpLCBcIi1jbGlwXCIpLCBtLnRocm90dGxlVHJpZ2dlcmVkQWZ0ZXJNb3VzZU1vdmUgPSB2RihtLnRyaWdnZXJlZEFmdGVyTW91c2VNb3ZlLCAoeCA9IHcudGhyb3R0bGVEZWxheSkgIT09IG51bGwgJiYgeCAhPT0gdm9pZCAwID8geCA6IDFlMyAvIDYwKSwgbS5zdGF0ZSA9IHt9LCBtO1xuICAgIH1cbiAgICByZXR1cm4gUFcodiwgW3tcbiAgICAgIGtleTogXCJjb21wb25lbnREaWRNb3VudFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgYiwgeDtcbiAgICAgICAgdGhpcy5hZGRMaXN0ZW5lcigpLCB0aGlzLmFjY2Vzc2liaWxpdHlNYW5hZ2VyLnNldERldGFpbHMoe1xuICAgICAgICAgIGNvbnRhaW5lcjogdGhpcy5jb250YWluZXIsXG4gICAgICAgICAgb2Zmc2V0OiB7XG4gICAgICAgICAgICBsZWZ0OiAoYiA9IHRoaXMucHJvcHMubWFyZ2luLmxlZnQpICE9PSBudWxsICYmIGIgIT09IHZvaWQgMCA/IGIgOiAwLFxuICAgICAgICAgICAgdG9wOiAoeCA9IHRoaXMucHJvcHMubWFyZ2luLnRvcCkgIT09IG51bGwgJiYgeCAhPT0gdm9pZCAwID8geCA6IDBcbiAgICAgICAgICB9LFxuICAgICAgICAgIGNvb3JkaW5hdGVMaXN0OiB0aGlzLnN0YXRlLnRvb2x0aXBUaWNrcyxcbiAgICAgICAgICBtb3VzZUhhbmRsZXJDYWxsYmFjazogdGhpcy50cmlnZ2VyZWRBZnRlck1vdXNlTW92ZSxcbiAgICAgICAgICBsYXlvdXQ6IHRoaXMucHJvcHMubGF5b3V0XG4gICAgICAgIH0pLCB0aGlzLmRpc3BsYXlEZWZhdWx0VG9vbHRpcCgpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJkaXNwbGF5RGVmYXVsdFRvb2x0aXBcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGIgPSB0aGlzLnByb3BzLCB4ID0gYi5jaGlsZHJlbiwgbSA9IGIuZGF0YSwgeSA9IGIuaGVpZ2h0LCBTID0gYi5sYXlvdXQsICQgPSB3dCh4LCB0bik7XG4gICAgICAgIGlmICgkKSB7XG4gICAgICAgICAgdmFyIE8gPSAkLnByb3BzLmRlZmF1bHRJbmRleDtcbiAgICAgICAgICBpZiAoISh0eXBlb2YgTyAhPSBcIm51bWJlclwiIHx8IE8gPCAwIHx8IE8gPiB0aGlzLnN0YXRlLnRvb2x0aXBUaWNrcy5sZW5ndGgpKSB7XG4gICAgICAgICAgICB2YXIgVCA9IHRoaXMuc3RhdGUudG9vbHRpcFRpY2tzW09dICYmIHRoaXMuc3RhdGUudG9vbHRpcFRpY2tzW09dLnZhbHVlLCBNID0gcWwodGhpcy5zdGF0ZSwgbSwgTywgVCksIEUgPSB0aGlzLnN0YXRlLnRvb2x0aXBUaWNrc1tPXS5jb29yZGluYXRlLCBBID0gKHRoaXMuc3RhdGUub2Zmc2V0LnRvcCArIHkpIC8gMiwgaiA9IFMgPT09IFwiaG9yaXpvbnRhbFwiLCBSID0gaiA/IHtcbiAgICAgICAgICAgICAgeDogRSxcbiAgICAgICAgICAgICAgeTogQVxuICAgICAgICAgICAgfSA6IHtcbiAgICAgICAgICAgICAgeTogRSxcbiAgICAgICAgICAgICAgeDogQVxuICAgICAgICAgICAgfSwgTiA9IHRoaXMuc3RhdGUuZm9ybWF0dGVkR3JhcGhpY2FsSXRlbXMuZmluZChmdW5jdGlvbihGKSB7XG4gICAgICAgICAgICAgIHZhciBWID0gRi5pdGVtO1xuICAgICAgICAgICAgICByZXR1cm4gVi50eXBlLm5hbWUgPT09IFwiU2NhdHRlclwiO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBOICYmIChSID0geih6KHt9LCBSKSwgTi5wcm9wcy5wb2ludHNbT10udG9vbHRpcFBvc2l0aW9uKSwgTSA9IE4ucHJvcHMucG9pbnRzW09dLnRvb2x0aXBQYXlsb2FkKTtcbiAgICAgICAgICAgIHZhciBrID0ge1xuICAgICAgICAgICAgICBhY3RpdmVUb29sdGlwSW5kZXg6IE8sXG4gICAgICAgICAgICAgIGlzVG9vbHRpcEFjdGl2ZTogITAsXG4gICAgICAgICAgICAgIGFjdGl2ZUxhYmVsOiBULFxuICAgICAgICAgICAgICBhY3RpdmVQYXlsb2FkOiBNLFxuICAgICAgICAgICAgICBhY3RpdmVDb29yZGluYXRlOiBSXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZShrKSwgdGhpcy5yZW5kZXJDdXJzb3IoJCksIHRoaXMuYWNjZXNzaWJpbGl0eU1hbmFnZXIuc2V0SW5kZXgoTyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImdldFNuYXBzaG90QmVmb3JlVXBkYXRlXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24oYiwgeCkge1xuICAgICAgICBpZiAoIXRoaXMucHJvcHMuYWNjZXNzaWJpbGl0eUxheWVyKVxuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBpZiAodGhpcy5zdGF0ZS50b29sdGlwVGlja3MgIT09IHgudG9vbHRpcFRpY2tzICYmIHRoaXMuYWNjZXNzaWJpbGl0eU1hbmFnZXIuc2V0RGV0YWlscyh7XG4gICAgICAgICAgY29vcmRpbmF0ZUxpc3Q6IHRoaXMuc3RhdGUudG9vbHRpcFRpY2tzXG4gICAgICAgIH0pLCB0aGlzLnByb3BzLmxheW91dCAhPT0gYi5sYXlvdXQgJiYgdGhpcy5hY2Nlc3NpYmlsaXR5TWFuYWdlci5zZXREZXRhaWxzKHtcbiAgICAgICAgICBsYXlvdXQ6IHRoaXMucHJvcHMubGF5b3V0XG4gICAgICAgIH0pLCB0aGlzLnByb3BzLm1hcmdpbiAhPT0gYi5tYXJnaW4pIHtcbiAgICAgICAgICB2YXIgbSwgeTtcbiAgICAgICAgICB0aGlzLmFjY2Vzc2liaWxpdHlNYW5hZ2VyLnNldERldGFpbHMoe1xuICAgICAgICAgICAgb2Zmc2V0OiB7XG4gICAgICAgICAgICAgIGxlZnQ6IChtID0gdGhpcy5wcm9wcy5tYXJnaW4ubGVmdCkgIT09IG51bGwgJiYgbSAhPT0gdm9pZCAwID8gbSA6IDAsXG4gICAgICAgICAgICAgIHRvcDogKHkgPSB0aGlzLnByb3BzLm1hcmdpbi50b3ApICE9PSBudWxsICYmIHkgIT09IHZvaWQgMCA/IHkgOiAwXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImNvbXBvbmVudERpZFVwZGF0ZVwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uKGIpIHtcbiAgICAgICAgRWMoW3d0KGIuY2hpbGRyZW4sIHRuKV0sIFt3dCh0aGlzLnByb3BzLmNoaWxkcmVuLCB0bildKSB8fCB0aGlzLmRpc3BsYXlEZWZhdWx0VG9vbHRpcCgpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJjb21wb25lbnRXaWxsVW5tb3VudFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKCksIHRoaXMudGhyb3R0bGVUcmlnZ2VyZWRBZnRlck1vdXNlTW92ZS5jYW5jZWwoKTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiZ2V0VG9vbHRpcEV2ZW50VHlwZVwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgYiA9IHd0KHRoaXMucHJvcHMuY2hpbGRyZW4sIHRuKTtcbiAgICAgICAgaWYgKGIgJiYgdHlwZW9mIGIucHJvcHMuc2hhcmVkID09IFwiYm9vbGVhblwiKSB7XG4gICAgICAgICAgdmFyIHggPSBiLnByb3BzLnNoYXJlZCA/IFwiYXhpc1wiIDogXCJpdGVtXCI7XG4gICAgICAgICAgcmV0dXJuIHUuaW5kZXhPZih4KSA+PSAwID8geCA6IGE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGE7XG4gICAgICB9XG4gICAgICAvKipcbiAgICAgICAqIEdldCB0aGUgaW5mb3JtYXRpb24gb2YgbW91c2UgaW4gY2hhcnQsIHJldHVybiBudWxsIHdoZW4gdGhlIG1vdXNlIGlzIG5vdCBpbiB0aGUgY2hhcnRcbiAgICAgICAqIEBwYXJhbSAge01vdXNlUG9pbnRlcn0gZXZlbnQgICAgVGhlIGV2ZW50IG9iamVjdFxuICAgICAgICogQHJldHVybiB7T2JqZWN0fSAgICAgICAgICBNb3VzZSBkYXRhXG4gICAgICAgKi9cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiZ2V0TW91c2VJbmZvXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24oYikge1xuICAgICAgICBpZiAoIXRoaXMuY29udGFpbmVyKVxuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB2YXIgeCA9IHRoaXMuY29udGFpbmVyLCBtID0geC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSwgeSA9ICRGKG0pLCBTID0ge1xuICAgICAgICAgIGNoYXJ0WDogTWF0aC5yb3VuZChiLnBhZ2VYIC0geS5sZWZ0KSxcbiAgICAgICAgICBjaGFydFk6IE1hdGgucm91bmQoYi5wYWdlWSAtIHkudG9wKVxuICAgICAgICB9LCAkID0gbS53aWR0aCAvIHgub2Zmc2V0V2lkdGggfHwgMSwgTyA9IHRoaXMuaW5SYW5nZShTLmNoYXJ0WCwgUy5jaGFydFksICQpO1xuICAgICAgICBpZiAoIU8pXG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIHZhciBUID0gdGhpcy5zdGF0ZSwgTSA9IFQueEF4aXNNYXAsIEUgPSBULnlBeGlzTWFwLCBBID0gdGhpcy5nZXRUb29sdGlwRXZlbnRUeXBlKCk7XG4gICAgICAgIGlmIChBICE9PSBcImF4aXNcIiAmJiBNICYmIEUpIHtcbiAgICAgICAgICB2YXIgaiA9IGtuKE0pLnNjYWxlLCBSID0ga24oRSkuc2NhbGUsIE4gPSBqICYmIGouaW52ZXJ0ID8gai5pbnZlcnQoUy5jaGFydFgpIDogbnVsbCwgayA9IFIgJiYgUi5pbnZlcnQgPyBSLmludmVydChTLmNoYXJ0WSkgOiBudWxsO1xuICAgICAgICAgIHJldHVybiB6KHooe30sIFMpLCB7fSwge1xuICAgICAgICAgICAgeFZhbHVlOiBOLFxuICAgICAgICAgICAgeVZhbHVlOiBrXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIEYgPSBubSh0aGlzLnN0YXRlLCB0aGlzLnByb3BzLmRhdGEsIHRoaXMucHJvcHMubGF5b3V0LCBPKTtcbiAgICAgICAgcmV0dXJuIEYgPyB6KHooe30sIFMpLCBGKSA6IG51bGw7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImluUmFuZ2VcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbihiLCB4KSB7XG4gICAgICAgIHZhciBtID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB2b2lkIDAgPyBhcmd1bWVudHNbMl0gOiAxLCB5ID0gdGhpcy5wcm9wcy5sYXlvdXQsIFMgPSBiIC8gbSwgJCA9IHggLyBtO1xuICAgICAgICBpZiAoeSA9PT0gXCJob3Jpem9udGFsXCIgfHwgeSA9PT0gXCJ2ZXJ0aWNhbFwiKSB7XG4gICAgICAgICAgdmFyIE8gPSB0aGlzLnN0YXRlLm9mZnNldCwgVCA9IFMgPj0gTy5sZWZ0ICYmIFMgPD0gTy5sZWZ0ICsgTy53aWR0aCAmJiAkID49IE8udG9wICYmICQgPD0gTy50b3AgKyBPLmhlaWdodDtcbiAgICAgICAgICByZXR1cm4gVCA/IHtcbiAgICAgICAgICAgIHg6IFMsXG4gICAgICAgICAgICB5OiAkXG4gICAgICAgICAgfSA6IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIE0gPSB0aGlzLnN0YXRlLCBFID0gTS5hbmdsZUF4aXNNYXAsIEEgPSBNLnJhZGl1c0F4aXNNYXA7XG4gICAgICAgIGlmIChFICYmIEEpIHtcbiAgICAgICAgICB2YXIgaiA9IGtuKEUpO1xuICAgICAgICAgIHJldHVybiBSZyh7XG4gICAgICAgICAgICB4OiBTLFxuICAgICAgICAgICAgeTogJFxuICAgICAgICAgIH0sIGopO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJwYXJzZUV2ZW50c09mV3JhcHBlclwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgYiA9IHRoaXMucHJvcHMuY2hpbGRyZW4sIHggPSB0aGlzLmdldFRvb2x0aXBFdmVudFR5cGUoKSwgbSA9IHd0KGIsIHRuKSwgeSA9IHt9O1xuICAgICAgICBtICYmIHggPT09IFwiYXhpc1wiICYmIChtLnByb3BzLnRyaWdnZXIgPT09IFwiY2xpY2tcIiA/IHkgPSB7XG4gICAgICAgICAgb25DbGljazogdGhpcy5oYW5kbGVDbGlja1xuICAgICAgICB9IDogeSA9IHtcbiAgICAgICAgICBvbk1vdXNlRW50ZXI6IHRoaXMuaGFuZGxlTW91c2VFbnRlcixcbiAgICAgICAgICBvbk1vdXNlTW92ZTogdGhpcy5oYW5kbGVNb3VzZU1vdmUsXG4gICAgICAgICAgb25Nb3VzZUxlYXZlOiB0aGlzLmhhbmRsZU1vdXNlTGVhdmUsXG4gICAgICAgICAgb25Ub3VjaE1vdmU6IHRoaXMuaGFuZGxlVG91Y2hNb3ZlLFxuICAgICAgICAgIG9uVG91Y2hTdGFydDogdGhpcy5oYW5kbGVUb3VjaFN0YXJ0LFxuICAgICAgICAgIG9uVG91Y2hFbmQ6IHRoaXMuaGFuZGxlVG91Y2hFbmRcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBTID0gTmEodGhpcy5wcm9wcywgdGhpcy5oYW5kbGVPdXRlckV2ZW50KTtcbiAgICAgICAgcmV0dXJuIHooeih7fSwgUyksIHkpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJhZGRMaXN0ZW5lclwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpYy5vbihvYywgdGhpcy5oYW5kbGVSZWNlaXZlU3luY0V2ZW50KTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwicmVtb3ZlTGlzdGVuZXJcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWMucmVtb3ZlTGlzdGVuZXIob2MsIHRoaXMuaGFuZGxlUmVjZWl2ZVN5bmNFdmVudCk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImZpbHRlckZvcm1hdEl0ZW1cIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbihiLCB4LCBtKSB7XG4gICAgICAgIGZvciAodmFyIHkgPSB0aGlzLnN0YXRlLmZvcm1hdHRlZEdyYXBoaWNhbEl0ZW1zLCBTID0gMCwgJCA9IHkubGVuZ3RoOyBTIDwgJDsgUysrKSB7XG4gICAgICAgICAgdmFyIE8gPSB5W1NdO1xuICAgICAgICAgIGlmIChPLml0ZW0gPT09IGIgfHwgTy5wcm9wcy5rZXkgPT09IGIua2V5IHx8IHggPT09IEZuKE8uaXRlbS50eXBlKSAmJiBtID09PSBPLmNoaWxkSW5kZXgpXG4gICAgICAgICAgICByZXR1cm4gTztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwicmVuZGVyQ2xpcFBhdGhcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGIgPSB0aGlzLmNsaXBQYXRoSWQsIHggPSB0aGlzLnN0YXRlLm9mZnNldCwgbSA9IHgubGVmdCwgeSA9IHgudG9wLCBTID0geC5oZWlnaHQsICQgPSB4LndpZHRoO1xuICAgICAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIFAuY3JlYXRlRWxlbWVudChcImRlZnNcIiwgbnVsbCwgLyogQF9fUFVSRV9fICovIFAuY3JlYXRlRWxlbWVudChcImNsaXBQYXRoXCIsIHtcbiAgICAgICAgICBpZDogYlxuICAgICAgICB9LCAvKiBAX19QVVJFX18gKi8gUC5jcmVhdGVFbGVtZW50KFwicmVjdFwiLCB7XG4gICAgICAgICAgeDogbSxcbiAgICAgICAgICB5LFxuICAgICAgICAgIGhlaWdodDogUyxcbiAgICAgICAgICB3aWR0aDogJFxuICAgICAgICB9KSkpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJnZXRYU2NhbGVzXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBiID0gdGhpcy5zdGF0ZS54QXhpc01hcDtcbiAgICAgICAgcmV0dXJuIGIgPyBPYmplY3QuZW50cmllcyhiKS5yZWR1Y2UoZnVuY3Rpb24oeCwgbSkge1xuICAgICAgICAgIHZhciB5ID0gUXYobSwgMiksIFMgPSB5WzBdLCAkID0geVsxXTtcbiAgICAgICAgICByZXR1cm4geih6KHt9LCB4KSwge30sIHNlKHt9LCBTLCAkLnNjYWxlKSk7XG4gICAgICAgIH0sIHt9KSA6IG51bGw7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImdldFlTY2FsZXNcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGIgPSB0aGlzLnN0YXRlLnlBeGlzTWFwO1xuICAgICAgICByZXR1cm4gYiA/IE9iamVjdC5lbnRyaWVzKGIpLnJlZHVjZShmdW5jdGlvbih4LCBtKSB7XG4gICAgICAgICAgdmFyIHkgPSBRdihtLCAyKSwgUyA9IHlbMF0sICQgPSB5WzFdO1xuICAgICAgICAgIHJldHVybiB6KHooe30sIHgpLCB7fSwgc2Uoe30sIFMsICQuc2NhbGUpKTtcbiAgICAgICAgfSwge30pIDogbnVsbDtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiZ2V0WFNjYWxlQnlBeGlzSWRcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbihiKSB7XG4gICAgICAgIHZhciB4O1xuICAgICAgICByZXR1cm4gKHggPSB0aGlzLnN0YXRlLnhBeGlzTWFwKSA9PT0gbnVsbCB8fCB4ID09PSB2b2lkIDAgfHwgKHggPSB4W2JdKSA9PT0gbnVsbCB8fCB4ID09PSB2b2lkIDAgPyB2b2lkIDAgOiB4LnNjYWxlO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJnZXRZU2NhbGVCeUF4aXNJZFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uKGIpIHtcbiAgICAgICAgdmFyIHg7XG4gICAgICAgIHJldHVybiAoeCA9IHRoaXMuc3RhdGUueUF4aXNNYXApID09PSBudWxsIHx8IHggPT09IHZvaWQgMCB8fCAoeCA9IHhbYl0pID09PSBudWxsIHx8IHggPT09IHZvaWQgMCA/IHZvaWQgMCA6IHguc2NhbGU7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImdldEl0ZW1CeVhZXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24oYikge1xuICAgICAgICB2YXIgeCA9IHRoaXMuc3RhdGUsIG0gPSB4LmZvcm1hdHRlZEdyYXBoaWNhbEl0ZW1zLCB5ID0geC5hY3RpdmVJdGVtO1xuICAgICAgICBpZiAobSAmJiBtLmxlbmd0aClcbiAgICAgICAgICBmb3IgKHZhciBTID0gMCwgJCA9IG0ubGVuZ3RoOyBTIDwgJDsgUysrKSB7XG4gICAgICAgICAgICB2YXIgTyA9IG1bU10sIFQgPSBPLnByb3BzLCBNID0gTy5pdGVtLCBFID0gRm4oTS50eXBlKTtcbiAgICAgICAgICAgIGlmIChFID09PSBcIkJhclwiKSB7XG4gICAgICAgICAgICAgIHZhciBBID0gKFQuZGF0YSB8fCBbXSkuZmluZChmdW5jdGlvbihrKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFc3KGIsIGspO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgaWYgKEEpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgIGdyYXBoaWNhbEl0ZW06IE8sXG4gICAgICAgICAgICAgICAgICBwYXlsb2FkOiBBXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoRSA9PT0gXCJSYWRpYWxCYXJcIikge1xuICAgICAgICAgICAgICB2YXIgaiA9IChULmRhdGEgfHwgW10pLmZpbmQoZnVuY3Rpb24oaykge1xuICAgICAgICAgICAgICAgIHJldHVybiBSZyhiLCBrKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGlmIChqKVxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICBncmFwaGljYWxJdGVtOiBPLFxuICAgICAgICAgICAgICAgICAgcGF5bG9hZDogalxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGl1KE8sIHkpIHx8IG91KE8sIHkpIHx8IEVvKE8sIHkpKSB7XG4gICAgICAgICAgICAgIHZhciBSID0gcTkoe1xuICAgICAgICAgICAgICAgIGdyYXBoaWNhbEl0ZW06IE8sXG4gICAgICAgICAgICAgICAgYWN0aXZlVG9vbHRpcEl0ZW06IHksXG4gICAgICAgICAgICAgICAgaXRlbURhdGE6IE0ucHJvcHMuZGF0YVxuICAgICAgICAgICAgICB9KSwgTiA9IE0ucHJvcHMuYWN0aXZlSW5kZXggPT09IHZvaWQgMCA/IFIgOiBNLnByb3BzLmFjdGl2ZUluZGV4O1xuICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGdyYXBoaWNhbEl0ZW06IHooeih7fSwgTyksIHt9LCB7XG4gICAgICAgICAgICAgICAgICBjaGlsZEluZGV4OiBOXG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgcGF5bG9hZDogRW8oTywgeSkgPyBNLnByb3BzLmRhdGFbUl0gOiBPLnByb3BzLmRhdGFbUl1cbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJyZW5kZXJcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGIgPSB0aGlzO1xuICAgICAgICBpZiAoIU9wKHRoaXMpKVxuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB2YXIgeCA9IHRoaXMucHJvcHMsIG0gPSB4LmNoaWxkcmVuLCB5ID0geC5jbGFzc05hbWUsIFMgPSB4LndpZHRoLCAkID0geC5oZWlnaHQsIE8gPSB4LnN0eWxlLCBUID0geC5jb21wYWN0LCBNID0geC50aXRsZSwgRSA9IHguZGVzYywgQSA9IGVtKHgsIHdXKSwgaiA9IHllKEEsICExKTtcbiAgICAgICAgaWYgKFQpXG4gICAgICAgICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBQLmNyZWF0ZUVsZW1lbnQoRHYsIHtcbiAgICAgICAgICAgIHN0YXRlOiB0aGlzLnN0YXRlLFxuICAgICAgICAgICAgd2lkdGg6IHRoaXMucHJvcHMud2lkdGgsXG4gICAgICAgICAgICBoZWlnaHQ6IHRoaXMucHJvcHMuaGVpZ2h0LFxuICAgICAgICAgICAgY2xpcFBhdGhJZDogdGhpcy5jbGlwUGF0aElkXG4gICAgICAgICAgfSwgLyogQF9fUFVSRV9fICovIFAuY3JlYXRlRWxlbWVudChNYywgS2koe30sIGosIHtcbiAgICAgICAgICAgIHdpZHRoOiBTLFxuICAgICAgICAgICAgaGVpZ2h0OiAkLFxuICAgICAgICAgICAgdGl0bGU6IE0sXG4gICAgICAgICAgICBkZXNjOiBFXG4gICAgICAgICAgfSksIHRoaXMucmVuZGVyQ2xpcFBhdGgoKSwgQXAobSwgdGhpcy5yZW5kZXJNYXApKSk7XG4gICAgICAgIGlmICh0aGlzLnByb3BzLmFjY2Vzc2liaWxpdHlMYXllcikge1xuICAgICAgICAgIHZhciBSLCBOO1xuICAgICAgICAgIGoudGFiSW5kZXggPSAoUiA9IHRoaXMucHJvcHMudGFiSW5kZXgpICE9PSBudWxsICYmIFIgIT09IHZvaWQgMCA/IFIgOiAwLCBqLnJvbGUgPSAoTiA9IHRoaXMucHJvcHMucm9sZSkgIT09IG51bGwgJiYgTiAhPT0gdm9pZCAwID8gTiA6IFwiYXBwbGljYXRpb25cIiwgai5vbktleURvd24gPSBmdW5jdGlvbihGKSB7XG4gICAgICAgICAgICBiLmFjY2Vzc2liaWxpdHlNYW5hZ2VyLmtleWJvYXJkRXZlbnQoRik7XG4gICAgICAgICAgfSwgai5vbkZvY3VzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBiLmFjY2Vzc2liaWxpdHlNYW5hZ2VyLmZvY3VzKCk7XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgayA9IHRoaXMucGFyc2VFdmVudHNPZldyYXBwZXIoKTtcbiAgICAgICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBQLmNyZWF0ZUVsZW1lbnQoRHYsIHtcbiAgICAgICAgICBzdGF0ZTogdGhpcy5zdGF0ZSxcbiAgICAgICAgICB3aWR0aDogdGhpcy5wcm9wcy53aWR0aCxcbiAgICAgICAgICBoZWlnaHQ6IHRoaXMucHJvcHMuaGVpZ2h0LFxuICAgICAgICAgIGNsaXBQYXRoSWQ6IHRoaXMuY2xpcFBhdGhJZFxuICAgICAgICB9LCAvKiBAX19QVVJFX18gKi8gUC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIEtpKHtcbiAgICAgICAgICBjbGFzc05hbWU6ICRlKFwicmVjaGFydHMtd3JhcHBlclwiLCB5KSxcbiAgICAgICAgICBzdHlsZTogeih7XG4gICAgICAgICAgICBwb3NpdGlvbjogXCJyZWxhdGl2ZVwiLFxuICAgICAgICAgICAgY3Vyc29yOiBcImRlZmF1bHRcIixcbiAgICAgICAgICAgIHdpZHRoOiBTLFxuICAgICAgICAgICAgaGVpZ2h0OiAkXG4gICAgICAgICAgfSwgTylcbiAgICAgICAgfSwgaywge1xuICAgICAgICAgIHJlZjogZnVuY3Rpb24oVikge1xuICAgICAgICAgICAgYi5jb250YWluZXIgPSBWO1xuICAgICAgICAgIH1cbiAgICAgICAgfSksIC8qIEBfX1BVUkVfXyAqLyBQLmNyZWF0ZUVsZW1lbnQoTWMsIEtpKHt9LCBqLCB7XG4gICAgICAgICAgd2lkdGg6IFMsXG4gICAgICAgICAgaGVpZ2h0OiAkLFxuICAgICAgICAgIHRpdGxlOiBNLFxuICAgICAgICAgIGRlc2M6IEUsXG4gICAgICAgICAgc3R5bGU6IERXXG4gICAgICAgIH0pLCB0aGlzLnJlbmRlckNsaXBQYXRoKCksIEFwKG0sIHRoaXMucmVuZGVyTWFwKSksIHRoaXMucmVuZGVyTGVnZW5kKCksIHRoaXMucmVuZGVyVG9vbHRpcCgpKSk7XG4gICAgICB9XG4gICAgfV0pLCB2O1xuICB9KGxtKSwgc2UobiwgXCJkaXNwbGF5TmFtZVwiLCByKSwgc2UobiwgXCJkZWZhdWx0UHJvcHNcIiwgeih7XG4gICAgbGF5b3V0OiBcImhvcml6b250YWxcIixcbiAgICBzdGFja09mZnNldDogXCJub25lXCIsXG4gICAgYmFyQ2F0ZWdvcnlHYXA6IFwiMTAlXCIsXG4gICAgYmFyR2FwOiA0LFxuICAgIG1hcmdpbjoge1xuICAgICAgdG9wOiA1LFxuICAgICAgcmlnaHQ6IDUsXG4gICAgICBib3R0b206IDUsXG4gICAgICBsZWZ0OiA1XG4gICAgfSxcbiAgICByZXZlcnNlU3RhY2tPcmRlcjogITEsXG4gICAgc3luY01ldGhvZDogXCJpbmRleFwiXG4gIH0sIGQpKSwgc2UobiwgXCJnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHNcIiwgZnVuY3Rpb24oaCwgdikge1xuICAgIHZhciB3ID0gaC5kYXRhS2V5LCBiID0gaC5kYXRhLCB4ID0gaC5jaGlsZHJlbiwgbSA9IGgud2lkdGgsIHkgPSBoLmhlaWdodCwgUyA9IGgubGF5b3V0LCAkID0gaC5zdGFja09mZnNldCwgTyA9IGgubWFyZ2luLCBUID0gdi5kYXRhU3RhcnRJbmRleCwgTSA9IHYuZGF0YUVuZEluZGV4O1xuICAgIGlmICh2LnVwZGF0ZUlkID09PSB2b2lkIDApIHtcbiAgICAgIHZhciBFID0gcm0oaCk7XG4gICAgICByZXR1cm4geih6KHooe30sIEUpLCB7fSwge1xuICAgICAgICB1cGRhdGVJZDogMFxuICAgICAgfSwgZyh6KHooe1xuICAgICAgICBwcm9wczogaFxuICAgICAgfSwgRSksIHt9LCB7XG4gICAgICAgIHVwZGF0ZUlkOiAwXG4gICAgICB9KSwgdikpLCB7fSwge1xuICAgICAgICBwcmV2RGF0YUtleTogdyxcbiAgICAgICAgcHJldkRhdGE6IGIsXG4gICAgICAgIHByZXZXaWR0aDogbSxcbiAgICAgICAgcHJldkhlaWdodDogeSxcbiAgICAgICAgcHJldkxheW91dDogUyxcbiAgICAgICAgcHJldlN0YWNrT2Zmc2V0OiAkLFxuICAgICAgICBwcmV2TWFyZ2luOiBPLFxuICAgICAgICBwcmV2Q2hpbGRyZW46IHhcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAodyAhPT0gdi5wcmV2RGF0YUtleSB8fCBiICE9PSB2LnByZXZEYXRhIHx8IG0gIT09IHYucHJldldpZHRoIHx8IHkgIT09IHYucHJldkhlaWdodCB8fCBTICE9PSB2LnByZXZMYXlvdXQgfHwgJCAhPT0gdi5wcmV2U3RhY2tPZmZzZXQgfHwgIVJyKE8sIHYucHJldk1hcmdpbikpIHtcbiAgICAgIHZhciBBID0gcm0oaCksIGogPSB7XG4gICAgICAgIC8vIChjaGFydFgsIGNoYXJ0WSkgYXJlICgwLDApIGluIGRlZmF1bHQgc3RhdGUsIGJ1dCB3ZSB3YW50IHRvIGtlZXAgdGhlIGxhc3QgbW91c2UgcG9zaXRpb24gdG8gYXZvaWRcbiAgICAgICAgLy8gYW55IGZsaWNrZXJpbmdcbiAgICAgICAgY2hhcnRYOiB2LmNoYXJ0WCxcbiAgICAgICAgY2hhcnRZOiB2LmNoYXJ0WSxcbiAgICAgICAgLy8gVGhlIHRvb2x0aXAgc2hvdWxkIHN0YXkgYWN0aXZlIHdoZW4gaXQgd2FzIGFjdGl2ZSBpbiB0aGUgcHJldmlvdXMgcmVuZGVyLiBJZiB0aGlzIGlzIG5vdFxuICAgICAgICAvLyB0aGUgY2FzZSwgdGhlIHRvb2x0aXAgZGlzYXBwZWFycyBhbmQgaW1tZWRpYXRlbHkgcmUtYXBwZWFycywgY2F1c2luZyBhIGZsaWNrZXJpbmcgZWZmZWN0XG4gICAgICAgIGlzVG9vbHRpcEFjdGl2ZTogdi5pc1Rvb2x0aXBBY3RpdmVcbiAgICAgIH0sIFIgPSB6KHooe30sIG5tKHYsIGIsIFMpKSwge30sIHtcbiAgICAgICAgdXBkYXRlSWQ6IHYudXBkYXRlSWQgKyAxXG4gICAgICB9KSwgTiA9IHooeih6KHt9LCBBKSwgaiksIFIpO1xuICAgICAgcmV0dXJuIHooeih6KHt9LCBOKSwgZyh6KHtcbiAgICAgICAgcHJvcHM6IGhcbiAgICAgIH0sIE4pLCB2KSksIHt9LCB7XG4gICAgICAgIHByZXZEYXRhS2V5OiB3LFxuICAgICAgICBwcmV2RGF0YTogYixcbiAgICAgICAgcHJldldpZHRoOiBtLFxuICAgICAgICBwcmV2SGVpZ2h0OiB5LFxuICAgICAgICBwcmV2TGF5b3V0OiBTLFxuICAgICAgICBwcmV2U3RhY2tPZmZzZXQ6ICQsXG4gICAgICAgIHByZXZNYXJnaW46IE8sXG4gICAgICAgIHByZXZDaGlsZHJlbjogeFxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmICghRWMoeCwgdi5wcmV2Q2hpbGRyZW4pKSB7XG4gICAgICB2YXIgaywgRiwgViwgTCwgSSA9IHd0KHgsIFhyKSwgRCA9IEkgJiYgKGsgPSAoRiA9IEkucHJvcHMpID09PSBudWxsIHx8IEYgPT09IHZvaWQgMCA/IHZvaWQgMCA6IEYuc3RhcnRJbmRleCkgIT09IG51bGwgJiYgayAhPT0gdm9pZCAwID8gayA6IFQsIEcgPSBJICYmIChWID0gKEwgPSBJLnByb3BzKSA9PT0gbnVsbCB8fCBMID09PSB2b2lkIDAgPyB2b2lkIDAgOiBMLmVuZEluZGV4KSAhPT0gbnVsbCAmJiBWICE9PSB2b2lkIDAgPyBWIDogTSwgcSA9IEQgIT09IFQgfHwgRyAhPT0gTSwgSiA9ICFtZShiKSwgbmUgPSBKICYmICFxID8gdi51cGRhdGVJZCA6IHYudXBkYXRlSWQgKyAxO1xuICAgICAgcmV0dXJuIHooeih7XG4gICAgICAgIHVwZGF0ZUlkOiBuZVxuICAgICAgfSwgZyh6KHooe1xuICAgICAgICBwcm9wczogaFxuICAgICAgfSwgdiksIHt9LCB7XG4gICAgICAgIHVwZGF0ZUlkOiBuZSxcbiAgICAgICAgZGF0YVN0YXJ0SW5kZXg6IEQsXG4gICAgICAgIGRhdGFFbmRJbmRleDogR1xuICAgICAgfSksIHYpKSwge30sIHtcbiAgICAgICAgcHJldkNoaWxkcmVuOiB4LFxuICAgICAgICBkYXRhU3RhcnRJbmRleDogRCxcbiAgICAgICAgZGF0YUVuZEluZGV4OiBHXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH0pLCBzZShuLCBcInJlbmRlckFjdGl2ZURvdFwiLCBmdW5jdGlvbihoLCB2KSB7XG4gICAgdmFyIHc7XG4gICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyB2dChoKSA/IHcgPSAvKiBAX19QVVJFX18gKi8gR2UoaCwgdikgOiBwZShoKSA/IHcgPSBoKHYpIDogdyA9IC8qIEBfX1BVUkVfXyAqLyBQLmNyZWF0ZUVsZW1lbnQocGQsIHYpLCAvKiBAX19QVVJFX18gKi8gUC5jcmVhdGVFbGVtZW50KFdlLCB7XG4gICAgICBjbGFzc05hbWU6IFwicmVjaGFydHMtYWN0aXZlLWRvdFwiLFxuICAgICAga2V5OiB2LmtleVxuICAgIH0sIHcpO1xuICB9KSwgbjtcbn0sIHFXID0gSFcoe1xuICBjaGFydE5hbWU6IFwiTGluZUNoYXJ0XCIsXG4gIEdyYXBoaWNhbENoaWxkOiB0aSxcbiAgYXhpc0NvbXBvbmVudHM6IFt7XG4gICAgYXhpc1R5cGU6IFwieEF4aXNcIixcbiAgICBBeGlzQ29tcDogc3VcbiAgfSwge1xuICAgIGF4aXNUeXBlOiBcInlBeGlzXCIsXG4gICAgQXhpc0NvbXA6IHV1XG4gIH1dLFxuICBmb3JtYXRBeGlzTWFwOiB2NVxufSk7XG5jb25zdCB0SCA9ICh7IGRhdGE6IGUgfSkgPT4gLyogQF9fUFVSRV9fICovIFgoXCJkaXZcIiwgeyBzdHlsZTogeyB3aWR0aDogXCIxMDAlXCIsIGhlaWdodDogXCIxMDAlXCIgfSwgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyB6ZShxVywgeyB3aWR0aDogNTAwLCBoZWlnaHQ6IDMwMCwgZGF0YTogZSwgY2hpbGRyZW46IFtcbiAgLyogQF9fUFVSRV9fICovIFgoTXcsIHsgc3Ryb2tlRGFzaGFycmF5OiBcIjMgM1wiIH0pLFxuICAvKiBAX19QVVJFX18gKi8gWChzdSwgeyBkYXRhS2V5OiBcIm5hbWVcIiwgcGFkZGluZzogeyBsZWZ0OiAzMCwgcmlnaHQ6IDMwIH0gfSksXG4gIC8qIEBfX1BVUkVfXyAqLyBYKHV1LCB7fSksXG4gIC8qIEBfX1BVUkVfXyAqLyBYKHRuLCB7fSksXG4gIC8qIEBfX1BVUkVfXyAqLyBYKFZyLCB7fSksXG4gIC8qIEBfX1BVUkVfXyAqLyBYKFxuICAgIHRpLFxuICAgIHtcbiAgICAgIHR5cGU6IFwibW9ub3RvbmVcIixcbiAgICAgIGRhdGFLZXk6IFwicHZcIixcbiAgICAgIHN0cm9rZTogXCIjODg4NGQ4XCIsXG4gICAgICBhY3RpdmVEb3Q6IHsgcjogOCB9XG4gICAgfVxuICApLFxuICAvKiBAX19QVVJFX18gKi8gWCh0aSwgeyB0eXBlOiBcIm1vbm90b25lXCIsIGRhdGFLZXk6IFwidXZcIiwgc3Ryb2tlOiBcIiM4MmNhOWRcIiB9KVxuXSB9KSB9KTtcbi8qKlxuICAgKiB0YWJsZS1jb3JlXG4gICAqXG4gICAqIENvcHlyaWdodCAoYykgVGFuU3RhY2tcbiAgICpcbiAgICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gICAqIExJQ0VOU0UubWQgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAgICpcbiAgICogQGxpY2Vuc2UgTUlUXG4gICAqL1xuZnVuY3Rpb24gTm4oZSwgdCkge1xuICByZXR1cm4gdHlwZW9mIGUgPT0gXCJmdW5jdGlvblwiID8gZSh0KSA6IGU7XG59XG5mdW5jdGlvbiBQdChlLCB0KSB7XG4gIHJldHVybiAobikgPT4ge1xuICAgIHQuc2V0U3RhdGUoKHIpID0+ICh7XG4gICAgICAuLi5yLFxuICAgICAgW2VdOiBObihuLCByW2VdKVxuICAgIH0pKTtcbiAgfTtcbn1cbmZ1bmN0aW9uIGx1KGUpIHtcbiAgcmV0dXJuIGUgaW5zdGFuY2VvZiBGdW5jdGlvbjtcbn1cbmZ1bmN0aW9uIEtXKGUpIHtcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkoZSkgJiYgZS5ldmVyeSgodCkgPT4gdHlwZW9mIHQgPT0gXCJudW1iZXJcIik7XG59XG5mdW5jdGlvbiBZVyhlLCB0KSB7XG4gIGNvbnN0IG4gPSBbXSwgciA9IChpKSA9PiB7XG4gICAgaS5mb3JFYWNoKChvKSA9PiB7XG4gICAgICBuLnB1c2gobyk7XG4gICAgICBjb25zdCBhID0gdChvKTtcbiAgICAgIGEgIT0gbnVsbCAmJiBhLmxlbmd0aCAmJiByKGEpO1xuICAgIH0pO1xuICB9O1xuICByZXR1cm4gcihlKSwgbjtcbn1cbmZ1bmN0aW9uIG9lKGUsIHQsIG4pIHtcbiAgbGV0IHIgPSBbXSwgaTtcbiAgcmV0dXJuIChvKSA9PiB7XG4gICAgbGV0IGE7XG4gICAgbi5rZXkgJiYgbi5kZWJ1ZyAmJiAoYSA9IERhdGUubm93KCkpO1xuICAgIGNvbnN0IHMgPSBlKG8pO1xuICAgIGlmICghKHMubGVuZ3RoICE9PSByLmxlbmd0aCB8fCBzLnNvbWUoKGYsIGwpID0+IHJbbF0gIT09IGYpKSlcbiAgICAgIHJldHVybiBpO1xuICAgIHIgPSBzO1xuICAgIGxldCBjO1xuICAgIGlmIChuLmtleSAmJiBuLmRlYnVnICYmIChjID0gRGF0ZS5ub3coKSksIGkgPSB0KC4uLnMpLCBuID09IG51bGwgfHwgbi5vbkNoYW5nZSA9PSBudWxsIHx8IG4ub25DaGFuZ2UoaSksIG4ua2V5ICYmIG4uZGVidWcgJiYgbiAhPSBudWxsICYmIG4uZGVidWcoKSkge1xuICAgICAgY29uc3QgZiA9IE1hdGgucm91bmQoKERhdGUubm93KCkgLSBhKSAqIDEwMCkgLyAxMDAsIGwgPSBNYXRoLnJvdW5kKChEYXRlLm5vdygpIC0gYykgKiAxMDApIC8gMTAwLCBkID0gbCAvIDE2LCBwID0gKGcsIGgpID0+IHtcbiAgICAgICAgZm9yIChnID0gU3RyaW5nKGcpOyBnLmxlbmd0aCA8IGg7IClcbiAgICAgICAgICBnID0gXCIgXCIgKyBnO1xuICAgICAgICByZXR1cm4gZztcbiAgICAgIH07XG4gICAgICBjb25zb2xlLmluZm8oYCVj4o+xICR7cChsLCA1KX0gLyR7cChmLCA1KX0gbXNgLCBgXG4gICAgICAgICAgICBmb250LXNpemU6IC42cmVtO1xuICAgICAgICAgICAgZm9udC13ZWlnaHQ6IGJvbGQ7XG4gICAgICAgICAgICBjb2xvcjogaHNsKCR7TWF0aC5tYXgoMCwgTWF0aC5taW4oMTIwIC0gMTIwICogZCwgMTIwKSl9ZGVnIDEwMCUgMzElKTtgLCBuID09IG51bGwgPyB2b2lkIDAgOiBuLmtleSk7XG4gICAgfVxuICAgIHJldHVybiBpO1xuICB9O1xufVxuZnVuY3Rpb24gYWUoZSwgdCwgbiwgcikge1xuICByZXR1cm4ge1xuICAgIGRlYnVnOiAoKSA9PiB7XG4gICAgICB2YXIgaTtcbiAgICAgIHJldHVybiAoaSA9IGUgPT0gbnVsbCA/IHZvaWQgMCA6IGUuZGVidWdBbGwpICE9IG51bGwgPyBpIDogZVt0XTtcbiAgICB9LFxuICAgIGtleTogcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwiZGV2ZWxvcG1lbnRcIiAmJiBuLFxuICAgIG9uQ2hhbmdlOiByXG4gIH07XG59XG5mdW5jdGlvbiBYVyhlLCB0LCBuLCByKSB7XG4gIGNvbnN0IGkgPSAoKSA9PiB7XG4gICAgdmFyIGE7XG4gICAgcmV0dXJuIChhID0gby5nZXRWYWx1ZSgpKSAhPSBudWxsID8gYSA6IGUub3B0aW9ucy5yZW5kZXJGYWxsYmFja1ZhbHVlO1xuICB9LCBvID0ge1xuICAgIGlkOiBgJHt0LmlkfV8ke24uaWR9YCxcbiAgICByb3c6IHQsXG4gICAgY29sdW1uOiBuLFxuICAgIGdldFZhbHVlOiAoKSA9PiB0LmdldFZhbHVlKHIpLFxuICAgIHJlbmRlclZhbHVlOiBpLFxuICAgIGdldENvbnRleHQ6IG9lKCgpID0+IFtlLCBuLCB0LCBvXSwgKGEsIHMsIHUsIGMpID0+ICh7XG4gICAgICB0YWJsZTogYSxcbiAgICAgIGNvbHVtbjogcyxcbiAgICAgIHJvdzogdSxcbiAgICAgIGNlbGw6IGMsXG4gICAgICBnZXRWYWx1ZTogYy5nZXRWYWx1ZSxcbiAgICAgIHJlbmRlclZhbHVlOiBjLnJlbmRlclZhbHVlXG4gICAgfSksIGFlKGUub3B0aW9ucywgXCJkZWJ1Z0NlbGxzXCIsIFwiY2VsbC5nZXRDb250ZXh0XCIpKVxuICB9O1xuICByZXR1cm4gZS5fZmVhdHVyZXMuZm9yRWFjaCgoYSkgPT4ge1xuICAgIGEuY3JlYXRlQ2VsbCA9PSBudWxsIHx8IGEuY3JlYXRlQ2VsbChvLCBuLCB0LCBlKTtcbiAgfSwge30pLCBvO1xufVxuZnVuY3Rpb24gWlcoZSwgdCwgbiwgcikge1xuICB2YXIgaSwgbztcbiAgY29uc3QgcyA9IHtcbiAgICAuLi5lLl9nZXREZWZhdWx0Q29sdW1uRGVmKCksXG4gICAgLi4udFxuICB9LCB1ID0gcy5hY2Nlc3NvcktleTtcbiAgbGV0IGMgPSAoaSA9IChvID0gcy5pZCkgIT0gbnVsbCA/IG8gOiB1ID8gdS5yZXBsYWNlKFwiLlwiLCBcIl9cIikgOiB2b2lkIDApICE9IG51bGwgPyBpIDogdHlwZW9mIHMuaGVhZGVyID09IFwic3RyaW5nXCIgPyBzLmhlYWRlciA6IHZvaWQgMCwgZjtcbiAgaWYgKHMuYWNjZXNzb3JGbiA/IGYgPSBzLmFjY2Vzc29yRm4gOiB1ICYmICh1LmluY2x1ZGVzKFwiLlwiKSA/IGYgPSAoZCkgPT4ge1xuICAgIGxldCBwID0gZDtcbiAgICBmb3IgKGNvbnN0IGggb2YgdS5zcGxpdChcIi5cIikpIHtcbiAgICAgIHZhciBnO1xuICAgICAgcCA9IChnID0gcCkgPT0gbnVsbCA/IHZvaWQgMCA6IGdbaF0sIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiBwID09PSB2b2lkIDAgJiYgY29uc29sZS53YXJuKGBcIiR7aH1cIiBpbiBkZWVwbHkgbmVzdGVkIGtleSBcIiR7dX1cIiByZXR1cm5lZCB1bmRlZmluZWQuYCk7XG4gICAgfVxuICAgIHJldHVybiBwO1xuICB9IDogZiA9IChkKSA9PiBkW3MuYWNjZXNzb3JLZXldKSwgIWMpXG4gICAgdGhyb3cgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gbmV3IEVycm9yKHMuYWNjZXNzb3JGbiA/IFwiQ29sdW1ucyByZXF1aXJlIGFuIGlkIHdoZW4gdXNpbmcgYW4gYWNjZXNzb3JGblwiIDogXCJDb2x1bW5zIHJlcXVpcmUgYW4gaWQgd2hlbiB1c2luZyBhIG5vbi1zdHJpbmcgaGVhZGVyXCIpIDogbmV3IEVycm9yKCk7XG4gIGxldCBsID0ge1xuICAgIGlkOiBgJHtTdHJpbmcoYyl9YCxcbiAgICBhY2Nlc3NvckZuOiBmLFxuICAgIHBhcmVudDogcixcbiAgICBkZXB0aDogbixcbiAgICBjb2x1bW5EZWY6IHMsXG4gICAgY29sdW1uczogW10sXG4gICAgZ2V0RmxhdENvbHVtbnM6IG9lKCgpID0+IFshMF0sICgpID0+IHtcbiAgICAgIHZhciBkO1xuICAgICAgcmV0dXJuIFtsLCAuLi4oZCA9IGwuY29sdW1ucykgPT0gbnVsbCA/IHZvaWQgMCA6IGQuZmxhdE1hcCgocCkgPT4gcC5nZXRGbGF0Q29sdW1ucygpKV07XG4gICAgfSwgYWUoZS5vcHRpb25zLCBcImRlYnVnQ29sdW1uc1wiLCBcImNvbHVtbi5nZXRGbGF0Q29sdW1uc1wiKSksXG4gICAgZ2V0TGVhZkNvbHVtbnM6IG9lKCgpID0+IFtlLl9nZXRPcmRlckNvbHVtbnNGbigpXSwgKGQpID0+IHtcbiAgICAgIHZhciBwO1xuICAgICAgaWYgKChwID0gbC5jb2x1bW5zKSAhPSBudWxsICYmIHAubGVuZ3RoKSB7XG4gICAgICAgIGxldCBnID0gbC5jb2x1bW5zLmZsYXRNYXAoKGgpID0+IGguZ2V0TGVhZkNvbHVtbnMoKSk7XG4gICAgICAgIHJldHVybiBkKGcpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFtsXTtcbiAgICB9LCBhZShlLm9wdGlvbnMsIFwiZGVidWdDb2x1bW5zXCIsIFwiY29sdW1uLmdldExlYWZDb2x1bW5zXCIpKVxuICB9O1xuICBmb3IgKGNvbnN0IGQgb2YgZS5fZmVhdHVyZXMpXG4gICAgZC5jcmVhdGVDb2x1bW4gPT0gbnVsbCB8fCBkLmNyZWF0ZUNvbHVtbihsLCBlKTtcbiAgcmV0dXJuIGw7XG59XG5jb25zdCBpdCA9IFwiZGVidWdIZWFkZXJzXCI7XG5mdW5jdGlvbiBvbShlLCB0LCBuKSB7XG4gIHZhciByO1xuICBsZXQgbyA9IHtcbiAgICBpZDogKHIgPSBuLmlkKSAhPSBudWxsID8gciA6IHQuaWQsXG4gICAgY29sdW1uOiB0LFxuICAgIGluZGV4OiBuLmluZGV4LFxuICAgIGlzUGxhY2Vob2xkZXI6ICEhbi5pc1BsYWNlaG9sZGVyLFxuICAgIHBsYWNlaG9sZGVySWQ6IG4ucGxhY2Vob2xkZXJJZCxcbiAgICBkZXB0aDogbi5kZXB0aCxcbiAgICBzdWJIZWFkZXJzOiBbXSxcbiAgICBjb2xTcGFuOiAwLFxuICAgIHJvd1NwYW46IDAsXG4gICAgaGVhZGVyR3JvdXA6IG51bGwsXG4gICAgZ2V0TGVhZkhlYWRlcnM6ICgpID0+IHtcbiAgICAgIGNvbnN0IGEgPSBbXSwgcyA9ICh1KSA9PiB7XG4gICAgICAgIHUuc3ViSGVhZGVycyAmJiB1LnN1YkhlYWRlcnMubGVuZ3RoICYmIHUuc3ViSGVhZGVycy5tYXAocyksIGEucHVzaCh1KTtcbiAgICAgIH07XG4gICAgICByZXR1cm4gcyhvKSwgYTtcbiAgICB9LFxuICAgIGdldENvbnRleHQ6ICgpID0+ICh7XG4gICAgICB0YWJsZTogZSxcbiAgICAgIGhlYWRlcjogbyxcbiAgICAgIGNvbHVtbjogdFxuICAgIH0pXG4gIH07XG4gIHJldHVybiBlLl9mZWF0dXJlcy5mb3JFYWNoKChhKSA9PiB7XG4gICAgYS5jcmVhdGVIZWFkZXIgPT0gbnVsbCB8fCBhLmNyZWF0ZUhlYWRlcihvLCBlKTtcbiAgfSksIG87XG59XG5jb25zdCBKVyA9IHtcbiAgY3JlYXRlVGFibGU6IChlKSA9PiB7XG4gICAgZS5nZXRIZWFkZXJHcm91cHMgPSBvZSgoKSA9PiBbZS5nZXRBbGxDb2x1bW5zKCksIGUuZ2V0VmlzaWJsZUxlYWZDb2x1bW5zKCksIGUuZ2V0U3RhdGUoKS5jb2x1bW5QaW5uaW5nLmxlZnQsIGUuZ2V0U3RhdGUoKS5jb2x1bW5QaW5uaW5nLnJpZ2h0XSwgKHQsIG4sIHIsIGkpID0+IHtcbiAgICAgIHZhciBvLCBhO1xuICAgICAgY29uc3QgcyA9IChvID0gciA9PSBudWxsID8gdm9pZCAwIDogci5tYXAoKGwpID0+IG4uZmluZCgoZCkgPT4gZC5pZCA9PT0gbCkpLmZpbHRlcihCb29sZWFuKSkgIT0gbnVsbCA/IG8gOiBbXSwgdSA9IChhID0gaSA9PSBudWxsID8gdm9pZCAwIDogaS5tYXAoKGwpID0+IG4uZmluZCgoZCkgPT4gZC5pZCA9PT0gbCkpLmZpbHRlcihCb29sZWFuKSkgIT0gbnVsbCA/IGEgOiBbXSwgYyA9IG4uZmlsdGVyKChsKSA9PiAhKHIgIT0gbnVsbCAmJiByLmluY2x1ZGVzKGwuaWQpKSAmJiAhKGkgIT0gbnVsbCAmJiBpLmluY2x1ZGVzKGwuaWQpKSk7XG4gICAgICByZXR1cm4gJGEodCwgWy4uLnMsIC4uLmMsIC4uLnVdLCBlKTtcbiAgICB9LCBhZShlLm9wdGlvbnMsIGl0LCBcImdldEhlYWRlckdyb3Vwc1wiKSksIGUuZ2V0Q2VudGVySGVhZGVyR3JvdXBzID0gb2UoKCkgPT4gW2UuZ2V0QWxsQ29sdW1ucygpLCBlLmdldFZpc2libGVMZWFmQ29sdW1ucygpLCBlLmdldFN0YXRlKCkuY29sdW1uUGlubmluZy5sZWZ0LCBlLmdldFN0YXRlKCkuY29sdW1uUGlubmluZy5yaWdodF0sICh0LCBuLCByLCBpKSA9PiAobiA9IG4uZmlsdGVyKChvKSA9PiAhKHIgIT0gbnVsbCAmJiByLmluY2x1ZGVzKG8uaWQpKSAmJiAhKGkgIT0gbnVsbCAmJiBpLmluY2x1ZGVzKG8uaWQpKSksICRhKHQsIG4sIGUsIFwiY2VudGVyXCIpKSwgYWUoZS5vcHRpb25zLCBpdCwgXCJnZXRDZW50ZXJIZWFkZXJHcm91cHNcIikpLCBlLmdldExlZnRIZWFkZXJHcm91cHMgPSBvZSgoKSA9PiBbZS5nZXRBbGxDb2x1bW5zKCksIGUuZ2V0VmlzaWJsZUxlYWZDb2x1bW5zKCksIGUuZ2V0U3RhdGUoKS5jb2x1bW5QaW5uaW5nLmxlZnRdLCAodCwgbiwgcikgPT4ge1xuICAgICAgdmFyIGk7XG4gICAgICBjb25zdCBvID0gKGkgPSByID09IG51bGwgPyB2b2lkIDAgOiByLm1hcCgoYSkgPT4gbi5maW5kKChzKSA9PiBzLmlkID09PSBhKSkuZmlsdGVyKEJvb2xlYW4pKSAhPSBudWxsID8gaSA6IFtdO1xuICAgICAgcmV0dXJuICRhKHQsIG8sIGUsIFwibGVmdFwiKTtcbiAgICB9LCBhZShlLm9wdGlvbnMsIGl0LCBcImdldExlZnRIZWFkZXJHcm91cHNcIikpLCBlLmdldFJpZ2h0SGVhZGVyR3JvdXBzID0gb2UoKCkgPT4gW2UuZ2V0QWxsQ29sdW1ucygpLCBlLmdldFZpc2libGVMZWFmQ29sdW1ucygpLCBlLmdldFN0YXRlKCkuY29sdW1uUGlubmluZy5yaWdodF0sICh0LCBuLCByKSA9PiB7XG4gICAgICB2YXIgaTtcbiAgICAgIGNvbnN0IG8gPSAoaSA9IHIgPT0gbnVsbCA/IHZvaWQgMCA6IHIubWFwKChhKSA9PiBuLmZpbmQoKHMpID0+IHMuaWQgPT09IGEpKS5maWx0ZXIoQm9vbGVhbikpICE9IG51bGwgPyBpIDogW107XG4gICAgICByZXR1cm4gJGEodCwgbywgZSwgXCJyaWdodFwiKTtcbiAgICB9LCBhZShlLm9wdGlvbnMsIGl0LCBcImdldFJpZ2h0SGVhZGVyR3JvdXBzXCIpKSwgZS5nZXRGb290ZXJHcm91cHMgPSBvZSgoKSA9PiBbZS5nZXRIZWFkZXJHcm91cHMoKV0sICh0KSA9PiBbLi4udF0ucmV2ZXJzZSgpLCBhZShlLm9wdGlvbnMsIGl0LCBcImdldEZvb3Rlckdyb3Vwc1wiKSksIGUuZ2V0TGVmdEZvb3Rlckdyb3VwcyA9IG9lKCgpID0+IFtlLmdldExlZnRIZWFkZXJHcm91cHMoKV0sICh0KSA9PiBbLi4udF0ucmV2ZXJzZSgpLCBhZShlLm9wdGlvbnMsIGl0LCBcImdldExlZnRGb290ZXJHcm91cHNcIikpLCBlLmdldENlbnRlckZvb3Rlckdyb3VwcyA9IG9lKCgpID0+IFtlLmdldENlbnRlckhlYWRlckdyb3VwcygpXSwgKHQpID0+IFsuLi50XS5yZXZlcnNlKCksIGFlKGUub3B0aW9ucywgaXQsIFwiZ2V0Q2VudGVyRm9vdGVyR3JvdXBzXCIpKSwgZS5nZXRSaWdodEZvb3Rlckdyb3VwcyA9IG9lKCgpID0+IFtlLmdldFJpZ2h0SGVhZGVyR3JvdXBzKCldLCAodCkgPT4gWy4uLnRdLnJldmVyc2UoKSwgYWUoZS5vcHRpb25zLCBpdCwgXCJnZXRSaWdodEZvb3Rlckdyb3Vwc1wiKSksIGUuZ2V0RmxhdEhlYWRlcnMgPSBvZSgoKSA9PiBbZS5nZXRIZWFkZXJHcm91cHMoKV0sICh0KSA9PiB0Lm1hcCgobikgPT4gbi5oZWFkZXJzKS5mbGF0KCksIGFlKGUub3B0aW9ucywgaXQsIFwiZ2V0RmxhdEhlYWRlcnNcIikpLCBlLmdldExlZnRGbGF0SGVhZGVycyA9IG9lKCgpID0+IFtlLmdldExlZnRIZWFkZXJHcm91cHMoKV0sICh0KSA9PiB0Lm1hcCgobikgPT4gbi5oZWFkZXJzKS5mbGF0KCksIGFlKGUub3B0aW9ucywgaXQsIFwiZ2V0TGVmdEZsYXRIZWFkZXJzXCIpKSwgZS5nZXRDZW50ZXJGbGF0SGVhZGVycyA9IG9lKCgpID0+IFtlLmdldENlbnRlckhlYWRlckdyb3VwcygpXSwgKHQpID0+IHQubWFwKChuKSA9PiBuLmhlYWRlcnMpLmZsYXQoKSwgYWUoZS5vcHRpb25zLCBpdCwgXCJnZXRDZW50ZXJGbGF0SGVhZGVyc1wiKSksIGUuZ2V0UmlnaHRGbGF0SGVhZGVycyA9IG9lKCgpID0+IFtlLmdldFJpZ2h0SGVhZGVyR3JvdXBzKCldLCAodCkgPT4gdC5tYXAoKG4pID0+IG4uaGVhZGVycykuZmxhdCgpLCBhZShlLm9wdGlvbnMsIGl0LCBcImdldFJpZ2h0RmxhdEhlYWRlcnNcIikpLCBlLmdldENlbnRlckxlYWZIZWFkZXJzID0gb2UoKCkgPT4gW2UuZ2V0Q2VudGVyRmxhdEhlYWRlcnMoKV0sICh0KSA9PiB0LmZpbHRlcigobikgPT4ge1xuICAgICAgdmFyIHI7XG4gICAgICByZXR1cm4gISgociA9IG4uc3ViSGVhZGVycykgIT0gbnVsbCAmJiByLmxlbmd0aCk7XG4gICAgfSksIGFlKGUub3B0aW9ucywgaXQsIFwiZ2V0Q2VudGVyTGVhZkhlYWRlcnNcIikpLCBlLmdldExlZnRMZWFmSGVhZGVycyA9IG9lKCgpID0+IFtlLmdldExlZnRGbGF0SGVhZGVycygpXSwgKHQpID0+IHQuZmlsdGVyKChuKSA9PiB7XG4gICAgICB2YXIgcjtcbiAgICAgIHJldHVybiAhKChyID0gbi5zdWJIZWFkZXJzKSAhPSBudWxsICYmIHIubGVuZ3RoKTtcbiAgICB9KSwgYWUoZS5vcHRpb25zLCBpdCwgXCJnZXRMZWZ0TGVhZkhlYWRlcnNcIikpLCBlLmdldFJpZ2h0TGVhZkhlYWRlcnMgPSBvZSgoKSA9PiBbZS5nZXRSaWdodEZsYXRIZWFkZXJzKCldLCAodCkgPT4gdC5maWx0ZXIoKG4pID0+IHtcbiAgICAgIHZhciByO1xuICAgICAgcmV0dXJuICEoKHIgPSBuLnN1YkhlYWRlcnMpICE9IG51bGwgJiYgci5sZW5ndGgpO1xuICAgIH0pLCBhZShlLm9wdGlvbnMsIGl0LCBcImdldFJpZ2h0TGVhZkhlYWRlcnNcIikpLCBlLmdldExlYWZIZWFkZXJzID0gb2UoKCkgPT4gW2UuZ2V0TGVmdEhlYWRlckdyb3VwcygpLCBlLmdldENlbnRlckhlYWRlckdyb3VwcygpLCBlLmdldFJpZ2h0SGVhZGVyR3JvdXBzKCldLCAodCwgbiwgcikgPT4ge1xuICAgICAgdmFyIGksIG8sIGEsIHMsIHUsIGM7XG4gICAgICByZXR1cm4gWy4uLihpID0gKG8gPSB0WzBdKSA9PSBudWxsID8gdm9pZCAwIDogby5oZWFkZXJzKSAhPSBudWxsID8gaSA6IFtdLCAuLi4oYSA9IChzID0gblswXSkgPT0gbnVsbCA/IHZvaWQgMCA6IHMuaGVhZGVycykgIT0gbnVsbCA/IGEgOiBbXSwgLi4uKHUgPSAoYyA9IHJbMF0pID09IG51bGwgPyB2b2lkIDAgOiBjLmhlYWRlcnMpICE9IG51bGwgPyB1IDogW11dLm1hcCgoZikgPT4gZi5nZXRMZWFmSGVhZGVycygpKS5mbGF0KCk7XG4gICAgfSwgYWUoZS5vcHRpb25zLCBpdCwgXCJnZXRMZWFmSGVhZGVyc1wiKSk7XG4gIH1cbn07XG5mdW5jdGlvbiAkYShlLCB0LCBuLCByKSB7XG4gIHZhciBpLCBvO1xuICBsZXQgYSA9IDA7XG4gIGNvbnN0IHMgPSBmdW5jdGlvbihkLCBwKSB7XG4gICAgcCA9PT0gdm9pZCAwICYmIChwID0gMSksIGEgPSBNYXRoLm1heChhLCBwKSwgZC5maWx0ZXIoKGcpID0+IGcuZ2V0SXNWaXNpYmxlKCkpLmZvckVhY2goKGcpID0+IHtcbiAgICAgIHZhciBoO1xuICAgICAgKGggPSBnLmNvbHVtbnMpICE9IG51bGwgJiYgaC5sZW5ndGggJiYgcyhnLmNvbHVtbnMsIHAgKyAxKTtcbiAgICB9LCAwKTtcbiAgfTtcbiAgcyhlKTtcbiAgbGV0IHUgPSBbXTtcbiAgY29uc3QgYyA9IChkLCBwKSA9PiB7XG4gICAgY29uc3QgZyA9IHtcbiAgICAgIGRlcHRoOiBwLFxuICAgICAgaWQ6IFtyLCBgJHtwfWBdLmZpbHRlcihCb29sZWFuKS5qb2luKFwiX1wiKSxcbiAgICAgIGhlYWRlcnM6IFtdXG4gICAgfSwgaCA9IFtdO1xuICAgIGQuZm9yRWFjaCgodikgPT4ge1xuICAgICAgY29uc3QgdyA9IFsuLi5oXS5yZXZlcnNlKClbMF0sIGIgPSB2LmNvbHVtbi5kZXB0aCA9PT0gZy5kZXB0aDtcbiAgICAgIGxldCB4LCBtID0gITE7XG4gICAgICBpZiAoYiAmJiB2LmNvbHVtbi5wYXJlbnQgPyB4ID0gdi5jb2x1bW4ucGFyZW50IDogKHggPSB2LmNvbHVtbiwgbSA9ICEwKSwgdyAmJiAodyA9PSBudWxsID8gdm9pZCAwIDogdy5jb2x1bW4pID09PSB4KVxuICAgICAgICB3LnN1YkhlYWRlcnMucHVzaCh2KTtcbiAgICAgIGVsc2Uge1xuICAgICAgICBjb25zdCB5ID0gb20obiwgeCwge1xuICAgICAgICAgIGlkOiBbciwgcCwgeC5pZCwgdiA9PSBudWxsID8gdm9pZCAwIDogdi5pZF0uZmlsdGVyKEJvb2xlYW4pLmpvaW4oXCJfXCIpLFxuICAgICAgICAgIGlzUGxhY2Vob2xkZXI6IG0sXG4gICAgICAgICAgcGxhY2Vob2xkZXJJZDogbSA/IGAke2guZmlsdGVyKChTKSA9PiBTLmNvbHVtbiA9PT0geCkubGVuZ3RofWAgOiB2b2lkIDAsXG4gICAgICAgICAgZGVwdGg6IHAsXG4gICAgICAgICAgaW5kZXg6IGgubGVuZ3RoXG4gICAgICAgIH0pO1xuICAgICAgICB5LnN1YkhlYWRlcnMucHVzaCh2KSwgaC5wdXNoKHkpO1xuICAgICAgfVxuICAgICAgZy5oZWFkZXJzLnB1c2godiksIHYuaGVhZGVyR3JvdXAgPSBnO1xuICAgIH0pLCB1LnB1c2goZyksIHAgPiAwICYmIGMoaCwgcCAtIDEpO1xuICB9LCBmID0gdC5tYXAoKGQsIHApID0+IG9tKG4sIGQsIHtcbiAgICBkZXB0aDogYSxcbiAgICBpbmRleDogcFxuICB9KSk7XG4gIGMoZiwgYSAtIDEpLCB1LnJldmVyc2UoKTtcbiAgY29uc3QgbCA9IChkKSA9PiBkLmZpbHRlcigoZykgPT4gZy5jb2x1bW4uZ2V0SXNWaXNpYmxlKCkpLm1hcCgoZykgPT4ge1xuICAgIGxldCBoID0gMCwgdiA9IDAsIHcgPSBbMF07XG4gICAgZy5zdWJIZWFkZXJzICYmIGcuc3ViSGVhZGVycy5sZW5ndGggPyAodyA9IFtdLCBsKGcuc3ViSGVhZGVycykuZm9yRWFjaCgoeCkgPT4ge1xuICAgICAgbGV0IHtcbiAgICAgICAgY29sU3BhbjogbSxcbiAgICAgICAgcm93U3BhbjogeVxuICAgICAgfSA9IHg7XG4gICAgICBoICs9IG0sIHcucHVzaCh5KTtcbiAgICB9KSkgOiBoID0gMTtcbiAgICBjb25zdCBiID0gTWF0aC5taW4oLi4udyk7XG4gICAgcmV0dXJuIHYgPSB2ICsgYiwgZy5jb2xTcGFuID0gaCwgZy5yb3dTcGFuID0gdiwge1xuICAgICAgY29sU3BhbjogaCxcbiAgICAgIHJvd1NwYW46IHZcbiAgICB9O1xuICB9KTtcbiAgcmV0dXJuIGwoKGkgPSAobyA9IHVbMF0pID09IG51bGwgPyB2b2lkIDAgOiBvLmhlYWRlcnMpICE9IG51bGwgPyBpIDogW10pLCB1O1xufVxuY29uc3QgU2QgPSAoZSwgdCwgbiwgciwgaSwgbywgYSkgPT4ge1xuICBsZXQgcyA9IHtcbiAgICBpZDogdCxcbiAgICBpbmRleDogcixcbiAgICBvcmlnaW5hbDogbixcbiAgICBkZXB0aDogaSxcbiAgICBwYXJlbnRJZDogYSxcbiAgICBfdmFsdWVzQ2FjaGU6IHt9LFxuICAgIF91bmlxdWVWYWx1ZXNDYWNoZToge30sXG4gICAgZ2V0VmFsdWU6ICh1KSA9PiB7XG4gICAgICBpZiAocy5fdmFsdWVzQ2FjaGUuaGFzT3duUHJvcGVydHkodSkpXG4gICAgICAgIHJldHVybiBzLl92YWx1ZXNDYWNoZVt1XTtcbiAgICAgIGNvbnN0IGMgPSBlLmdldENvbHVtbih1KTtcbiAgICAgIGlmIChjICE9IG51bGwgJiYgYy5hY2Nlc3NvckZuKVxuICAgICAgICByZXR1cm4gcy5fdmFsdWVzQ2FjaGVbdV0gPSBjLmFjY2Vzc29yRm4ocy5vcmlnaW5hbCwgciksIHMuX3ZhbHVlc0NhY2hlW3VdO1xuICAgIH0sXG4gICAgZ2V0VW5pcXVlVmFsdWVzOiAodSkgPT4ge1xuICAgICAgaWYgKHMuX3VuaXF1ZVZhbHVlc0NhY2hlLmhhc093blByb3BlcnR5KHUpKVxuICAgICAgICByZXR1cm4gcy5fdW5pcXVlVmFsdWVzQ2FjaGVbdV07XG4gICAgICBjb25zdCBjID0gZS5nZXRDb2x1bW4odSk7XG4gICAgICBpZiAoYyAhPSBudWxsICYmIGMuYWNjZXNzb3JGbilcbiAgICAgICAgcmV0dXJuIGMuY29sdW1uRGVmLmdldFVuaXF1ZVZhbHVlcyA/IChzLl91bmlxdWVWYWx1ZXNDYWNoZVt1XSA9IGMuY29sdW1uRGVmLmdldFVuaXF1ZVZhbHVlcyhzLm9yaWdpbmFsLCByKSwgcy5fdW5pcXVlVmFsdWVzQ2FjaGVbdV0pIDogKHMuX3VuaXF1ZVZhbHVlc0NhY2hlW3VdID0gW3MuZ2V0VmFsdWUodSldLCBzLl91bmlxdWVWYWx1ZXNDYWNoZVt1XSk7XG4gICAgfSxcbiAgICByZW5kZXJWYWx1ZTogKHUpID0+IHtcbiAgICAgIHZhciBjO1xuICAgICAgcmV0dXJuIChjID0gcy5nZXRWYWx1ZSh1KSkgIT0gbnVsbCA/IGMgOiBlLm9wdGlvbnMucmVuZGVyRmFsbGJhY2tWYWx1ZTtcbiAgICB9LFxuICAgIHN1YlJvd3M6IFtdLFxuICAgIGdldExlYWZSb3dzOiAoKSA9PiBZVyhzLnN1YlJvd3MsICh1KSA9PiB1LnN1YlJvd3MpLFxuICAgIGdldFBhcmVudFJvdzogKCkgPT4gcy5wYXJlbnRJZCA/IGUuZ2V0Um93KHMucGFyZW50SWQsICEwKSA6IHZvaWQgMCxcbiAgICBnZXRQYXJlbnRSb3dzOiAoKSA9PiB7XG4gICAgICBsZXQgdSA9IFtdLCBjID0gcztcbiAgICAgIGZvciAoOyA7ICkge1xuICAgICAgICBjb25zdCBmID0gYy5nZXRQYXJlbnRSb3coKTtcbiAgICAgICAgaWYgKCFmKVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB1LnB1c2goZiksIGMgPSBmO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHUucmV2ZXJzZSgpO1xuICAgIH0sXG4gICAgZ2V0QWxsQ2VsbHM6IG9lKCgpID0+IFtlLmdldEFsbExlYWZDb2x1bW5zKCldLCAodSkgPT4gdS5tYXAoKGMpID0+IFhXKGUsIHMsIGMsIGMuaWQpKSwgYWUoZS5vcHRpb25zLCBcImRlYnVnUm93c1wiLCBcImdldEFsbENlbGxzXCIpKSxcbiAgICBfZ2V0QWxsQ2VsbHNCeUNvbHVtbklkOiBvZSgoKSA9PiBbcy5nZXRBbGxDZWxscygpXSwgKHUpID0+IHUucmVkdWNlKChjLCBmKSA9PiAoY1tmLmNvbHVtbi5pZF0gPSBmLCBjKSwge30pLCBhZShlLm9wdGlvbnMsIFwiZGVidWdSb3dzXCIsIFwiZ2V0QWxsQ2VsbHNCeUNvbHVtbklkXCIpKVxuICB9O1xuICBmb3IgKGxldCB1ID0gMDsgdSA8IGUuX2ZlYXR1cmVzLmxlbmd0aDsgdSsrKSB7XG4gICAgY29uc3QgYyA9IGUuX2ZlYXR1cmVzW3VdO1xuICAgIGMgPT0gbnVsbCB8fCBjLmNyZWF0ZVJvdyA9PSBudWxsIHx8IGMuY3JlYXRlUm93KHMsIGUpO1xuICB9XG4gIHJldHVybiBzO1xufSwgUVcgPSB7XG4gIGNyZWF0ZUNvbHVtbjogKGUsIHQpID0+IHtcbiAgICBlLl9nZXRGYWNldGVkUm93TW9kZWwgPSB0Lm9wdGlvbnMuZ2V0RmFjZXRlZFJvd01vZGVsICYmIHQub3B0aW9ucy5nZXRGYWNldGVkUm93TW9kZWwodCwgZS5pZCksIGUuZ2V0RmFjZXRlZFJvd01vZGVsID0gKCkgPT4gZS5fZ2V0RmFjZXRlZFJvd01vZGVsID8gZS5fZ2V0RmFjZXRlZFJvd01vZGVsKCkgOiB0LmdldFByZUZpbHRlcmVkUm93TW9kZWwoKSwgZS5fZ2V0RmFjZXRlZFVuaXF1ZVZhbHVlcyA9IHQub3B0aW9ucy5nZXRGYWNldGVkVW5pcXVlVmFsdWVzICYmIHQub3B0aW9ucy5nZXRGYWNldGVkVW5pcXVlVmFsdWVzKHQsIGUuaWQpLCBlLmdldEZhY2V0ZWRVbmlxdWVWYWx1ZXMgPSAoKSA9PiBlLl9nZXRGYWNldGVkVW5pcXVlVmFsdWVzID8gZS5fZ2V0RmFjZXRlZFVuaXF1ZVZhbHVlcygpIDogLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSwgZS5fZ2V0RmFjZXRlZE1pbk1heFZhbHVlcyA9IHQub3B0aW9ucy5nZXRGYWNldGVkTWluTWF4VmFsdWVzICYmIHQub3B0aW9ucy5nZXRGYWNldGVkTWluTWF4VmFsdWVzKHQsIGUuaWQpLCBlLmdldEZhY2V0ZWRNaW5NYXhWYWx1ZXMgPSAoKSA9PiB7XG4gICAgICBpZiAoZS5fZ2V0RmFjZXRlZE1pbk1heFZhbHVlcylcbiAgICAgICAgcmV0dXJuIGUuX2dldEZhY2V0ZWRNaW5NYXhWYWx1ZXMoKTtcbiAgICB9O1xuICB9XG59LCBWdyA9IChlLCB0LCBuKSA9PiB7XG4gIHZhciByO1xuICBjb25zdCBpID0gbi50b0xvd2VyQ2FzZSgpO1xuICByZXR1cm4gISEoISgociA9IGUuZ2V0VmFsdWUodCkpID09IG51bGwgfHwgKHIgPSByLnRvU3RyaW5nKCkpID09IG51bGwgfHwgKHIgPSByLnRvTG93ZXJDYXNlKCkpID09IG51bGwpICYmIHIuaW5jbHVkZXMoaSkpO1xufTtcblZ3LmF1dG9SZW1vdmUgPSAoZSkgPT4gWHQoZSk7XG5jb25zdCBHdyA9IChlLCB0LCBuKSA9PiB7XG4gIHZhciByO1xuICByZXR1cm4gISEoISgociA9IGUuZ2V0VmFsdWUodCkpID09IG51bGwgfHwgKHIgPSByLnRvU3RyaW5nKCkpID09IG51bGwpICYmIHIuaW5jbHVkZXMobikpO1xufTtcbkd3LmF1dG9SZW1vdmUgPSAoZSkgPT4gWHQoZSk7XG5jb25zdCBXdyA9IChlLCB0LCBuKSA9PiB7XG4gIHZhciByO1xuICByZXR1cm4gKChyID0gZS5nZXRWYWx1ZSh0KSkgPT0gbnVsbCB8fCAociA9IHIudG9TdHJpbmcoKSkgPT0gbnVsbCA/IHZvaWQgMCA6IHIudG9Mb3dlckNhc2UoKSkgPT09IChuID09IG51bGwgPyB2b2lkIDAgOiBuLnRvTG93ZXJDYXNlKCkpO1xufTtcbld3LmF1dG9SZW1vdmUgPSAoZSkgPT4gWHQoZSk7XG5jb25zdCBVdyA9IChlLCB0LCBuKSA9PiB7XG4gIHZhciByO1xuICByZXR1cm4gKHIgPSBlLmdldFZhbHVlKHQpKSA9PSBudWxsID8gdm9pZCAwIDogci5pbmNsdWRlcyhuKTtcbn07XG5Vdy5hdXRvUmVtb3ZlID0gKGUpID0+IFh0KGUpIHx8ICEoZSAhPSBudWxsICYmIGUubGVuZ3RoKTtcbmNvbnN0IEh3ID0gKGUsIHQsIG4pID0+ICFuLnNvbWUoKHIpID0+IHtcbiAgdmFyIGk7XG4gIHJldHVybiAhKChpID0gZS5nZXRWYWx1ZSh0KSkgIT0gbnVsbCAmJiBpLmluY2x1ZGVzKHIpKTtcbn0pO1xuSHcuYXV0b1JlbW92ZSA9IChlKSA9PiBYdChlKSB8fCAhKGUgIT0gbnVsbCAmJiBlLmxlbmd0aCk7XG5jb25zdCBxdyA9IChlLCB0LCBuKSA9PiBuLnNvbWUoKHIpID0+IHtcbiAgdmFyIGk7XG4gIHJldHVybiAoaSA9IGUuZ2V0VmFsdWUodCkpID09IG51bGwgPyB2b2lkIDAgOiBpLmluY2x1ZGVzKHIpO1xufSk7XG5xdy5hdXRvUmVtb3ZlID0gKGUpID0+IFh0KGUpIHx8ICEoZSAhPSBudWxsICYmIGUubGVuZ3RoKTtcbmNvbnN0IEt3ID0gKGUsIHQsIG4pID0+IGUuZ2V0VmFsdWUodCkgPT09IG47XG5Ldy5hdXRvUmVtb3ZlID0gKGUpID0+IFh0KGUpO1xuY29uc3QgWXcgPSAoZSwgdCwgbikgPT4gZS5nZXRWYWx1ZSh0KSA9PSBuO1xuWXcuYXV0b1JlbW92ZSA9IChlKSA9PiBYdChlKTtcbmNvbnN0ICRkID0gKGUsIHQsIG4pID0+IHtcbiAgbGV0IFtyLCBpXSA9IG47XG4gIGNvbnN0IG8gPSBlLmdldFZhbHVlKHQpO1xuICByZXR1cm4gbyA+PSByICYmIG8gPD0gaTtcbn07XG4kZC5yZXNvbHZlRmlsdGVyVmFsdWUgPSAoZSkgPT4ge1xuICBsZXQgW3QsIG5dID0gZSwgciA9IHR5cGVvZiB0ICE9IFwibnVtYmVyXCIgPyBwYXJzZUZsb2F0KHQpIDogdCwgaSA9IHR5cGVvZiBuICE9IFwibnVtYmVyXCIgPyBwYXJzZUZsb2F0KG4pIDogbiwgbyA9IHQgPT09IG51bGwgfHwgTnVtYmVyLmlzTmFOKHIpID8gLTEgLyAwIDogciwgYSA9IG4gPT09IG51bGwgfHwgTnVtYmVyLmlzTmFOKGkpID8gMSAvIDAgOiBpO1xuICBpZiAobyA+IGEpIHtcbiAgICBjb25zdCBzID0gbztcbiAgICBvID0gYSwgYSA9IHM7XG4gIH1cbiAgcmV0dXJuIFtvLCBhXTtcbn07XG4kZC5hdXRvUmVtb3ZlID0gKGUpID0+IFh0KGUpIHx8IFh0KGVbMF0pICYmIFh0KGVbMV0pO1xuY29uc3QgaG4gPSB7XG4gIGluY2x1ZGVzU3RyaW5nOiBWdyxcbiAgaW5jbHVkZXNTdHJpbmdTZW5zaXRpdmU6IEd3LFxuICBlcXVhbHNTdHJpbmc6IFd3LFxuICBhcnJJbmNsdWRlczogVXcsXG4gIGFyckluY2x1ZGVzQWxsOiBIdyxcbiAgYXJySW5jbHVkZXNTb21lOiBxdyxcbiAgZXF1YWxzOiBLdyxcbiAgd2Vha0VxdWFsczogWXcsXG4gIGluTnVtYmVyUmFuZ2U6ICRkXG59O1xuZnVuY3Rpb24gWHQoZSkge1xuICByZXR1cm4gZSA9PSBudWxsIHx8IGUgPT09IFwiXCI7XG59XG5jb25zdCBlVSA9IHtcbiAgZ2V0RGVmYXVsdENvbHVtbkRlZjogKCkgPT4gKHtcbiAgICBmaWx0ZXJGbjogXCJhdXRvXCJcbiAgfSksXG4gIGdldEluaXRpYWxTdGF0ZTogKGUpID0+ICh7XG4gICAgY29sdW1uRmlsdGVyczogW10sXG4gICAgLi4uZVxuICB9KSxcbiAgZ2V0RGVmYXVsdE9wdGlvbnM6IChlKSA9PiAoe1xuICAgIG9uQ29sdW1uRmlsdGVyc0NoYW5nZTogUHQoXCJjb2x1bW5GaWx0ZXJzXCIsIGUpLFxuICAgIGZpbHRlckZyb21MZWFmUm93czogITEsXG4gICAgbWF4TGVhZlJvd0ZpbHRlckRlcHRoOiAxMDBcbiAgfSksXG4gIGNyZWF0ZUNvbHVtbjogKGUsIHQpID0+IHtcbiAgICBlLmdldEF1dG9GaWx0ZXJGbiA9ICgpID0+IHtcbiAgICAgIGNvbnN0IG4gPSB0LmdldENvcmVSb3dNb2RlbCgpLmZsYXRSb3dzWzBdLCByID0gbiA9PSBudWxsID8gdm9pZCAwIDogbi5nZXRWYWx1ZShlLmlkKTtcbiAgICAgIHJldHVybiB0eXBlb2YgciA9PSBcInN0cmluZ1wiID8gaG4uaW5jbHVkZXNTdHJpbmcgOiB0eXBlb2YgciA9PSBcIm51bWJlclwiID8gaG4uaW5OdW1iZXJSYW5nZSA6IHR5cGVvZiByID09IFwiYm9vbGVhblwiIHx8IHIgIT09IG51bGwgJiYgdHlwZW9mIHIgPT0gXCJvYmplY3RcIiA/IGhuLmVxdWFscyA6IEFycmF5LmlzQXJyYXkocikgPyBobi5hcnJJbmNsdWRlcyA6IGhuLndlYWtFcXVhbHM7XG4gICAgfSwgZS5nZXRGaWx0ZXJGbiA9ICgpID0+IHtcbiAgICAgIHZhciBuLCByO1xuICAgICAgcmV0dXJuIGx1KGUuY29sdW1uRGVmLmZpbHRlckZuKSA/IGUuY29sdW1uRGVmLmZpbHRlckZuIDogZS5jb2x1bW5EZWYuZmlsdGVyRm4gPT09IFwiYXV0b1wiID8gZS5nZXRBdXRvRmlsdGVyRm4oKSA6IChcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAobiA9IChyID0gdC5vcHRpb25zLmZpbHRlckZucykgPT0gbnVsbCA/IHZvaWQgMCA6IHJbZS5jb2x1bW5EZWYuZmlsdGVyRm5dKSAhPSBudWxsID8gbiA6IGhuW2UuY29sdW1uRGVmLmZpbHRlckZuXVxuICAgICAgKTtcbiAgICB9LCBlLmdldENhbkZpbHRlciA9ICgpID0+IHtcbiAgICAgIHZhciBuLCByLCBpO1xuICAgICAgcmV0dXJuICgobiA9IGUuY29sdW1uRGVmLmVuYWJsZUNvbHVtbkZpbHRlcikgIT0gbnVsbCA/IG4gOiAhMCkgJiYgKChyID0gdC5vcHRpb25zLmVuYWJsZUNvbHVtbkZpbHRlcnMpICE9IG51bGwgPyByIDogITApICYmICgoaSA9IHQub3B0aW9ucy5lbmFibGVGaWx0ZXJzKSAhPSBudWxsID8gaSA6ICEwKSAmJiAhIWUuYWNjZXNzb3JGbjtcbiAgICB9LCBlLmdldElzRmlsdGVyZWQgPSAoKSA9PiBlLmdldEZpbHRlckluZGV4KCkgPiAtMSwgZS5nZXRGaWx0ZXJWYWx1ZSA9ICgpID0+IHtcbiAgICAgIHZhciBuO1xuICAgICAgcmV0dXJuIChuID0gdC5nZXRTdGF0ZSgpLmNvbHVtbkZpbHRlcnMpID09IG51bGwgfHwgKG4gPSBuLmZpbmQoKHIpID0+IHIuaWQgPT09IGUuaWQpKSA9PSBudWxsID8gdm9pZCAwIDogbi52YWx1ZTtcbiAgICB9LCBlLmdldEZpbHRlckluZGV4ID0gKCkgPT4ge1xuICAgICAgdmFyIG4sIHI7XG4gICAgICByZXR1cm4gKG4gPSAociA9IHQuZ2V0U3RhdGUoKS5jb2x1bW5GaWx0ZXJzKSA9PSBudWxsID8gdm9pZCAwIDogci5maW5kSW5kZXgoKGkpID0+IGkuaWQgPT09IGUuaWQpKSAhPSBudWxsID8gbiA6IC0xO1xuICAgIH0sIGUuc2V0RmlsdGVyVmFsdWUgPSAobikgPT4ge1xuICAgICAgdC5zZXRDb2x1bW5GaWx0ZXJzKChyKSA9PiB7XG4gICAgICAgIGNvbnN0IGkgPSBlLmdldEZpbHRlckZuKCksIG8gPSByID09IG51bGwgPyB2b2lkIDAgOiByLmZpbmQoKGYpID0+IGYuaWQgPT09IGUuaWQpLCBhID0gTm4obiwgbyA/IG8udmFsdWUgOiB2b2lkIDApO1xuICAgICAgICBpZiAoYW0oaSwgYSwgZSkpIHtcbiAgICAgICAgICB2YXIgcztcbiAgICAgICAgICByZXR1cm4gKHMgPSByID09IG51bGwgPyB2b2lkIDAgOiByLmZpbHRlcigoZikgPT4gZi5pZCAhPT0gZS5pZCkpICE9IG51bGwgPyBzIDogW107XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdSA9IHtcbiAgICAgICAgICBpZDogZS5pZCxcbiAgICAgICAgICB2YWx1ZTogYVxuICAgICAgICB9O1xuICAgICAgICBpZiAobykge1xuICAgICAgICAgIHZhciBjO1xuICAgICAgICAgIHJldHVybiAoYyA9IHIgPT0gbnVsbCA/IHZvaWQgMCA6IHIubWFwKChmKSA9PiBmLmlkID09PSBlLmlkID8gdSA6IGYpKSAhPSBudWxsID8gYyA6IFtdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByICE9IG51bGwgJiYgci5sZW5ndGggPyBbLi4uciwgdV0gOiBbdV07XG4gICAgICB9KTtcbiAgICB9O1xuICB9LFxuICBjcmVhdGVSb3c6IChlLCB0KSA9PiB7XG4gICAgZS5jb2x1bW5GaWx0ZXJzID0ge30sIGUuY29sdW1uRmlsdGVyc01ldGEgPSB7fTtcbiAgfSxcbiAgY3JlYXRlVGFibGU6IChlKSA9PiB7XG4gICAgZS5zZXRDb2x1bW5GaWx0ZXJzID0gKHQpID0+IHtcbiAgICAgIGNvbnN0IG4gPSBlLmdldEFsbExlYWZDb2x1bW5zKCksIHIgPSAoaSkgPT4ge1xuICAgICAgICB2YXIgbztcbiAgICAgICAgcmV0dXJuIChvID0gTm4odCwgaSkpID09IG51bGwgPyB2b2lkIDAgOiBvLmZpbHRlcigoYSkgPT4ge1xuICAgICAgICAgIGNvbnN0IHMgPSBuLmZpbmQoKHUpID0+IHUuaWQgPT09IGEuaWQpO1xuICAgICAgICAgIGlmIChzKSB7XG4gICAgICAgICAgICBjb25zdCB1ID0gcy5nZXRGaWx0ZXJGbigpO1xuICAgICAgICAgICAgaWYgKGFtKHUsIGEudmFsdWUsIHMpKVxuICAgICAgICAgICAgICByZXR1cm4gITE7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiAhMDtcbiAgICAgICAgfSk7XG4gICAgICB9O1xuICAgICAgZS5vcHRpb25zLm9uQ29sdW1uRmlsdGVyc0NoYW5nZSA9PSBudWxsIHx8IGUub3B0aW9ucy5vbkNvbHVtbkZpbHRlcnNDaGFuZ2Uocik7XG4gICAgfSwgZS5yZXNldENvbHVtbkZpbHRlcnMgPSAodCkgPT4ge1xuICAgICAgdmFyIG4sIHI7XG4gICAgICBlLnNldENvbHVtbkZpbHRlcnModCA/IFtdIDogKG4gPSAociA9IGUuaW5pdGlhbFN0YXRlKSA9PSBudWxsID8gdm9pZCAwIDogci5jb2x1bW5GaWx0ZXJzKSAhPSBudWxsID8gbiA6IFtdKTtcbiAgICB9LCBlLmdldFByZUZpbHRlcmVkUm93TW9kZWwgPSAoKSA9PiBlLmdldENvcmVSb3dNb2RlbCgpLCBlLmdldEZpbHRlcmVkUm93TW9kZWwgPSAoKSA9PiAoIWUuX2dldEZpbHRlcmVkUm93TW9kZWwgJiYgZS5vcHRpb25zLmdldEZpbHRlcmVkUm93TW9kZWwgJiYgKGUuX2dldEZpbHRlcmVkUm93TW9kZWwgPSBlLm9wdGlvbnMuZ2V0RmlsdGVyZWRSb3dNb2RlbChlKSksIGUub3B0aW9ucy5tYW51YWxGaWx0ZXJpbmcgfHwgIWUuX2dldEZpbHRlcmVkUm93TW9kZWwgPyBlLmdldFByZUZpbHRlcmVkUm93TW9kZWwoKSA6IGUuX2dldEZpbHRlcmVkUm93TW9kZWwoKSk7XG4gIH1cbn07XG5mdW5jdGlvbiBhbShlLCB0LCBuKSB7XG4gIHJldHVybiAoZSAmJiBlLmF1dG9SZW1vdmUgPyBlLmF1dG9SZW1vdmUodCwgbikgOiAhMSkgfHwgdHlwZW9mIHQgPiBcInVcIiB8fCB0eXBlb2YgdCA9PSBcInN0cmluZ1wiICYmICF0O1xufVxuY29uc3QgdFUgPSAoZSwgdCwgbikgPT4gbi5yZWR1Y2UoKHIsIGkpID0+IHtcbiAgY29uc3QgbyA9IGkuZ2V0VmFsdWUoZSk7XG4gIHJldHVybiByICsgKHR5cGVvZiBvID09IFwibnVtYmVyXCIgPyBvIDogMCk7XG59LCAwKSwgblUgPSAoZSwgdCwgbikgPT4ge1xuICBsZXQgcjtcbiAgcmV0dXJuIG4uZm9yRWFjaCgoaSkgPT4ge1xuICAgIGNvbnN0IG8gPSBpLmdldFZhbHVlKGUpO1xuICAgIG8gIT0gbnVsbCAmJiAociA+IG8gfHwgciA9PT0gdm9pZCAwICYmIG8gPj0gbykgJiYgKHIgPSBvKTtcbiAgfSksIHI7XG59LCByVSA9IChlLCB0LCBuKSA9PiB7XG4gIGxldCByO1xuICByZXR1cm4gbi5mb3JFYWNoKChpKSA9PiB7XG4gICAgY29uc3QgbyA9IGkuZ2V0VmFsdWUoZSk7XG4gICAgbyAhPSBudWxsICYmIChyIDwgbyB8fCByID09PSB2b2lkIDAgJiYgbyA+PSBvKSAmJiAociA9IG8pO1xuICB9KSwgcjtcbn0sIGlVID0gKGUsIHQsIG4pID0+IHtcbiAgbGV0IHIsIGk7XG4gIHJldHVybiBuLmZvckVhY2goKG8pID0+IHtcbiAgICBjb25zdCBhID0gby5nZXRWYWx1ZShlKTtcbiAgICBhICE9IG51bGwgJiYgKHIgPT09IHZvaWQgMCA/IGEgPj0gYSAmJiAociA9IGkgPSBhKSA6IChyID4gYSAmJiAociA9IGEpLCBpIDwgYSAmJiAoaSA9IGEpKSk7XG4gIH0pLCBbciwgaV07XG59LCBvVSA9IChlLCB0KSA9PiB7XG4gIGxldCBuID0gMCwgciA9IDA7XG4gIGlmICh0LmZvckVhY2goKGkpID0+IHtcbiAgICBsZXQgbyA9IGkuZ2V0VmFsdWUoZSk7XG4gICAgbyAhPSBudWxsICYmIChvID0gK28pID49IG8gJiYgKCsrbiwgciArPSBvKTtcbiAgfSksIG4pXG4gICAgcmV0dXJuIHIgLyBuO1xufSwgYVUgPSAoZSwgdCkgPT4ge1xuICBpZiAoIXQubGVuZ3RoKVxuICAgIHJldHVybjtcbiAgY29uc3QgbiA9IHQubWFwKChvKSA9PiBvLmdldFZhbHVlKGUpKTtcbiAgaWYgKCFLVyhuKSlcbiAgICByZXR1cm47XG4gIGlmIChuLmxlbmd0aCA9PT0gMSlcbiAgICByZXR1cm4gblswXTtcbiAgY29uc3QgciA9IE1hdGguZmxvb3Iobi5sZW5ndGggLyAyKSwgaSA9IG4uc29ydCgobywgYSkgPT4gbyAtIGEpO1xuICByZXR1cm4gbi5sZW5ndGggJSAyICE9PSAwID8gaVtyXSA6IChpW3IgLSAxXSArIGlbcl0pIC8gMjtcbn0sIHNVID0gKGUsIHQpID0+IEFycmF5LmZyb20obmV3IFNldCh0Lm1hcCgobikgPT4gbi5nZXRWYWx1ZShlKSkpLnZhbHVlcygpKSwgdVUgPSAoZSwgdCkgPT4gbmV3IFNldCh0Lm1hcCgobikgPT4gbi5nZXRWYWx1ZShlKSkpLnNpemUsIGNVID0gKGUsIHQpID0+IHQubGVuZ3RoLCBzYyA9IHtcbiAgc3VtOiB0VSxcbiAgbWluOiBuVSxcbiAgbWF4OiByVSxcbiAgZXh0ZW50OiBpVSxcbiAgbWVhbjogb1UsXG4gIG1lZGlhbjogYVUsXG4gIHVuaXF1ZTogc1UsXG4gIHVuaXF1ZUNvdW50OiB1VSxcbiAgY291bnQ6IGNVXG59LCBsVSA9IHtcbiAgZ2V0RGVmYXVsdENvbHVtbkRlZjogKCkgPT4gKHtcbiAgICBhZ2dyZWdhdGVkQ2VsbDogKGUpID0+IHtcbiAgICAgIHZhciB0LCBuO1xuICAgICAgcmV0dXJuICh0ID0gKG4gPSBlLmdldFZhbHVlKCkpID09IG51bGwgfHwgbi50b1N0cmluZyA9PSBudWxsID8gdm9pZCAwIDogbi50b1N0cmluZygpKSAhPSBudWxsID8gdCA6IG51bGw7XG4gICAgfSxcbiAgICBhZ2dyZWdhdGlvbkZuOiBcImF1dG9cIlxuICB9KSxcbiAgZ2V0SW5pdGlhbFN0YXRlOiAoZSkgPT4gKHtcbiAgICBncm91cGluZzogW10sXG4gICAgLi4uZVxuICB9KSxcbiAgZ2V0RGVmYXVsdE9wdGlvbnM6IChlKSA9PiAoe1xuICAgIG9uR3JvdXBpbmdDaGFuZ2U6IFB0KFwiZ3JvdXBpbmdcIiwgZSksXG4gICAgZ3JvdXBlZENvbHVtbk1vZGU6IFwicmVvcmRlclwiXG4gIH0pLFxuICBjcmVhdGVDb2x1bW46IChlLCB0KSA9PiB7XG4gICAgZS50b2dnbGVHcm91cGluZyA9ICgpID0+IHtcbiAgICAgIHQuc2V0R3JvdXBpbmcoKG4pID0+IG4gIT0gbnVsbCAmJiBuLmluY2x1ZGVzKGUuaWQpID8gbi5maWx0ZXIoKHIpID0+IHIgIT09IGUuaWQpIDogWy4uLm4gPz8gW10sIGUuaWRdKTtcbiAgICB9LCBlLmdldENhbkdyb3VwID0gKCkgPT4ge1xuICAgICAgdmFyIG4sIHI7XG4gICAgICByZXR1cm4gKChuID0gZS5jb2x1bW5EZWYuZW5hYmxlR3JvdXBpbmcpICE9IG51bGwgPyBuIDogITApICYmICgociA9IHQub3B0aW9ucy5lbmFibGVHcm91cGluZykgIT0gbnVsbCA/IHIgOiAhMCkgJiYgKCEhZS5hY2Nlc3NvckZuIHx8ICEhZS5jb2x1bW5EZWYuZ2V0R3JvdXBpbmdWYWx1ZSk7XG4gICAgfSwgZS5nZXRJc0dyb3VwZWQgPSAoKSA9PiB7XG4gICAgICB2YXIgbjtcbiAgICAgIHJldHVybiAobiA9IHQuZ2V0U3RhdGUoKS5ncm91cGluZykgPT0gbnVsbCA/IHZvaWQgMCA6IG4uaW5jbHVkZXMoZS5pZCk7XG4gICAgfSwgZS5nZXRHcm91cGVkSW5kZXggPSAoKSA9PiB7XG4gICAgICB2YXIgbjtcbiAgICAgIHJldHVybiAobiA9IHQuZ2V0U3RhdGUoKS5ncm91cGluZykgPT0gbnVsbCA/IHZvaWQgMCA6IG4uaW5kZXhPZihlLmlkKTtcbiAgICB9LCBlLmdldFRvZ2dsZUdyb3VwaW5nSGFuZGxlciA9ICgpID0+IHtcbiAgICAgIGNvbnN0IG4gPSBlLmdldENhbkdyb3VwKCk7XG4gICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICBuICYmIGUudG9nZ2xlR3JvdXBpbmcoKTtcbiAgICAgIH07XG4gICAgfSwgZS5nZXRBdXRvQWdncmVnYXRpb25GbiA9ICgpID0+IHtcbiAgICAgIGNvbnN0IG4gPSB0LmdldENvcmVSb3dNb2RlbCgpLmZsYXRSb3dzWzBdLCByID0gbiA9PSBudWxsID8gdm9pZCAwIDogbi5nZXRWYWx1ZShlLmlkKTtcbiAgICAgIGlmICh0eXBlb2YgciA9PSBcIm51bWJlclwiKVxuICAgICAgICByZXR1cm4gc2Muc3VtO1xuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChyKSA9PT0gXCJbb2JqZWN0IERhdGVdXCIpXG4gICAgICAgIHJldHVybiBzYy5leHRlbnQ7XG4gICAgfSwgZS5nZXRBZ2dyZWdhdGlvbkZuID0gKCkgPT4ge1xuICAgICAgdmFyIG4sIHI7XG4gICAgICBpZiAoIWUpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcigpO1xuICAgICAgcmV0dXJuIGx1KGUuY29sdW1uRGVmLmFnZ3JlZ2F0aW9uRm4pID8gZS5jb2x1bW5EZWYuYWdncmVnYXRpb25GbiA6IGUuY29sdW1uRGVmLmFnZ3JlZ2F0aW9uRm4gPT09IFwiYXV0b1wiID8gZS5nZXRBdXRvQWdncmVnYXRpb25GbigpIDogKG4gPSAociA9IHQub3B0aW9ucy5hZ2dyZWdhdGlvbkZucykgPT0gbnVsbCA/IHZvaWQgMCA6IHJbZS5jb2x1bW5EZWYuYWdncmVnYXRpb25Gbl0pICE9IG51bGwgPyBuIDogc2NbZS5jb2x1bW5EZWYuYWdncmVnYXRpb25Gbl07XG4gICAgfTtcbiAgfSxcbiAgY3JlYXRlVGFibGU6IChlKSA9PiB7XG4gICAgZS5zZXRHcm91cGluZyA9ICh0KSA9PiBlLm9wdGlvbnMub25Hcm91cGluZ0NoYW5nZSA9PSBudWxsID8gdm9pZCAwIDogZS5vcHRpb25zLm9uR3JvdXBpbmdDaGFuZ2UodCksIGUucmVzZXRHcm91cGluZyA9ICh0KSA9PiB7XG4gICAgICB2YXIgbiwgcjtcbiAgICAgIGUuc2V0R3JvdXBpbmcodCA/IFtdIDogKG4gPSAociA9IGUuaW5pdGlhbFN0YXRlKSA9PSBudWxsID8gdm9pZCAwIDogci5ncm91cGluZykgIT0gbnVsbCA/IG4gOiBbXSk7XG4gICAgfSwgZS5nZXRQcmVHcm91cGVkUm93TW9kZWwgPSAoKSA9PiBlLmdldEZpbHRlcmVkUm93TW9kZWwoKSwgZS5nZXRHcm91cGVkUm93TW9kZWwgPSAoKSA9PiAoIWUuX2dldEdyb3VwZWRSb3dNb2RlbCAmJiBlLm9wdGlvbnMuZ2V0R3JvdXBlZFJvd01vZGVsICYmIChlLl9nZXRHcm91cGVkUm93TW9kZWwgPSBlLm9wdGlvbnMuZ2V0R3JvdXBlZFJvd01vZGVsKGUpKSwgZS5vcHRpb25zLm1hbnVhbEdyb3VwaW5nIHx8ICFlLl9nZXRHcm91cGVkUm93TW9kZWwgPyBlLmdldFByZUdyb3VwZWRSb3dNb2RlbCgpIDogZS5fZ2V0R3JvdXBlZFJvd01vZGVsKCkpO1xuICB9LFxuICBjcmVhdGVSb3c6IChlLCB0KSA9PiB7XG4gICAgZS5nZXRJc0dyb3VwZWQgPSAoKSA9PiAhIWUuZ3JvdXBpbmdDb2x1bW5JZCwgZS5nZXRHcm91cGluZ1ZhbHVlID0gKG4pID0+IHtcbiAgICAgIGlmIChlLl9ncm91cGluZ1ZhbHVlc0NhY2hlLmhhc093blByb3BlcnR5KG4pKVxuICAgICAgICByZXR1cm4gZS5fZ3JvdXBpbmdWYWx1ZXNDYWNoZVtuXTtcbiAgICAgIGNvbnN0IHIgPSB0LmdldENvbHVtbihuKTtcbiAgICAgIHJldHVybiByICE9IG51bGwgJiYgci5jb2x1bW5EZWYuZ2V0R3JvdXBpbmdWYWx1ZSA/IChlLl9ncm91cGluZ1ZhbHVlc0NhY2hlW25dID0gci5jb2x1bW5EZWYuZ2V0R3JvdXBpbmdWYWx1ZShlLm9yaWdpbmFsKSwgZS5fZ3JvdXBpbmdWYWx1ZXNDYWNoZVtuXSkgOiBlLmdldFZhbHVlKG4pO1xuICAgIH0sIGUuX2dyb3VwaW5nVmFsdWVzQ2FjaGUgPSB7fTtcbiAgfSxcbiAgY3JlYXRlQ2VsbDogKGUsIHQsIG4sIHIpID0+IHtcbiAgICBlLmdldElzR3JvdXBlZCA9ICgpID0+IHQuZ2V0SXNHcm91cGVkKCkgJiYgdC5pZCA9PT0gbi5ncm91cGluZ0NvbHVtbklkLCBlLmdldElzUGxhY2Vob2xkZXIgPSAoKSA9PiAhZS5nZXRJc0dyb3VwZWQoKSAmJiB0LmdldElzR3JvdXBlZCgpLCBlLmdldElzQWdncmVnYXRlZCA9ICgpID0+IHtcbiAgICAgIHZhciBpO1xuICAgICAgcmV0dXJuICFlLmdldElzR3JvdXBlZCgpICYmICFlLmdldElzUGxhY2Vob2xkZXIoKSAmJiAhISgoaSA9IG4uc3ViUm93cykgIT0gbnVsbCAmJiBpLmxlbmd0aCk7XG4gICAgfTtcbiAgfVxufTtcbmZ1bmN0aW9uIGZVKGUsIHQsIG4pIHtcbiAgaWYgKCEodCAhPSBudWxsICYmIHQubGVuZ3RoKSB8fCAhbilcbiAgICByZXR1cm4gZTtcbiAgY29uc3QgciA9IGUuZmlsdGVyKChvKSA9PiAhdC5pbmNsdWRlcyhvLmlkKSk7XG4gIHJldHVybiBuID09PSBcInJlbW92ZVwiID8gciA6IFsuLi50Lm1hcCgobykgPT4gZS5maW5kKChhKSA9PiBhLmlkID09PSBvKSkuZmlsdGVyKEJvb2xlYW4pLCAuLi5yXTtcbn1cbmNvbnN0IGRVID0ge1xuICBnZXRJbml0aWFsU3RhdGU6IChlKSA9PiAoe1xuICAgIGNvbHVtbk9yZGVyOiBbXSxcbiAgICAuLi5lXG4gIH0pLFxuICBnZXREZWZhdWx0T3B0aW9uczogKGUpID0+ICh7XG4gICAgb25Db2x1bW5PcmRlckNoYW5nZTogUHQoXCJjb2x1bW5PcmRlclwiLCBlKVxuICB9KSxcbiAgY3JlYXRlQ29sdW1uOiAoZSwgdCkgPT4ge1xuICAgIGUuZ2V0SW5kZXggPSBvZSgobikgPT4gW1lpKHQsIG4pXSwgKG4pID0+IG4uZmluZEluZGV4KChyKSA9PiByLmlkID09PSBlLmlkKSwgYWUodC5vcHRpb25zLCBcImRlYnVnQ29sdW1uc1wiLCBcImdldEluZGV4XCIpKSwgZS5nZXRJc0ZpcnN0Q29sdW1uID0gKG4pID0+IHtcbiAgICAgIHZhciByO1xuICAgICAgcmV0dXJuICgociA9IFlpKHQsIG4pWzBdKSA9PSBudWxsID8gdm9pZCAwIDogci5pZCkgPT09IGUuaWQ7XG4gICAgfSwgZS5nZXRJc0xhc3RDb2x1bW4gPSAobikgPT4ge1xuICAgICAgdmFyIHI7XG4gICAgICBjb25zdCBpID0gWWkodCwgbik7XG4gICAgICByZXR1cm4gKChyID0gaVtpLmxlbmd0aCAtIDFdKSA9PSBudWxsID8gdm9pZCAwIDogci5pZCkgPT09IGUuaWQ7XG4gICAgfTtcbiAgfSxcbiAgY3JlYXRlVGFibGU6IChlKSA9PiB7XG4gICAgZS5zZXRDb2x1bW5PcmRlciA9ICh0KSA9PiBlLm9wdGlvbnMub25Db2x1bW5PcmRlckNoYW5nZSA9PSBudWxsID8gdm9pZCAwIDogZS5vcHRpb25zLm9uQ29sdW1uT3JkZXJDaGFuZ2UodCksIGUucmVzZXRDb2x1bW5PcmRlciA9ICh0KSA9PiB7XG4gICAgICB2YXIgbjtcbiAgICAgIGUuc2V0Q29sdW1uT3JkZXIodCA/IFtdIDogKG4gPSBlLmluaXRpYWxTdGF0ZS5jb2x1bW5PcmRlcikgIT0gbnVsbCA/IG4gOiBbXSk7XG4gICAgfSwgZS5fZ2V0T3JkZXJDb2x1bW5zRm4gPSBvZSgoKSA9PiBbZS5nZXRTdGF0ZSgpLmNvbHVtbk9yZGVyLCBlLmdldFN0YXRlKCkuZ3JvdXBpbmcsIGUub3B0aW9ucy5ncm91cGVkQ29sdW1uTW9kZV0sICh0LCBuLCByKSA9PiAoaSkgPT4ge1xuICAgICAgbGV0IG8gPSBbXTtcbiAgICAgIGlmICghKHQgIT0gbnVsbCAmJiB0Lmxlbmd0aCkpXG4gICAgICAgIG8gPSBpO1xuICAgICAgZWxzZSB7XG4gICAgICAgIGNvbnN0IGEgPSBbLi4udF0sIHMgPSBbLi4uaV07XG4gICAgICAgIGZvciAoOyBzLmxlbmd0aCAmJiBhLmxlbmd0aDsgKSB7XG4gICAgICAgICAgY29uc3QgdSA9IGEuc2hpZnQoKSwgYyA9IHMuZmluZEluZGV4KChmKSA9PiBmLmlkID09PSB1KTtcbiAgICAgICAgICBjID4gLTEgJiYgby5wdXNoKHMuc3BsaWNlKGMsIDEpWzBdKTtcbiAgICAgICAgfVxuICAgICAgICBvID0gWy4uLm8sIC4uLnNdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZVKG8sIG4sIHIpO1xuICAgIH0sIGFlKGUub3B0aW9ucywgXCJkZWJ1Z1RhYmxlXCIsIFwiX2dldE9yZGVyQ29sdW1uc0ZuXCIpKTtcbiAgfVxufSwgdWMgPSAoKSA9PiAoe1xuICBsZWZ0OiBbXSxcbiAgcmlnaHQ6IFtdXG59KSwgcFUgPSB7XG4gIGdldEluaXRpYWxTdGF0ZTogKGUpID0+ICh7XG4gICAgY29sdW1uUGlubmluZzogdWMoKSxcbiAgICAuLi5lXG4gIH0pLFxuICBnZXREZWZhdWx0T3B0aW9uczogKGUpID0+ICh7XG4gICAgb25Db2x1bW5QaW5uaW5nQ2hhbmdlOiBQdChcImNvbHVtblBpbm5pbmdcIiwgZSlcbiAgfSksXG4gIGNyZWF0ZUNvbHVtbjogKGUsIHQpID0+IHtcbiAgICBlLnBpbiA9IChuKSA9PiB7XG4gICAgICBjb25zdCByID0gZS5nZXRMZWFmQ29sdW1ucygpLm1hcCgoaSkgPT4gaS5pZCkuZmlsdGVyKEJvb2xlYW4pO1xuICAgICAgdC5zZXRDb2x1bW5QaW5uaW5nKChpKSA9PiB7XG4gICAgICAgIHZhciBvLCBhO1xuICAgICAgICBpZiAobiA9PT0gXCJyaWdodFwiKSB7XG4gICAgICAgICAgdmFyIHMsIHU7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGxlZnQ6ICgocyA9IGkgPT0gbnVsbCA/IHZvaWQgMCA6IGkubGVmdCkgIT0gbnVsbCA/IHMgOiBbXSkuZmlsdGVyKChsKSA9PiAhKHIgIT0gbnVsbCAmJiByLmluY2x1ZGVzKGwpKSksXG4gICAgICAgICAgICByaWdodDogWy4uLigodSA9IGkgPT0gbnVsbCA/IHZvaWQgMCA6IGkucmlnaHQpICE9IG51bGwgPyB1IDogW10pLmZpbHRlcigobCkgPT4gIShyICE9IG51bGwgJiYgci5pbmNsdWRlcyhsKSkpLCAuLi5yXVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG4gPT09IFwibGVmdFwiKSB7XG4gICAgICAgICAgdmFyIGMsIGY7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGxlZnQ6IFsuLi4oKGMgPSBpID09IG51bGwgPyB2b2lkIDAgOiBpLmxlZnQpICE9IG51bGwgPyBjIDogW10pLmZpbHRlcigobCkgPT4gIShyICE9IG51bGwgJiYgci5pbmNsdWRlcyhsKSkpLCAuLi5yXSxcbiAgICAgICAgICAgIHJpZ2h0OiAoKGYgPSBpID09IG51bGwgPyB2b2lkIDAgOiBpLnJpZ2h0KSAhPSBudWxsID8gZiA6IFtdKS5maWx0ZXIoKGwpID0+ICEociAhPSBudWxsICYmIHIuaW5jbHVkZXMobCkpKVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBsZWZ0OiAoKG8gPSBpID09IG51bGwgPyB2b2lkIDAgOiBpLmxlZnQpICE9IG51bGwgPyBvIDogW10pLmZpbHRlcigobCkgPT4gIShyICE9IG51bGwgJiYgci5pbmNsdWRlcyhsKSkpLFxuICAgICAgICAgIHJpZ2h0OiAoKGEgPSBpID09IG51bGwgPyB2b2lkIDAgOiBpLnJpZ2h0KSAhPSBudWxsID8gYSA6IFtdKS5maWx0ZXIoKGwpID0+ICEociAhPSBudWxsICYmIHIuaW5jbHVkZXMobCkpKVxuICAgICAgICB9O1xuICAgICAgfSk7XG4gICAgfSwgZS5nZXRDYW5QaW4gPSAoKSA9PiBlLmdldExlYWZDb2x1bW5zKCkuc29tZSgocikgPT4ge1xuICAgICAgdmFyIGksIG8sIGE7XG4gICAgICByZXR1cm4gKChpID0gci5jb2x1bW5EZWYuZW5hYmxlUGlubmluZykgIT0gbnVsbCA/IGkgOiAhMCkgJiYgKChvID0gKGEgPSB0Lm9wdGlvbnMuZW5hYmxlQ29sdW1uUGlubmluZykgIT0gbnVsbCA/IGEgOiB0Lm9wdGlvbnMuZW5hYmxlUGlubmluZykgIT0gbnVsbCA/IG8gOiAhMCk7XG4gICAgfSksIGUuZ2V0SXNQaW5uZWQgPSAoKSA9PiB7XG4gICAgICBjb25zdCBuID0gZS5nZXRMZWFmQ29sdW1ucygpLm1hcCgocykgPT4gcy5pZCksIHtcbiAgICAgICAgbGVmdDogcixcbiAgICAgICAgcmlnaHQ6IGlcbiAgICAgIH0gPSB0LmdldFN0YXRlKCkuY29sdW1uUGlubmluZywgbyA9IG4uc29tZSgocykgPT4gciA9PSBudWxsID8gdm9pZCAwIDogci5pbmNsdWRlcyhzKSksIGEgPSBuLnNvbWUoKHMpID0+IGkgPT0gbnVsbCA/IHZvaWQgMCA6IGkuaW5jbHVkZXMocykpO1xuICAgICAgcmV0dXJuIG8gPyBcImxlZnRcIiA6IGEgPyBcInJpZ2h0XCIgOiAhMTtcbiAgICB9LCBlLmdldFBpbm5lZEluZGV4ID0gKCkgPT4ge1xuICAgICAgdmFyIG4sIHI7XG4gICAgICBjb25zdCBpID0gZS5nZXRJc1Bpbm5lZCgpO1xuICAgICAgcmV0dXJuIGkgPyAobiA9IChyID0gdC5nZXRTdGF0ZSgpLmNvbHVtblBpbm5pbmcpID09IG51bGwgfHwgKHIgPSByW2ldKSA9PSBudWxsID8gdm9pZCAwIDogci5pbmRleE9mKGUuaWQpKSAhPSBudWxsID8gbiA6IC0xIDogMDtcbiAgICB9O1xuICB9LFxuICBjcmVhdGVSb3c6IChlLCB0KSA9PiB7XG4gICAgZS5nZXRDZW50ZXJWaXNpYmxlQ2VsbHMgPSBvZSgoKSA9PiBbZS5fZ2V0QWxsVmlzaWJsZUNlbGxzKCksIHQuZ2V0U3RhdGUoKS5jb2x1bW5QaW5uaW5nLmxlZnQsIHQuZ2V0U3RhdGUoKS5jb2x1bW5QaW5uaW5nLnJpZ2h0XSwgKG4sIHIsIGkpID0+IHtcbiAgICAgIGNvbnN0IG8gPSBbLi4uciA/PyBbXSwgLi4uaSA/PyBbXV07XG4gICAgICByZXR1cm4gbi5maWx0ZXIoKGEpID0+ICFvLmluY2x1ZGVzKGEuY29sdW1uLmlkKSk7XG4gICAgfSwgYWUodC5vcHRpb25zLCBcImRlYnVnUm93c1wiLCBcImdldENlbnRlclZpc2libGVDZWxsc1wiKSksIGUuZ2V0TGVmdFZpc2libGVDZWxscyA9IG9lKCgpID0+IFtlLl9nZXRBbGxWaXNpYmxlQ2VsbHMoKSwgdC5nZXRTdGF0ZSgpLmNvbHVtblBpbm5pbmcubGVmdF0sIChuLCByKSA9PiAociA/PyBbXSkubWFwKChvKSA9PiBuLmZpbmQoKGEpID0+IGEuY29sdW1uLmlkID09PSBvKSkuZmlsdGVyKEJvb2xlYW4pLm1hcCgobykgPT4gKHtcbiAgICAgIC4uLm8sXG4gICAgICBwb3NpdGlvbjogXCJsZWZ0XCJcbiAgICB9KSksIGFlKHQub3B0aW9ucywgXCJkZWJ1Z1Jvd3NcIiwgXCJnZXRMZWZ0VmlzaWJsZUNlbGxzXCIpKSwgZS5nZXRSaWdodFZpc2libGVDZWxscyA9IG9lKCgpID0+IFtlLl9nZXRBbGxWaXNpYmxlQ2VsbHMoKSwgdC5nZXRTdGF0ZSgpLmNvbHVtblBpbm5pbmcucmlnaHRdLCAobiwgcikgPT4gKHIgPz8gW10pLm1hcCgobykgPT4gbi5maW5kKChhKSA9PiBhLmNvbHVtbi5pZCA9PT0gbykpLmZpbHRlcihCb29sZWFuKS5tYXAoKG8pID0+ICh7XG4gICAgICAuLi5vLFxuICAgICAgcG9zaXRpb246IFwicmlnaHRcIlxuICAgIH0pKSwgYWUodC5vcHRpb25zLCBcImRlYnVnUm93c1wiLCBcImdldFJpZ2h0VmlzaWJsZUNlbGxzXCIpKTtcbiAgfSxcbiAgY3JlYXRlVGFibGU6IChlKSA9PiB7XG4gICAgZS5zZXRDb2x1bW5QaW5uaW5nID0gKHQpID0+IGUub3B0aW9ucy5vbkNvbHVtblBpbm5pbmdDaGFuZ2UgPT0gbnVsbCA/IHZvaWQgMCA6IGUub3B0aW9ucy5vbkNvbHVtblBpbm5pbmdDaGFuZ2UodCksIGUucmVzZXRDb2x1bW5QaW5uaW5nID0gKHQpID0+IHtcbiAgICAgIHZhciBuLCByO1xuICAgICAgcmV0dXJuIGUuc2V0Q29sdW1uUGlubmluZyh0ID8gdWMoKSA6IChuID0gKHIgPSBlLmluaXRpYWxTdGF0ZSkgPT0gbnVsbCA/IHZvaWQgMCA6IHIuY29sdW1uUGlubmluZykgIT0gbnVsbCA/IG4gOiB1YygpKTtcbiAgICB9LCBlLmdldElzU29tZUNvbHVtbnNQaW5uZWQgPSAodCkgPT4ge1xuICAgICAgdmFyIG47XG4gICAgICBjb25zdCByID0gZS5nZXRTdGF0ZSgpLmNvbHVtblBpbm5pbmc7XG4gICAgICBpZiAoIXQpIHtcbiAgICAgICAgdmFyIGksIG87XG4gICAgICAgIHJldHVybiAhISgoaSA9IHIubGVmdCkgIT0gbnVsbCAmJiBpLmxlbmd0aCB8fCAobyA9IHIucmlnaHQpICE9IG51bGwgJiYgby5sZW5ndGgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuICEhKChuID0gclt0XSkgIT0gbnVsbCAmJiBuLmxlbmd0aCk7XG4gICAgfSwgZS5nZXRMZWZ0TGVhZkNvbHVtbnMgPSBvZSgoKSA9PiBbZS5nZXRBbGxMZWFmQ29sdW1ucygpLCBlLmdldFN0YXRlKCkuY29sdW1uUGlubmluZy5sZWZ0XSwgKHQsIG4pID0+IChuID8/IFtdKS5tYXAoKHIpID0+IHQuZmluZCgoaSkgPT4gaS5pZCA9PT0gcikpLmZpbHRlcihCb29sZWFuKSwgYWUoZS5vcHRpb25zLCBcImRlYnVnQ29sdW1uc1wiLCBcImdldExlZnRMZWFmQ29sdW1uc1wiKSksIGUuZ2V0UmlnaHRMZWFmQ29sdW1ucyA9IG9lKCgpID0+IFtlLmdldEFsbExlYWZDb2x1bW5zKCksIGUuZ2V0U3RhdGUoKS5jb2x1bW5QaW5uaW5nLnJpZ2h0XSwgKHQsIG4pID0+IChuID8/IFtdKS5tYXAoKHIpID0+IHQuZmluZCgoaSkgPT4gaS5pZCA9PT0gcikpLmZpbHRlcihCb29sZWFuKSwgYWUoZS5vcHRpb25zLCBcImRlYnVnQ29sdW1uc1wiLCBcImdldFJpZ2h0TGVhZkNvbHVtbnNcIikpLCBlLmdldENlbnRlckxlYWZDb2x1bW5zID0gb2UoKCkgPT4gW2UuZ2V0QWxsTGVhZkNvbHVtbnMoKSwgZS5nZXRTdGF0ZSgpLmNvbHVtblBpbm5pbmcubGVmdCwgZS5nZXRTdGF0ZSgpLmNvbHVtblBpbm5pbmcucmlnaHRdLCAodCwgbiwgcikgPT4ge1xuICAgICAgY29uc3QgaSA9IFsuLi5uID8/IFtdLCAuLi5yID8/IFtdXTtcbiAgICAgIHJldHVybiB0LmZpbHRlcigobykgPT4gIWkuaW5jbHVkZXMoby5pZCkpO1xuICAgIH0sIGFlKGUub3B0aW9ucywgXCJkZWJ1Z0NvbHVtbnNcIiwgXCJnZXRDZW50ZXJMZWFmQ29sdW1uc1wiKSk7XG4gIH1cbn0sIE9hID0ge1xuICBzaXplOiAxNTAsXG4gIG1pblNpemU6IDIwLFxuICBtYXhTaXplOiBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUlxufSwgY2MgPSAoKSA9PiAoe1xuICBzdGFydE9mZnNldDogbnVsbCxcbiAgc3RhcnRTaXplOiBudWxsLFxuICBkZWx0YU9mZnNldDogbnVsbCxcbiAgZGVsdGFQZXJjZW50YWdlOiBudWxsLFxuICBpc1Jlc2l6aW5nQ29sdW1uOiAhMSxcbiAgY29sdW1uU2l6aW5nU3RhcnQ6IFtdXG59KSwgaFUgPSB7XG4gIGdldERlZmF1bHRDb2x1bW5EZWY6ICgpID0+IE9hLFxuICBnZXRJbml0aWFsU3RhdGU6IChlKSA9PiAoe1xuICAgIGNvbHVtblNpemluZzoge30sXG4gICAgY29sdW1uU2l6aW5nSW5mbzogY2MoKSxcbiAgICAuLi5lXG4gIH0pLFxuICBnZXREZWZhdWx0T3B0aW9uczogKGUpID0+ICh7XG4gICAgY29sdW1uUmVzaXplTW9kZTogXCJvbkVuZFwiLFxuICAgIGNvbHVtblJlc2l6ZURpcmVjdGlvbjogXCJsdHJcIixcbiAgICBvbkNvbHVtblNpemluZ0NoYW5nZTogUHQoXCJjb2x1bW5TaXppbmdcIiwgZSksXG4gICAgb25Db2x1bW5TaXppbmdJbmZvQ2hhbmdlOiBQdChcImNvbHVtblNpemluZ0luZm9cIiwgZSlcbiAgfSksXG4gIGNyZWF0ZUNvbHVtbjogKGUsIHQpID0+IHtcbiAgICBlLmdldFNpemUgPSAoKSA9PiB7XG4gICAgICB2YXIgbiwgciwgaTtcbiAgICAgIGNvbnN0IG8gPSB0LmdldFN0YXRlKCkuY29sdW1uU2l6aW5nW2UuaWRdO1xuICAgICAgcmV0dXJuIE1hdGgubWluKE1hdGgubWF4KChuID0gZS5jb2x1bW5EZWYubWluU2l6ZSkgIT0gbnVsbCA/IG4gOiBPYS5taW5TaXplLCAociA9IG8gPz8gZS5jb2x1bW5EZWYuc2l6ZSkgIT0gbnVsbCA/IHIgOiBPYS5zaXplKSwgKGkgPSBlLmNvbHVtbkRlZi5tYXhTaXplKSAhPSBudWxsID8gaSA6IE9hLm1heFNpemUpO1xuICAgIH0sIGUuZ2V0U3RhcnQgPSBvZSgobikgPT4gW24sIFlpKHQsIG4pLCB0LmdldFN0YXRlKCkuY29sdW1uU2l6aW5nXSwgKG4sIHIpID0+IHIuc2xpY2UoMCwgZS5nZXRJbmRleChuKSkucmVkdWNlKChpLCBvKSA9PiBpICsgby5nZXRTaXplKCksIDApLCBhZSh0Lm9wdGlvbnMsIFwiZGVidWdDb2x1bW5zXCIsIFwiZ2V0U3RhcnRcIikpLCBlLmdldEFmdGVyID0gb2UoKG4pID0+IFtuLCBZaSh0LCBuKSwgdC5nZXRTdGF0ZSgpLmNvbHVtblNpemluZ10sIChuLCByKSA9PiByLnNsaWNlKGUuZ2V0SW5kZXgobikgKyAxKS5yZWR1Y2UoKGksIG8pID0+IGkgKyBvLmdldFNpemUoKSwgMCksIGFlKHQub3B0aW9ucywgXCJkZWJ1Z0NvbHVtbnNcIiwgXCJnZXRBZnRlclwiKSksIGUucmVzZXRTaXplID0gKCkgPT4ge1xuICAgICAgdC5zZXRDb2x1bW5TaXppbmcoKG4pID0+IHtcbiAgICAgICAgbGV0IHtcbiAgICAgICAgICBbZS5pZF06IHIsXG4gICAgICAgICAgLi4uaVxuICAgICAgICB9ID0gbjtcbiAgICAgICAgcmV0dXJuIGk7XG4gICAgICB9KTtcbiAgICB9LCBlLmdldENhblJlc2l6ZSA9ICgpID0+IHtcbiAgICAgIHZhciBuLCByO1xuICAgICAgcmV0dXJuICgobiA9IGUuY29sdW1uRGVmLmVuYWJsZVJlc2l6aW5nKSAhPSBudWxsID8gbiA6ICEwKSAmJiAoKHIgPSB0Lm9wdGlvbnMuZW5hYmxlQ29sdW1uUmVzaXppbmcpICE9IG51bGwgPyByIDogITApO1xuICAgIH0sIGUuZ2V0SXNSZXNpemluZyA9ICgpID0+IHQuZ2V0U3RhdGUoKS5jb2x1bW5TaXppbmdJbmZvLmlzUmVzaXppbmdDb2x1bW4gPT09IGUuaWQ7XG4gIH0sXG4gIGNyZWF0ZUhlYWRlcjogKGUsIHQpID0+IHtcbiAgICBlLmdldFNpemUgPSAoKSA9PiB7XG4gICAgICBsZXQgbiA9IDA7XG4gICAgICBjb25zdCByID0gKGkpID0+IHtcbiAgICAgICAgaWYgKGkuc3ViSGVhZGVycy5sZW5ndGgpXG4gICAgICAgICAgaS5zdWJIZWFkZXJzLmZvckVhY2gocik7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHZhciBvO1xuICAgICAgICAgIG4gKz0gKG8gPSBpLmNvbHVtbi5nZXRTaXplKCkpICE9IG51bGwgPyBvIDogMDtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHJldHVybiByKGUpLCBuO1xuICAgIH0sIGUuZ2V0U3RhcnQgPSAoKSA9PiB7XG4gICAgICBpZiAoZS5pbmRleCA+IDApIHtcbiAgICAgICAgY29uc3QgbiA9IGUuaGVhZGVyR3JvdXAuaGVhZGVyc1tlLmluZGV4IC0gMV07XG4gICAgICAgIHJldHVybiBuLmdldFN0YXJ0KCkgKyBuLmdldFNpemUoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAwO1xuICAgIH0sIGUuZ2V0UmVzaXplSGFuZGxlciA9IChuKSA9PiB7XG4gICAgICBjb25zdCByID0gdC5nZXRDb2x1bW4oZS5jb2x1bW4uaWQpLCBpID0gciA9PSBudWxsID8gdm9pZCAwIDogci5nZXRDYW5SZXNpemUoKTtcbiAgICAgIHJldHVybiAobykgPT4ge1xuICAgICAgICBpZiAoIXIgfHwgIWkgfHwgKG8ucGVyc2lzdCA9PSBudWxsIHx8IG8ucGVyc2lzdCgpLCBsYyhvKSAmJiBvLnRvdWNoZXMgJiYgby50b3VjaGVzLmxlbmd0aCA+IDEpKVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3QgYSA9IGUuZ2V0U2l6ZSgpLCBzID0gZSA/IGUuZ2V0TGVhZkhlYWRlcnMoKS5tYXAoKHcpID0+IFt3LmNvbHVtbi5pZCwgdy5jb2x1bW4uZ2V0U2l6ZSgpXSkgOiBbW3IuaWQsIHIuZ2V0U2l6ZSgpXV0sIHUgPSBsYyhvKSA/IE1hdGgucm91bmQoby50b3VjaGVzWzBdLmNsaWVudFgpIDogby5jbGllbnRYLCBjID0ge30sIGYgPSAodywgYikgPT4ge1xuICAgICAgICAgIHR5cGVvZiBiID09IFwibnVtYmVyXCIgJiYgKHQuc2V0Q29sdW1uU2l6aW5nSW5mbygoeCkgPT4ge1xuICAgICAgICAgICAgdmFyIG0sIHk7XG4gICAgICAgICAgICBjb25zdCBTID0gdC5vcHRpb25zLmNvbHVtblJlc2l6ZURpcmVjdGlvbiA9PT0gXCJydGxcIiA/IC0xIDogMSwgJCA9IChiIC0gKChtID0geCA9PSBudWxsID8gdm9pZCAwIDogeC5zdGFydE9mZnNldCkgIT0gbnVsbCA/IG0gOiAwKSkgKiBTLCBPID0gTWF0aC5tYXgoJCAvICgoeSA9IHggPT0gbnVsbCA/IHZvaWQgMCA6IHguc3RhcnRTaXplKSAhPSBudWxsID8geSA6IDApLCAtMC45OTk5OTkpO1xuICAgICAgICAgICAgcmV0dXJuIHguY29sdW1uU2l6aW5nU3RhcnQuZm9yRWFjaCgoVCkgPT4ge1xuICAgICAgICAgICAgICBsZXQgW00sIEVdID0gVDtcbiAgICAgICAgICAgICAgY1tNXSA9IE1hdGgucm91bmQoTWF0aC5tYXgoRSArIEUgKiBPLCAwKSAqIDEwMCkgLyAxMDA7XG4gICAgICAgICAgICB9KSwge1xuICAgICAgICAgICAgICAuLi54LFxuICAgICAgICAgICAgICBkZWx0YU9mZnNldDogJCxcbiAgICAgICAgICAgICAgZGVsdGFQZXJjZW50YWdlOiBPXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH0pLCAodC5vcHRpb25zLmNvbHVtblJlc2l6ZU1vZGUgPT09IFwib25DaGFuZ2VcIiB8fCB3ID09PSBcImVuZFwiKSAmJiB0LnNldENvbHVtblNpemluZygoeCkgPT4gKHtcbiAgICAgICAgICAgIC4uLngsXG4gICAgICAgICAgICAuLi5jXG4gICAgICAgICAgfSkpKTtcbiAgICAgICAgfSwgbCA9ICh3KSA9PiBmKFwibW92ZVwiLCB3KSwgZCA9ICh3KSA9PiB7XG4gICAgICAgICAgZihcImVuZFwiLCB3KSwgdC5zZXRDb2x1bW5TaXppbmdJbmZvKChiKSA9PiAoe1xuICAgICAgICAgICAgLi4uYixcbiAgICAgICAgICAgIGlzUmVzaXppbmdDb2x1bW46ICExLFxuICAgICAgICAgICAgc3RhcnRPZmZzZXQ6IG51bGwsXG4gICAgICAgICAgICBzdGFydFNpemU6IG51bGwsXG4gICAgICAgICAgICBkZWx0YU9mZnNldDogbnVsbCxcbiAgICAgICAgICAgIGRlbHRhUGVyY2VudGFnZTogbnVsbCxcbiAgICAgICAgICAgIGNvbHVtblNpemluZ1N0YXJ0OiBbXVxuICAgICAgICAgIH0pKTtcbiAgICAgICAgfSwgcCA9IG4gfHwgdHlwZW9mIGRvY3VtZW50IDwgXCJ1XCIgPyBkb2N1bWVudCA6IG51bGwsIGcgPSB7XG4gICAgICAgICAgbW92ZUhhbmRsZXI6ICh3KSA9PiBsKHcuY2xpZW50WCksXG4gICAgICAgICAgdXBIYW5kbGVyOiAodykgPT4ge1xuICAgICAgICAgICAgcCA9PSBudWxsIHx8IHAucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNlbW92ZVwiLCBnLm1vdmVIYW5kbGVyKSwgcCA9PSBudWxsIHx8IHAucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNldXBcIiwgZy51cEhhbmRsZXIpLCBkKHcuY2xpZW50WCk7XG4gICAgICAgICAgfVxuICAgICAgICB9LCBoID0ge1xuICAgICAgICAgIG1vdmVIYW5kbGVyOiAodykgPT4gKHcuY2FuY2VsYWJsZSAmJiAody5wcmV2ZW50RGVmYXVsdCgpLCB3LnN0b3BQcm9wYWdhdGlvbigpKSwgbCh3LnRvdWNoZXNbMF0uY2xpZW50WCksICExKSxcbiAgICAgICAgICB1cEhhbmRsZXI6ICh3KSA9PiB7XG4gICAgICAgICAgICB2YXIgYjtcbiAgICAgICAgICAgIHAgPT0gbnVsbCB8fCBwLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ0b3VjaG1vdmVcIiwgaC5tb3ZlSGFuZGxlciksIHAgPT0gbnVsbCB8fCBwLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ0b3VjaGVuZFwiLCBoLnVwSGFuZGxlciksIHcuY2FuY2VsYWJsZSAmJiAody5wcmV2ZW50RGVmYXVsdCgpLCB3LnN0b3BQcm9wYWdhdGlvbigpKSwgZCgoYiA9IHcudG91Y2hlc1swXSkgPT0gbnVsbCA/IHZvaWQgMCA6IGIuY2xpZW50WCk7XG4gICAgICAgICAgfVxuICAgICAgICB9LCB2ID0gZ1UoKSA/IHtcbiAgICAgICAgICBwYXNzaXZlOiAhMVxuICAgICAgICB9IDogITE7XG4gICAgICAgIGxjKG8pID8gKHAgPT0gbnVsbCB8fCBwLmFkZEV2ZW50TGlzdGVuZXIoXCJ0b3VjaG1vdmVcIiwgaC5tb3ZlSGFuZGxlciwgdiksIHAgPT0gbnVsbCB8fCBwLmFkZEV2ZW50TGlzdGVuZXIoXCJ0b3VjaGVuZFwiLCBoLnVwSGFuZGxlciwgdikpIDogKHAgPT0gbnVsbCB8fCBwLmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZW1vdmVcIiwgZy5tb3ZlSGFuZGxlciwgdiksIHAgPT0gbnVsbCB8fCBwLmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZXVwXCIsIGcudXBIYW5kbGVyLCB2KSksIHQuc2V0Q29sdW1uU2l6aW5nSW5mbygodykgPT4gKHtcbiAgICAgICAgICAuLi53LFxuICAgICAgICAgIHN0YXJ0T2Zmc2V0OiB1LFxuICAgICAgICAgIHN0YXJ0U2l6ZTogYSxcbiAgICAgICAgICBkZWx0YU9mZnNldDogMCxcbiAgICAgICAgICBkZWx0YVBlcmNlbnRhZ2U6IDAsXG4gICAgICAgICAgY29sdW1uU2l6aW5nU3RhcnQ6IHMsXG4gICAgICAgICAgaXNSZXNpemluZ0NvbHVtbjogci5pZFxuICAgICAgICB9KSk7XG4gICAgICB9O1xuICAgIH07XG4gIH0sXG4gIGNyZWF0ZVRhYmxlOiAoZSkgPT4ge1xuICAgIGUuc2V0Q29sdW1uU2l6aW5nID0gKHQpID0+IGUub3B0aW9ucy5vbkNvbHVtblNpemluZ0NoYW5nZSA9PSBudWxsID8gdm9pZCAwIDogZS5vcHRpb25zLm9uQ29sdW1uU2l6aW5nQ2hhbmdlKHQpLCBlLnNldENvbHVtblNpemluZ0luZm8gPSAodCkgPT4gZS5vcHRpb25zLm9uQ29sdW1uU2l6aW5nSW5mb0NoYW5nZSA9PSBudWxsID8gdm9pZCAwIDogZS5vcHRpb25zLm9uQ29sdW1uU2l6aW5nSW5mb0NoYW5nZSh0KSwgZS5yZXNldENvbHVtblNpemluZyA9ICh0KSA9PiB7XG4gICAgICB2YXIgbjtcbiAgICAgIGUuc2V0Q29sdW1uU2l6aW5nKHQgPyB7fSA6IChuID0gZS5pbml0aWFsU3RhdGUuY29sdW1uU2l6aW5nKSAhPSBudWxsID8gbiA6IHt9KTtcbiAgICB9LCBlLnJlc2V0SGVhZGVyU2l6ZUluZm8gPSAodCkgPT4ge1xuICAgICAgdmFyIG47XG4gICAgICBlLnNldENvbHVtblNpemluZ0luZm8odCA/IGNjKCkgOiAobiA9IGUuaW5pdGlhbFN0YXRlLmNvbHVtblNpemluZ0luZm8pICE9IG51bGwgPyBuIDogY2MoKSk7XG4gICAgfSwgZS5nZXRUb3RhbFNpemUgPSAoKSA9PiB7XG4gICAgICB2YXIgdCwgbjtcbiAgICAgIHJldHVybiAodCA9IChuID0gZS5nZXRIZWFkZXJHcm91cHMoKVswXSkgPT0gbnVsbCA/IHZvaWQgMCA6IG4uaGVhZGVycy5yZWR1Y2UoKHIsIGkpID0+IHIgKyBpLmdldFNpemUoKSwgMCkpICE9IG51bGwgPyB0IDogMDtcbiAgICB9LCBlLmdldExlZnRUb3RhbFNpemUgPSAoKSA9PiB7XG4gICAgICB2YXIgdCwgbjtcbiAgICAgIHJldHVybiAodCA9IChuID0gZS5nZXRMZWZ0SGVhZGVyR3JvdXBzKClbMF0pID09IG51bGwgPyB2b2lkIDAgOiBuLmhlYWRlcnMucmVkdWNlKChyLCBpKSA9PiByICsgaS5nZXRTaXplKCksIDApKSAhPSBudWxsID8gdCA6IDA7XG4gICAgfSwgZS5nZXRDZW50ZXJUb3RhbFNpemUgPSAoKSA9PiB7XG4gICAgICB2YXIgdCwgbjtcbiAgICAgIHJldHVybiAodCA9IChuID0gZS5nZXRDZW50ZXJIZWFkZXJHcm91cHMoKVswXSkgPT0gbnVsbCA/IHZvaWQgMCA6IG4uaGVhZGVycy5yZWR1Y2UoKHIsIGkpID0+IHIgKyBpLmdldFNpemUoKSwgMCkpICE9IG51bGwgPyB0IDogMDtcbiAgICB9LCBlLmdldFJpZ2h0VG90YWxTaXplID0gKCkgPT4ge1xuICAgICAgdmFyIHQsIG47XG4gICAgICByZXR1cm4gKHQgPSAobiA9IGUuZ2V0UmlnaHRIZWFkZXJHcm91cHMoKVswXSkgPT0gbnVsbCA/IHZvaWQgMCA6IG4uaGVhZGVycy5yZWR1Y2UoKHIsIGkpID0+IHIgKyBpLmdldFNpemUoKSwgMCkpICE9IG51bGwgPyB0IDogMDtcbiAgICB9O1xuICB9XG59O1xubGV0IF9hID0gbnVsbDtcbmZ1bmN0aW9uIGdVKCkge1xuICBpZiAodHlwZW9mIF9hID09IFwiYm9vbGVhblwiKVxuICAgIHJldHVybiBfYTtcbiAgbGV0IGUgPSAhMTtcbiAgdHJ5IHtcbiAgICBjb25zdCB0ID0ge1xuICAgICAgZ2V0IHBhc3NpdmUoKSB7XG4gICAgICAgIHJldHVybiBlID0gITAsICExO1xuICAgICAgfVxuICAgIH0sIG4gPSAoKSA9PiB7XG4gICAgfTtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInRlc3RcIiwgbiwgdCksIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwidGVzdFwiLCBuKTtcbiAgfSBjYXRjaCB7XG4gICAgZSA9ICExO1xuICB9XG4gIHJldHVybiBfYSA9IGUsIF9hO1xufVxuZnVuY3Rpb24gbGMoZSkge1xuICByZXR1cm4gZS50eXBlID09PSBcInRvdWNoc3RhcnRcIjtcbn1cbmNvbnN0IHZVID0ge1xuICBnZXRJbml0aWFsU3RhdGU6IChlKSA9PiAoe1xuICAgIGNvbHVtblZpc2liaWxpdHk6IHt9LFxuICAgIC4uLmVcbiAgfSksXG4gIGdldERlZmF1bHRPcHRpb25zOiAoZSkgPT4gKHtcbiAgICBvbkNvbHVtblZpc2liaWxpdHlDaGFuZ2U6IFB0KFwiY29sdW1uVmlzaWJpbGl0eVwiLCBlKVxuICB9KSxcbiAgY3JlYXRlQ29sdW1uOiAoZSwgdCkgPT4ge1xuICAgIGUudG9nZ2xlVmlzaWJpbGl0eSA9IChuKSA9PiB7XG4gICAgICBlLmdldENhbkhpZGUoKSAmJiB0LnNldENvbHVtblZpc2liaWxpdHkoKHIpID0+ICh7XG4gICAgICAgIC4uLnIsXG4gICAgICAgIFtlLmlkXTogbiA/PyAhZS5nZXRJc1Zpc2libGUoKVxuICAgICAgfSkpO1xuICAgIH0sIGUuZ2V0SXNWaXNpYmxlID0gKCkgPT4ge1xuICAgICAgdmFyIG4sIHI7XG4gICAgICBjb25zdCBpID0gZS5jb2x1bW5zO1xuICAgICAgcmV0dXJuIChuID0gaS5sZW5ndGggPyBpLnNvbWUoKG8pID0+IG8uZ2V0SXNWaXNpYmxlKCkpIDogKHIgPSB0LmdldFN0YXRlKCkuY29sdW1uVmlzaWJpbGl0eSkgPT0gbnVsbCA/IHZvaWQgMCA6IHJbZS5pZF0pICE9IG51bGwgPyBuIDogITA7XG4gICAgfSwgZS5nZXRDYW5IaWRlID0gKCkgPT4ge1xuICAgICAgdmFyIG4sIHI7XG4gICAgICByZXR1cm4gKChuID0gZS5jb2x1bW5EZWYuZW5hYmxlSGlkaW5nKSAhPSBudWxsID8gbiA6ICEwKSAmJiAoKHIgPSB0Lm9wdGlvbnMuZW5hYmxlSGlkaW5nKSAhPSBudWxsID8gciA6ICEwKTtcbiAgICB9LCBlLmdldFRvZ2dsZVZpc2liaWxpdHlIYW5kbGVyID0gKCkgPT4gKG4pID0+IHtcbiAgICAgIGUudG9nZ2xlVmlzaWJpbGl0eSA9PSBudWxsIHx8IGUudG9nZ2xlVmlzaWJpbGl0eShuLnRhcmdldC5jaGVja2VkKTtcbiAgICB9O1xuICB9LFxuICBjcmVhdGVSb3c6IChlLCB0KSA9PiB7XG4gICAgZS5fZ2V0QWxsVmlzaWJsZUNlbGxzID0gb2UoKCkgPT4gW2UuZ2V0QWxsQ2VsbHMoKSwgdC5nZXRTdGF0ZSgpLmNvbHVtblZpc2liaWxpdHldLCAobikgPT4gbi5maWx0ZXIoKHIpID0+IHIuY29sdW1uLmdldElzVmlzaWJsZSgpKSwgYWUodC5vcHRpb25zLCBcImRlYnVnUm93c1wiLCBcIl9nZXRBbGxWaXNpYmxlQ2VsbHNcIikpLCBlLmdldFZpc2libGVDZWxscyA9IG9lKCgpID0+IFtlLmdldExlZnRWaXNpYmxlQ2VsbHMoKSwgZS5nZXRDZW50ZXJWaXNpYmxlQ2VsbHMoKSwgZS5nZXRSaWdodFZpc2libGVDZWxscygpXSwgKG4sIHIsIGkpID0+IFsuLi5uLCAuLi5yLCAuLi5pXSwgYWUodC5vcHRpb25zLCBcImRlYnVnUm93c1wiLCBcImdldFZpc2libGVDZWxsc1wiKSk7XG4gIH0sXG4gIGNyZWF0ZVRhYmxlOiAoZSkgPT4ge1xuICAgIGNvbnN0IHQgPSAobiwgcikgPT4gb2UoKCkgPT4gW3IoKSwgcigpLmZpbHRlcigoaSkgPT4gaS5nZXRJc1Zpc2libGUoKSkubWFwKChpKSA9PiBpLmlkKS5qb2luKFwiX1wiKV0sIChpKSA9PiBpLmZpbHRlcigobykgPT4gby5nZXRJc1Zpc2libGUgPT0gbnVsbCA/IHZvaWQgMCA6IG8uZ2V0SXNWaXNpYmxlKCkpLCBhZShlLm9wdGlvbnMsIFwiZGVidWdDb2x1bW5zXCIsIG4pKTtcbiAgICBlLmdldFZpc2libGVGbGF0Q29sdW1ucyA9IHQoXCJnZXRWaXNpYmxlRmxhdENvbHVtbnNcIiwgKCkgPT4gZS5nZXRBbGxGbGF0Q29sdW1ucygpKSwgZS5nZXRWaXNpYmxlTGVhZkNvbHVtbnMgPSB0KFwiZ2V0VmlzaWJsZUxlYWZDb2x1bW5zXCIsICgpID0+IGUuZ2V0QWxsTGVhZkNvbHVtbnMoKSksIGUuZ2V0TGVmdFZpc2libGVMZWFmQ29sdW1ucyA9IHQoXCJnZXRMZWZ0VmlzaWJsZUxlYWZDb2x1bW5zXCIsICgpID0+IGUuZ2V0TGVmdExlYWZDb2x1bW5zKCkpLCBlLmdldFJpZ2h0VmlzaWJsZUxlYWZDb2x1bW5zID0gdChcImdldFJpZ2h0VmlzaWJsZUxlYWZDb2x1bW5zXCIsICgpID0+IGUuZ2V0UmlnaHRMZWFmQ29sdW1ucygpKSwgZS5nZXRDZW50ZXJWaXNpYmxlTGVhZkNvbHVtbnMgPSB0KFwiZ2V0Q2VudGVyVmlzaWJsZUxlYWZDb2x1bW5zXCIsICgpID0+IGUuZ2V0Q2VudGVyTGVhZkNvbHVtbnMoKSksIGUuc2V0Q29sdW1uVmlzaWJpbGl0eSA9IChuKSA9PiBlLm9wdGlvbnMub25Db2x1bW5WaXNpYmlsaXR5Q2hhbmdlID09IG51bGwgPyB2b2lkIDAgOiBlLm9wdGlvbnMub25Db2x1bW5WaXNpYmlsaXR5Q2hhbmdlKG4pLCBlLnJlc2V0Q29sdW1uVmlzaWJpbGl0eSA9IChuKSA9PiB7XG4gICAgICB2YXIgcjtcbiAgICAgIGUuc2V0Q29sdW1uVmlzaWJpbGl0eShuID8ge30gOiAociA9IGUuaW5pdGlhbFN0YXRlLmNvbHVtblZpc2liaWxpdHkpICE9IG51bGwgPyByIDoge30pO1xuICAgIH0sIGUudG9nZ2xlQWxsQ29sdW1uc1Zpc2libGUgPSAobikgPT4ge1xuICAgICAgdmFyIHI7XG4gICAgICBuID0gKHIgPSBuKSAhPSBudWxsID8gciA6ICFlLmdldElzQWxsQ29sdW1uc1Zpc2libGUoKSwgZS5zZXRDb2x1bW5WaXNpYmlsaXR5KGUuZ2V0QWxsTGVhZkNvbHVtbnMoKS5yZWR1Y2UoKGksIG8pID0+ICh7XG4gICAgICAgIC4uLmksXG4gICAgICAgIFtvLmlkXTogbiB8fCAhKG8uZ2V0Q2FuSGlkZSAhPSBudWxsICYmIG8uZ2V0Q2FuSGlkZSgpKVxuICAgICAgfSksIHt9KSk7XG4gICAgfSwgZS5nZXRJc0FsbENvbHVtbnNWaXNpYmxlID0gKCkgPT4gIWUuZ2V0QWxsTGVhZkNvbHVtbnMoKS5zb21lKChuKSA9PiAhKG4uZ2V0SXNWaXNpYmxlICE9IG51bGwgJiYgbi5nZXRJc1Zpc2libGUoKSkpLCBlLmdldElzU29tZUNvbHVtbnNWaXNpYmxlID0gKCkgPT4gZS5nZXRBbGxMZWFmQ29sdW1ucygpLnNvbWUoKG4pID0+IG4uZ2V0SXNWaXNpYmxlID09IG51bGwgPyB2b2lkIDAgOiBuLmdldElzVmlzaWJsZSgpKSwgZS5nZXRUb2dnbGVBbGxDb2x1bW5zVmlzaWJpbGl0eUhhbmRsZXIgPSAoKSA9PiAobikgPT4ge1xuICAgICAgdmFyIHI7XG4gICAgICBlLnRvZ2dsZUFsbENvbHVtbnNWaXNpYmxlKChyID0gbi50YXJnZXQpID09IG51bGwgPyB2b2lkIDAgOiByLmNoZWNrZWQpO1xuICAgIH07XG4gIH1cbn07XG5mdW5jdGlvbiBZaShlLCB0KSB7XG4gIHJldHVybiB0ID8gdCA9PT0gXCJjZW50ZXJcIiA/IGUuZ2V0Q2VudGVyVmlzaWJsZUxlYWZDb2x1bW5zKCkgOiB0ID09PSBcImxlZnRcIiA/IGUuZ2V0TGVmdFZpc2libGVMZWFmQ29sdW1ucygpIDogZS5nZXRSaWdodFZpc2libGVMZWFmQ29sdW1ucygpIDogZS5nZXRWaXNpYmxlTGVhZkNvbHVtbnMoKTtcbn1cbmNvbnN0IG1VID0ge1xuICBjcmVhdGVUYWJsZTogKGUpID0+IHtcbiAgICBlLl9nZXRHbG9iYWxGYWNldGVkUm93TW9kZWwgPSBlLm9wdGlvbnMuZ2V0RmFjZXRlZFJvd01vZGVsICYmIGUub3B0aW9ucy5nZXRGYWNldGVkUm93TW9kZWwoZSwgXCJfX2dsb2JhbF9fXCIpLCBlLmdldEdsb2JhbEZhY2V0ZWRSb3dNb2RlbCA9ICgpID0+IGUub3B0aW9ucy5tYW51YWxGaWx0ZXJpbmcgfHwgIWUuX2dldEdsb2JhbEZhY2V0ZWRSb3dNb2RlbCA/IGUuZ2V0UHJlRmlsdGVyZWRSb3dNb2RlbCgpIDogZS5fZ2V0R2xvYmFsRmFjZXRlZFJvd01vZGVsKCksIGUuX2dldEdsb2JhbEZhY2V0ZWRVbmlxdWVWYWx1ZXMgPSBlLm9wdGlvbnMuZ2V0RmFjZXRlZFVuaXF1ZVZhbHVlcyAmJiBlLm9wdGlvbnMuZ2V0RmFjZXRlZFVuaXF1ZVZhbHVlcyhlLCBcIl9fZ2xvYmFsX19cIiksIGUuZ2V0R2xvYmFsRmFjZXRlZFVuaXF1ZVZhbHVlcyA9ICgpID0+IGUuX2dldEdsb2JhbEZhY2V0ZWRVbmlxdWVWYWx1ZXMgPyBlLl9nZXRHbG9iYWxGYWNldGVkVW5pcXVlVmFsdWVzKCkgOiAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpLCBlLl9nZXRHbG9iYWxGYWNldGVkTWluTWF4VmFsdWVzID0gZS5vcHRpb25zLmdldEZhY2V0ZWRNaW5NYXhWYWx1ZXMgJiYgZS5vcHRpb25zLmdldEZhY2V0ZWRNaW5NYXhWYWx1ZXMoZSwgXCJfX2dsb2JhbF9fXCIpLCBlLmdldEdsb2JhbEZhY2V0ZWRNaW5NYXhWYWx1ZXMgPSAoKSA9PiB7XG4gICAgICBpZiAoZS5fZ2V0R2xvYmFsRmFjZXRlZE1pbk1heFZhbHVlcylcbiAgICAgICAgcmV0dXJuIGUuX2dldEdsb2JhbEZhY2V0ZWRNaW5NYXhWYWx1ZXMoKTtcbiAgICB9O1xuICB9XG59LCB5VSA9IHtcbiAgZ2V0SW5pdGlhbFN0YXRlOiAoZSkgPT4gKHtcbiAgICBnbG9iYWxGaWx0ZXI6IHZvaWQgMCxcbiAgICAuLi5lXG4gIH0pLFxuICBnZXREZWZhdWx0T3B0aW9uczogKGUpID0+ICh7XG4gICAgb25HbG9iYWxGaWx0ZXJDaGFuZ2U6IFB0KFwiZ2xvYmFsRmlsdGVyXCIsIGUpLFxuICAgIGdsb2JhbEZpbHRlckZuOiBcImF1dG9cIixcbiAgICBnZXRDb2x1bW5DYW5HbG9iYWxGaWx0ZXI6ICh0KSA9PiB7XG4gICAgICB2YXIgbjtcbiAgICAgIGNvbnN0IHIgPSAobiA9IGUuZ2V0Q29yZVJvd01vZGVsKCkuZmxhdFJvd3NbMF0pID09IG51bGwgfHwgKG4gPSBuLl9nZXRBbGxDZWxsc0J5Q29sdW1uSWQoKVt0LmlkXSkgPT0gbnVsbCA/IHZvaWQgMCA6IG4uZ2V0VmFsdWUoKTtcbiAgICAgIHJldHVybiB0eXBlb2YgciA9PSBcInN0cmluZ1wiIHx8IHR5cGVvZiByID09IFwibnVtYmVyXCI7XG4gICAgfVxuICB9KSxcbiAgY3JlYXRlQ29sdW1uOiAoZSwgdCkgPT4ge1xuICAgIGUuZ2V0Q2FuR2xvYmFsRmlsdGVyID0gKCkgPT4ge1xuICAgICAgdmFyIG4sIHIsIGksIG87XG4gICAgICByZXR1cm4gKChuID0gZS5jb2x1bW5EZWYuZW5hYmxlR2xvYmFsRmlsdGVyKSAhPSBudWxsID8gbiA6ICEwKSAmJiAoKHIgPSB0Lm9wdGlvbnMuZW5hYmxlR2xvYmFsRmlsdGVyKSAhPSBudWxsID8gciA6ICEwKSAmJiAoKGkgPSB0Lm9wdGlvbnMuZW5hYmxlRmlsdGVycykgIT0gbnVsbCA/IGkgOiAhMCkgJiYgKChvID0gdC5vcHRpb25zLmdldENvbHVtbkNhbkdsb2JhbEZpbHRlciA9PSBudWxsID8gdm9pZCAwIDogdC5vcHRpb25zLmdldENvbHVtbkNhbkdsb2JhbEZpbHRlcihlKSkgIT0gbnVsbCA/IG8gOiAhMCkgJiYgISFlLmFjY2Vzc29yRm47XG4gICAgfTtcbiAgfSxcbiAgY3JlYXRlVGFibGU6IChlKSA9PiB7XG4gICAgZS5nZXRHbG9iYWxBdXRvRmlsdGVyRm4gPSAoKSA9PiBobi5pbmNsdWRlc1N0cmluZywgZS5nZXRHbG9iYWxGaWx0ZXJGbiA9ICgpID0+IHtcbiAgICAgIHZhciB0LCBuO1xuICAgICAgY29uc3Qge1xuICAgICAgICBnbG9iYWxGaWx0ZXJGbjogclxuICAgICAgfSA9IGUub3B0aW9ucztcbiAgICAgIHJldHVybiBsdShyKSA/IHIgOiByID09PSBcImF1dG9cIiA/IGUuZ2V0R2xvYmFsQXV0b0ZpbHRlckZuKCkgOiAodCA9IChuID0gZS5vcHRpb25zLmZpbHRlckZucykgPT0gbnVsbCA/IHZvaWQgMCA6IG5bcl0pICE9IG51bGwgPyB0IDogaG5bcl07XG4gICAgfSwgZS5zZXRHbG9iYWxGaWx0ZXIgPSAodCkgPT4ge1xuICAgICAgZS5vcHRpb25zLm9uR2xvYmFsRmlsdGVyQ2hhbmdlID09IG51bGwgfHwgZS5vcHRpb25zLm9uR2xvYmFsRmlsdGVyQ2hhbmdlKHQpO1xuICAgIH0sIGUucmVzZXRHbG9iYWxGaWx0ZXIgPSAodCkgPT4ge1xuICAgICAgZS5zZXRHbG9iYWxGaWx0ZXIodCA/IHZvaWQgMCA6IGUuaW5pdGlhbFN0YXRlLmdsb2JhbEZpbHRlcik7XG4gICAgfTtcbiAgfVxufSwgYlUgPSB7XG4gIGdldEluaXRpYWxTdGF0ZTogKGUpID0+ICh7XG4gICAgZXhwYW5kZWQ6IHt9LFxuICAgIC4uLmVcbiAgfSksXG4gIGdldERlZmF1bHRPcHRpb25zOiAoZSkgPT4gKHtcbiAgICBvbkV4cGFuZGVkQ2hhbmdlOiBQdChcImV4cGFuZGVkXCIsIGUpLFxuICAgIHBhZ2luYXRlRXhwYW5kZWRSb3dzOiAhMFxuICB9KSxcbiAgY3JlYXRlVGFibGU6IChlKSA9PiB7XG4gICAgbGV0IHQgPSAhMSwgbiA9ICExO1xuICAgIGUuX2F1dG9SZXNldEV4cGFuZGVkID0gKCkgPT4ge1xuICAgICAgdmFyIHIsIGk7XG4gICAgICBpZiAoIXQpIHtcbiAgICAgICAgZS5fcXVldWUoKCkgPT4ge1xuICAgICAgICAgIHQgPSAhMDtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICgociA9IChpID0gZS5vcHRpb25zLmF1dG9SZXNldEFsbCkgIT0gbnVsbCA/IGkgOiBlLm9wdGlvbnMuYXV0b1Jlc2V0RXhwYW5kZWQpICE9IG51bGwgPyByIDogIWUub3B0aW9ucy5tYW51YWxFeHBhbmRpbmcpIHtcbiAgICAgICAgaWYgKG4pXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICBuID0gITAsIGUuX3F1ZXVlKCgpID0+IHtcbiAgICAgICAgICBlLnJlc2V0RXhwYW5kZWQoKSwgbiA9ICExO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9LCBlLnNldEV4cGFuZGVkID0gKHIpID0+IGUub3B0aW9ucy5vbkV4cGFuZGVkQ2hhbmdlID09IG51bGwgPyB2b2lkIDAgOiBlLm9wdGlvbnMub25FeHBhbmRlZENoYW5nZShyKSwgZS50b2dnbGVBbGxSb3dzRXhwYW5kZWQgPSAocikgPT4ge1xuICAgICAgciA/PyAhZS5nZXRJc0FsbFJvd3NFeHBhbmRlZCgpID8gZS5zZXRFeHBhbmRlZCghMCkgOiBlLnNldEV4cGFuZGVkKHt9KTtcbiAgICB9LCBlLnJlc2V0RXhwYW5kZWQgPSAocikgPT4ge1xuICAgICAgdmFyIGksIG87XG4gICAgICBlLnNldEV4cGFuZGVkKHIgPyB7fSA6IChpID0gKG8gPSBlLmluaXRpYWxTdGF0ZSkgPT0gbnVsbCA/IHZvaWQgMCA6IG8uZXhwYW5kZWQpICE9IG51bGwgPyBpIDoge30pO1xuICAgIH0sIGUuZ2V0Q2FuU29tZVJvd3NFeHBhbmQgPSAoKSA9PiBlLmdldFByZVBhZ2luYXRpb25Sb3dNb2RlbCgpLmZsYXRSb3dzLnNvbWUoKHIpID0+IHIuZ2V0Q2FuRXhwYW5kKCkpLCBlLmdldFRvZ2dsZUFsbFJvd3NFeHBhbmRlZEhhbmRsZXIgPSAoKSA9PiAocikgPT4ge1xuICAgICAgci5wZXJzaXN0ID09IG51bGwgfHwgci5wZXJzaXN0KCksIGUudG9nZ2xlQWxsUm93c0V4cGFuZGVkKCk7XG4gICAgfSwgZS5nZXRJc1NvbWVSb3dzRXhwYW5kZWQgPSAoKSA9PiB7XG4gICAgICBjb25zdCByID0gZS5nZXRTdGF0ZSgpLmV4cGFuZGVkO1xuICAgICAgcmV0dXJuIHIgPT09ICEwIHx8IE9iamVjdC52YWx1ZXMocikuc29tZShCb29sZWFuKTtcbiAgICB9LCBlLmdldElzQWxsUm93c0V4cGFuZGVkID0gKCkgPT4ge1xuICAgICAgY29uc3QgciA9IGUuZ2V0U3RhdGUoKS5leHBhbmRlZDtcbiAgICAgIHJldHVybiB0eXBlb2YgciA9PSBcImJvb2xlYW5cIiA/IHIgPT09ICEwIDogISghT2JqZWN0LmtleXMocikubGVuZ3RoIHx8IGUuZ2V0Um93TW9kZWwoKS5mbGF0Um93cy5zb21lKChpKSA9PiAhaS5nZXRJc0V4cGFuZGVkKCkpKTtcbiAgICB9LCBlLmdldEV4cGFuZGVkRGVwdGggPSAoKSA9PiB7XG4gICAgICBsZXQgciA9IDA7XG4gICAgICByZXR1cm4gKGUuZ2V0U3RhdGUoKS5leHBhbmRlZCA9PT0gITAgPyBPYmplY3Qua2V5cyhlLmdldFJvd01vZGVsKCkucm93c0J5SWQpIDogT2JqZWN0LmtleXMoZS5nZXRTdGF0ZSgpLmV4cGFuZGVkKSkuZm9yRWFjaCgobykgPT4ge1xuICAgICAgICBjb25zdCBhID0gby5zcGxpdChcIi5cIik7XG4gICAgICAgIHIgPSBNYXRoLm1heChyLCBhLmxlbmd0aCk7XG4gICAgICB9KSwgcjtcbiAgICB9LCBlLmdldFByZUV4cGFuZGVkUm93TW9kZWwgPSAoKSA9PiBlLmdldFNvcnRlZFJvd01vZGVsKCksIGUuZ2V0RXhwYW5kZWRSb3dNb2RlbCA9ICgpID0+ICghZS5fZ2V0RXhwYW5kZWRSb3dNb2RlbCAmJiBlLm9wdGlvbnMuZ2V0RXhwYW5kZWRSb3dNb2RlbCAmJiAoZS5fZ2V0RXhwYW5kZWRSb3dNb2RlbCA9IGUub3B0aW9ucy5nZXRFeHBhbmRlZFJvd01vZGVsKGUpKSwgZS5vcHRpb25zLm1hbnVhbEV4cGFuZGluZyB8fCAhZS5fZ2V0RXhwYW5kZWRSb3dNb2RlbCA/IGUuZ2V0UHJlRXhwYW5kZWRSb3dNb2RlbCgpIDogZS5fZ2V0RXhwYW5kZWRSb3dNb2RlbCgpKTtcbiAgfSxcbiAgY3JlYXRlUm93OiAoZSwgdCkgPT4ge1xuICAgIGUudG9nZ2xlRXhwYW5kZWQgPSAobikgPT4ge1xuICAgICAgdC5zZXRFeHBhbmRlZCgocikgPT4ge1xuICAgICAgICB2YXIgaTtcbiAgICAgICAgY29uc3QgbyA9IHIgPT09ICEwID8gITAgOiAhIShyICE9IG51bGwgJiYgcltlLmlkXSk7XG4gICAgICAgIGxldCBhID0ge307XG4gICAgICAgIGlmIChyID09PSAhMCA/IE9iamVjdC5rZXlzKHQuZ2V0Um93TW9kZWwoKS5yb3dzQnlJZCkuZm9yRWFjaCgocykgPT4ge1xuICAgICAgICAgIGFbc10gPSAhMDtcbiAgICAgICAgfSkgOiBhID0gciwgbiA9IChpID0gbikgIT0gbnVsbCA/IGkgOiAhbywgIW8gJiYgbilcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4uYSxcbiAgICAgICAgICAgIFtlLmlkXTogITBcbiAgICAgICAgICB9O1xuICAgICAgICBpZiAobyAmJiAhbikge1xuICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgIFtlLmlkXTogcyxcbiAgICAgICAgICAgIC4uLnVcbiAgICAgICAgICB9ID0gYTtcbiAgICAgICAgICByZXR1cm4gdTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcjtcbiAgICAgIH0pO1xuICAgIH0sIGUuZ2V0SXNFeHBhbmRlZCA9ICgpID0+IHtcbiAgICAgIHZhciBuO1xuICAgICAgY29uc3QgciA9IHQuZ2V0U3RhdGUoKS5leHBhbmRlZDtcbiAgICAgIHJldHVybiAhISgobiA9IHQub3B0aW9ucy5nZXRJc1Jvd0V4cGFuZGVkID09IG51bGwgPyB2b2lkIDAgOiB0Lm9wdGlvbnMuZ2V0SXNSb3dFeHBhbmRlZChlKSkgIT0gbnVsbCA/IG4gOiByID09PSAhMCB8fCByICE9IG51bGwgJiYgcltlLmlkXSk7XG4gICAgfSwgZS5nZXRDYW5FeHBhbmQgPSAoKSA9PiB7XG4gICAgICB2YXIgbiwgciwgaTtcbiAgICAgIHJldHVybiAobiA9IHQub3B0aW9ucy5nZXRSb3dDYW5FeHBhbmQgPT0gbnVsbCA/IHZvaWQgMCA6IHQub3B0aW9ucy5nZXRSb3dDYW5FeHBhbmQoZSkpICE9IG51bGwgPyBuIDogKChyID0gdC5vcHRpb25zLmVuYWJsZUV4cGFuZGluZykgIT0gbnVsbCA/IHIgOiAhMCkgJiYgISEoKGkgPSBlLnN1YlJvd3MpICE9IG51bGwgJiYgaS5sZW5ndGgpO1xuICAgIH0sIGUuZ2V0SXNBbGxQYXJlbnRzRXhwYW5kZWQgPSAoKSA9PiB7XG4gICAgICBsZXQgbiA9ICEwLCByID0gZTtcbiAgICAgIGZvciAoOyBuICYmIHIucGFyZW50SWQ7IClcbiAgICAgICAgciA9IHQuZ2V0Um93KHIucGFyZW50SWQsICEwKSwgbiA9IHIuZ2V0SXNFeHBhbmRlZCgpO1xuICAgICAgcmV0dXJuIG47XG4gICAgfSwgZS5nZXRUb2dnbGVFeHBhbmRlZEhhbmRsZXIgPSAoKSA9PiB7XG4gICAgICBjb25zdCBuID0gZS5nZXRDYW5FeHBhbmQoKTtcbiAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIG4gJiYgZS50b2dnbGVFeHBhbmRlZCgpO1xuICAgICAgfTtcbiAgICB9O1xuICB9XG59LCBLbCA9IDAsIFlsID0gMTAsIGZjID0gKCkgPT4gKHtcbiAgcGFnZUluZGV4OiBLbCxcbiAgcGFnZVNpemU6IFlsXG59KSwgd1UgPSB7XG4gIGdldEluaXRpYWxTdGF0ZTogKGUpID0+ICh7XG4gICAgLi4uZSxcbiAgICBwYWdpbmF0aW9uOiB7XG4gICAgICAuLi5mYygpLFxuICAgICAgLi4uZSA9PSBudWxsID8gdm9pZCAwIDogZS5wYWdpbmF0aW9uXG4gICAgfVxuICB9KSxcbiAgZ2V0RGVmYXVsdE9wdGlvbnM6IChlKSA9PiAoe1xuICAgIG9uUGFnaW5hdGlvbkNoYW5nZTogUHQoXCJwYWdpbmF0aW9uXCIsIGUpXG4gIH0pLFxuICBjcmVhdGVUYWJsZTogKGUpID0+IHtcbiAgICBsZXQgdCA9ICExLCBuID0gITE7XG4gICAgZS5fYXV0b1Jlc2V0UGFnZUluZGV4ID0gKCkgPT4ge1xuICAgICAgdmFyIHIsIGk7XG4gICAgICBpZiAoIXQpIHtcbiAgICAgICAgZS5fcXVldWUoKCkgPT4ge1xuICAgICAgICAgIHQgPSAhMDtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICgociA9IChpID0gZS5vcHRpb25zLmF1dG9SZXNldEFsbCkgIT0gbnVsbCA/IGkgOiBlLm9wdGlvbnMuYXV0b1Jlc2V0UGFnZUluZGV4KSAhPSBudWxsID8gciA6ICFlLm9wdGlvbnMubWFudWFsUGFnaW5hdGlvbikge1xuICAgICAgICBpZiAobilcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIG4gPSAhMCwgZS5fcXVldWUoKCkgPT4ge1xuICAgICAgICAgIGUucmVzZXRQYWdlSW5kZXgoKSwgbiA9ICExO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9LCBlLnNldFBhZ2luYXRpb24gPSAocikgPT4ge1xuICAgICAgY29uc3QgaSA9IChvKSA9PiBObihyLCBvKTtcbiAgICAgIHJldHVybiBlLm9wdGlvbnMub25QYWdpbmF0aW9uQ2hhbmdlID09IG51bGwgPyB2b2lkIDAgOiBlLm9wdGlvbnMub25QYWdpbmF0aW9uQ2hhbmdlKGkpO1xuICAgIH0sIGUucmVzZXRQYWdpbmF0aW9uID0gKHIpID0+IHtcbiAgICAgIHZhciBpO1xuICAgICAgZS5zZXRQYWdpbmF0aW9uKHIgPyBmYygpIDogKGkgPSBlLmluaXRpYWxTdGF0ZS5wYWdpbmF0aW9uKSAhPSBudWxsID8gaSA6IGZjKCkpO1xuICAgIH0sIGUuc2V0UGFnZUluZGV4ID0gKHIpID0+IHtcbiAgICAgIGUuc2V0UGFnaW5hdGlvbigoaSkgPT4ge1xuICAgICAgICBsZXQgbyA9IE5uKHIsIGkucGFnZUluZGV4KTtcbiAgICAgICAgY29uc3QgYSA9IHR5cGVvZiBlLm9wdGlvbnMucGFnZUNvdW50ID4gXCJ1XCIgfHwgZS5vcHRpb25zLnBhZ2VDb3VudCA9PT0gLTEgPyBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUiA6IGUub3B0aW9ucy5wYWdlQ291bnQgLSAxO1xuICAgICAgICByZXR1cm4gbyA9IE1hdGgubWF4KDAsIE1hdGgubWluKG8sIGEpKSwge1xuICAgICAgICAgIC4uLmksXG4gICAgICAgICAgcGFnZUluZGV4OiBvXG4gICAgICAgIH07XG4gICAgICB9KTtcbiAgICB9LCBlLnJlc2V0UGFnZUluZGV4ID0gKHIpID0+IHtcbiAgICAgIHZhciBpLCBvO1xuICAgICAgZS5zZXRQYWdlSW5kZXgociA/IEtsIDogKGkgPSAobyA9IGUuaW5pdGlhbFN0YXRlKSA9PSBudWxsIHx8IChvID0gby5wYWdpbmF0aW9uKSA9PSBudWxsID8gdm9pZCAwIDogby5wYWdlSW5kZXgpICE9IG51bGwgPyBpIDogS2wpO1xuICAgIH0sIGUucmVzZXRQYWdlU2l6ZSA9IChyKSA9PiB7XG4gICAgICB2YXIgaSwgbztcbiAgICAgIGUuc2V0UGFnZVNpemUociA/IFlsIDogKGkgPSAobyA9IGUuaW5pdGlhbFN0YXRlKSA9PSBudWxsIHx8IChvID0gby5wYWdpbmF0aW9uKSA9PSBudWxsID8gdm9pZCAwIDogby5wYWdlU2l6ZSkgIT0gbnVsbCA/IGkgOiBZbCk7XG4gICAgfSwgZS5zZXRQYWdlU2l6ZSA9IChyKSA9PiB7XG4gICAgICBlLnNldFBhZ2luYXRpb24oKGkpID0+IHtcbiAgICAgICAgY29uc3QgbyA9IE1hdGgubWF4KDEsIE5uKHIsIGkucGFnZVNpemUpKSwgYSA9IGkucGFnZVNpemUgKiBpLnBhZ2VJbmRleCwgcyA9IE1hdGguZmxvb3IoYSAvIG8pO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIC4uLmksXG4gICAgICAgICAgcGFnZUluZGV4OiBzLFxuICAgICAgICAgIHBhZ2VTaXplOiBvXG4gICAgICAgIH07XG4gICAgICB9KTtcbiAgICB9LCBlLnNldFBhZ2VDb3VudCA9IChyKSA9PiBlLnNldFBhZ2luYXRpb24oKGkpID0+IHtcbiAgICAgIHZhciBvO1xuICAgICAgbGV0IGEgPSBObihyLCAobyA9IGUub3B0aW9ucy5wYWdlQ291bnQpICE9IG51bGwgPyBvIDogLTEpO1xuICAgICAgcmV0dXJuIHR5cGVvZiBhID09IFwibnVtYmVyXCIgJiYgKGEgPSBNYXRoLm1heCgtMSwgYSkpLCB7XG4gICAgICAgIC4uLmksXG4gICAgICAgIHBhZ2VDb3VudDogYVxuICAgICAgfTtcbiAgICB9KSwgZS5nZXRQYWdlT3B0aW9ucyA9IG9lKCgpID0+IFtlLmdldFBhZ2VDb3VudCgpXSwgKHIpID0+IHtcbiAgICAgIGxldCBpID0gW107XG4gICAgICByZXR1cm4gciAmJiByID4gMCAmJiAoaSA9IFsuLi5uZXcgQXJyYXkocildLmZpbGwobnVsbCkubWFwKChvLCBhKSA9PiBhKSksIGk7XG4gICAgfSwgYWUoZS5vcHRpb25zLCBcImRlYnVnVGFibGVcIiwgXCJnZXRQYWdlT3B0aW9uc1wiKSksIGUuZ2V0Q2FuUHJldmlvdXNQYWdlID0gKCkgPT4gZS5nZXRTdGF0ZSgpLnBhZ2luYXRpb24ucGFnZUluZGV4ID4gMCwgZS5nZXRDYW5OZXh0UGFnZSA9ICgpID0+IHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgcGFnZUluZGV4OiByXG4gICAgICB9ID0gZS5nZXRTdGF0ZSgpLnBhZ2luYXRpb24sIGkgPSBlLmdldFBhZ2VDb3VudCgpO1xuICAgICAgcmV0dXJuIGkgPT09IC0xID8gITAgOiBpID09PSAwID8gITEgOiByIDwgaSAtIDE7XG4gICAgfSwgZS5wcmV2aW91c1BhZ2UgPSAoKSA9PiBlLnNldFBhZ2VJbmRleCgocikgPT4gciAtIDEpLCBlLm5leHRQYWdlID0gKCkgPT4gZS5zZXRQYWdlSW5kZXgoKHIpID0+IHIgKyAxKSwgZS5maXJzdFBhZ2UgPSAoKSA9PiBlLnNldFBhZ2VJbmRleCgwKSwgZS5sYXN0UGFnZSA9ICgpID0+IGUuc2V0UGFnZUluZGV4KGUuZ2V0UGFnZUNvdW50KCkgLSAxKSwgZS5nZXRQcmVQYWdpbmF0aW9uUm93TW9kZWwgPSAoKSA9PiBlLmdldEV4cGFuZGVkUm93TW9kZWwoKSwgZS5nZXRQYWdpbmF0aW9uUm93TW9kZWwgPSAoKSA9PiAoIWUuX2dldFBhZ2luYXRpb25Sb3dNb2RlbCAmJiBlLm9wdGlvbnMuZ2V0UGFnaW5hdGlvblJvd01vZGVsICYmIChlLl9nZXRQYWdpbmF0aW9uUm93TW9kZWwgPSBlLm9wdGlvbnMuZ2V0UGFnaW5hdGlvblJvd01vZGVsKGUpKSwgZS5vcHRpb25zLm1hbnVhbFBhZ2luYXRpb24gfHwgIWUuX2dldFBhZ2luYXRpb25Sb3dNb2RlbCA/IGUuZ2V0UHJlUGFnaW5hdGlvblJvd01vZGVsKCkgOiBlLl9nZXRQYWdpbmF0aW9uUm93TW9kZWwoKSksIGUuZ2V0UGFnZUNvdW50ID0gKCkgPT4ge1xuICAgICAgdmFyIHI7XG4gICAgICByZXR1cm4gKHIgPSBlLm9wdGlvbnMucGFnZUNvdW50KSAhPSBudWxsID8gciA6IE1hdGguY2VpbChlLmdldFJvd0NvdW50KCkgLyBlLmdldFN0YXRlKCkucGFnaW5hdGlvbi5wYWdlU2l6ZSk7XG4gICAgfSwgZS5nZXRSb3dDb3VudCA9ICgpID0+IHtcbiAgICAgIHZhciByO1xuICAgICAgcmV0dXJuIChyID0gZS5vcHRpb25zLnJvd0NvdW50KSAhPSBudWxsID8gciA6IGUuZ2V0UHJlUGFnaW5hdGlvblJvd01vZGVsKCkucm93cy5sZW5ndGg7XG4gICAgfTtcbiAgfVxufSwgZGMgPSAoKSA9PiAoe1xuICB0b3A6IFtdLFxuICBib3R0b206IFtdXG59KSwgeFUgPSB7XG4gIGdldEluaXRpYWxTdGF0ZTogKGUpID0+ICh7XG4gICAgcm93UGlubmluZzogZGMoKSxcbiAgICAuLi5lXG4gIH0pLFxuICBnZXREZWZhdWx0T3B0aW9uczogKGUpID0+ICh7XG4gICAgb25Sb3dQaW5uaW5nQ2hhbmdlOiBQdChcInJvd1Bpbm5pbmdcIiwgZSlcbiAgfSksXG4gIGNyZWF0ZVJvdzogKGUsIHQpID0+IHtcbiAgICBlLnBpbiA9IChuLCByLCBpKSA9PiB7XG4gICAgICBjb25zdCBvID0gciA/IGUuZ2V0TGVhZlJvd3MoKS5tYXAoKHUpID0+IHtcbiAgICAgICAgbGV0IHtcbiAgICAgICAgICBpZDogY1xuICAgICAgICB9ID0gdTtcbiAgICAgICAgcmV0dXJuIGM7XG4gICAgICB9KSA6IFtdLCBhID0gaSA/IGUuZ2V0UGFyZW50Um93cygpLm1hcCgodSkgPT4ge1xuICAgICAgICBsZXQge1xuICAgICAgICAgIGlkOiBjXG4gICAgICAgIH0gPSB1O1xuICAgICAgICByZXR1cm4gYztcbiAgICAgIH0pIDogW10sIHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldChbLi4uYSwgZS5pZCwgLi4ub10pO1xuICAgICAgdC5zZXRSb3dQaW5uaW5nKCh1KSA9PiB7XG4gICAgICAgIHZhciBjLCBmO1xuICAgICAgICBpZiAobiA9PT0gXCJib3R0b21cIikge1xuICAgICAgICAgIHZhciBsLCBkO1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0b3A6ICgobCA9IHUgPT0gbnVsbCA/IHZvaWQgMCA6IHUudG9wKSAhPSBudWxsID8gbCA6IFtdKS5maWx0ZXIoKGgpID0+ICEocyAhPSBudWxsICYmIHMuaGFzKGgpKSksXG4gICAgICAgICAgICBib3R0b206IFsuLi4oKGQgPSB1ID09IG51bGwgPyB2b2lkIDAgOiB1LmJvdHRvbSkgIT0gbnVsbCA/IGQgOiBbXSkuZmlsdGVyKChoKSA9PiAhKHMgIT0gbnVsbCAmJiBzLmhhcyhoKSkpLCAuLi5BcnJheS5mcm9tKHMpXVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG4gPT09IFwidG9wXCIpIHtcbiAgICAgICAgICB2YXIgcCwgZztcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdG9wOiBbLi4uKChwID0gdSA9PSBudWxsID8gdm9pZCAwIDogdS50b3ApICE9IG51bGwgPyBwIDogW10pLmZpbHRlcigoaCkgPT4gIShzICE9IG51bGwgJiYgcy5oYXMoaCkpKSwgLi4uQXJyYXkuZnJvbShzKV0sXG4gICAgICAgICAgICBib3R0b206ICgoZyA9IHUgPT0gbnVsbCA/IHZvaWQgMCA6IHUuYm90dG9tKSAhPSBudWxsID8gZyA6IFtdKS5maWx0ZXIoKGgpID0+ICEocyAhPSBudWxsICYmIHMuaGFzKGgpKSlcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdG9wOiAoKGMgPSB1ID09IG51bGwgPyB2b2lkIDAgOiB1LnRvcCkgIT0gbnVsbCA/IGMgOiBbXSkuZmlsdGVyKChoKSA9PiAhKHMgIT0gbnVsbCAmJiBzLmhhcyhoKSkpLFxuICAgICAgICAgIGJvdHRvbTogKChmID0gdSA9PSBudWxsID8gdm9pZCAwIDogdS5ib3R0b20pICE9IG51bGwgPyBmIDogW10pLmZpbHRlcigoaCkgPT4gIShzICE9IG51bGwgJiYgcy5oYXMoaCkpKVxuICAgICAgICB9O1xuICAgICAgfSk7XG4gICAgfSwgZS5nZXRDYW5QaW4gPSAoKSA9PiB7XG4gICAgICB2YXIgbjtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgZW5hYmxlUm93UGlubmluZzogcixcbiAgICAgICAgZW5hYmxlUGlubmluZzogaVxuICAgICAgfSA9IHQub3B0aW9ucztcbiAgICAgIHJldHVybiB0eXBlb2YgciA9PSBcImZ1bmN0aW9uXCIgPyByKGUpIDogKG4gPSByID8/IGkpICE9IG51bGwgPyBuIDogITA7XG4gICAgfSwgZS5nZXRJc1Bpbm5lZCA9ICgpID0+IHtcbiAgICAgIGNvbnN0IG4gPSBbZS5pZF0sIHtcbiAgICAgICAgdG9wOiByLFxuICAgICAgICBib3R0b206IGlcbiAgICAgIH0gPSB0LmdldFN0YXRlKCkucm93UGlubmluZywgbyA9IG4uc29tZSgocykgPT4gciA9PSBudWxsID8gdm9pZCAwIDogci5pbmNsdWRlcyhzKSksIGEgPSBuLnNvbWUoKHMpID0+IGkgPT0gbnVsbCA/IHZvaWQgMCA6IGkuaW5jbHVkZXMocykpO1xuICAgICAgcmV0dXJuIG8gPyBcInRvcFwiIDogYSA/IFwiYm90dG9tXCIgOiAhMTtcbiAgICB9LCBlLmdldFBpbm5lZEluZGV4ID0gKCkgPT4ge1xuICAgICAgdmFyIG4sIHI7XG4gICAgICBjb25zdCBpID0gZS5nZXRJc1Bpbm5lZCgpO1xuICAgICAgaWYgKCFpKVxuICAgICAgICByZXR1cm4gLTE7XG4gICAgICBjb25zdCBvID0gKG4gPSB0Ll9nZXRQaW5uZWRSb3dzKGkpKSA9PSBudWxsID8gdm9pZCAwIDogbi5tYXAoKGEpID0+IHtcbiAgICAgICAgbGV0IHtcbiAgICAgICAgICBpZDogc1xuICAgICAgICB9ID0gYTtcbiAgICAgICAgcmV0dXJuIHM7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiAociA9IG8gPT0gbnVsbCA/IHZvaWQgMCA6IG8uaW5kZXhPZihlLmlkKSkgIT0gbnVsbCA/IHIgOiAtMTtcbiAgICB9O1xuICB9LFxuICBjcmVhdGVUYWJsZTogKGUpID0+IHtcbiAgICBlLnNldFJvd1Bpbm5pbmcgPSAodCkgPT4gZS5vcHRpb25zLm9uUm93UGlubmluZ0NoYW5nZSA9PSBudWxsID8gdm9pZCAwIDogZS5vcHRpb25zLm9uUm93UGlubmluZ0NoYW5nZSh0KSwgZS5yZXNldFJvd1Bpbm5pbmcgPSAodCkgPT4ge1xuICAgICAgdmFyIG4sIHI7XG4gICAgICByZXR1cm4gZS5zZXRSb3dQaW5uaW5nKHQgPyBkYygpIDogKG4gPSAociA9IGUuaW5pdGlhbFN0YXRlKSA9PSBudWxsID8gdm9pZCAwIDogci5yb3dQaW5uaW5nKSAhPSBudWxsID8gbiA6IGRjKCkpO1xuICAgIH0sIGUuZ2V0SXNTb21lUm93c1Bpbm5lZCA9ICh0KSA9PiB7XG4gICAgICB2YXIgbjtcbiAgICAgIGNvbnN0IHIgPSBlLmdldFN0YXRlKCkucm93UGlubmluZztcbiAgICAgIGlmICghdCkge1xuICAgICAgICB2YXIgaSwgbztcbiAgICAgICAgcmV0dXJuICEhKChpID0gci50b3ApICE9IG51bGwgJiYgaS5sZW5ndGggfHwgKG8gPSByLmJvdHRvbSkgIT0gbnVsbCAmJiBvLmxlbmd0aCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gISEoKG4gPSByW3RdKSAhPSBudWxsICYmIG4ubGVuZ3RoKTtcbiAgICB9LCBlLl9nZXRQaW5uZWRSb3dzID0gb2UoKHQpID0+IFtlLmdldFJvd01vZGVsKCkucm93cywgZS5nZXRTdGF0ZSgpLnJvd1Bpbm5pbmdbdF0sIHRdLCAodCwgbiwgcikgPT4ge1xuICAgICAgdmFyIGk7XG4gICAgICByZXR1cm4gKChpID0gZS5vcHRpb25zLmtlZXBQaW5uZWRSb3dzKSA9PSBudWxsIHx8IGkgPyAoXG4gICAgICAgIC8vZ2V0IGFsbCByb3dzIHRoYXQgYXJlIHBpbm5lZCBldmVuIGlmIHRoZXkgd291bGQgbm90IGJlIG90aGVyd2lzZSB2aXNpYmxlXG4gICAgICAgIC8vYWNjb3VudCBmb3IgZXhwYW5kZWQgcGFyZW50IHJvd3MsIGJ1dCBub3QgcGFnaW5hdGlvbiBvciBmaWx0ZXJpbmdcbiAgICAgICAgKG4gPz8gW10pLm1hcCgoYSkgPT4ge1xuICAgICAgICAgIGNvbnN0IHMgPSBlLmdldFJvdyhhLCAhMCk7XG4gICAgICAgICAgcmV0dXJuIHMuZ2V0SXNBbGxQYXJlbnRzRXhwYW5kZWQoKSA/IHMgOiBudWxsO1xuICAgICAgICB9KVxuICAgICAgKSA6IChcbiAgICAgICAgLy9lbHNlIGdldCBvbmx5IHZpc2libGUgcm93cyB0aGF0IGFyZSBwaW5uZWRcbiAgICAgICAgKG4gPz8gW10pLm1hcCgoYSkgPT4gdC5maW5kKChzKSA9PiBzLmlkID09PSBhKSlcbiAgICAgICkpLmZpbHRlcihCb29sZWFuKS5tYXAoKGEpID0+ICh7XG4gICAgICAgIC4uLmEsXG4gICAgICAgIHBvc2l0aW9uOiByXG4gICAgICB9KSk7XG4gICAgfSwgYWUoZS5vcHRpb25zLCBcImRlYnVnUm93c1wiLCBcIl9nZXRQaW5uZWRSb3dzXCIpKSwgZS5nZXRUb3BSb3dzID0gKCkgPT4gZS5fZ2V0UGlubmVkUm93cyhcInRvcFwiKSwgZS5nZXRCb3R0b21Sb3dzID0gKCkgPT4gZS5fZ2V0UGlubmVkUm93cyhcImJvdHRvbVwiKSwgZS5nZXRDZW50ZXJSb3dzID0gb2UoKCkgPT4gW2UuZ2V0Um93TW9kZWwoKS5yb3dzLCBlLmdldFN0YXRlKCkucm93UGlubmluZy50b3AsIGUuZ2V0U3RhdGUoKS5yb3dQaW5uaW5nLmJvdHRvbV0sICh0LCBuLCByKSA9PiB7XG4gICAgICBjb25zdCBpID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoWy4uLm4gPz8gW10sIC4uLnIgPz8gW11dKTtcbiAgICAgIHJldHVybiB0LmZpbHRlcigobykgPT4gIWkuaGFzKG8uaWQpKTtcbiAgICB9LCBhZShlLm9wdGlvbnMsIFwiZGVidWdSb3dzXCIsIFwiZ2V0Q2VudGVyUm93c1wiKSk7XG4gIH1cbn0sIFNVID0ge1xuICBnZXRJbml0aWFsU3RhdGU6IChlKSA9PiAoe1xuICAgIHJvd1NlbGVjdGlvbjoge30sXG4gICAgLi4uZVxuICB9KSxcbiAgZ2V0RGVmYXVsdE9wdGlvbnM6IChlKSA9PiAoe1xuICAgIG9uUm93U2VsZWN0aW9uQ2hhbmdlOiBQdChcInJvd1NlbGVjdGlvblwiLCBlKSxcbiAgICBlbmFibGVSb3dTZWxlY3Rpb246ICEwLFxuICAgIGVuYWJsZU11bHRpUm93U2VsZWN0aW9uOiAhMCxcbiAgICBlbmFibGVTdWJSb3dTZWxlY3Rpb246ICEwXG4gICAgLy8gZW5hYmxlR3JvdXBpbmdSb3dTZWxlY3Rpb246IGZhbHNlLFxuICAgIC8vIGlzQWRkaXRpdmVTZWxlY3RFdmVudDogKGU6IHVua25vd24pID0+ICEhZS5tZXRhS2V5LFxuICAgIC8vIGlzSW5jbHVzaXZlU2VsZWN0RXZlbnQ6IChlOiB1bmtub3duKSA9PiAhIWUuc2hpZnRLZXksXG4gIH0pLFxuICBjcmVhdGVUYWJsZTogKGUpID0+IHtcbiAgICBlLnNldFJvd1NlbGVjdGlvbiA9ICh0KSA9PiBlLm9wdGlvbnMub25Sb3dTZWxlY3Rpb25DaGFuZ2UgPT0gbnVsbCA/IHZvaWQgMCA6IGUub3B0aW9ucy5vblJvd1NlbGVjdGlvbkNoYW5nZSh0KSwgZS5yZXNldFJvd1NlbGVjdGlvbiA9ICh0KSA9PiB7XG4gICAgICB2YXIgbjtcbiAgICAgIHJldHVybiBlLnNldFJvd1NlbGVjdGlvbih0ID8ge30gOiAobiA9IGUuaW5pdGlhbFN0YXRlLnJvd1NlbGVjdGlvbikgIT0gbnVsbCA/IG4gOiB7fSk7XG4gICAgfSwgZS50b2dnbGVBbGxSb3dzU2VsZWN0ZWQgPSAodCkgPT4ge1xuICAgICAgZS5zZXRSb3dTZWxlY3Rpb24oKG4pID0+IHtcbiAgICAgICAgdCA9IHR5cGVvZiB0IDwgXCJ1XCIgPyB0IDogIWUuZ2V0SXNBbGxSb3dzU2VsZWN0ZWQoKTtcbiAgICAgICAgY29uc3QgciA9IHtcbiAgICAgICAgICAuLi5uXG4gICAgICAgIH0sIGkgPSBlLmdldFByZUdyb3VwZWRSb3dNb2RlbCgpLmZsYXRSb3dzO1xuICAgICAgICByZXR1cm4gdCA/IGkuZm9yRWFjaCgobykgPT4ge1xuICAgICAgICAgIG8uZ2V0Q2FuU2VsZWN0KCkgJiYgKHJbby5pZF0gPSAhMCk7XG4gICAgICAgIH0pIDogaS5mb3JFYWNoKChvKSA9PiB7XG4gICAgICAgICAgZGVsZXRlIHJbby5pZF07XG4gICAgICAgIH0pLCByO1xuICAgICAgfSk7XG4gICAgfSwgZS50b2dnbGVBbGxQYWdlUm93c1NlbGVjdGVkID0gKHQpID0+IGUuc2V0Um93U2VsZWN0aW9uKChuKSA9PiB7XG4gICAgICBjb25zdCByID0gdHlwZW9mIHQgPCBcInVcIiA/IHQgOiAhZS5nZXRJc0FsbFBhZ2VSb3dzU2VsZWN0ZWQoKSwgaSA9IHtcbiAgICAgICAgLi4ublxuICAgICAgfTtcbiAgICAgIHJldHVybiBlLmdldFJvd01vZGVsKCkucm93cy5mb3JFYWNoKChvKSA9PiB7XG4gICAgICAgIFhsKGksIG8uaWQsIHIsICEwLCBlKTtcbiAgICAgIH0pLCBpO1xuICAgIH0pLCBlLmdldFByZVNlbGVjdGVkUm93TW9kZWwgPSAoKSA9PiBlLmdldENvcmVSb3dNb2RlbCgpLCBlLmdldFNlbGVjdGVkUm93TW9kZWwgPSBvZSgoKSA9PiBbZS5nZXRTdGF0ZSgpLnJvd1NlbGVjdGlvbiwgZS5nZXRDb3JlUm93TW9kZWwoKV0sICh0LCBuKSA9PiBPYmplY3Qua2V5cyh0KS5sZW5ndGggPyBwYyhlLCBuKSA6IHtcbiAgICAgIHJvd3M6IFtdLFxuICAgICAgZmxhdFJvd3M6IFtdLFxuICAgICAgcm93c0J5SWQ6IHt9XG4gICAgfSwgYWUoZS5vcHRpb25zLCBcImRlYnVnVGFibGVcIiwgXCJnZXRTZWxlY3RlZFJvd01vZGVsXCIpKSwgZS5nZXRGaWx0ZXJlZFNlbGVjdGVkUm93TW9kZWwgPSBvZSgoKSA9PiBbZS5nZXRTdGF0ZSgpLnJvd1NlbGVjdGlvbiwgZS5nZXRGaWx0ZXJlZFJvd01vZGVsKCldLCAodCwgbikgPT4gT2JqZWN0LmtleXModCkubGVuZ3RoID8gcGMoZSwgbikgOiB7XG4gICAgICByb3dzOiBbXSxcbiAgICAgIGZsYXRSb3dzOiBbXSxcbiAgICAgIHJvd3NCeUlkOiB7fVxuICAgIH0sIGFlKGUub3B0aW9ucywgXCJkZWJ1Z1RhYmxlXCIsIFwiZ2V0RmlsdGVyZWRTZWxlY3RlZFJvd01vZGVsXCIpKSwgZS5nZXRHcm91cGVkU2VsZWN0ZWRSb3dNb2RlbCA9IG9lKCgpID0+IFtlLmdldFN0YXRlKCkucm93U2VsZWN0aW9uLCBlLmdldFNvcnRlZFJvd01vZGVsKCldLCAodCwgbikgPT4gT2JqZWN0LmtleXModCkubGVuZ3RoID8gcGMoZSwgbikgOiB7XG4gICAgICByb3dzOiBbXSxcbiAgICAgIGZsYXRSb3dzOiBbXSxcbiAgICAgIHJvd3NCeUlkOiB7fVxuICAgIH0sIGFlKGUub3B0aW9ucywgXCJkZWJ1Z1RhYmxlXCIsIFwiZ2V0R3JvdXBlZFNlbGVjdGVkUm93TW9kZWxcIikpLCBlLmdldElzQWxsUm93c1NlbGVjdGVkID0gKCkgPT4ge1xuICAgICAgY29uc3QgdCA9IGUuZ2V0RmlsdGVyZWRSb3dNb2RlbCgpLmZsYXRSb3dzLCB7XG4gICAgICAgIHJvd1NlbGVjdGlvbjogblxuICAgICAgfSA9IGUuZ2V0U3RhdGUoKTtcbiAgICAgIGxldCByID0gISEodC5sZW5ndGggJiYgT2JqZWN0LmtleXMobikubGVuZ3RoKTtcbiAgICAgIHJldHVybiByICYmIHQuc29tZSgoaSkgPT4gaS5nZXRDYW5TZWxlY3QoKSAmJiAhbltpLmlkXSkgJiYgKHIgPSAhMSksIHI7XG4gICAgfSwgZS5nZXRJc0FsbFBhZ2VSb3dzU2VsZWN0ZWQgPSAoKSA9PiB7XG4gICAgICBjb25zdCB0ID0gZS5nZXRQYWdpbmF0aW9uUm93TW9kZWwoKS5mbGF0Um93cy5maWx0ZXIoKGkpID0+IGkuZ2V0Q2FuU2VsZWN0KCkpLCB7XG4gICAgICAgIHJvd1NlbGVjdGlvbjogblxuICAgICAgfSA9IGUuZ2V0U3RhdGUoKTtcbiAgICAgIGxldCByID0gISF0Lmxlbmd0aDtcbiAgICAgIHJldHVybiByICYmIHQuc29tZSgoaSkgPT4gIW5baS5pZF0pICYmIChyID0gITEpLCByO1xuICAgIH0sIGUuZ2V0SXNTb21lUm93c1NlbGVjdGVkID0gKCkgPT4ge1xuICAgICAgdmFyIHQ7XG4gICAgICBjb25zdCBuID0gT2JqZWN0LmtleXMoKHQgPSBlLmdldFN0YXRlKCkucm93U2VsZWN0aW9uKSAhPSBudWxsID8gdCA6IHt9KS5sZW5ndGg7XG4gICAgICByZXR1cm4gbiA+IDAgJiYgbiA8IGUuZ2V0RmlsdGVyZWRSb3dNb2RlbCgpLmZsYXRSb3dzLmxlbmd0aDtcbiAgICB9LCBlLmdldElzU29tZVBhZ2VSb3dzU2VsZWN0ZWQgPSAoKSA9PiB7XG4gICAgICBjb25zdCB0ID0gZS5nZXRQYWdpbmF0aW9uUm93TW9kZWwoKS5mbGF0Um93cztcbiAgICAgIHJldHVybiBlLmdldElzQWxsUGFnZVJvd3NTZWxlY3RlZCgpID8gITEgOiB0LmZpbHRlcigobikgPT4gbi5nZXRDYW5TZWxlY3QoKSkuc29tZSgobikgPT4gbi5nZXRJc1NlbGVjdGVkKCkgfHwgbi5nZXRJc1NvbWVTZWxlY3RlZCgpKTtcbiAgICB9LCBlLmdldFRvZ2dsZUFsbFJvd3NTZWxlY3RlZEhhbmRsZXIgPSAoKSA9PiAodCkgPT4ge1xuICAgICAgZS50b2dnbGVBbGxSb3dzU2VsZWN0ZWQodC50YXJnZXQuY2hlY2tlZCk7XG4gICAgfSwgZS5nZXRUb2dnbGVBbGxQYWdlUm93c1NlbGVjdGVkSGFuZGxlciA9ICgpID0+ICh0KSA9PiB7XG4gICAgICBlLnRvZ2dsZUFsbFBhZ2VSb3dzU2VsZWN0ZWQodC50YXJnZXQuY2hlY2tlZCk7XG4gICAgfTtcbiAgfSxcbiAgY3JlYXRlUm93OiAoZSwgdCkgPT4ge1xuICAgIGUudG9nZ2xlU2VsZWN0ZWQgPSAobiwgcikgPT4ge1xuICAgICAgY29uc3QgaSA9IGUuZ2V0SXNTZWxlY3RlZCgpO1xuICAgICAgdC5zZXRSb3dTZWxlY3Rpb24oKG8pID0+IHtcbiAgICAgICAgdmFyIGE7XG4gICAgICAgIGlmIChuID0gdHlwZW9mIG4gPCBcInVcIiA/IG4gOiAhaSwgZS5nZXRDYW5TZWxlY3QoKSAmJiBpID09PSBuKVxuICAgICAgICAgIHJldHVybiBvO1xuICAgICAgICBjb25zdCBzID0ge1xuICAgICAgICAgIC4uLm9cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIFhsKHMsIGUuaWQsIG4sIChhID0gciA9PSBudWxsID8gdm9pZCAwIDogci5zZWxlY3RDaGlsZHJlbikgIT0gbnVsbCA/IGEgOiAhMCwgdCksIHM7XG4gICAgICB9KTtcbiAgICB9LCBlLmdldElzU2VsZWN0ZWQgPSAoKSA9PiB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHJvd1NlbGVjdGlvbjogblxuICAgICAgfSA9IHQuZ2V0U3RhdGUoKTtcbiAgICAgIHJldHVybiBPZChlLCBuKTtcbiAgICB9LCBlLmdldElzU29tZVNlbGVjdGVkID0gKCkgPT4ge1xuICAgICAgY29uc3Qge1xuICAgICAgICByb3dTZWxlY3Rpb246IG5cbiAgICAgIH0gPSB0LmdldFN0YXRlKCk7XG4gICAgICByZXR1cm4gWmwoZSwgbikgPT09IFwic29tZVwiO1xuICAgIH0sIGUuZ2V0SXNBbGxTdWJSb3dzU2VsZWN0ZWQgPSAoKSA9PiB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHJvd1NlbGVjdGlvbjogblxuICAgICAgfSA9IHQuZ2V0U3RhdGUoKTtcbiAgICAgIHJldHVybiBabChlLCBuKSA9PT0gXCJhbGxcIjtcbiAgICB9LCBlLmdldENhblNlbGVjdCA9ICgpID0+IHtcbiAgICAgIHZhciBuO1xuICAgICAgcmV0dXJuIHR5cGVvZiB0Lm9wdGlvbnMuZW5hYmxlUm93U2VsZWN0aW9uID09IFwiZnVuY3Rpb25cIiA/IHQub3B0aW9ucy5lbmFibGVSb3dTZWxlY3Rpb24oZSkgOiAobiA9IHQub3B0aW9ucy5lbmFibGVSb3dTZWxlY3Rpb24pICE9IG51bGwgPyBuIDogITA7XG4gICAgfSwgZS5nZXRDYW5TZWxlY3RTdWJSb3dzID0gKCkgPT4ge1xuICAgICAgdmFyIG47XG4gICAgICByZXR1cm4gdHlwZW9mIHQub3B0aW9ucy5lbmFibGVTdWJSb3dTZWxlY3Rpb24gPT0gXCJmdW5jdGlvblwiID8gdC5vcHRpb25zLmVuYWJsZVN1YlJvd1NlbGVjdGlvbihlKSA6IChuID0gdC5vcHRpb25zLmVuYWJsZVN1YlJvd1NlbGVjdGlvbikgIT0gbnVsbCA/IG4gOiAhMDtcbiAgICB9LCBlLmdldENhbk11bHRpU2VsZWN0ID0gKCkgPT4ge1xuICAgICAgdmFyIG47XG4gICAgICByZXR1cm4gdHlwZW9mIHQub3B0aW9ucy5lbmFibGVNdWx0aVJvd1NlbGVjdGlvbiA9PSBcImZ1bmN0aW9uXCIgPyB0Lm9wdGlvbnMuZW5hYmxlTXVsdGlSb3dTZWxlY3Rpb24oZSkgOiAobiA9IHQub3B0aW9ucy5lbmFibGVNdWx0aVJvd1NlbGVjdGlvbikgIT0gbnVsbCA/IG4gOiAhMDtcbiAgICB9LCBlLmdldFRvZ2dsZVNlbGVjdGVkSGFuZGxlciA9ICgpID0+IHtcbiAgICAgIGNvbnN0IG4gPSBlLmdldENhblNlbGVjdCgpO1xuICAgICAgcmV0dXJuIChyKSA9PiB7XG4gICAgICAgIHZhciBpO1xuICAgICAgICBuICYmIGUudG9nZ2xlU2VsZWN0ZWQoKGkgPSByLnRhcmdldCkgPT0gbnVsbCA/IHZvaWQgMCA6IGkuY2hlY2tlZCk7XG4gICAgICB9O1xuICAgIH07XG4gIH1cbn0sIFhsID0gKGUsIHQsIG4sIHIsIGkpID0+IHtcbiAgdmFyIG87XG4gIGNvbnN0IGEgPSBpLmdldFJvdyh0LCAhMCk7XG4gIG4gPyAoYS5nZXRDYW5NdWx0aVNlbGVjdCgpIHx8IE9iamVjdC5rZXlzKGUpLmZvckVhY2goKHMpID0+IGRlbGV0ZSBlW3NdKSwgYS5nZXRDYW5TZWxlY3QoKSAmJiAoZVt0XSA9ICEwKSkgOiBkZWxldGUgZVt0XSwgciAmJiAobyA9IGEuc3ViUm93cykgIT0gbnVsbCAmJiBvLmxlbmd0aCAmJiBhLmdldENhblNlbGVjdFN1YlJvd3MoKSAmJiBhLnN1YlJvd3MuZm9yRWFjaCgocykgPT4gWGwoZSwgcy5pZCwgbiwgciwgaSkpO1xufTtcbmZ1bmN0aW9uIHBjKGUsIHQpIHtcbiAgY29uc3QgbiA9IGUuZ2V0U3RhdGUoKS5yb3dTZWxlY3Rpb24sIHIgPSBbXSwgaSA9IHt9LCBvID0gZnVuY3Rpb24oYSwgcykge1xuICAgIHJldHVybiBhLm1hcCgodSkgPT4ge1xuICAgICAgdmFyIGM7XG4gICAgICBjb25zdCBmID0gT2QodSwgbik7XG4gICAgICBpZiAoZiAmJiAoci5wdXNoKHUpLCBpW3UuaWRdID0gdSksIChjID0gdS5zdWJSb3dzKSAhPSBudWxsICYmIGMubGVuZ3RoICYmICh1ID0ge1xuICAgICAgICAuLi51LFxuICAgICAgICBzdWJSb3dzOiBvKHUuc3ViUm93cylcbiAgICAgIH0pLCBmKVxuICAgICAgICByZXR1cm4gdTtcbiAgICB9KS5maWx0ZXIoQm9vbGVhbik7XG4gIH07XG4gIHJldHVybiB7XG4gICAgcm93czogbyh0LnJvd3MpLFxuICAgIGZsYXRSb3dzOiByLFxuICAgIHJvd3NCeUlkOiBpXG4gIH07XG59XG5mdW5jdGlvbiBPZChlLCB0KSB7XG4gIHZhciBuO1xuICByZXR1cm4gKG4gPSB0W2UuaWRdKSAhPSBudWxsID8gbiA6ICExO1xufVxuZnVuY3Rpb24gWmwoZSwgdCwgbikge1xuICB2YXIgcjtcbiAgaWYgKCEoKHIgPSBlLnN1YlJvd3MpICE9IG51bGwgJiYgci5sZW5ndGgpKVxuICAgIHJldHVybiAhMTtcbiAgbGV0IGkgPSAhMCwgbyA9ICExO1xuICByZXR1cm4gZS5zdWJSb3dzLmZvckVhY2goKGEpID0+IHtcbiAgICBpZiAoIShvICYmICFpKSAmJiAoYS5nZXRDYW5TZWxlY3QoKSAmJiAoT2QoYSwgdCkgPyBvID0gITAgOiBpID0gITEpLCBhLnN1YlJvd3MgJiYgYS5zdWJSb3dzLmxlbmd0aCkpIHtcbiAgICAgIGNvbnN0IHMgPSBabChhLCB0KTtcbiAgICAgIHMgPT09IFwiYWxsXCIgPyBvID0gITAgOiAocyA9PT0gXCJzb21lXCIgJiYgKG8gPSAhMCksIGkgPSAhMSk7XG4gICAgfVxuICB9KSwgaSA/IFwiYWxsXCIgOiBvID8gXCJzb21lXCIgOiAhMTtcbn1cbmNvbnN0IEpsID0gLyhbMC05XSspL2dtLCAkVSA9IChlLCB0LCBuKSA9PiBYdyhHbihlLmdldFZhbHVlKG4pKS50b0xvd2VyQ2FzZSgpLCBHbih0LmdldFZhbHVlKG4pKS50b0xvd2VyQ2FzZSgpKSwgT1UgPSAoZSwgdCwgbikgPT4gWHcoR24oZS5nZXRWYWx1ZShuKSksIEduKHQuZ2V0VmFsdWUobikpKSwgX1UgPSAoZSwgdCwgbikgPT4gX2QoR24oZS5nZXRWYWx1ZShuKSkudG9Mb3dlckNhc2UoKSwgR24odC5nZXRWYWx1ZShuKSkudG9Mb3dlckNhc2UoKSksIEFVID0gKGUsIHQsIG4pID0+IF9kKEduKGUuZ2V0VmFsdWUobikpLCBHbih0LmdldFZhbHVlKG4pKSksIFBVID0gKGUsIHQsIG4pID0+IHtcbiAgY29uc3QgciA9IGUuZ2V0VmFsdWUobiksIGkgPSB0LmdldFZhbHVlKG4pO1xuICByZXR1cm4gciA+IGkgPyAxIDogciA8IGkgPyAtMSA6IDA7XG59LCBDVSA9IChlLCB0LCBuKSA9PiBfZChlLmdldFZhbHVlKG4pLCB0LmdldFZhbHVlKG4pKTtcbmZ1bmN0aW9uIF9kKGUsIHQpIHtcbiAgcmV0dXJuIGUgPT09IHQgPyAwIDogZSA+IHQgPyAxIDogLTE7XG59XG5mdW5jdGlvbiBHbihlKSB7XG4gIHJldHVybiB0eXBlb2YgZSA9PSBcIm51bWJlclwiID8gaXNOYU4oZSkgfHwgZSA9PT0gMSAvIDAgfHwgZSA9PT0gLTEgLyAwID8gXCJcIiA6IFN0cmluZyhlKSA6IHR5cGVvZiBlID09IFwic3RyaW5nXCIgPyBlIDogXCJcIjtcbn1cbmZ1bmN0aW9uIFh3KGUsIHQpIHtcbiAgY29uc3QgbiA9IGUuc3BsaXQoSmwpLmZpbHRlcihCb29sZWFuKSwgciA9IHQuc3BsaXQoSmwpLmZpbHRlcihCb29sZWFuKTtcbiAgZm9yICg7IG4ubGVuZ3RoICYmIHIubGVuZ3RoOyApIHtcbiAgICBjb25zdCBpID0gbi5zaGlmdCgpLCBvID0gci5zaGlmdCgpLCBhID0gcGFyc2VJbnQoaSwgMTApLCBzID0gcGFyc2VJbnQobywgMTApLCB1ID0gW2EsIHNdLnNvcnQoKTtcbiAgICBpZiAoaXNOYU4odVswXSkpIHtcbiAgICAgIGlmIChpID4gbylcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgICBpZiAobyA+IGkpXG4gICAgICAgIHJldHVybiAtMTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAoaXNOYU4odVsxXSkpXG4gICAgICByZXR1cm4gaXNOYU4oYSkgPyAtMSA6IDE7XG4gICAgaWYgKGEgPiBzKVxuICAgICAgcmV0dXJuIDE7XG4gICAgaWYgKHMgPiBhKVxuICAgICAgcmV0dXJuIC0xO1xuICB9XG4gIHJldHVybiBuLmxlbmd0aCAtIHIubGVuZ3RoO1xufVxuY29uc3QgQmkgPSB7XG4gIGFscGhhbnVtZXJpYzogJFUsXG4gIGFscGhhbnVtZXJpY0Nhc2VTZW5zaXRpdmU6IE9VLFxuICB0ZXh0OiBfVSxcbiAgdGV4dENhc2VTZW5zaXRpdmU6IEFVLFxuICBkYXRldGltZTogUFUsXG4gIGJhc2ljOiBDVVxufSwgRVUgPSB7XG4gIGdldEluaXRpYWxTdGF0ZTogKGUpID0+ICh7XG4gICAgc29ydGluZzogW10sXG4gICAgLi4uZVxuICB9KSxcbiAgZ2V0RGVmYXVsdENvbHVtbkRlZjogKCkgPT4gKHtcbiAgICBzb3J0aW5nRm46IFwiYXV0b1wiLFxuICAgIHNvcnRVbmRlZmluZWQ6IDFcbiAgfSksXG4gIGdldERlZmF1bHRPcHRpb25zOiAoZSkgPT4gKHtcbiAgICBvblNvcnRpbmdDaGFuZ2U6IFB0KFwic29ydGluZ1wiLCBlKSxcbiAgICBpc011bHRpU29ydEV2ZW50OiAodCkgPT4gdC5zaGlmdEtleVxuICB9KSxcbiAgY3JlYXRlQ29sdW1uOiAoZSwgdCkgPT4ge1xuICAgIGUuZ2V0QXV0b1NvcnRpbmdGbiA9ICgpID0+IHtcbiAgICAgIGNvbnN0IG4gPSB0LmdldEZpbHRlcmVkUm93TW9kZWwoKS5mbGF0Um93cy5zbGljZSgxMCk7XG4gICAgICBsZXQgciA9ICExO1xuICAgICAgZm9yIChjb25zdCBpIG9mIG4pIHtcbiAgICAgICAgY29uc3QgbyA9IGkgPT0gbnVsbCA/IHZvaWQgMCA6IGkuZ2V0VmFsdWUoZS5pZCk7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykgPT09IFwiW29iamVjdCBEYXRlXVwiKVxuICAgICAgICAgIHJldHVybiBCaS5kYXRldGltZTtcbiAgICAgICAgaWYgKHR5cGVvZiBvID09IFwic3RyaW5nXCIgJiYgKHIgPSAhMCwgby5zcGxpdChKbCkubGVuZ3RoID4gMSkpXG4gICAgICAgICAgcmV0dXJuIEJpLmFscGhhbnVtZXJpYztcbiAgICAgIH1cbiAgICAgIHJldHVybiByID8gQmkudGV4dCA6IEJpLmJhc2ljO1xuICAgIH0sIGUuZ2V0QXV0b1NvcnREaXIgPSAoKSA9PiB7XG4gICAgICBjb25zdCBuID0gdC5nZXRGaWx0ZXJlZFJvd01vZGVsKCkuZmxhdFJvd3NbMF07XG4gICAgICByZXR1cm4gdHlwZW9mIChuID09IG51bGwgPyB2b2lkIDAgOiBuLmdldFZhbHVlKGUuaWQpKSA9PSBcInN0cmluZ1wiID8gXCJhc2NcIiA6IFwiZGVzY1wiO1xuICAgIH0sIGUuZ2V0U29ydGluZ0ZuID0gKCkgPT4ge1xuICAgICAgdmFyIG4sIHI7XG4gICAgICBpZiAoIWUpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcigpO1xuICAgICAgcmV0dXJuIGx1KGUuY29sdW1uRGVmLnNvcnRpbmdGbikgPyBlLmNvbHVtbkRlZi5zb3J0aW5nRm4gOiBlLmNvbHVtbkRlZi5zb3J0aW5nRm4gPT09IFwiYXV0b1wiID8gZS5nZXRBdXRvU29ydGluZ0ZuKCkgOiAobiA9IChyID0gdC5vcHRpb25zLnNvcnRpbmdGbnMpID09IG51bGwgPyB2b2lkIDAgOiByW2UuY29sdW1uRGVmLnNvcnRpbmdGbl0pICE9IG51bGwgPyBuIDogQmlbZS5jb2x1bW5EZWYuc29ydGluZ0ZuXTtcbiAgICB9LCBlLnRvZ2dsZVNvcnRpbmcgPSAobiwgcikgPT4ge1xuICAgICAgY29uc3QgaSA9IGUuZ2V0TmV4dFNvcnRpbmdPcmRlcigpLCBvID0gdHlwZW9mIG4gPCBcInVcIiAmJiBuICE9PSBudWxsO1xuICAgICAgdC5zZXRTb3J0aW5nKChhKSA9PiB7XG4gICAgICAgIGNvbnN0IHMgPSBhID09IG51bGwgPyB2b2lkIDAgOiBhLmZpbmQoKHApID0+IHAuaWQgPT09IGUuaWQpLCB1ID0gYSA9PSBudWxsID8gdm9pZCAwIDogYS5maW5kSW5kZXgoKHApID0+IHAuaWQgPT09IGUuaWQpO1xuICAgICAgICBsZXQgYyA9IFtdLCBmLCBsID0gbyA/IG4gOiBpID09PSBcImRlc2NcIjtcbiAgICAgICAgaWYgKGEgIT0gbnVsbCAmJiBhLmxlbmd0aCAmJiBlLmdldENhbk11bHRpU29ydCgpICYmIHIgPyBzID8gZiA9IFwidG9nZ2xlXCIgOiBmID0gXCJhZGRcIiA6IGEgIT0gbnVsbCAmJiBhLmxlbmd0aCAmJiB1ICE9PSBhLmxlbmd0aCAtIDEgPyBmID0gXCJyZXBsYWNlXCIgOiBzID8gZiA9IFwidG9nZ2xlXCIgOiBmID0gXCJyZXBsYWNlXCIsIGYgPT09IFwidG9nZ2xlXCIgJiYgKG8gfHwgaSB8fCAoZiA9IFwicmVtb3ZlXCIpKSwgZiA9PT0gXCJhZGRcIikge1xuICAgICAgICAgIHZhciBkO1xuICAgICAgICAgIGMgPSBbLi4uYSwge1xuICAgICAgICAgICAgaWQ6IGUuaWQsXG4gICAgICAgICAgICBkZXNjOiBsXG4gICAgICAgICAgfV0sIGMuc3BsaWNlKDAsIGMubGVuZ3RoIC0gKChkID0gdC5vcHRpb25zLm1heE11bHRpU29ydENvbENvdW50KSAhPSBudWxsID8gZCA6IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSKSk7XG4gICAgICAgIH0gZWxzZVxuICAgICAgICAgIGYgPT09IFwidG9nZ2xlXCIgPyBjID0gYS5tYXAoKHApID0+IHAuaWQgPT09IGUuaWQgPyB7XG4gICAgICAgICAgICAuLi5wLFxuICAgICAgICAgICAgZGVzYzogbFxuICAgICAgICAgIH0gOiBwKSA6IGYgPT09IFwicmVtb3ZlXCIgPyBjID0gYS5maWx0ZXIoKHApID0+IHAuaWQgIT09IGUuaWQpIDogYyA9IFt7XG4gICAgICAgICAgICBpZDogZS5pZCxcbiAgICAgICAgICAgIGRlc2M6IGxcbiAgICAgICAgICB9XTtcbiAgICAgICAgcmV0dXJuIGM7XG4gICAgICB9KTtcbiAgICB9LCBlLmdldEZpcnN0U29ydERpciA9ICgpID0+IHtcbiAgICAgIHZhciBuLCByO1xuICAgICAgcmV0dXJuICgobiA9IChyID0gZS5jb2x1bW5EZWYuc29ydERlc2NGaXJzdCkgIT0gbnVsbCA/IHIgOiB0Lm9wdGlvbnMuc29ydERlc2NGaXJzdCkgIT0gbnVsbCA/IG4gOiBlLmdldEF1dG9Tb3J0RGlyKCkgPT09IFwiZGVzY1wiKSA/IFwiZGVzY1wiIDogXCJhc2NcIjtcbiAgICB9LCBlLmdldE5leHRTb3J0aW5nT3JkZXIgPSAobikgPT4ge1xuICAgICAgdmFyIHIsIGk7XG4gICAgICBjb25zdCBvID0gZS5nZXRGaXJzdFNvcnREaXIoKSwgYSA9IGUuZ2V0SXNTb3J0ZWQoKTtcbiAgICAgIHJldHVybiBhID8gYSAhPT0gbyAmJiAoKHIgPSB0Lm9wdGlvbnMuZW5hYmxlU29ydGluZ1JlbW92YWwpID09IG51bGwgfHwgcikgJiYgLy8gSWYgZW5hYmxlU29ydFJlbW92ZSwgZW5hYmxlIGluIGdlbmVyYWxcbiAgICAgICghKG4gJiYgKGkgPSB0Lm9wdGlvbnMuZW5hYmxlTXVsdGlSZW1vdmUpICE9IG51bGwpIHx8IGkpID8gITEgOiBhID09PSBcImRlc2NcIiA/IFwiYXNjXCIgOiBcImRlc2NcIiA6IG87XG4gICAgfSwgZS5nZXRDYW5Tb3J0ID0gKCkgPT4ge1xuICAgICAgdmFyIG4sIHI7XG4gICAgICByZXR1cm4gKChuID0gZS5jb2x1bW5EZWYuZW5hYmxlU29ydGluZykgIT0gbnVsbCA/IG4gOiAhMCkgJiYgKChyID0gdC5vcHRpb25zLmVuYWJsZVNvcnRpbmcpICE9IG51bGwgPyByIDogITApICYmICEhZS5hY2Nlc3NvckZuO1xuICAgIH0sIGUuZ2V0Q2FuTXVsdGlTb3J0ID0gKCkgPT4ge1xuICAgICAgdmFyIG4sIHI7XG4gICAgICByZXR1cm4gKG4gPSAociA9IGUuY29sdW1uRGVmLmVuYWJsZU11bHRpU29ydCkgIT0gbnVsbCA/IHIgOiB0Lm9wdGlvbnMuZW5hYmxlTXVsdGlTb3J0KSAhPSBudWxsID8gbiA6ICEhZS5hY2Nlc3NvckZuO1xuICAgIH0sIGUuZ2V0SXNTb3J0ZWQgPSAoKSA9PiB7XG4gICAgICB2YXIgbjtcbiAgICAgIGNvbnN0IHIgPSAobiA9IHQuZ2V0U3RhdGUoKS5zb3J0aW5nKSA9PSBudWxsID8gdm9pZCAwIDogbi5maW5kKChpKSA9PiBpLmlkID09PSBlLmlkKTtcbiAgICAgIHJldHVybiByID8gci5kZXNjID8gXCJkZXNjXCIgOiBcImFzY1wiIDogITE7XG4gICAgfSwgZS5nZXRTb3J0SW5kZXggPSAoKSA9PiB7XG4gICAgICB2YXIgbiwgcjtcbiAgICAgIHJldHVybiAobiA9IChyID0gdC5nZXRTdGF0ZSgpLnNvcnRpbmcpID09IG51bGwgPyB2b2lkIDAgOiByLmZpbmRJbmRleCgoaSkgPT4gaS5pZCA9PT0gZS5pZCkpICE9IG51bGwgPyBuIDogLTE7XG4gICAgfSwgZS5jbGVhclNvcnRpbmcgPSAoKSA9PiB7XG4gICAgICB0LnNldFNvcnRpbmcoKG4pID0+IG4gIT0gbnVsbCAmJiBuLmxlbmd0aCA/IG4uZmlsdGVyKChyKSA9PiByLmlkICE9PSBlLmlkKSA6IFtdKTtcbiAgICB9LCBlLmdldFRvZ2dsZVNvcnRpbmdIYW5kbGVyID0gKCkgPT4ge1xuICAgICAgY29uc3QgbiA9IGUuZ2V0Q2FuU29ydCgpO1xuICAgICAgcmV0dXJuIChyKSA9PiB7XG4gICAgICAgIG4gJiYgKHIucGVyc2lzdCA9PSBudWxsIHx8IHIucGVyc2lzdCgpLCBlLnRvZ2dsZVNvcnRpbmcgPT0gbnVsbCB8fCBlLnRvZ2dsZVNvcnRpbmcodm9pZCAwLCBlLmdldENhbk11bHRpU29ydCgpID8gdC5vcHRpb25zLmlzTXVsdGlTb3J0RXZlbnQgPT0gbnVsbCA/IHZvaWQgMCA6IHQub3B0aW9ucy5pc011bHRpU29ydEV2ZW50KHIpIDogITEpKTtcbiAgICAgIH07XG4gICAgfTtcbiAgfSxcbiAgY3JlYXRlVGFibGU6IChlKSA9PiB7XG4gICAgZS5zZXRTb3J0aW5nID0gKHQpID0+IGUub3B0aW9ucy5vblNvcnRpbmdDaGFuZ2UgPT0gbnVsbCA/IHZvaWQgMCA6IGUub3B0aW9ucy5vblNvcnRpbmdDaGFuZ2UodCksIGUucmVzZXRTb3J0aW5nID0gKHQpID0+IHtcbiAgICAgIHZhciBuLCByO1xuICAgICAgZS5zZXRTb3J0aW5nKHQgPyBbXSA6IChuID0gKHIgPSBlLmluaXRpYWxTdGF0ZSkgPT0gbnVsbCA/IHZvaWQgMCA6IHIuc29ydGluZykgIT0gbnVsbCA/IG4gOiBbXSk7XG4gICAgfSwgZS5nZXRQcmVTb3J0ZWRSb3dNb2RlbCA9ICgpID0+IGUuZ2V0R3JvdXBlZFJvd01vZGVsKCksIGUuZ2V0U29ydGVkUm93TW9kZWwgPSAoKSA9PiAoIWUuX2dldFNvcnRlZFJvd01vZGVsICYmIGUub3B0aW9ucy5nZXRTb3J0ZWRSb3dNb2RlbCAmJiAoZS5fZ2V0U29ydGVkUm93TW9kZWwgPSBlLm9wdGlvbnMuZ2V0U29ydGVkUm93TW9kZWwoZSkpLCBlLm9wdGlvbnMubWFudWFsU29ydGluZyB8fCAhZS5fZ2V0U29ydGVkUm93TW9kZWwgPyBlLmdldFByZVNvcnRlZFJvd01vZGVsKCkgOiBlLl9nZXRTb3J0ZWRSb3dNb2RlbCgpKTtcbiAgfVxufSwgVFUgPSBbXG4gIEpXLFxuICB2VSxcbiAgZFUsXG4gIHBVLFxuICBRVyxcbiAgZVUsXG4gIG1VLFxuICAvL2RlcGVuZHMgb24gQ29sdW1uRmFjZXRpbmdcbiAgeVUsXG4gIC8vZGVwZW5kcyBvbiBDb2x1bW5GaWx0ZXJpbmdcbiAgRVUsXG4gIGxVLFxuICAvL2RlcGVuZHMgb24gUm93U29ydGluZ1xuICBiVSxcbiAgd1UsXG4gIHhVLFxuICBTVSxcbiAgaFVcbl07XG5mdW5jdGlvbiBNVShlKSB7XG4gIHZhciB0LCBuO1xuICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgKGUuZGVidWdBbGwgfHwgZS5kZWJ1Z1RhYmxlKSAmJiBjb25zb2xlLmluZm8oXCJDcmVhdGluZyBUYWJsZSBJbnN0YW5jZS4uLlwiKTtcbiAgY29uc3QgciA9IFsuLi5UVSwgLi4uKHQgPSBlLl9mZWF0dXJlcykgIT0gbnVsbCA/IHQgOiBbXV07XG4gIGxldCBpID0ge1xuICAgIF9mZWF0dXJlczogclxuICB9O1xuICBjb25zdCBvID0gaS5fZmVhdHVyZXMucmVkdWNlKChkLCBwKSA9PiBPYmplY3QuYXNzaWduKGQsIHAuZ2V0RGVmYXVsdE9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IHAuZ2V0RGVmYXVsdE9wdGlvbnMoaSkpLCB7fSksIGEgPSAoZCkgPT4gaS5vcHRpb25zLm1lcmdlT3B0aW9ucyA/IGkub3B0aW9ucy5tZXJnZU9wdGlvbnMobywgZCkgOiB7XG4gICAgLi4ubyxcbiAgICAuLi5kXG4gIH07XG4gIGxldCB1ID0ge1xuICAgIC4uLnt9LFxuICAgIC4uLihuID0gZS5pbml0aWFsU3RhdGUpICE9IG51bGwgPyBuIDoge31cbiAgfTtcbiAgaS5fZmVhdHVyZXMuZm9yRWFjaCgoZCkgPT4ge1xuICAgIHZhciBwO1xuICAgIHUgPSAocCA9IGQuZ2V0SW5pdGlhbFN0YXRlID09IG51bGwgPyB2b2lkIDAgOiBkLmdldEluaXRpYWxTdGF0ZSh1KSkgIT0gbnVsbCA/IHAgOiB1O1xuICB9KTtcbiAgY29uc3QgYyA9IFtdO1xuICBsZXQgZiA9ICExO1xuICBjb25zdCBsID0ge1xuICAgIF9mZWF0dXJlczogcixcbiAgICBvcHRpb25zOiB7XG4gICAgICAuLi5vLFxuICAgICAgLi4uZVxuICAgIH0sXG4gICAgaW5pdGlhbFN0YXRlOiB1LFxuICAgIF9xdWV1ZTogKGQpID0+IHtcbiAgICAgIGMucHVzaChkKSwgZiB8fCAoZiA9ICEwLCBQcm9taXNlLnJlc29sdmUoKS50aGVuKCgpID0+IHtcbiAgICAgICAgZm9yICg7IGMubGVuZ3RoOyApXG4gICAgICAgICAgYy5zaGlmdCgpKCk7XG4gICAgICAgIGYgPSAhMTtcbiAgICAgIH0pLmNhdGNoKChwKSA9PiBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgdGhyb3cgcDtcbiAgICAgIH0pKSk7XG4gICAgfSxcbiAgICByZXNldDogKCkgPT4ge1xuICAgICAgaS5zZXRTdGF0ZShpLmluaXRpYWxTdGF0ZSk7XG4gICAgfSxcbiAgICBzZXRPcHRpb25zOiAoZCkgPT4ge1xuICAgICAgY29uc3QgcCA9IE5uKGQsIGkub3B0aW9ucyk7XG4gICAgICBpLm9wdGlvbnMgPSBhKHApO1xuICAgIH0sXG4gICAgZ2V0U3RhdGU6ICgpID0+IGkub3B0aW9ucy5zdGF0ZSxcbiAgICBzZXRTdGF0ZTogKGQpID0+IHtcbiAgICAgIGkub3B0aW9ucy5vblN0YXRlQ2hhbmdlID09IG51bGwgfHwgaS5vcHRpb25zLm9uU3RhdGVDaGFuZ2UoZCk7XG4gICAgfSxcbiAgICBfZ2V0Um93SWQ6IChkLCBwLCBnKSA9PiB7XG4gICAgICB2YXIgaDtcbiAgICAgIHJldHVybiAoaCA9IGkub3B0aW9ucy5nZXRSb3dJZCA9PSBudWxsID8gdm9pZCAwIDogaS5vcHRpb25zLmdldFJvd0lkKGQsIHAsIGcpKSAhPSBudWxsID8gaCA6IGAke2cgPyBbZy5pZCwgcF0uam9pbihcIi5cIikgOiBwfWA7XG4gICAgfSxcbiAgICBnZXRDb3JlUm93TW9kZWw6ICgpID0+IChpLl9nZXRDb3JlUm93TW9kZWwgfHwgKGkuX2dldENvcmVSb3dNb2RlbCA9IGkub3B0aW9ucy5nZXRDb3JlUm93TW9kZWwoaSkpLCBpLl9nZXRDb3JlUm93TW9kZWwoKSksXG4gICAgLy8gVGhlIGZpbmFsIGNhbGxzIHN0YXJ0IGF0IHRoZSBib3R0b20gb2YgdGhlIG1vZGVsLFxuICAgIC8vIGV4cGFuZGVkIHJvd3MsIHdoaWNoIHRoZW4gd29yayB0aGVpciB3YXkgdXBcbiAgICBnZXRSb3dNb2RlbDogKCkgPT4gaS5nZXRQYWdpbmF0aW9uUm93TW9kZWwoKSxcbiAgICAvL2luIG5leHQgdmVyc2lvbiwgd2Ugc2hvdWxkIGp1c3QgcGFzcyBpbiB0aGUgcm93IG1vZGVsIGFzIHRoZSBvcHRpb25hbCAybmQgYXJnXG4gICAgZ2V0Um93OiAoZCwgcCkgPT4ge1xuICAgICAgbGV0IGcgPSAocCA/IGkuZ2V0UHJlUGFnaW5hdGlvblJvd01vZGVsKCkgOiBpLmdldFJvd01vZGVsKCkpLnJvd3NCeUlkW2RdO1xuICAgICAgaWYgKCFnICYmIChnID0gaS5nZXRDb3JlUm93TW9kZWwoKS5yb3dzQnlJZFtkXSwgIWcpKVxuICAgICAgICB0aHJvdyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBuZXcgRXJyb3IoYGdldFJvdyBjb3VsZCBub3QgZmluZCByb3cgd2l0aCBJRDogJHtkfWApIDogbmV3IEVycm9yKCk7XG4gICAgICByZXR1cm4gZztcbiAgICB9LFxuICAgIF9nZXREZWZhdWx0Q29sdW1uRGVmOiBvZSgoKSA9PiBbaS5vcHRpb25zLmRlZmF1bHRDb2x1bW5dLCAoZCkgPT4ge1xuICAgICAgdmFyIHA7XG4gICAgICByZXR1cm4gZCA9IChwID0gZCkgIT0gbnVsbCA/IHAgOiB7fSwge1xuICAgICAgICBoZWFkZXI6IChnKSA9PiB7XG4gICAgICAgICAgY29uc3QgaCA9IGcuaGVhZGVyLmNvbHVtbi5jb2x1bW5EZWY7XG4gICAgICAgICAgcmV0dXJuIGguYWNjZXNzb3JLZXkgPyBoLmFjY2Vzc29yS2V5IDogaC5hY2Nlc3NvckZuID8gaC5pZCA6IG51bGw7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIGZvb3RlcjogcHJvcHMgPT4gcHJvcHMuaGVhZGVyLmNvbHVtbi5pZCxcbiAgICAgICAgY2VsbDogKGcpID0+IHtcbiAgICAgICAgICB2YXIgaCwgdjtcbiAgICAgICAgICByZXR1cm4gKGggPSAodiA9IGcucmVuZGVyVmFsdWUoKSkgPT0gbnVsbCB8fCB2LnRvU3RyaW5nID09IG51bGwgPyB2b2lkIDAgOiB2LnRvU3RyaW5nKCkpICE9IG51bGwgPyBoIDogbnVsbDtcbiAgICAgICAgfSxcbiAgICAgICAgLi4uaS5fZmVhdHVyZXMucmVkdWNlKChnLCBoKSA9PiBPYmplY3QuYXNzaWduKGcsIGguZ2V0RGVmYXVsdENvbHVtbkRlZiA9PSBudWxsID8gdm9pZCAwIDogaC5nZXREZWZhdWx0Q29sdW1uRGVmKCkpLCB7fSksXG4gICAgICAgIC4uLmRcbiAgICAgIH07XG4gICAgfSwgYWUoZSwgXCJkZWJ1Z0NvbHVtbnNcIiwgXCJfZ2V0RGVmYXVsdENvbHVtbkRlZlwiKSksXG4gICAgX2dldENvbHVtbkRlZnM6ICgpID0+IGkub3B0aW9ucy5jb2x1bW5zLFxuICAgIGdldEFsbENvbHVtbnM6IG9lKCgpID0+IFtpLl9nZXRDb2x1bW5EZWZzKCldLCAoZCkgPT4ge1xuICAgICAgY29uc3QgcCA9IGZ1bmN0aW9uKGcsIGgsIHYpIHtcbiAgICAgICAgcmV0dXJuIHYgPT09IHZvaWQgMCAmJiAodiA9IDApLCBnLm1hcCgodykgPT4ge1xuICAgICAgICAgIGNvbnN0IGIgPSBaVyhpLCB3LCB2LCBoKSwgeCA9IHc7XG4gICAgICAgICAgcmV0dXJuIGIuY29sdW1ucyA9IHguY29sdW1ucyA/IHAoeC5jb2x1bW5zLCBiLCB2ICsgMSkgOiBbXSwgYjtcbiAgICAgICAgfSk7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIHAoZCk7XG4gICAgfSwgYWUoZSwgXCJkZWJ1Z0NvbHVtbnNcIiwgXCJnZXRBbGxDb2x1bW5zXCIpKSxcbiAgICBnZXRBbGxGbGF0Q29sdW1uczogb2UoKCkgPT4gW2kuZ2V0QWxsQ29sdW1ucygpXSwgKGQpID0+IGQuZmxhdE1hcCgocCkgPT4gcC5nZXRGbGF0Q29sdW1ucygpKSwgYWUoZSwgXCJkZWJ1Z0NvbHVtbnNcIiwgXCJnZXRBbGxGbGF0Q29sdW1uc1wiKSksXG4gICAgX2dldEFsbEZsYXRDb2x1bW5zQnlJZDogb2UoKCkgPT4gW2kuZ2V0QWxsRmxhdENvbHVtbnMoKV0sIChkKSA9PiBkLnJlZHVjZSgocCwgZykgPT4gKHBbZy5pZF0gPSBnLCBwKSwge30pLCBhZShlLCBcImRlYnVnQ29sdW1uc1wiLCBcImdldEFsbEZsYXRDb2x1bW5zQnlJZFwiKSksXG4gICAgZ2V0QWxsTGVhZkNvbHVtbnM6IG9lKCgpID0+IFtpLmdldEFsbENvbHVtbnMoKSwgaS5fZ2V0T3JkZXJDb2x1bW5zRm4oKV0sIChkLCBwKSA9PiB7XG4gICAgICBsZXQgZyA9IGQuZmxhdE1hcCgoaCkgPT4gaC5nZXRMZWFmQ29sdW1ucygpKTtcbiAgICAgIHJldHVybiBwKGcpO1xuICAgIH0sIGFlKGUsIFwiZGVidWdDb2x1bW5zXCIsIFwiZ2V0QWxsTGVhZkNvbHVtbnNcIikpLFxuICAgIGdldENvbHVtbjogKGQpID0+IHtcbiAgICAgIGNvbnN0IHAgPSBpLl9nZXRBbGxGbGF0Q29sdW1uc0J5SWQoKVtkXTtcbiAgICAgIHJldHVybiBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgIXAgJiYgY29uc29sZS5lcnJvcihgW1RhYmxlXSBDb2x1bW4gd2l0aCBpZCAnJHtkfScgZG9lcyBub3QgZXhpc3QuYCksIHA7XG4gICAgfVxuICB9O1xuICBPYmplY3QuYXNzaWduKGksIGwpO1xuICBmb3IgKGxldCBkID0gMDsgZCA8IGkuX2ZlYXR1cmVzLmxlbmd0aDsgZCsrKSB7XG4gICAgY29uc3QgcCA9IGkuX2ZlYXR1cmVzW2RdO1xuICAgIHAgPT0gbnVsbCB8fCBwLmNyZWF0ZVRhYmxlID09IG51bGwgfHwgcC5jcmVhdGVUYWJsZShpKTtcbiAgfVxuICByZXR1cm4gaTtcbn1cbmZ1bmN0aW9uIFJVKCkge1xuICByZXR1cm4gKGUpID0+IG9lKCgpID0+IFtlLm9wdGlvbnMuZGF0YV0sICh0KSA9PiB7XG4gICAgY29uc3QgbiA9IHtcbiAgICAgIHJvd3M6IFtdLFxuICAgICAgZmxhdFJvd3M6IFtdLFxuICAgICAgcm93c0J5SWQ6IHt9XG4gICAgfSwgciA9IGZ1bmN0aW9uKGksIG8sIGEpIHtcbiAgICAgIG8gPT09IHZvaWQgMCAmJiAobyA9IDApO1xuICAgICAgY29uc3QgcyA9IFtdO1xuICAgICAgZm9yIChsZXQgYyA9IDA7IGMgPCBpLmxlbmd0aDsgYysrKSB7XG4gICAgICAgIGNvbnN0IGYgPSBTZChlLCBlLl9nZXRSb3dJZChpW2NdLCBjLCBhKSwgaVtjXSwgYywgbywgdm9pZCAwLCBhID09IG51bGwgPyB2b2lkIDAgOiBhLmlkKTtcbiAgICAgICAgaWYgKG4uZmxhdFJvd3MucHVzaChmKSwgbi5yb3dzQnlJZFtmLmlkXSA9IGYsIHMucHVzaChmKSwgZS5vcHRpb25zLmdldFN1YlJvd3MpIHtcbiAgICAgICAgICB2YXIgdTtcbiAgICAgICAgICBmLm9yaWdpbmFsU3ViUm93cyA9IGUub3B0aW9ucy5nZXRTdWJSb3dzKGlbY10sIGMpLCAodSA9IGYub3JpZ2luYWxTdWJSb3dzKSAhPSBudWxsICYmIHUubGVuZ3RoICYmIChmLnN1YlJvd3MgPSByKGYub3JpZ2luYWxTdWJSb3dzLCBvICsgMSwgZikpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcztcbiAgICB9O1xuICAgIHJldHVybiBuLnJvd3MgPSByKHQpLCBuO1xuICB9LCBhZShlLm9wdGlvbnMsIFwiZGVidWdUYWJsZVwiLCBcImdldFJvd01vZGVsXCIsICgpID0+IGUuX2F1dG9SZXNldFBhZ2VJbmRleCgpKSk7XG59XG5mdW5jdGlvbiBJVShlKSB7XG4gIGNvbnN0IHQgPSBbXSwgbiA9IChyKSA9PiB7XG4gICAgdmFyIGk7XG4gICAgdC5wdXNoKHIpLCAoaSA9IHIuc3ViUm93cykgIT0gbnVsbCAmJiBpLmxlbmd0aCAmJiByLmdldElzRXhwYW5kZWQoKSAmJiByLnN1YlJvd3MuZm9yRWFjaChuKTtcbiAgfTtcbiAgcmV0dXJuIGUucm93cy5mb3JFYWNoKG4pLCB7XG4gICAgcm93czogdCxcbiAgICBmbGF0Um93czogZS5mbGF0Um93cyxcbiAgICByb3dzQnlJZDogZS5yb3dzQnlJZFxuICB9O1xufVxuZnVuY3Rpb24galUoZSwgdCwgbikge1xuICByZXR1cm4gbi5vcHRpb25zLmZpbHRlckZyb21MZWFmUm93cyA/IGtVKGUsIHQsIG4pIDogRFUoZSwgdCwgbik7XG59XG5mdW5jdGlvbiBrVShlLCB0LCBuKSB7XG4gIHZhciByO1xuICBjb25zdCBpID0gW10sIG8gPSB7fSwgYSA9IChyID0gbi5vcHRpb25zLm1heExlYWZSb3dGaWx0ZXJEZXB0aCkgIT0gbnVsbCA/IHIgOiAxMDAsIHMgPSBmdW5jdGlvbih1LCBjKSB7XG4gICAgYyA9PT0gdm9pZCAwICYmIChjID0gMCk7XG4gICAgY29uc3QgZiA9IFtdO1xuICAgIGZvciAobGV0IGQgPSAwOyBkIDwgdS5sZW5ndGg7IGQrKykge1xuICAgICAgdmFyIGw7XG4gICAgICBsZXQgcCA9IHVbZF07XG4gICAgICBjb25zdCBnID0gU2QobiwgcC5pZCwgcC5vcmlnaW5hbCwgcC5pbmRleCwgcC5kZXB0aCwgdm9pZCAwLCBwLnBhcmVudElkKTtcbiAgICAgIGlmIChnLmNvbHVtbkZpbHRlcnMgPSBwLmNvbHVtbkZpbHRlcnMsIChsID0gcC5zdWJSb3dzKSAhPSBudWxsICYmIGwubGVuZ3RoICYmIGMgPCBhKSB7XG4gICAgICAgIGlmIChnLnN1YlJvd3MgPSBzKHAuc3ViUm93cywgYyArIDEpLCBwID0gZywgdChwKSAmJiAhZy5zdWJSb3dzLmxlbmd0aCkge1xuICAgICAgICAgIGYucHVzaChwKSwgb1twLmlkXSA9IHAsIGkucHVzaChwKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodChwKSB8fCBnLnN1YlJvd3MubGVuZ3RoKSB7XG4gICAgICAgICAgZi5wdXNoKHApLCBvW3AuaWRdID0gcCwgaS5wdXNoKHApO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2VcbiAgICAgICAgcCA9IGcsIHQocCkgJiYgKGYucHVzaChwKSwgb1twLmlkXSA9IHAsIGkucHVzaChwKSk7XG4gICAgfVxuICAgIHJldHVybiBmO1xuICB9O1xuICByZXR1cm4ge1xuICAgIHJvd3M6IHMoZSksXG4gICAgZmxhdFJvd3M6IGksXG4gICAgcm93c0J5SWQ6IG9cbiAgfTtcbn1cbmZ1bmN0aW9uIERVKGUsIHQsIG4pIHtcbiAgdmFyIHI7XG4gIGNvbnN0IGkgPSBbXSwgbyA9IHt9LCBhID0gKHIgPSBuLm9wdGlvbnMubWF4TGVhZlJvd0ZpbHRlckRlcHRoKSAhPSBudWxsID8gciA6IDEwMCwgcyA9IGZ1bmN0aW9uKHUsIGMpIHtcbiAgICBjID09PSB2b2lkIDAgJiYgKGMgPSAwKTtcbiAgICBjb25zdCBmID0gW107XG4gICAgZm9yIChsZXQgZCA9IDA7IGQgPCB1Lmxlbmd0aDsgZCsrKSB7XG4gICAgICBsZXQgcCA9IHVbZF07XG4gICAgICBpZiAodChwKSkge1xuICAgICAgICB2YXIgbDtcbiAgICAgICAgaWYgKChsID0gcC5zdWJSb3dzKSAhPSBudWxsICYmIGwubGVuZ3RoICYmIGMgPCBhKSB7XG4gICAgICAgICAgY29uc3QgaCA9IFNkKG4sIHAuaWQsIHAub3JpZ2luYWwsIHAuaW5kZXgsIHAuZGVwdGgsIHZvaWQgMCwgcC5wYXJlbnRJZCk7XG4gICAgICAgICAgaC5zdWJSb3dzID0gcyhwLnN1YlJvd3MsIGMgKyAxKSwgcCA9IGg7XG4gICAgICAgIH1cbiAgICAgICAgZi5wdXNoKHApLCBpLnB1c2gocCksIG9bcC5pZF0gPSBwO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZjtcbiAgfTtcbiAgcmV0dXJuIHtcbiAgICByb3dzOiBzKGUpLFxuICAgIGZsYXRSb3dzOiBpLFxuICAgIHJvd3NCeUlkOiBvXG4gIH07XG59XG5mdW5jdGlvbiBOVSgpIHtcbiAgcmV0dXJuIChlKSA9PiBvZSgoKSA9PiBbZS5nZXRQcmVGaWx0ZXJlZFJvd01vZGVsKCksIGUuZ2V0U3RhdGUoKS5jb2x1bW5GaWx0ZXJzLCBlLmdldFN0YXRlKCkuZ2xvYmFsRmlsdGVyXSwgKHQsIG4sIHIpID0+IHtcbiAgICBpZiAoIXQucm93cy5sZW5ndGggfHwgIShuICE9IG51bGwgJiYgbi5sZW5ndGgpICYmICFyKSB7XG4gICAgICBmb3IgKGxldCBkID0gMDsgZCA8IHQuZmxhdFJvd3MubGVuZ3RoOyBkKyspXG4gICAgICAgIHQuZmxhdFJvd3NbZF0uY29sdW1uRmlsdGVycyA9IHt9LCB0LmZsYXRSb3dzW2RdLmNvbHVtbkZpbHRlcnNNZXRhID0ge307XG4gICAgICByZXR1cm4gdDtcbiAgICB9XG4gICAgY29uc3QgaSA9IFtdLCBvID0gW107XG4gICAgKG4gPz8gW10pLmZvckVhY2goKGQpID0+IHtcbiAgICAgIHZhciBwO1xuICAgICAgY29uc3QgZyA9IGUuZ2V0Q29sdW1uKGQuaWQpO1xuICAgICAgaWYgKCFnKVxuICAgICAgICByZXR1cm47XG4gICAgICBjb25zdCBoID0gZy5nZXRGaWx0ZXJGbigpO1xuICAgICAgaWYgKCFoKSB7XG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiBjb25zb2xlLndhcm4oYENvdWxkIG5vdCBmaW5kIGEgdmFsaWQgJ2NvbHVtbi5maWx0ZXJGbicgZm9yIGNvbHVtbiB3aXRoIHRoZSBJRDogJHtnLmlkfS5gKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaS5wdXNoKHtcbiAgICAgICAgaWQ6IGQuaWQsXG4gICAgICAgIGZpbHRlckZuOiBoLFxuICAgICAgICByZXNvbHZlZFZhbHVlOiAocCA9IGgucmVzb2x2ZUZpbHRlclZhbHVlID09IG51bGwgPyB2b2lkIDAgOiBoLnJlc29sdmVGaWx0ZXJWYWx1ZShkLnZhbHVlKSkgIT0gbnVsbCA/IHAgOiBkLnZhbHVlXG4gICAgICB9KTtcbiAgICB9KTtcbiAgICBjb25zdCBhID0gKG4gPz8gW10pLm1hcCgoZCkgPT4gZC5pZCksIHMgPSBlLmdldEdsb2JhbEZpbHRlckZuKCksIHUgPSBlLmdldEFsbExlYWZDb2x1bW5zKCkuZmlsdGVyKChkKSA9PiBkLmdldENhbkdsb2JhbEZpbHRlcigpKTtcbiAgICByICYmIHMgJiYgdS5sZW5ndGggJiYgKGEucHVzaChcIl9fZ2xvYmFsX19cIiksIHUuZm9yRWFjaCgoZCkgPT4ge1xuICAgICAgdmFyIHA7XG4gICAgICBvLnB1c2goe1xuICAgICAgICBpZDogZC5pZCxcbiAgICAgICAgZmlsdGVyRm46IHMsXG4gICAgICAgIHJlc29sdmVkVmFsdWU6IChwID0gcy5yZXNvbHZlRmlsdGVyVmFsdWUgPT0gbnVsbCA/IHZvaWQgMCA6IHMucmVzb2x2ZUZpbHRlclZhbHVlKHIpKSAhPSBudWxsID8gcCA6IHJcbiAgICAgIH0pO1xuICAgIH0pKTtcbiAgICBsZXQgYywgZjtcbiAgICBmb3IgKGxldCBkID0gMDsgZCA8IHQuZmxhdFJvd3MubGVuZ3RoOyBkKyspIHtcbiAgICAgIGNvbnN0IHAgPSB0LmZsYXRSb3dzW2RdO1xuICAgICAgaWYgKHAuY29sdW1uRmlsdGVycyA9IHt9LCBpLmxlbmd0aClcbiAgICAgICAgZm9yIChsZXQgZyA9IDA7IGcgPCBpLmxlbmd0aDsgZysrKSB7XG4gICAgICAgICAgYyA9IGlbZ107XG4gICAgICAgICAgY29uc3QgaCA9IGMuaWQ7XG4gICAgICAgICAgcC5jb2x1bW5GaWx0ZXJzW2hdID0gYy5maWx0ZXJGbihwLCBoLCBjLnJlc29sdmVkVmFsdWUsICh2KSA9PiB7XG4gICAgICAgICAgICBwLmNvbHVtbkZpbHRlcnNNZXRhW2hdID0gdjtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgaWYgKG8ubGVuZ3RoKSB7XG4gICAgICAgIGZvciAobGV0IGcgPSAwOyBnIDwgby5sZW5ndGg7IGcrKykge1xuICAgICAgICAgIGYgPSBvW2ddO1xuICAgICAgICAgIGNvbnN0IGggPSBmLmlkO1xuICAgICAgICAgIGlmIChmLmZpbHRlckZuKHAsIGgsIGYucmVzb2x2ZWRWYWx1ZSwgKHYpID0+IHtcbiAgICAgICAgICAgIHAuY29sdW1uRmlsdGVyc01ldGFbaF0gPSB2O1xuICAgICAgICAgIH0pKSB7XG4gICAgICAgICAgICBwLmNvbHVtbkZpbHRlcnMuX19nbG9iYWxfXyA9ICEwO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHAuY29sdW1uRmlsdGVycy5fX2dsb2JhbF9fICE9PSAhMCAmJiAocC5jb2x1bW5GaWx0ZXJzLl9fZ2xvYmFsX18gPSAhMSk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGwgPSAoZCkgPT4ge1xuICAgICAgZm9yIChsZXQgcCA9IDA7IHAgPCBhLmxlbmd0aDsgcCsrKVxuICAgICAgICBpZiAoZC5jb2x1bW5GaWx0ZXJzW2FbcF1dID09PSAhMSlcbiAgICAgICAgICByZXR1cm4gITE7XG4gICAgICByZXR1cm4gITA7XG4gICAgfTtcbiAgICByZXR1cm4galUodC5yb3dzLCBsLCBlKTtcbiAgfSwgYWUoZS5vcHRpb25zLCBcImRlYnVnVGFibGVcIiwgXCJnZXRGaWx0ZXJlZFJvd01vZGVsXCIsICgpID0+IGUuX2F1dG9SZXNldFBhZ2VJbmRleCgpKSk7XG59XG5mdW5jdGlvbiBGVShlKSB7XG4gIHJldHVybiAodCkgPT4gb2UoKCkgPT4gW3QuZ2V0U3RhdGUoKS5wYWdpbmF0aW9uLCB0LmdldFByZVBhZ2luYXRpb25Sb3dNb2RlbCgpLCB0Lm9wdGlvbnMucGFnaW5hdGVFeHBhbmRlZFJvd3MgPyB2b2lkIDAgOiB0LmdldFN0YXRlKCkuZXhwYW5kZWRdLCAobiwgcikgPT4ge1xuICAgIGlmICghci5yb3dzLmxlbmd0aClcbiAgICAgIHJldHVybiByO1xuICAgIGNvbnN0IHtcbiAgICAgIHBhZ2VTaXplOiBpLFxuICAgICAgcGFnZUluZGV4OiBvXG4gICAgfSA9IG47XG4gICAgbGV0IHtcbiAgICAgIHJvd3M6IGEsXG4gICAgICBmbGF0Um93czogcyxcbiAgICAgIHJvd3NCeUlkOiB1XG4gICAgfSA9IHI7XG4gICAgY29uc3QgYyA9IGkgKiBvLCBmID0gYyArIGk7XG4gICAgYSA9IGEuc2xpY2UoYywgZik7XG4gICAgbGV0IGw7XG4gICAgdC5vcHRpb25zLnBhZ2luYXRlRXhwYW5kZWRSb3dzID8gbCA9IHtcbiAgICAgIHJvd3M6IGEsXG4gICAgICBmbGF0Um93czogcyxcbiAgICAgIHJvd3NCeUlkOiB1XG4gICAgfSA6IGwgPSBJVSh7XG4gICAgICByb3dzOiBhLFxuICAgICAgZmxhdFJvd3M6IHMsXG4gICAgICByb3dzQnlJZDogdVxuICAgIH0pLCBsLmZsYXRSb3dzID0gW107XG4gICAgY29uc3QgZCA9IChwKSA9PiB7XG4gICAgICBsLmZsYXRSb3dzLnB1c2gocCksIHAuc3ViUm93cy5sZW5ndGggJiYgcC5zdWJSb3dzLmZvckVhY2goZCk7XG4gICAgfTtcbiAgICByZXR1cm4gbC5yb3dzLmZvckVhY2goZCksIGw7XG4gIH0sIGFlKHQub3B0aW9ucywgXCJkZWJ1Z1RhYmxlXCIsIFwiZ2V0UGFnaW5hdGlvblJvd01vZGVsXCIpKTtcbn1cbmZ1bmN0aW9uIExVKCkge1xuICByZXR1cm4gKGUpID0+IG9lKCgpID0+IFtlLmdldFN0YXRlKCkuc29ydGluZywgZS5nZXRQcmVTb3J0ZWRSb3dNb2RlbCgpXSwgKHQsIG4pID0+IHtcbiAgICBpZiAoIW4ucm93cy5sZW5ndGggfHwgISh0ICE9IG51bGwgJiYgdC5sZW5ndGgpKVxuICAgICAgcmV0dXJuIG47XG4gICAgY29uc3QgciA9IGUuZ2V0U3RhdGUoKS5zb3J0aW5nLCBpID0gW10sIG8gPSByLmZpbHRlcigodSkgPT4ge1xuICAgICAgdmFyIGM7XG4gICAgICByZXR1cm4gKGMgPSBlLmdldENvbHVtbih1LmlkKSkgPT0gbnVsbCA/IHZvaWQgMCA6IGMuZ2V0Q2FuU29ydCgpO1xuICAgIH0pLCBhID0ge307XG4gICAgby5mb3JFYWNoKCh1KSA9PiB7XG4gICAgICBjb25zdCBjID0gZS5nZXRDb2x1bW4odS5pZCk7XG4gICAgICBjICYmIChhW3UuaWRdID0ge1xuICAgICAgICBzb3J0VW5kZWZpbmVkOiBjLmNvbHVtbkRlZi5zb3J0VW5kZWZpbmVkLFxuICAgICAgICBpbnZlcnRTb3J0aW5nOiBjLmNvbHVtbkRlZi5pbnZlcnRTb3J0aW5nLFxuICAgICAgICBzb3J0aW5nRm46IGMuZ2V0U29ydGluZ0ZuKClcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIGNvbnN0IHMgPSAodSkgPT4ge1xuICAgICAgY29uc3QgYyA9IHUubWFwKChmKSA9PiAoe1xuICAgICAgICAuLi5mXG4gICAgICB9KSk7XG4gICAgICByZXR1cm4gYy5zb3J0KChmLCBsKSA9PiB7XG4gICAgICAgIGZvciAobGV0IHAgPSAwOyBwIDwgby5sZW5ndGg7IHAgKz0gMSkge1xuICAgICAgICAgIHZhciBkO1xuICAgICAgICAgIGNvbnN0IGcgPSBvW3BdLCBoID0gYVtnLmlkXSwgdiA9IGguc29ydFVuZGVmaW5lZCwgdyA9IChkID0gZyA9PSBudWxsID8gdm9pZCAwIDogZy5kZXNjKSAhPSBudWxsID8gZCA6ICExO1xuICAgICAgICAgIGxldCBiID0gMDtcbiAgICAgICAgICBpZiAodikge1xuICAgICAgICAgICAgY29uc3QgeCA9IGYuZ2V0VmFsdWUoZy5pZCksIG0gPSBsLmdldFZhbHVlKGcuaWQpLCB5ID0geCA9PT0gdm9pZCAwLCBTID0gbSA9PT0gdm9pZCAwO1xuICAgICAgICAgICAgaWYgKHkgfHwgUykge1xuICAgICAgICAgICAgICBpZiAodiA9PT0gXCJmaXJzdFwiKVxuICAgICAgICAgICAgICAgIHJldHVybiB5ID8gLTEgOiAxO1xuICAgICAgICAgICAgICBpZiAodiA9PT0gXCJsYXN0XCIpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHkgPyAxIDogLTE7XG4gICAgICAgICAgICAgIGIgPSB5ICYmIFMgPyAwIDogeSA/IHYgOiAtdjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGIgPT09IDAgJiYgKGIgPSBoLnNvcnRpbmdGbihmLCBsLCBnLmlkKSksIGIgIT09IDApXG4gICAgICAgICAgICByZXR1cm4gdyAmJiAoYiAqPSAtMSksIGguaW52ZXJ0U29ydGluZyAmJiAoYiAqPSAtMSksIGI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGYuaW5kZXggLSBsLmluZGV4O1xuICAgICAgfSksIGMuZm9yRWFjaCgoZikgPT4ge1xuICAgICAgICB2YXIgbDtcbiAgICAgICAgaS5wdXNoKGYpLCAobCA9IGYuc3ViUm93cykgIT0gbnVsbCAmJiBsLmxlbmd0aCAmJiAoZi5zdWJSb3dzID0gcyhmLnN1YlJvd3MpKTtcbiAgICAgIH0pLCBjO1xuICAgIH07XG4gICAgcmV0dXJuIHtcbiAgICAgIHJvd3M6IHMobi5yb3dzKSxcbiAgICAgIGZsYXRSb3dzOiBpLFxuICAgICAgcm93c0J5SWQ6IG4ucm93c0J5SWRcbiAgICB9O1xuICB9LCBhZShlLm9wdGlvbnMsIFwiZGVidWdUYWJsZVwiLCBcImdldFNvcnRlZFJvd01vZGVsXCIsICgpID0+IGUuX2F1dG9SZXNldFBhZ2VJbmRleCgpKSk7XG59XG4vKipcbiAgICogcmVhY3QtdGFibGVcbiAgICpcbiAgICogQ29weXJpZ2h0IChjKSBUYW5TdGFja1xuICAgKlxuICAgKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAgICogTElDRU5TRS5tZCBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICAgKlxuICAgKiBAbGljZW5zZSBNSVRcbiAgICovXG5mdW5jdGlvbiBzbShlLCB0KSB7XG4gIHJldHVybiBlID8gQlUoZSkgPyAvKiBAX19QVVJFX18gKi8gSC5jcmVhdGVFbGVtZW50KGUsIHQpIDogZSA6IG51bGw7XG59XG5mdW5jdGlvbiBCVShlKSB7XG4gIHJldHVybiB6VShlKSB8fCB0eXBlb2YgZSA9PSBcImZ1bmN0aW9uXCIgfHwgVlUoZSk7XG59XG5mdW5jdGlvbiB6VShlKSB7XG4gIHJldHVybiB0eXBlb2YgZSA9PSBcImZ1bmN0aW9uXCIgJiYgKCgpID0+IHtcbiAgICBjb25zdCB0ID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKGUpO1xuICAgIHJldHVybiB0LnByb3RvdHlwZSAmJiB0LnByb3RvdHlwZS5pc1JlYWN0Q29tcG9uZW50O1xuICB9KSgpO1xufVxuZnVuY3Rpb24gVlUoZSkge1xuICByZXR1cm4gdHlwZW9mIGUgPT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgZS4kJHR5cGVvZiA9PSBcInN5bWJvbFwiICYmIFtcInJlYWN0Lm1lbW9cIiwgXCJyZWFjdC5mb3J3YXJkX3JlZlwiXS5pbmNsdWRlcyhlLiQkdHlwZW9mLmRlc2NyaXB0aW9uKTtcbn1cbmZ1bmN0aW9uIEdVKGUpIHtcbiAgY29uc3QgdCA9IHtcbiAgICBzdGF0ZToge30sXG4gICAgLy8gRHVtbXkgc3RhdGVcbiAgICBvblN0YXRlQ2hhbmdlOiAoKSA9PiB7XG4gICAgfSxcbiAgICAvLyBub29wXG4gICAgcmVuZGVyRmFsbGJhY2tWYWx1ZTogbnVsbCxcbiAgICAuLi5lXG4gIH0sIFtuXSA9IEgudXNlU3RhdGUoKCkgPT4gKHtcbiAgICBjdXJyZW50OiBNVSh0KVxuICB9KSksIFtyLCBpXSA9IEgudXNlU3RhdGUoKCkgPT4gbi5jdXJyZW50LmluaXRpYWxTdGF0ZSk7XG4gIHJldHVybiBuLmN1cnJlbnQuc2V0T3B0aW9ucygobykgPT4gKHtcbiAgICAuLi5vLFxuICAgIC4uLmUsXG4gICAgc3RhdGU6IHtcbiAgICAgIC4uLnIsXG4gICAgICAuLi5lLnN0YXRlXG4gICAgfSxcbiAgICAvLyBTaW1pbGFybHksIHdlJ2xsIG1haW50YWluIGJvdGggb3VyIGludGVybmFsIHN0YXRlIGFuZCBhbnkgdXNlci1wcm92aWRlZFxuICAgIC8vIHN0YXRlLlxuICAgIG9uU3RhdGVDaGFuZ2U6IChhKSA9PiB7XG4gICAgICBpKGEpLCBlLm9uU3RhdGVDaGFuZ2UgPT0gbnVsbCB8fCBlLm9uU3RhdGVDaGFuZ2UoYSk7XG4gICAgfVxuICB9KSksIG4uY3VycmVudDtcbn1cbmNvbnN0IFp3ID0gSC5mb3J3YXJkUmVmKFxuICAoeyBjbGFzc05hbWU6IGUsIHR5cGU6IHQsIC4uLm4gfSwgcikgPT4gLyogQF9fUFVSRV9fICovIFgoXG4gICAgXCJpbnB1dFwiLFxuICAgIHtcbiAgICAgIHR5cGU6IHQsXG4gICAgICBjbGFzc05hbWU6IExlKFxuICAgICAgICBcImZsZXggaC0xMCB3LWZ1bGwgcm91bmRlZC1tZCBib3JkZXIgYm9yZGVyLWlucHV0IGJnLWJhY2tncm91bmQgcHgtMyBweS0yIHRleHQtc20gcmluZy1vZmZzZXQtYmFja2dyb3VuZCBmaWxlOmJvcmRlci0wIGZpbGU6YmctdHJhbnNwYXJlbnQgZmlsZTp0ZXh0LXNtIGZpbGU6Zm9udC1tZWRpdW0gcGxhY2Vob2xkZXI6dGV4dC1tdXRlZC1mb3JlZ3JvdW5kIGZvY3VzLXZpc2libGU6b3V0bGluZS1ub25lIGZvY3VzLXZpc2libGU6cmluZy0yIGZvY3VzLXZpc2libGU6cmluZy1yaW5nIGZvY3VzLXZpc2libGU6cmluZy1vZmZzZXQtMiBkaXNhYmxlZDpjdXJzb3Itbm90LWFsbG93ZWQgZGlzYWJsZWQ6b3BhY2l0eS01MFwiLFxuICAgICAgICBlXG4gICAgICApLFxuICAgICAgcmVmOiByLFxuICAgICAgLi4ublxuICAgIH1cbiAgKVxuKTtcblp3LmRpc3BsYXlOYW1lID0gXCJJbnB1dFwiO1xuY29uc3QgSncgPSBILmZvcndhcmRSZWYoKHsgY2xhc3NOYW1lOiBlLCAuLi50IH0sIG4pID0+IC8qIEBfX1BVUkVfXyAqLyBYKFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcInJlbGF0aXZlIHctZnVsbCBvdmVyZmxvdy1hdXRvXCIsIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8gWChcbiAgXCJ0YWJsZVwiLFxuICB7XG4gICAgcmVmOiBuLFxuICAgIGNsYXNzTmFtZTogTGUoXCJ3LWZ1bGwgY2FwdGlvbi1ib3R0b20gdGV4dC1zbVwiLCBlKSxcbiAgICAuLi50XG4gIH1cbikgfSkpO1xuSncuZGlzcGxheU5hbWUgPSBcIlRhYmxlXCI7XG5jb25zdCBRdyA9IEguZm9yd2FyZFJlZigoeyBjbGFzc05hbWU6IGUsIC4uLnQgfSwgbikgPT4gLyogQF9fUFVSRV9fICovIFgoXCJ0aGVhZFwiLCB7IHJlZjogbiwgY2xhc3NOYW1lOiBMZShcIlsmX3RyXTpib3JkZXItYlwiLCBlKSwgLi4udCB9KSk7XG5Rdy5kaXNwbGF5TmFtZSA9IFwiVGFibGVIZWFkZXJcIjtcbmNvbnN0IGV4ID0gSC5mb3J3YXJkUmVmKCh7IGNsYXNzTmFtZTogZSwgLi4udCB9LCBuKSA9PiAvKiBAX19QVVJFX18gKi8gWChcbiAgXCJ0Ym9keVwiLFxuICB7XG4gICAgcmVmOiBuLFxuICAgIGNsYXNzTmFtZTogTGUoXCJbJl90cjpsYXN0LWNoaWxkXTpib3JkZXItMFwiLCBlKSxcbiAgICAuLi50XG4gIH1cbikpO1xuZXguZGlzcGxheU5hbWUgPSBcIlRhYmxlQm9keVwiO1xuY29uc3QgV1UgPSBILmZvcndhcmRSZWYoKHsgY2xhc3NOYW1lOiBlLCAuLi50IH0sIG4pID0+IC8qIEBfX1BVUkVfXyAqLyBYKFxuICBcInRmb290XCIsXG4gIHtcbiAgICByZWY6IG4sXG4gICAgY2xhc3NOYW1lOiBMZShcbiAgICAgIFwiYm9yZGVyLXQgYmctbXV0ZWQvNTAgZm9udC1tZWRpdW0gWyY+dHJdOmxhc3Q6Ym9yZGVyLWItMFwiLFxuICAgICAgZVxuICAgICksXG4gICAgLi4udFxuICB9XG4pKTtcbldVLmRpc3BsYXlOYW1lID0gXCJUYWJsZUZvb3RlclwiO1xuY29uc3QgVGEgPSBILmZvcndhcmRSZWYoKHsgY2xhc3NOYW1lOiBlLCAuLi50IH0sIG4pID0+IC8qIEBfX1BVUkVfXyAqLyBYKFxuICBcInRyXCIsXG4gIHtcbiAgICByZWY6IG4sXG4gICAgY2xhc3NOYW1lOiBMZShcbiAgICAgIFwiYm9yZGVyLWIgdHJhbnNpdGlvbi1jb2xvcnMgaG92ZXI6YmctbXV0ZWQvNTAgZGF0YS1bc3RhdGU9c2VsZWN0ZWRdOmJnLW11dGVkXCIsXG4gICAgICBlXG4gICAgKSxcbiAgICAuLi50XG4gIH1cbikpO1xuVGEuZGlzcGxheU5hbWUgPSBcIlRhYmxlUm93XCI7XG5jb25zdCB0eCA9IEguZm9yd2FyZFJlZigoeyBjbGFzc05hbWU6IGUsIC4uLnQgfSwgbikgPT4gLyogQF9fUFVSRV9fICovIFgoXG4gIFwidGhcIixcbiAge1xuICAgIHJlZjogbixcbiAgICBjbGFzc05hbWU6IExlKFxuICAgICAgXCJoLTEyIHB4LTQgdGV4dC1sZWZ0IGFsaWduLW1pZGRsZSBmb250LW1lZGl1bSB0ZXh0LW11dGVkLWZvcmVncm91bmQgWyY6aGFzKFtyb2xlPWNoZWNrYm94XSldOnByLTBcIixcbiAgICAgIGVcbiAgICApLFxuICAgIC4uLnRcbiAgfVxuKSk7XG50eC5kaXNwbGF5TmFtZSA9IFwiVGFibGVIZWFkXCI7XG5jb25zdCBRbCA9IEguZm9yd2FyZFJlZigoeyBjbGFzc05hbWU6IGUsIC4uLnQgfSwgbikgPT4gLyogQF9fUFVSRV9fICovIFgoXG4gIFwidGRcIixcbiAge1xuICAgIHJlZjogbixcbiAgICBjbGFzc05hbWU6IExlKFwicC00IGFsaWduLW1pZGRsZSBbJjpoYXMoW3JvbGU9Y2hlY2tib3hdKV06cHItMFwiLCBlKSxcbiAgICAuLi50XG4gIH1cbikpO1xuUWwuZGlzcGxheU5hbWUgPSBcIlRhYmxlQ2VsbFwiO1xuY29uc3QgVVUgPSBILmZvcndhcmRSZWYoKHsgY2xhc3NOYW1lOiBlLCAuLi50IH0sIG4pID0+IC8qIEBfX1BVUkVfXyAqLyBYKFxuICBcImNhcHRpb25cIixcbiAge1xuICAgIHJlZjogbixcbiAgICBjbGFzc05hbWU6IExlKFwibXQtNCB0ZXh0LXNtIHRleHQtbXV0ZWQtZm9yZWdyb3VuZFwiLCBlKSxcbiAgICAuLi50XG4gIH1cbikpO1xuVVUuZGlzcGxheU5hbWUgPSBcIlRhYmxlQ2FwdGlvblwiO1xuZnVuY3Rpb24gbkgoe1xuICBpbnB1dFBsYWNlSG9sZGVyOiBlLFxuICBkYXRhOiB0LFxuICBjb2x1bW5Ub1NlYXJjaERhdGE6IG4sXG4gIGNvbHVtbnM6IHIsXG4gIG5leHRCdXR0b25QYWdpbmF0aW9uVGV4dDogaSxcbiAgbm9SZXN1bHRUZXh0OiBvLFxuICBwcmV2aW91c0J1dHRvblBhZ2luYXRpb25UZXh0OiBhLFxuICByb3dzU2VsZWN0ZWRUZXh0OiBzXG59KSB7XG4gIHZhciB3LCBiO1xuICBjb25zdCBbdSwgY10gPSBILnVzZVN0YXRlKFtdKSwgW2YsIGxdID0gSC51c2VTdGF0ZShcbiAgICBbXVxuICApLCBbZCwgcF0gPSBILnVzZVN0YXRlKHt9KSwgW2csIGhdID0gSC51c2VTdGF0ZSh7fSksIHYgPSBHVSh7XG4gICAgZGF0YTogdCxcbiAgICBjb2x1bW5zOiByLFxuICAgIG9uU29ydGluZ0NoYW5nZTogYyxcbiAgICBvbkNvbHVtbkZpbHRlcnNDaGFuZ2U6IGwsXG4gICAgZ2V0Q29yZVJvd01vZGVsOiBSVSgpLFxuICAgIGdldFBhZ2luYXRpb25Sb3dNb2RlbDogRlUoKSxcbiAgICBnZXRTb3J0ZWRSb3dNb2RlbDogTFUoKSxcbiAgICBnZXRGaWx0ZXJlZFJvd01vZGVsOiBOVSgpLFxuICAgIG9uQ29sdW1uVmlzaWJpbGl0eUNoYW5nZTogcCxcbiAgICBvblJvd1NlbGVjdGlvbkNoYW5nZTogaCxcbiAgICBzdGF0ZToge1xuICAgICAgc29ydGluZzogdSxcbiAgICAgIGNvbHVtbkZpbHRlcnM6IGYsXG4gICAgICBjb2x1bW5WaXNpYmlsaXR5OiBkLFxuICAgICAgcm93U2VsZWN0aW9uOiBnXG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyB6ZShcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJ3LWZ1bGxcIiwgY2hpbGRyZW46IFtcbiAgICAvKiBAX19QVVJFX18gKi8gemUoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwiZmxleCBpdGVtcy1jZW50ZXIgcHktNFwiLCBjaGlsZHJlbjogW1xuICAgICAgLyogQF9fUFVSRV9fICovIFgoXG4gICAgICAgIFp3LFxuICAgICAgICB7XG4gICAgICAgICAgcGxhY2Vob2xkZXI6IGUsXG4gICAgICAgICAgdmFsdWU6ICgodyA9IHYuZ2V0Q29sdW1uKG4pKSA9PSBudWxsID8gdm9pZCAwIDogdy5nZXRGaWx0ZXJWYWx1ZSgpKSA/PyBcIlwiLFxuICAgICAgICAgIG9uQ2hhbmdlOiAoeCkgPT4ge1xuICAgICAgICAgICAgdmFyIG07XG4gICAgICAgICAgICByZXR1cm4gKG0gPSB2LmdldENvbHVtbihuKSkgPT0gbnVsbCA/IHZvaWQgMCA6IG0uc2V0RmlsdGVyVmFsdWUoeC50YXJnZXQudmFsdWUpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgY2xhc3NOYW1lOiBcIm1heC13LXNtXCJcbiAgICAgICAgfVxuICAgICAgKSxcbiAgICAgIC8qIEBfX1BVUkVfXyAqLyB6ZShFeSwgeyBjaGlsZHJlbjogW1xuICAgICAgICAvKiBAX19QVVJFX18gKi8gWChUeSwgeyBhc0NoaWxkOiAhMCwgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyB6ZShhciwgeyB2YXJpYW50OiBcIm91dGxpbmVcIiwgY2xhc3NOYW1lOiBcIm1sLWF1dG9cIiwgY2hpbGRyZW46IFtcbiAgICAgICAgICBcIkNvbHVtbnMgXCIsXG4gICAgICAgICAgLyogQF9fUFVSRV9fICovIFgoaDEsIHsgY2xhc3NOYW1lOiBcIm1sLTIgaC00IHctNFwiIH0pXG4gICAgICAgIF0gfSkgfSksXG4gICAgICAgIC8qIEBfX1BVUkVfXyAqLyBYKGdmLCB7IGFsaWduOiBcImVuZFwiLCBjaGlsZHJlbjogdi5nZXRBbGxDb2x1bW5zKCkuZmlsdGVyKCh4KSA9PiB4LmdldENhbkhpZGUoKSkubWFwKCh4KSA9PiAvKiBAX19QVVJFX18gKi8gWChcbiAgICAgICAgICBNeSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBjbGFzc05hbWU6IFwiY2FwaXRhbGl6ZVwiLFxuICAgICAgICAgICAgY2hlY2tlZDogeC5nZXRJc1Zpc2libGUoKSxcbiAgICAgICAgICAgIG9uQ2hlY2tlZENoYW5nZTogKG0pID0+IHgudG9nZ2xlVmlzaWJpbGl0eSghIW0pLFxuICAgICAgICAgICAgY2hpbGRyZW46IHguaWRcbiAgICAgICAgICB9LFxuICAgICAgICAgIHguaWRcbiAgICAgICAgKSkgfSlcbiAgICAgIF0gfSlcbiAgICBdIH0pLFxuICAgIC8qIEBfX1BVUkVfXyAqLyBYKFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcInJvdW5kZWQtbWQgYm9yZGVyXCIsIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8gemUoSncsIHsgY2hpbGRyZW46IFtcbiAgICAgIC8qIEBfX1BVUkVfXyAqLyBYKFF3LCB7IGNoaWxkcmVuOiB2LmdldEhlYWRlckdyb3VwcygpLm1hcCgoeCkgPT4gLyogQF9fUFVSRV9fICovIFgoVGEsIHsgY2hpbGRyZW46IHguaGVhZGVycy5tYXAoKG0pID0+IC8qIEBfX1BVUkVfXyAqLyBYKHR4LCB7IGNoaWxkcmVuOiBtLmlzUGxhY2Vob2xkZXIgPyBudWxsIDogc20oXG4gICAgICAgIG0uY29sdW1uLmNvbHVtbkRlZi5oZWFkZXIsXG4gICAgICAgIG0uZ2V0Q29udGV4dCgpXG4gICAgICApIH0sIG0uaWQpKSB9LCB4LmlkKSkgfSksXG4gICAgICAvKiBAX19QVVJFX18gKi8gWChleCwgeyBjaGlsZHJlbjogKGIgPSB2LmdldFJvd01vZGVsKCkucm93cykgIT0gbnVsbCAmJiBiLmxlbmd0aCA/IHYuZ2V0Um93TW9kZWwoKS5yb3dzLm1hcCgoeCkgPT4gLyogQF9fUFVSRV9fICovIFgoXG4gICAgICAgIFRhLFxuICAgICAgICB7XG4gICAgICAgICAgXCJkYXRhLXN0YXRlXCI6IHguZ2V0SXNTZWxlY3RlZCgpICYmIFwic2VsZWN0ZWRcIixcbiAgICAgICAgICBjaGlsZHJlbjogeC5nZXRWaXNpYmxlQ2VsbHMoKS5tYXAoKG0pID0+IC8qIEBfX1BVUkVfXyAqLyBYKFFsLCB7IGNoaWxkcmVuOiBzbShcbiAgICAgICAgICAgIG0uY29sdW1uLmNvbHVtbkRlZi5jZWxsLFxuICAgICAgICAgICAgbS5nZXRDb250ZXh0KClcbiAgICAgICAgICApIH0sIG0uaWQpKVxuICAgICAgICB9LFxuICAgICAgICB4LmlkXG4gICAgICApKSA6IC8qIEBfX1BVUkVfXyAqLyBYKFRhLCB7IGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8gWChcbiAgICAgICAgUWwsXG4gICAgICAgIHtcbiAgICAgICAgICBjb2xTcGFuOiByLmxlbmd0aCxcbiAgICAgICAgICBjbGFzc05hbWU6IFwiaC0yNCB0ZXh0LWNlbnRlclwiLFxuICAgICAgICAgIGNoaWxkcmVuOiBvXG4gICAgICAgIH1cbiAgICAgICkgfSkgfSlcbiAgICBdIH0pIH0pLFxuICAgIC8qIEBfX1BVUkVfXyAqLyB6ZShcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJmbGV4IGl0ZW1zLWNlbnRlciBqdXN0aWZ5LWVuZCBzcGFjZS14LTIgcHktNFwiLCBjaGlsZHJlbjogW1xuICAgICAgLyogQF9fUFVSRV9fICovIHplKFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcImZsZXgtMSB0ZXh0LXNtIHRleHQtbXV0ZWQtZm9yZWdyb3VuZFwiLCBjaGlsZHJlbjogW1xuICAgICAgICB2LmdldEZpbHRlcmVkU2VsZWN0ZWRSb3dNb2RlbCgpLnJvd3MubGVuZ3RoLFxuICAgICAgICBcIiBvZlwiLFxuICAgICAgICBcIiBcIixcbiAgICAgICAgdi5nZXRGaWx0ZXJlZFJvd01vZGVsKCkucm93cy5sZW5ndGgsXG4gICAgICAgIFwiIFwiLFxuICAgICAgICBzLFxuICAgICAgICBcIi5cIlxuICAgICAgXSB9KSxcbiAgICAgIC8qIEBfX1BVUkVfXyAqLyB6ZShcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJzcGFjZS14LTJcIiwgY2hpbGRyZW46IFtcbiAgICAgICAgLyogQF9fUFVSRV9fICovIFgoXG4gICAgICAgICAgYXIsXG4gICAgICAgICAge1xuICAgICAgICAgICAgdmFyaWFudDogXCJvdXRsaW5lXCIsXG4gICAgICAgICAgICBzaXplOiBcInNtXCIsXG4gICAgICAgICAgICBvbkNsaWNrOiAoKSA9PiB2LnByZXZpb3VzUGFnZSgpLFxuICAgICAgICAgICAgZGlzYWJsZWQ6ICF2LmdldENhblByZXZpb3VzUGFnZSgpLFxuICAgICAgICAgICAgY2hpbGRyZW46IGFcbiAgICAgICAgICB9XG4gICAgICAgICksXG4gICAgICAgIC8qIEBfX1BVUkVfXyAqLyBYKFxuICAgICAgICAgIGFyLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHZhcmlhbnQ6IFwib3V0bGluZVwiLFxuICAgICAgICAgICAgc2l6ZTogXCJzbVwiLFxuICAgICAgICAgICAgb25DbGljazogKCkgPT4gdi5uZXh0UGFnZSgpLFxuICAgICAgICAgICAgZGlzYWJsZWQ6ICF2LmdldENhbk5leHRQYWdlKCksXG4gICAgICAgICAgICBjaGlsZHJlbjogaVxuICAgICAgICAgIH1cbiAgICAgICAgKVxuICAgICAgXSB9KVxuICAgIF0gfSlcbiAgXSB9KTtcbn1cbmV4cG9ydCB7XG4gIGFyIGFzIEJ1dHRvbixcbiAgU20gYXMgQ2FyZCxcbiAgbkggYXMgRGF0YVRhYmxlLFxuICB0SCBhcyBHcmFwaCxcbiAgS1UgYXMgTmV3QnV0dG9uLFxuICBZVSBhcyBOZXdDYXJkLFxuICBlSCBhcyBUb2dnbGVCdXR0b25cbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1oYXpsZXktdWkuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/hazley-ui/dist/hazley-ui.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/zustand/esm/middleware.mjs":
/*!*************************************************!*\
  !*** ./node_modules/zustand/esm/middleware.mjs ***!
  \*************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   combine: function() { return /* binding */ combine; },\n/* harmony export */   createJSONStorage: function() { return /* binding */ createJSONStorage; },\n/* harmony export */   devtools: function() { return /* binding */ devtools; },\n/* harmony export */   persist: function() { return /* binding */ persist; },\n/* harmony export */   redux: function() { return /* binding */ redux; },\n/* harmony export */   subscribeWithSelector: function() { return /* binding */ subscribeWithSelector; }\n/* harmony export */ });\nconst reduxImpl = (reducer, initial) => (set, _get, api) => {\n  api.dispatch = (action) => {\n    set((state) => reducer(state, action), false, action);\n    return action;\n  };\n  api.dispatchFromDevtools = true;\n  return { dispatch: (...a) => api.dispatch(...a), ...initial };\n};\nconst redux = reduxImpl;\n\nconst trackedConnections = /* @__PURE__ */ new Map();\nconst getTrackedConnectionState = (name) => {\n  const api = trackedConnections.get(name);\n  if (!api)\n    return {};\n  return Object.fromEntries(\n    Object.entries(api.stores).map(([key, api2]) => [key, api2.getState()])\n  );\n};\nconst extractConnectionInformation = (store, extensionConnector, options) => {\n  if (store === void 0) {\n    return {\n      type: \"untracked\",\n      connection: extensionConnector.connect(options)\n    };\n  }\n  const existingConnection = trackedConnections.get(options.name);\n  if (existingConnection) {\n    return { type: \"tracked\", store, ...existingConnection };\n  }\n  const newConnection = {\n    connection: extensionConnector.connect(options),\n    stores: {}\n  };\n  trackedConnections.set(options.name, newConnection);\n  return { type: \"tracked\", store, ...newConnection };\n};\nconst devtoolsImpl = (fn, devtoolsOptions = {}) => (set, get, api) => {\n  const { enabled, anonymousActionType, store, ...options } = devtoolsOptions;\n  let extensionConnector;\n  try {\n    extensionConnector = (enabled != null ? enabled : ( false ? 0 : void 0) !== \"production\") && window.__REDUX_DEVTOOLS_EXTENSION__;\n  } catch (e) {\n  }\n  if (!extensionConnector) {\n    if (( false ? 0 : void 0) !== \"production\" && enabled) {\n      console.warn(\n        \"[zustand devtools middleware] Please install/enable Redux devtools extension\"\n      );\n    }\n    return fn(set, get, api);\n  }\n  const { connection, ...connectionInformation } = extractConnectionInformation(store, extensionConnector, options);\n  let isRecording = true;\n  api.setState = (state, replace, nameOrAction) => {\n    const r = set(state, replace);\n    if (!isRecording)\n      return r;\n    const action = nameOrAction === void 0 ? { type: anonymousActionType || \"anonymous\" } : typeof nameOrAction === \"string\" ? { type: nameOrAction } : nameOrAction;\n    if (store === void 0) {\n      connection == null ? void 0 : connection.send(action, get());\n      return r;\n    }\n    connection == null ? void 0 : connection.send(\n      {\n        ...action,\n        type: `${store}/${action.type}`\n      },\n      {\n        ...getTrackedConnectionState(options.name),\n        [store]: api.getState()\n      }\n    );\n    return r;\n  };\n  const setStateFromDevtools = (...a) => {\n    const originalIsRecording = isRecording;\n    isRecording = false;\n    set(...a);\n    isRecording = originalIsRecording;\n  };\n  const initialState = fn(api.setState, get, api);\n  if (connectionInformation.type === \"untracked\") {\n    connection == null ? void 0 : connection.init(initialState);\n  } else {\n    connectionInformation.stores[connectionInformation.store] = api;\n    connection == null ? void 0 : connection.init(\n      Object.fromEntries(\n        Object.entries(connectionInformation.stores).map(([key, store2]) => [\n          key,\n          key === connectionInformation.store ? initialState : store2.getState()\n        ])\n      )\n    );\n  }\n  if (api.dispatchFromDevtools && typeof api.dispatch === \"function\") {\n    let didWarnAboutReservedActionType = false;\n    const originalDispatch = api.dispatch;\n    api.dispatch = (...a) => {\n      if (( false ? 0 : void 0) !== \"production\" && a[0].type === \"__setState\" && !didWarnAboutReservedActionType) {\n        console.warn(\n          '[zustand devtools middleware] \"__setState\" action type is reserved to set state from the devtools. Avoid using it.'\n        );\n        didWarnAboutReservedActionType = true;\n      }\n      originalDispatch(...a);\n    };\n  }\n  connection.subscribe((message) => {\n    var _a;\n    switch (message.type) {\n      case \"ACTION\":\n        if (typeof message.payload !== \"string\") {\n          console.error(\n            \"[zustand devtools middleware] Unsupported action format\"\n          );\n          return;\n        }\n        return parseJsonThen(\n          message.payload,\n          (action) => {\n            if (action.type === \"__setState\") {\n              if (store === void 0) {\n                setStateFromDevtools(action.state);\n                return;\n              }\n              if (Object.keys(action.state).length !== 1) {\n                console.error(\n                  `\n                    [zustand devtools middleware] Unsupported __setState action format. \n                    When using 'store' option in devtools(), the 'state' should have only one key, which is a value of 'store' that was passed in devtools(),\n                    and value of this only key should be a state object. Example: { \"type\": \"__setState\", \"state\": { \"abc123Store\": { \"foo\": \"bar\" } } }\n                    `\n                );\n              }\n              const stateFromDevtools = action.state[store];\n              if (stateFromDevtools === void 0 || stateFromDevtools === null) {\n                return;\n              }\n              if (JSON.stringify(api.getState()) !== JSON.stringify(stateFromDevtools)) {\n                setStateFromDevtools(stateFromDevtools);\n              }\n              return;\n            }\n            if (!api.dispatchFromDevtools)\n              return;\n            if (typeof api.dispatch !== \"function\")\n              return;\n            api.dispatch(action);\n          }\n        );\n      case \"DISPATCH\":\n        switch (message.payload.type) {\n          case \"RESET\":\n            setStateFromDevtools(initialState);\n            if (store === void 0) {\n              return connection == null ? void 0 : connection.init(api.getState());\n            }\n            return connection == null ? void 0 : connection.init(getTrackedConnectionState(options.name));\n          case \"COMMIT\":\n            if (store === void 0) {\n              connection == null ? void 0 : connection.init(api.getState());\n              return;\n            }\n            return connection == null ? void 0 : connection.init(getTrackedConnectionState(options.name));\n          case \"ROLLBACK\":\n            return parseJsonThen(message.state, (state) => {\n              if (store === void 0) {\n                setStateFromDevtools(state);\n                connection == null ? void 0 : connection.init(api.getState());\n                return;\n              }\n              setStateFromDevtools(state[store]);\n              connection == null ? void 0 : connection.init(getTrackedConnectionState(options.name));\n            });\n          case \"JUMP_TO_STATE\":\n          case \"JUMP_TO_ACTION\":\n            return parseJsonThen(message.state, (state) => {\n              if (store === void 0) {\n                setStateFromDevtools(state);\n                return;\n              }\n              if (JSON.stringify(api.getState()) !== JSON.stringify(state[store])) {\n                setStateFromDevtools(state[store]);\n              }\n            });\n          case \"IMPORT_STATE\": {\n            const { nextLiftedState } = message.payload;\n            const lastComputedState = (_a = nextLiftedState.computedStates.slice(-1)[0]) == null ? void 0 : _a.state;\n            if (!lastComputedState)\n              return;\n            if (store === void 0) {\n              setStateFromDevtools(lastComputedState);\n            } else {\n              setStateFromDevtools(lastComputedState[store]);\n            }\n            connection == null ? void 0 : connection.send(\n              null,\n              // FIXME no-any\n              nextLiftedState\n            );\n            return;\n          }\n          case \"PAUSE_RECORDING\":\n            return isRecording = !isRecording;\n        }\n        return;\n    }\n  });\n  return initialState;\n};\nconst devtools = devtoolsImpl;\nconst parseJsonThen = (stringified, f) => {\n  let parsed;\n  try {\n    parsed = JSON.parse(stringified);\n  } catch (e) {\n    console.error(\n      \"[zustand devtools middleware] Could not parse the received json\",\n      e\n    );\n  }\n  if (parsed !== void 0)\n    f(parsed);\n};\n\nconst subscribeWithSelectorImpl = (fn) => (set, get, api) => {\n  const origSubscribe = api.subscribe;\n  api.subscribe = (selector, optListener, options) => {\n    let listener = selector;\n    if (optListener) {\n      const equalityFn = (options == null ? void 0 : options.equalityFn) || Object.is;\n      let currentSlice = selector(api.getState());\n      listener = (state) => {\n        const nextSlice = selector(state);\n        if (!equalityFn(currentSlice, nextSlice)) {\n          const previousSlice = currentSlice;\n          optListener(currentSlice = nextSlice, previousSlice);\n        }\n      };\n      if (options == null ? void 0 : options.fireImmediately) {\n        optListener(currentSlice, currentSlice);\n      }\n    }\n    return origSubscribe(listener);\n  };\n  const initialState = fn(set, get, api);\n  return initialState;\n};\nconst subscribeWithSelector = subscribeWithSelectorImpl;\n\nconst combine = (initialState, create) => (...a) => Object.assign({}, initialState, create(...a));\n\nfunction createJSONStorage(getStorage, options) {\n  let storage;\n  try {\n    storage = getStorage();\n  } catch (e) {\n    return;\n  }\n  const persistStorage = {\n    getItem: (name) => {\n      var _a;\n      const parse = (str2) => {\n        if (str2 === null) {\n          return null;\n        }\n        return JSON.parse(str2, options == null ? void 0 : options.reviver);\n      };\n      const str = (_a = storage.getItem(name)) != null ? _a : null;\n      if (str instanceof Promise) {\n        return str.then(parse);\n      }\n      return parse(str);\n    },\n    setItem: (name, newValue) => storage.setItem(\n      name,\n      JSON.stringify(newValue, options == null ? void 0 : options.replacer)\n    ),\n    removeItem: (name) => storage.removeItem(name)\n  };\n  return persistStorage;\n}\nconst toThenable = (fn) => (input) => {\n  try {\n    const result = fn(input);\n    if (result instanceof Promise) {\n      return result;\n    }\n    return {\n      then(onFulfilled) {\n        return toThenable(onFulfilled)(result);\n      },\n      catch(_onRejected) {\n        return this;\n      }\n    };\n  } catch (e) {\n    return {\n      then(_onFulfilled) {\n        return this;\n      },\n      catch(onRejected) {\n        return toThenable(onRejected)(e);\n      }\n    };\n  }\n};\nconst oldImpl = (config, baseOptions) => (set, get, api) => {\n  let options = {\n    getStorage: () => localStorage,\n    serialize: JSON.stringify,\n    deserialize: JSON.parse,\n    partialize: (state) => state,\n    version: 0,\n    merge: (persistedState, currentState) => ({\n      ...currentState,\n      ...persistedState\n    }),\n    ...baseOptions\n  };\n  let hasHydrated = false;\n  const hydrationListeners = /* @__PURE__ */ new Set();\n  const finishHydrationListeners = /* @__PURE__ */ new Set();\n  let storage;\n  try {\n    storage = options.getStorage();\n  } catch (e) {\n  }\n  if (!storage) {\n    return config(\n      (...args) => {\n        console.warn(\n          `[zustand persist middleware] Unable to update item '${options.name}', the given storage is currently unavailable.`\n        );\n        set(...args);\n      },\n      get,\n      api\n    );\n  }\n  const thenableSerialize = toThenable(options.serialize);\n  const setItem = () => {\n    const state = options.partialize({ ...get() });\n    let errorInSync;\n    const thenable = thenableSerialize({ state, version: options.version }).then(\n      (serializedValue) => storage.setItem(options.name, serializedValue)\n    ).catch((e) => {\n      errorInSync = e;\n    });\n    if (errorInSync) {\n      throw errorInSync;\n    }\n    return thenable;\n  };\n  const savedSetState = api.setState;\n  api.setState = (state, replace) => {\n    savedSetState(state, replace);\n    void setItem();\n  };\n  const configResult = config(\n    (...args) => {\n      set(...args);\n      void setItem();\n    },\n    get,\n    api\n  );\n  let stateFromStorage;\n  const hydrate = () => {\n    var _a;\n    if (!storage)\n      return;\n    hasHydrated = false;\n    hydrationListeners.forEach((cb) => cb(get()));\n    const postRehydrationCallback = ((_a = options.onRehydrateStorage) == null ? void 0 : _a.call(options, get())) || void 0;\n    return toThenable(storage.getItem.bind(storage))(options.name).then((storageValue) => {\n      if (storageValue) {\n        return options.deserialize(storageValue);\n      }\n    }).then((deserializedStorageValue) => {\n      if (deserializedStorageValue) {\n        if (typeof deserializedStorageValue.version === \"number\" && deserializedStorageValue.version !== options.version) {\n          if (options.migrate) {\n            return options.migrate(\n              deserializedStorageValue.state,\n              deserializedStorageValue.version\n            );\n          }\n          console.error(\n            `State loaded from storage couldn't be migrated since no migrate function was provided`\n          );\n        } else {\n          return deserializedStorageValue.state;\n        }\n      }\n    }).then((migratedState) => {\n      var _a2;\n      stateFromStorage = options.merge(\n        migratedState,\n        (_a2 = get()) != null ? _a2 : configResult\n      );\n      set(stateFromStorage, true);\n      return setItem();\n    }).then(() => {\n      postRehydrationCallback == null ? void 0 : postRehydrationCallback(stateFromStorage, void 0);\n      hasHydrated = true;\n      finishHydrationListeners.forEach((cb) => cb(stateFromStorage));\n    }).catch((e) => {\n      postRehydrationCallback == null ? void 0 : postRehydrationCallback(void 0, e);\n    });\n  };\n  api.persist = {\n    setOptions: (newOptions) => {\n      options = {\n        ...options,\n        ...newOptions\n      };\n      if (newOptions.getStorage) {\n        storage = newOptions.getStorage();\n      }\n    },\n    clearStorage: () => {\n      storage == null ? void 0 : storage.removeItem(options.name);\n    },\n    getOptions: () => options,\n    rehydrate: () => hydrate(),\n    hasHydrated: () => hasHydrated,\n    onHydrate: (cb) => {\n      hydrationListeners.add(cb);\n      return () => {\n        hydrationListeners.delete(cb);\n      };\n    },\n    onFinishHydration: (cb) => {\n      finishHydrationListeners.add(cb);\n      return () => {\n        finishHydrationListeners.delete(cb);\n      };\n    }\n  };\n  hydrate();\n  return stateFromStorage || configResult;\n};\nconst newImpl = (config, baseOptions) => (set, get, api) => {\n  let options = {\n    storage: createJSONStorage(() => localStorage),\n    partialize: (state) => state,\n    version: 0,\n    merge: (persistedState, currentState) => ({\n      ...currentState,\n      ...persistedState\n    }),\n    ...baseOptions\n  };\n  let hasHydrated = false;\n  const hydrationListeners = /* @__PURE__ */ new Set();\n  const finishHydrationListeners = /* @__PURE__ */ new Set();\n  let storage = options.storage;\n  if (!storage) {\n    return config(\n      (...args) => {\n        console.warn(\n          `[zustand persist middleware] Unable to update item '${options.name}', the given storage is currently unavailable.`\n        );\n        set(...args);\n      },\n      get,\n      api\n    );\n  }\n  const setItem = () => {\n    const state = options.partialize({ ...get() });\n    return storage.setItem(options.name, {\n      state,\n      version: options.version\n    });\n  };\n  const savedSetState = api.setState;\n  api.setState = (state, replace) => {\n    savedSetState(state, replace);\n    void setItem();\n  };\n  const configResult = config(\n    (...args) => {\n      set(...args);\n      void setItem();\n    },\n    get,\n    api\n  );\n  api.getInitialState = () => configResult;\n  let stateFromStorage;\n  const hydrate = () => {\n    var _a, _b;\n    if (!storage)\n      return;\n    hasHydrated = false;\n    hydrationListeners.forEach((cb) => {\n      var _a2;\n      return cb((_a2 = get()) != null ? _a2 : configResult);\n    });\n    const postRehydrationCallback = ((_b = options.onRehydrateStorage) == null ? void 0 : _b.call(options, (_a = get()) != null ? _a : configResult)) || void 0;\n    return toThenable(storage.getItem.bind(storage))(options.name).then((deserializedStorageValue) => {\n      if (deserializedStorageValue) {\n        if (typeof deserializedStorageValue.version === \"number\" && deserializedStorageValue.version !== options.version) {\n          if (options.migrate) {\n            return options.migrate(\n              deserializedStorageValue.state,\n              deserializedStorageValue.version\n            );\n          }\n          console.error(\n            `State loaded from storage couldn't be migrated since no migrate function was provided`\n          );\n        } else {\n          return deserializedStorageValue.state;\n        }\n      }\n    }).then((migratedState) => {\n      var _a2;\n      stateFromStorage = options.merge(\n        migratedState,\n        (_a2 = get()) != null ? _a2 : configResult\n      );\n      set(stateFromStorage, true);\n      return setItem();\n    }).then(() => {\n      postRehydrationCallback == null ? void 0 : postRehydrationCallback(stateFromStorage, void 0);\n      stateFromStorage = get();\n      hasHydrated = true;\n      finishHydrationListeners.forEach((cb) => cb(stateFromStorage));\n    }).catch((e) => {\n      postRehydrationCallback == null ? void 0 : postRehydrationCallback(void 0, e);\n    });\n  };\n  api.persist = {\n    setOptions: (newOptions) => {\n      options = {\n        ...options,\n        ...newOptions\n      };\n      if (newOptions.storage) {\n        storage = newOptions.storage;\n      }\n    },\n    clearStorage: () => {\n      storage == null ? void 0 : storage.removeItem(options.name);\n    },\n    getOptions: () => options,\n    rehydrate: () => hydrate(),\n    hasHydrated: () => hasHydrated,\n    onHydrate: (cb) => {\n      hydrationListeners.add(cb);\n      return () => {\n        hydrationListeners.delete(cb);\n      };\n    },\n    onFinishHydration: (cb) => {\n      finishHydrationListeners.add(cb);\n      return () => {\n        finishHydrationListeners.delete(cb);\n      };\n    }\n  };\n  if (!options.skipHydration) {\n    hydrate();\n  }\n  return stateFromStorage || configResult;\n};\nconst persistImpl = (config, baseOptions) => {\n  if (\"getStorage\" in baseOptions || \"serialize\" in baseOptions || \"deserialize\" in baseOptions) {\n    if (( false ? 0 : void 0) !== \"production\") {\n      console.warn(\n        \"[DEPRECATED] `getStorage`, `serialize` and `deserialize` options are deprecated. Use `storage` option instead.\"\n      );\n    }\n    return oldImpl(config, baseOptions);\n  }\n  return newImpl(config, baseOptions);\n};\nconst persist = persistImpl;\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy96dXN0YW5kL2VzbS9taWRkbGV3YXJlLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsOENBQThDO0FBQzlDLFVBQVUsa0RBQWtEO0FBQzVEO0FBQ0E7QUFDQSx1REFBdUQsTUFBZSxHQUFHLENBQW9CO0FBQzdGLElBQUk7QUFDSjtBQUNBO0FBQ0EsU0FBUyxNQUFlLEdBQUcsQ0FBb0I7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSx1Q0FBdUM7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQywyQ0FBMkMsdUNBQXVDLHFCQUFxQjtBQUN0SjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixNQUFNLEdBQUcsWUFBWTtBQUN0QyxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsTUFBZSxHQUFHLENBQW9CO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0ZBQW9GLGlDQUFpQyxpQkFBaUI7QUFDdEk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0Esb0JBQW9CLGtCQUFrQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0VBQW9FOztBQUVwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBaUUsYUFBYTtBQUM5RTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxVQUFVO0FBQ2pEO0FBQ0EseUNBQXlDLGlDQUFpQztBQUMxRTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBaUUsYUFBYTtBQUM5RTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsVUFBVTtBQUNqRDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxNQUFlLEdBQUcsQ0FBb0I7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUV1RiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvenVzdGFuZC9lc20vbWlkZGxld2FyZS5tanM/NmU1MiJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCByZWR1eEltcGwgPSAocmVkdWNlciwgaW5pdGlhbCkgPT4gKHNldCwgX2dldCwgYXBpKSA9PiB7XG4gIGFwaS5kaXNwYXRjaCA9IChhY3Rpb24pID0+IHtcbiAgICBzZXQoKHN0YXRlKSA9PiByZWR1Y2VyKHN0YXRlLCBhY3Rpb24pLCBmYWxzZSwgYWN0aW9uKTtcbiAgICByZXR1cm4gYWN0aW9uO1xuICB9O1xuICBhcGkuZGlzcGF0Y2hGcm9tRGV2dG9vbHMgPSB0cnVlO1xuICByZXR1cm4geyBkaXNwYXRjaDogKC4uLmEpID0+IGFwaS5kaXNwYXRjaCguLi5hKSwgLi4uaW5pdGlhbCB9O1xufTtcbmNvbnN0IHJlZHV4ID0gcmVkdXhJbXBsO1xuXG5jb25zdCB0cmFja2VkQ29ubmVjdGlvbnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuY29uc3QgZ2V0VHJhY2tlZENvbm5lY3Rpb25TdGF0ZSA9IChuYW1lKSA9PiB7XG4gIGNvbnN0IGFwaSA9IHRyYWNrZWRDb25uZWN0aW9ucy5nZXQobmFtZSk7XG4gIGlmICghYXBpKVxuICAgIHJldHVybiB7fTtcbiAgcmV0dXJuIE9iamVjdC5mcm9tRW50cmllcyhcbiAgICBPYmplY3QuZW50cmllcyhhcGkuc3RvcmVzKS5tYXAoKFtrZXksIGFwaTJdKSA9PiBba2V5LCBhcGkyLmdldFN0YXRlKCldKVxuICApO1xufTtcbmNvbnN0IGV4dHJhY3RDb25uZWN0aW9uSW5mb3JtYXRpb24gPSAoc3RvcmUsIGV4dGVuc2lvbkNvbm5lY3Rvciwgb3B0aW9ucykgPT4ge1xuICBpZiAoc3RvcmUgPT09IHZvaWQgMCkge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcInVudHJhY2tlZFwiLFxuICAgICAgY29ubmVjdGlvbjogZXh0ZW5zaW9uQ29ubmVjdG9yLmNvbm5lY3Qob3B0aW9ucylcbiAgICB9O1xuICB9XG4gIGNvbnN0IGV4aXN0aW5nQ29ubmVjdGlvbiA9IHRyYWNrZWRDb25uZWN0aW9ucy5nZXQob3B0aW9ucy5uYW1lKTtcbiAgaWYgKGV4aXN0aW5nQ29ubmVjdGlvbikge1xuICAgIHJldHVybiB7IHR5cGU6IFwidHJhY2tlZFwiLCBzdG9yZSwgLi4uZXhpc3RpbmdDb25uZWN0aW9uIH07XG4gIH1cbiAgY29uc3QgbmV3Q29ubmVjdGlvbiA9IHtcbiAgICBjb25uZWN0aW9uOiBleHRlbnNpb25Db25uZWN0b3IuY29ubmVjdChvcHRpb25zKSxcbiAgICBzdG9yZXM6IHt9XG4gIH07XG4gIHRyYWNrZWRDb25uZWN0aW9ucy5zZXQob3B0aW9ucy5uYW1lLCBuZXdDb25uZWN0aW9uKTtcbiAgcmV0dXJuIHsgdHlwZTogXCJ0cmFja2VkXCIsIHN0b3JlLCAuLi5uZXdDb25uZWN0aW9uIH07XG59O1xuY29uc3QgZGV2dG9vbHNJbXBsID0gKGZuLCBkZXZ0b29sc09wdGlvbnMgPSB7fSkgPT4gKHNldCwgZ2V0LCBhcGkpID0+IHtcbiAgY29uc3QgeyBlbmFibGVkLCBhbm9ueW1vdXNBY3Rpb25UeXBlLCBzdG9yZSwgLi4ub3B0aW9ucyB9ID0gZGV2dG9vbHNPcHRpb25zO1xuICBsZXQgZXh0ZW5zaW9uQ29ubmVjdG9yO1xuICB0cnkge1xuICAgIGV4dGVuc2lvbkNvbm5lY3RvciA9IChlbmFibGVkICE9IG51bGwgPyBlbmFibGVkIDogKGltcG9ydC5tZXRhLmVudiA/IGltcG9ydC5tZXRhLmVudi5NT0RFIDogdm9pZCAwKSAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIHdpbmRvdy5fX1JFRFVYX0RFVlRPT0xTX0VYVEVOU0lPTl9fO1xuICB9IGNhdGNoIChlKSB7XG4gIH1cbiAgaWYgKCFleHRlbnNpb25Db25uZWN0b3IpIHtcbiAgICBpZiAoKGltcG9ydC5tZXRhLmVudiA/IGltcG9ydC5tZXRhLmVudi5NT0RFIDogdm9pZCAwKSAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgZW5hYmxlZCkge1xuICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICBcIlt6dXN0YW5kIGRldnRvb2xzIG1pZGRsZXdhcmVdIFBsZWFzZSBpbnN0YWxsL2VuYWJsZSBSZWR1eCBkZXZ0b29scyBleHRlbnNpb25cIlxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIGZuKHNldCwgZ2V0LCBhcGkpO1xuICB9XG4gIGNvbnN0IHsgY29ubmVjdGlvbiwgLi4uY29ubmVjdGlvbkluZm9ybWF0aW9uIH0gPSBleHRyYWN0Q29ubmVjdGlvbkluZm9ybWF0aW9uKHN0b3JlLCBleHRlbnNpb25Db25uZWN0b3IsIG9wdGlvbnMpO1xuICBsZXQgaXNSZWNvcmRpbmcgPSB0cnVlO1xuICBhcGkuc2V0U3RhdGUgPSAoc3RhdGUsIHJlcGxhY2UsIG5hbWVPckFjdGlvbikgPT4ge1xuICAgIGNvbnN0IHIgPSBzZXQoc3RhdGUsIHJlcGxhY2UpO1xuICAgIGlmICghaXNSZWNvcmRpbmcpXG4gICAgICByZXR1cm4gcjtcbiAgICBjb25zdCBhY3Rpb24gPSBuYW1lT3JBY3Rpb24gPT09IHZvaWQgMCA/IHsgdHlwZTogYW5vbnltb3VzQWN0aW9uVHlwZSB8fCBcImFub255bW91c1wiIH0gOiB0eXBlb2YgbmFtZU9yQWN0aW9uID09PSBcInN0cmluZ1wiID8geyB0eXBlOiBuYW1lT3JBY3Rpb24gfSA6IG5hbWVPckFjdGlvbjtcbiAgICBpZiAoc3RvcmUgPT09IHZvaWQgMCkge1xuICAgICAgY29ubmVjdGlvbiA9PSBudWxsID8gdm9pZCAwIDogY29ubmVjdGlvbi5zZW5kKGFjdGlvbiwgZ2V0KCkpO1xuICAgICAgcmV0dXJuIHI7XG4gICAgfVxuICAgIGNvbm5lY3Rpb24gPT0gbnVsbCA/IHZvaWQgMCA6IGNvbm5lY3Rpb24uc2VuZChcbiAgICAgIHtcbiAgICAgICAgLi4uYWN0aW9uLFxuICAgICAgICB0eXBlOiBgJHtzdG9yZX0vJHthY3Rpb24udHlwZX1gXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICAuLi5nZXRUcmFja2VkQ29ubmVjdGlvblN0YXRlKG9wdGlvbnMubmFtZSksXG4gICAgICAgIFtzdG9yZV06IGFwaS5nZXRTdGF0ZSgpXG4gICAgICB9XG4gICAgKTtcbiAgICByZXR1cm4gcjtcbiAgfTtcbiAgY29uc3Qgc2V0U3RhdGVGcm9tRGV2dG9vbHMgPSAoLi4uYSkgPT4ge1xuICAgIGNvbnN0IG9yaWdpbmFsSXNSZWNvcmRpbmcgPSBpc1JlY29yZGluZztcbiAgICBpc1JlY29yZGluZyA9IGZhbHNlO1xuICAgIHNldCguLi5hKTtcbiAgICBpc1JlY29yZGluZyA9IG9yaWdpbmFsSXNSZWNvcmRpbmc7XG4gIH07XG4gIGNvbnN0IGluaXRpYWxTdGF0ZSA9IGZuKGFwaS5zZXRTdGF0ZSwgZ2V0LCBhcGkpO1xuICBpZiAoY29ubmVjdGlvbkluZm9ybWF0aW9uLnR5cGUgPT09IFwidW50cmFja2VkXCIpIHtcbiAgICBjb25uZWN0aW9uID09IG51bGwgPyB2b2lkIDAgOiBjb25uZWN0aW9uLmluaXQoaW5pdGlhbFN0YXRlKTtcbiAgfSBlbHNlIHtcbiAgICBjb25uZWN0aW9uSW5mb3JtYXRpb24uc3RvcmVzW2Nvbm5lY3Rpb25JbmZvcm1hdGlvbi5zdG9yZV0gPSBhcGk7XG4gICAgY29ubmVjdGlvbiA9PSBudWxsID8gdm9pZCAwIDogY29ubmVjdGlvbi5pbml0KFxuICAgICAgT2JqZWN0LmZyb21FbnRyaWVzKFxuICAgICAgICBPYmplY3QuZW50cmllcyhjb25uZWN0aW9uSW5mb3JtYXRpb24uc3RvcmVzKS5tYXAoKFtrZXksIHN0b3JlMl0pID0+IFtcbiAgICAgICAgICBrZXksXG4gICAgICAgICAga2V5ID09PSBjb25uZWN0aW9uSW5mb3JtYXRpb24uc3RvcmUgPyBpbml0aWFsU3RhdGUgOiBzdG9yZTIuZ2V0U3RhdGUoKVxuICAgICAgICBdKVxuICAgICAgKVxuICAgICk7XG4gIH1cbiAgaWYgKGFwaS5kaXNwYXRjaEZyb21EZXZ0b29scyAmJiB0eXBlb2YgYXBpLmRpc3BhdGNoID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBsZXQgZGlkV2FybkFib3V0UmVzZXJ2ZWRBY3Rpb25UeXBlID0gZmFsc2U7XG4gICAgY29uc3Qgb3JpZ2luYWxEaXNwYXRjaCA9IGFwaS5kaXNwYXRjaDtcbiAgICBhcGkuZGlzcGF0Y2ggPSAoLi4uYSkgPT4ge1xuICAgICAgaWYgKChpbXBvcnQubWV0YS5lbnYgPyBpbXBvcnQubWV0YS5lbnYuTU9ERSA6IHZvaWQgMCkgIT09IFwicHJvZHVjdGlvblwiICYmIGFbMF0udHlwZSA9PT0gXCJfX3NldFN0YXRlXCIgJiYgIWRpZFdhcm5BYm91dFJlc2VydmVkQWN0aW9uVHlwZSkge1xuICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgJ1t6dXN0YW5kIGRldnRvb2xzIG1pZGRsZXdhcmVdIFwiX19zZXRTdGF0ZVwiIGFjdGlvbiB0eXBlIGlzIHJlc2VydmVkIHRvIHNldCBzdGF0ZSBmcm9tIHRoZSBkZXZ0b29scy4gQXZvaWQgdXNpbmcgaXQuJ1xuICAgICAgICApO1xuICAgICAgICBkaWRXYXJuQWJvdXRSZXNlcnZlZEFjdGlvblR5cGUgPSB0cnVlO1xuICAgICAgfVxuICAgICAgb3JpZ2luYWxEaXNwYXRjaCguLi5hKTtcbiAgICB9O1xuICB9XG4gIGNvbm5lY3Rpb24uc3Vic2NyaWJlKChtZXNzYWdlKSA9PiB7XG4gICAgdmFyIF9hO1xuICAgIHN3aXRjaCAobWVzc2FnZS50eXBlKSB7XG4gICAgICBjYXNlIFwiQUNUSU9OXCI6XG4gICAgICAgIGlmICh0eXBlb2YgbWVzc2FnZS5wYXlsb2FkICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgIFwiW3p1c3RhbmQgZGV2dG9vbHMgbWlkZGxld2FyZV0gVW5zdXBwb3J0ZWQgYWN0aW9uIGZvcm1hdFwiXG4gICAgICAgICAgKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhcnNlSnNvblRoZW4oXG4gICAgICAgICAgbWVzc2FnZS5wYXlsb2FkLFxuICAgICAgICAgIChhY3Rpb24pID0+IHtcbiAgICAgICAgICAgIGlmIChhY3Rpb24udHlwZSA9PT0gXCJfX3NldFN0YXRlXCIpIHtcbiAgICAgICAgICAgICAgaWYgKHN0b3JlID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgICBzZXRTdGF0ZUZyb21EZXZ0b29scyhhY3Rpb24uc3RhdGUpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoT2JqZWN0LmtleXMoYWN0aW9uLnN0YXRlKS5sZW5ndGggIT09IDEpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgICAgYFxuICAgICAgICAgICAgICAgICAgICBbenVzdGFuZCBkZXZ0b29scyBtaWRkbGV3YXJlXSBVbnN1cHBvcnRlZCBfX3NldFN0YXRlIGFjdGlvbiBmb3JtYXQuIFxuICAgICAgICAgICAgICAgICAgICBXaGVuIHVzaW5nICdzdG9yZScgb3B0aW9uIGluIGRldnRvb2xzKCksIHRoZSAnc3RhdGUnIHNob3VsZCBoYXZlIG9ubHkgb25lIGtleSwgd2hpY2ggaXMgYSB2YWx1ZSBvZiAnc3RvcmUnIHRoYXQgd2FzIHBhc3NlZCBpbiBkZXZ0b29scygpLFxuICAgICAgICAgICAgICAgICAgICBhbmQgdmFsdWUgb2YgdGhpcyBvbmx5IGtleSBzaG91bGQgYmUgYSBzdGF0ZSBvYmplY3QuIEV4YW1wbGU6IHsgXCJ0eXBlXCI6IFwiX19zZXRTdGF0ZVwiLCBcInN0YXRlXCI6IHsgXCJhYmMxMjNTdG9yZVwiOiB7IFwiZm9vXCI6IFwiYmFyXCIgfSB9IH1cbiAgICAgICAgICAgICAgICAgICAgYFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY29uc3Qgc3RhdGVGcm9tRGV2dG9vbHMgPSBhY3Rpb24uc3RhdGVbc3RvcmVdO1xuICAgICAgICAgICAgICBpZiAoc3RhdGVGcm9tRGV2dG9vbHMgPT09IHZvaWQgMCB8fCBzdGF0ZUZyb21EZXZ0b29scyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoSlNPTi5zdHJpbmdpZnkoYXBpLmdldFN0YXRlKCkpICE9PSBKU09OLnN0cmluZ2lmeShzdGF0ZUZyb21EZXZ0b29scykpIHtcbiAgICAgICAgICAgICAgICBzZXRTdGF0ZUZyb21EZXZ0b29scyhzdGF0ZUZyb21EZXZ0b29scyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFhcGkuZGlzcGF0Y2hGcm9tRGV2dG9vbHMpXG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgYXBpLmRpc3BhdGNoICE9PSBcImZ1bmN0aW9uXCIpXG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGFwaS5kaXNwYXRjaChhY3Rpb24pO1xuICAgICAgICAgIH1cbiAgICAgICAgKTtcbiAgICAgIGNhc2UgXCJESVNQQVRDSFwiOlxuICAgICAgICBzd2l0Y2ggKG1lc3NhZ2UucGF5bG9hZC50eXBlKSB7XG4gICAgICAgICAgY2FzZSBcIlJFU0VUXCI6XG4gICAgICAgICAgICBzZXRTdGF0ZUZyb21EZXZ0b29scyhpbml0aWFsU3RhdGUpO1xuICAgICAgICAgICAgaWYgKHN0b3JlID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGNvbm5lY3Rpb24gPT0gbnVsbCA/IHZvaWQgMCA6IGNvbm5lY3Rpb24uaW5pdChhcGkuZ2V0U3RhdGUoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY29ubmVjdGlvbiA9PSBudWxsID8gdm9pZCAwIDogY29ubmVjdGlvbi5pbml0KGdldFRyYWNrZWRDb25uZWN0aW9uU3RhdGUob3B0aW9ucy5uYW1lKSk7XG4gICAgICAgICAgY2FzZSBcIkNPTU1JVFwiOlxuICAgICAgICAgICAgaWYgKHN0b3JlID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgY29ubmVjdGlvbiA9PSBudWxsID8gdm9pZCAwIDogY29ubmVjdGlvbi5pbml0KGFwaS5nZXRTdGF0ZSgpKTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGNvbm5lY3Rpb24gPT0gbnVsbCA/IHZvaWQgMCA6IGNvbm5lY3Rpb24uaW5pdChnZXRUcmFja2VkQ29ubmVjdGlvblN0YXRlKG9wdGlvbnMubmFtZSkpO1xuICAgICAgICAgIGNhc2UgXCJST0xMQkFDS1wiOlxuICAgICAgICAgICAgcmV0dXJuIHBhcnNlSnNvblRoZW4obWVzc2FnZS5zdGF0ZSwgKHN0YXRlKSA9PiB7XG4gICAgICAgICAgICAgIGlmIChzdG9yZSA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgICAgc2V0U3RhdGVGcm9tRGV2dG9vbHMoc3RhdGUpO1xuICAgICAgICAgICAgICAgIGNvbm5lY3Rpb24gPT0gbnVsbCA/IHZvaWQgMCA6IGNvbm5lY3Rpb24uaW5pdChhcGkuZ2V0U3RhdGUoKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHNldFN0YXRlRnJvbURldnRvb2xzKHN0YXRlW3N0b3JlXSk7XG4gICAgICAgICAgICAgIGNvbm5lY3Rpb24gPT0gbnVsbCA/IHZvaWQgMCA6IGNvbm5lY3Rpb24uaW5pdChnZXRUcmFja2VkQ29ubmVjdGlvblN0YXRlKG9wdGlvbnMubmFtZSkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgY2FzZSBcIkpVTVBfVE9fU1RBVEVcIjpcbiAgICAgICAgICBjYXNlIFwiSlVNUF9UT19BQ1RJT05cIjpcbiAgICAgICAgICAgIHJldHVybiBwYXJzZUpzb25UaGVuKG1lc3NhZ2Uuc3RhdGUsIChzdGF0ZSkgPT4ge1xuICAgICAgICAgICAgICBpZiAoc3RvcmUgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICAgIHNldFN0YXRlRnJvbURldnRvb2xzKHN0YXRlKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKEpTT04uc3RyaW5naWZ5KGFwaS5nZXRTdGF0ZSgpKSAhPT0gSlNPTi5zdHJpbmdpZnkoc3RhdGVbc3RvcmVdKSkge1xuICAgICAgICAgICAgICAgIHNldFN0YXRlRnJvbURldnRvb2xzKHN0YXRlW3N0b3JlXSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIGNhc2UgXCJJTVBPUlRfU1RBVEVcIjoge1xuICAgICAgICAgICAgY29uc3QgeyBuZXh0TGlmdGVkU3RhdGUgfSA9IG1lc3NhZ2UucGF5bG9hZDtcbiAgICAgICAgICAgIGNvbnN0IGxhc3RDb21wdXRlZFN0YXRlID0gKF9hID0gbmV4dExpZnRlZFN0YXRlLmNvbXB1dGVkU3RhdGVzLnNsaWNlKC0xKVswXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLnN0YXRlO1xuICAgICAgICAgICAgaWYgKCFsYXN0Q29tcHV0ZWRTdGF0ZSlcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgaWYgKHN0b3JlID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgc2V0U3RhdGVGcm9tRGV2dG9vbHMobGFzdENvbXB1dGVkU3RhdGUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgc2V0U3RhdGVGcm9tRGV2dG9vbHMobGFzdENvbXB1dGVkU3RhdGVbc3RvcmVdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbm5lY3Rpb24gPT0gbnVsbCA/IHZvaWQgMCA6IGNvbm5lY3Rpb24uc2VuZChcbiAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICAgLy8gRklYTUUgbm8tYW55XG4gICAgICAgICAgICAgIG5leHRMaWZ0ZWRTdGF0ZVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSBcIlBBVVNFX1JFQ09SRElOR1wiOlxuICAgICAgICAgICAgcmV0dXJuIGlzUmVjb3JkaW5nID0gIWlzUmVjb3JkaW5nO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gaW5pdGlhbFN0YXRlO1xufTtcbmNvbnN0IGRldnRvb2xzID0gZGV2dG9vbHNJbXBsO1xuY29uc3QgcGFyc2VKc29uVGhlbiA9IChzdHJpbmdpZmllZCwgZikgPT4ge1xuICBsZXQgcGFyc2VkO1xuICB0cnkge1xuICAgIHBhcnNlZCA9IEpTT04ucGFyc2Uoc3RyaW5naWZpZWQpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgY29uc29sZS5lcnJvcihcbiAgICAgIFwiW3p1c3RhbmQgZGV2dG9vbHMgbWlkZGxld2FyZV0gQ291bGQgbm90IHBhcnNlIHRoZSByZWNlaXZlZCBqc29uXCIsXG4gICAgICBlXG4gICAgKTtcbiAgfVxuICBpZiAocGFyc2VkICE9PSB2b2lkIDApXG4gICAgZihwYXJzZWQpO1xufTtcblxuY29uc3Qgc3Vic2NyaWJlV2l0aFNlbGVjdG9ySW1wbCA9IChmbikgPT4gKHNldCwgZ2V0LCBhcGkpID0+IHtcbiAgY29uc3Qgb3JpZ1N1YnNjcmliZSA9IGFwaS5zdWJzY3JpYmU7XG4gIGFwaS5zdWJzY3JpYmUgPSAoc2VsZWN0b3IsIG9wdExpc3RlbmVyLCBvcHRpb25zKSA9PiB7XG4gICAgbGV0IGxpc3RlbmVyID0gc2VsZWN0b3I7XG4gICAgaWYgKG9wdExpc3RlbmVyKSB7XG4gICAgICBjb25zdCBlcXVhbGl0eUZuID0gKG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMuZXF1YWxpdHlGbikgfHwgT2JqZWN0LmlzO1xuICAgICAgbGV0IGN1cnJlbnRTbGljZSA9IHNlbGVjdG9yKGFwaS5nZXRTdGF0ZSgpKTtcbiAgICAgIGxpc3RlbmVyID0gKHN0YXRlKSA9PiB7XG4gICAgICAgIGNvbnN0IG5leHRTbGljZSA9IHNlbGVjdG9yKHN0YXRlKTtcbiAgICAgICAgaWYgKCFlcXVhbGl0eUZuKGN1cnJlbnRTbGljZSwgbmV4dFNsaWNlKSkge1xuICAgICAgICAgIGNvbnN0IHByZXZpb3VzU2xpY2UgPSBjdXJyZW50U2xpY2U7XG4gICAgICAgICAgb3B0TGlzdGVuZXIoY3VycmVudFNsaWNlID0gbmV4dFNsaWNlLCBwcmV2aW91c1NsaWNlKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGlmIChvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLmZpcmVJbW1lZGlhdGVseSkge1xuICAgICAgICBvcHRMaXN0ZW5lcihjdXJyZW50U2xpY2UsIGN1cnJlbnRTbGljZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvcmlnU3Vic2NyaWJlKGxpc3RlbmVyKTtcbiAgfTtcbiAgY29uc3QgaW5pdGlhbFN0YXRlID0gZm4oc2V0LCBnZXQsIGFwaSk7XG4gIHJldHVybiBpbml0aWFsU3RhdGU7XG59O1xuY29uc3Qgc3Vic2NyaWJlV2l0aFNlbGVjdG9yID0gc3Vic2NyaWJlV2l0aFNlbGVjdG9ySW1wbDtcblxuY29uc3QgY29tYmluZSA9IChpbml0aWFsU3RhdGUsIGNyZWF0ZSkgPT4gKC4uLmEpID0+IE9iamVjdC5hc3NpZ24oe30sIGluaXRpYWxTdGF0ZSwgY3JlYXRlKC4uLmEpKTtcblxuZnVuY3Rpb24gY3JlYXRlSlNPTlN0b3JhZ2UoZ2V0U3RvcmFnZSwgb3B0aW9ucykge1xuICBsZXQgc3RvcmFnZTtcbiAgdHJ5IHtcbiAgICBzdG9yYWdlID0gZ2V0U3RvcmFnZSgpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IHBlcnNpc3RTdG9yYWdlID0ge1xuICAgIGdldEl0ZW06IChuYW1lKSA9PiB7XG4gICAgICB2YXIgX2E7XG4gICAgICBjb25zdCBwYXJzZSA9IChzdHIyKSA9PiB7XG4gICAgICAgIGlmIChzdHIyID09PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEpTT04ucGFyc2Uoc3RyMiwgb3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy5yZXZpdmVyKTtcbiAgICAgIH07XG4gICAgICBjb25zdCBzdHIgPSAoX2EgPSBzdG9yYWdlLmdldEl0ZW0obmFtZSkpICE9IG51bGwgPyBfYSA6IG51bGw7XG4gICAgICBpZiAoc3RyIGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICByZXR1cm4gc3RyLnRoZW4ocGFyc2UpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHBhcnNlKHN0cik7XG4gICAgfSxcbiAgICBzZXRJdGVtOiAobmFtZSwgbmV3VmFsdWUpID0+IHN0b3JhZ2Uuc2V0SXRlbShcbiAgICAgIG5hbWUsXG4gICAgICBKU09OLnN0cmluZ2lmeShuZXdWYWx1ZSwgb3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy5yZXBsYWNlcilcbiAgICApLFxuICAgIHJlbW92ZUl0ZW06IChuYW1lKSA9PiBzdG9yYWdlLnJlbW92ZUl0ZW0obmFtZSlcbiAgfTtcbiAgcmV0dXJuIHBlcnNpc3RTdG9yYWdlO1xufVxuY29uc3QgdG9UaGVuYWJsZSA9IChmbikgPT4gKGlucHV0KSA9PiB7XG4gIHRyeSB7XG4gICAgY29uc3QgcmVzdWx0ID0gZm4oaW5wdXQpO1xuICAgIGlmIChyZXN1bHQgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgdGhlbihvbkZ1bGZpbGxlZCkge1xuICAgICAgICByZXR1cm4gdG9UaGVuYWJsZShvbkZ1bGZpbGxlZCkocmVzdWx0KTtcbiAgICAgIH0sXG4gICAgICBjYXRjaChfb25SZWplY3RlZCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICB9O1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRoZW4oX29uRnVsZmlsbGVkKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSxcbiAgICAgIGNhdGNoKG9uUmVqZWN0ZWQpIHtcbiAgICAgICAgcmV0dXJuIHRvVGhlbmFibGUob25SZWplY3RlZCkoZSk7XG4gICAgICB9XG4gICAgfTtcbiAgfVxufTtcbmNvbnN0IG9sZEltcGwgPSAoY29uZmlnLCBiYXNlT3B0aW9ucykgPT4gKHNldCwgZ2V0LCBhcGkpID0+IHtcbiAgbGV0IG9wdGlvbnMgPSB7XG4gICAgZ2V0U3RvcmFnZTogKCkgPT4gbG9jYWxTdG9yYWdlLFxuICAgIHNlcmlhbGl6ZTogSlNPTi5zdHJpbmdpZnksXG4gICAgZGVzZXJpYWxpemU6IEpTT04ucGFyc2UsXG4gICAgcGFydGlhbGl6ZTogKHN0YXRlKSA9PiBzdGF0ZSxcbiAgICB2ZXJzaW9uOiAwLFxuICAgIG1lcmdlOiAocGVyc2lzdGVkU3RhdGUsIGN1cnJlbnRTdGF0ZSkgPT4gKHtcbiAgICAgIC4uLmN1cnJlbnRTdGF0ZSxcbiAgICAgIC4uLnBlcnNpc3RlZFN0YXRlXG4gICAgfSksXG4gICAgLi4uYmFzZU9wdGlvbnNcbiAgfTtcbiAgbGV0IGhhc0h5ZHJhdGVkID0gZmFsc2U7XG4gIGNvbnN0IGh5ZHJhdGlvbkxpc3RlbmVycyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gIGNvbnN0IGZpbmlzaEh5ZHJhdGlvbkxpc3RlbmVycyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gIGxldCBzdG9yYWdlO1xuICB0cnkge1xuICAgIHN0b3JhZ2UgPSBvcHRpb25zLmdldFN0b3JhZ2UoKTtcbiAgfSBjYXRjaCAoZSkge1xuICB9XG4gIGlmICghc3RvcmFnZSkge1xuICAgIHJldHVybiBjb25maWcoXG4gICAgICAoLi4uYXJncykgPT4ge1xuICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgYFt6dXN0YW5kIHBlcnNpc3QgbWlkZGxld2FyZV0gVW5hYmxlIHRvIHVwZGF0ZSBpdGVtICcke29wdGlvbnMubmFtZX0nLCB0aGUgZ2l2ZW4gc3RvcmFnZSBpcyBjdXJyZW50bHkgdW5hdmFpbGFibGUuYFxuICAgICAgICApO1xuICAgICAgICBzZXQoLi4uYXJncyk7XG4gICAgICB9LFxuICAgICAgZ2V0LFxuICAgICAgYXBpXG4gICAgKTtcbiAgfVxuICBjb25zdCB0aGVuYWJsZVNlcmlhbGl6ZSA9IHRvVGhlbmFibGUob3B0aW9ucy5zZXJpYWxpemUpO1xuICBjb25zdCBzZXRJdGVtID0gKCkgPT4ge1xuICAgIGNvbnN0IHN0YXRlID0gb3B0aW9ucy5wYXJ0aWFsaXplKHsgLi4uZ2V0KCkgfSk7XG4gICAgbGV0IGVycm9ySW5TeW5jO1xuICAgIGNvbnN0IHRoZW5hYmxlID0gdGhlbmFibGVTZXJpYWxpemUoeyBzdGF0ZSwgdmVyc2lvbjogb3B0aW9ucy52ZXJzaW9uIH0pLnRoZW4oXG4gICAgICAoc2VyaWFsaXplZFZhbHVlKSA9PiBzdG9yYWdlLnNldEl0ZW0ob3B0aW9ucy5uYW1lLCBzZXJpYWxpemVkVmFsdWUpXG4gICAgKS5jYXRjaCgoZSkgPT4ge1xuICAgICAgZXJyb3JJblN5bmMgPSBlO1xuICAgIH0pO1xuICAgIGlmIChlcnJvckluU3luYykge1xuICAgICAgdGhyb3cgZXJyb3JJblN5bmM7XG4gICAgfVxuICAgIHJldHVybiB0aGVuYWJsZTtcbiAgfTtcbiAgY29uc3Qgc2F2ZWRTZXRTdGF0ZSA9IGFwaS5zZXRTdGF0ZTtcbiAgYXBpLnNldFN0YXRlID0gKHN0YXRlLCByZXBsYWNlKSA9PiB7XG4gICAgc2F2ZWRTZXRTdGF0ZShzdGF0ZSwgcmVwbGFjZSk7XG4gICAgdm9pZCBzZXRJdGVtKCk7XG4gIH07XG4gIGNvbnN0IGNvbmZpZ1Jlc3VsdCA9IGNvbmZpZyhcbiAgICAoLi4uYXJncykgPT4ge1xuICAgICAgc2V0KC4uLmFyZ3MpO1xuICAgICAgdm9pZCBzZXRJdGVtKCk7XG4gICAgfSxcbiAgICBnZXQsXG4gICAgYXBpXG4gICk7XG4gIGxldCBzdGF0ZUZyb21TdG9yYWdlO1xuICBjb25zdCBoeWRyYXRlID0gKCkgPT4ge1xuICAgIHZhciBfYTtcbiAgICBpZiAoIXN0b3JhZ2UpXG4gICAgICByZXR1cm47XG4gICAgaGFzSHlkcmF0ZWQgPSBmYWxzZTtcbiAgICBoeWRyYXRpb25MaXN0ZW5lcnMuZm9yRWFjaCgoY2IpID0+IGNiKGdldCgpKSk7XG4gICAgY29uc3QgcG9zdFJlaHlkcmF0aW9uQ2FsbGJhY2sgPSAoKF9hID0gb3B0aW9ucy5vblJlaHlkcmF0ZVN0b3JhZ2UpID09IG51bGwgPyB2b2lkIDAgOiBfYS5jYWxsKG9wdGlvbnMsIGdldCgpKSkgfHwgdm9pZCAwO1xuICAgIHJldHVybiB0b1RoZW5hYmxlKHN0b3JhZ2UuZ2V0SXRlbS5iaW5kKHN0b3JhZ2UpKShvcHRpb25zLm5hbWUpLnRoZW4oKHN0b3JhZ2VWYWx1ZSkgPT4ge1xuICAgICAgaWYgKHN0b3JhZ2VWYWx1ZSkge1xuICAgICAgICByZXR1cm4gb3B0aW9ucy5kZXNlcmlhbGl6ZShzdG9yYWdlVmFsdWUpO1xuICAgICAgfVxuICAgIH0pLnRoZW4oKGRlc2VyaWFsaXplZFN0b3JhZ2VWYWx1ZSkgPT4ge1xuICAgICAgaWYgKGRlc2VyaWFsaXplZFN0b3JhZ2VWYWx1ZSkge1xuICAgICAgICBpZiAodHlwZW9mIGRlc2VyaWFsaXplZFN0b3JhZ2VWYWx1ZS52ZXJzaW9uID09PSBcIm51bWJlclwiICYmIGRlc2VyaWFsaXplZFN0b3JhZ2VWYWx1ZS52ZXJzaW9uICE9PSBvcHRpb25zLnZlcnNpb24pIHtcbiAgICAgICAgICBpZiAob3B0aW9ucy5taWdyYXRlKSB7XG4gICAgICAgICAgICByZXR1cm4gb3B0aW9ucy5taWdyYXRlKFxuICAgICAgICAgICAgICBkZXNlcmlhbGl6ZWRTdG9yYWdlVmFsdWUuc3RhdGUsXG4gICAgICAgICAgICAgIGRlc2VyaWFsaXplZFN0b3JhZ2VWYWx1ZS52ZXJzaW9uXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgYFN0YXRlIGxvYWRlZCBmcm9tIHN0b3JhZ2UgY291bGRuJ3QgYmUgbWlncmF0ZWQgc2luY2Ugbm8gbWlncmF0ZSBmdW5jdGlvbiB3YXMgcHJvdmlkZWRgXG4gICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gZGVzZXJpYWxpemVkU3RvcmFnZVZhbHVlLnN0YXRlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSkudGhlbigobWlncmF0ZWRTdGF0ZSkgPT4ge1xuICAgICAgdmFyIF9hMjtcbiAgICAgIHN0YXRlRnJvbVN0b3JhZ2UgPSBvcHRpb25zLm1lcmdlKFxuICAgICAgICBtaWdyYXRlZFN0YXRlLFxuICAgICAgICAoX2EyID0gZ2V0KCkpICE9IG51bGwgPyBfYTIgOiBjb25maWdSZXN1bHRcbiAgICAgICk7XG4gICAgICBzZXQoc3RhdGVGcm9tU3RvcmFnZSwgdHJ1ZSk7XG4gICAgICByZXR1cm4gc2V0SXRlbSgpO1xuICAgIH0pLnRoZW4oKCkgPT4ge1xuICAgICAgcG9zdFJlaHlkcmF0aW9uQ2FsbGJhY2sgPT0gbnVsbCA/IHZvaWQgMCA6IHBvc3RSZWh5ZHJhdGlvbkNhbGxiYWNrKHN0YXRlRnJvbVN0b3JhZ2UsIHZvaWQgMCk7XG4gICAgICBoYXNIeWRyYXRlZCA9IHRydWU7XG4gICAgICBmaW5pc2hIeWRyYXRpb25MaXN0ZW5lcnMuZm9yRWFjaCgoY2IpID0+IGNiKHN0YXRlRnJvbVN0b3JhZ2UpKTtcbiAgICB9KS5jYXRjaCgoZSkgPT4ge1xuICAgICAgcG9zdFJlaHlkcmF0aW9uQ2FsbGJhY2sgPT0gbnVsbCA/IHZvaWQgMCA6IHBvc3RSZWh5ZHJhdGlvbkNhbGxiYWNrKHZvaWQgMCwgZSk7XG4gICAgfSk7XG4gIH07XG4gIGFwaS5wZXJzaXN0ID0ge1xuICAgIHNldE9wdGlvbnM6IChuZXdPcHRpb25zKSA9PiB7XG4gICAgICBvcHRpb25zID0ge1xuICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICAuLi5uZXdPcHRpb25zXG4gICAgICB9O1xuICAgICAgaWYgKG5ld09wdGlvbnMuZ2V0U3RvcmFnZSkge1xuICAgICAgICBzdG9yYWdlID0gbmV3T3B0aW9ucy5nZXRTdG9yYWdlKCk7XG4gICAgICB9XG4gICAgfSxcbiAgICBjbGVhclN0b3JhZ2U6ICgpID0+IHtcbiAgICAgIHN0b3JhZ2UgPT0gbnVsbCA/IHZvaWQgMCA6IHN0b3JhZ2UucmVtb3ZlSXRlbShvcHRpb25zLm5hbWUpO1xuICAgIH0sXG4gICAgZ2V0T3B0aW9uczogKCkgPT4gb3B0aW9ucyxcbiAgICByZWh5ZHJhdGU6ICgpID0+IGh5ZHJhdGUoKSxcbiAgICBoYXNIeWRyYXRlZDogKCkgPT4gaGFzSHlkcmF0ZWQsXG4gICAgb25IeWRyYXRlOiAoY2IpID0+IHtcbiAgICAgIGh5ZHJhdGlvbkxpc3RlbmVycy5hZGQoY2IpO1xuICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgaHlkcmF0aW9uTGlzdGVuZXJzLmRlbGV0ZShjYik7XG4gICAgICB9O1xuICAgIH0sXG4gICAgb25GaW5pc2hIeWRyYXRpb246IChjYikgPT4ge1xuICAgICAgZmluaXNoSHlkcmF0aW9uTGlzdGVuZXJzLmFkZChjYik7XG4gICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICBmaW5pc2hIeWRyYXRpb25MaXN0ZW5lcnMuZGVsZXRlKGNiKTtcbiAgICAgIH07XG4gICAgfVxuICB9O1xuICBoeWRyYXRlKCk7XG4gIHJldHVybiBzdGF0ZUZyb21TdG9yYWdlIHx8IGNvbmZpZ1Jlc3VsdDtcbn07XG5jb25zdCBuZXdJbXBsID0gKGNvbmZpZywgYmFzZU9wdGlvbnMpID0+IChzZXQsIGdldCwgYXBpKSA9PiB7XG4gIGxldCBvcHRpb25zID0ge1xuICAgIHN0b3JhZ2U6IGNyZWF0ZUpTT05TdG9yYWdlKCgpID0+IGxvY2FsU3RvcmFnZSksXG4gICAgcGFydGlhbGl6ZTogKHN0YXRlKSA9PiBzdGF0ZSxcbiAgICB2ZXJzaW9uOiAwLFxuICAgIG1lcmdlOiAocGVyc2lzdGVkU3RhdGUsIGN1cnJlbnRTdGF0ZSkgPT4gKHtcbiAgICAgIC4uLmN1cnJlbnRTdGF0ZSxcbiAgICAgIC4uLnBlcnNpc3RlZFN0YXRlXG4gICAgfSksXG4gICAgLi4uYmFzZU9wdGlvbnNcbiAgfTtcbiAgbGV0IGhhc0h5ZHJhdGVkID0gZmFsc2U7XG4gIGNvbnN0IGh5ZHJhdGlvbkxpc3RlbmVycyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gIGNvbnN0IGZpbmlzaEh5ZHJhdGlvbkxpc3RlbmVycyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gIGxldCBzdG9yYWdlID0gb3B0aW9ucy5zdG9yYWdlO1xuICBpZiAoIXN0b3JhZ2UpIHtcbiAgICByZXR1cm4gY29uZmlnKFxuICAgICAgKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgIGBbenVzdGFuZCBwZXJzaXN0IG1pZGRsZXdhcmVdIFVuYWJsZSB0byB1cGRhdGUgaXRlbSAnJHtvcHRpb25zLm5hbWV9JywgdGhlIGdpdmVuIHN0b3JhZ2UgaXMgY3VycmVudGx5IHVuYXZhaWxhYmxlLmBcbiAgICAgICAgKTtcbiAgICAgICAgc2V0KC4uLmFyZ3MpO1xuICAgICAgfSxcbiAgICAgIGdldCxcbiAgICAgIGFwaVxuICAgICk7XG4gIH1cbiAgY29uc3Qgc2V0SXRlbSA9ICgpID0+IHtcbiAgICBjb25zdCBzdGF0ZSA9IG9wdGlvbnMucGFydGlhbGl6ZSh7IC4uLmdldCgpIH0pO1xuICAgIHJldHVybiBzdG9yYWdlLnNldEl0ZW0ob3B0aW9ucy5uYW1lLCB7XG4gICAgICBzdGF0ZSxcbiAgICAgIHZlcnNpb246IG9wdGlvbnMudmVyc2lvblxuICAgIH0pO1xuICB9O1xuICBjb25zdCBzYXZlZFNldFN0YXRlID0gYXBpLnNldFN0YXRlO1xuICBhcGkuc2V0U3RhdGUgPSAoc3RhdGUsIHJlcGxhY2UpID0+IHtcbiAgICBzYXZlZFNldFN0YXRlKHN0YXRlLCByZXBsYWNlKTtcbiAgICB2b2lkIHNldEl0ZW0oKTtcbiAgfTtcbiAgY29uc3QgY29uZmlnUmVzdWx0ID0gY29uZmlnKFxuICAgICguLi5hcmdzKSA9PiB7XG4gICAgICBzZXQoLi4uYXJncyk7XG4gICAgICB2b2lkIHNldEl0ZW0oKTtcbiAgICB9LFxuICAgIGdldCxcbiAgICBhcGlcbiAgKTtcbiAgYXBpLmdldEluaXRpYWxTdGF0ZSA9ICgpID0+IGNvbmZpZ1Jlc3VsdDtcbiAgbGV0IHN0YXRlRnJvbVN0b3JhZ2U7XG4gIGNvbnN0IGh5ZHJhdGUgPSAoKSA9PiB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICBpZiAoIXN0b3JhZ2UpXG4gICAgICByZXR1cm47XG4gICAgaGFzSHlkcmF0ZWQgPSBmYWxzZTtcbiAgICBoeWRyYXRpb25MaXN0ZW5lcnMuZm9yRWFjaCgoY2IpID0+IHtcbiAgICAgIHZhciBfYTI7XG4gICAgICByZXR1cm4gY2IoKF9hMiA9IGdldCgpKSAhPSBudWxsID8gX2EyIDogY29uZmlnUmVzdWx0KTtcbiAgICB9KTtcbiAgICBjb25zdCBwb3N0UmVoeWRyYXRpb25DYWxsYmFjayA9ICgoX2IgPSBvcHRpb25zLm9uUmVoeWRyYXRlU3RvcmFnZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLmNhbGwob3B0aW9ucywgKF9hID0gZ2V0KCkpICE9IG51bGwgPyBfYSA6IGNvbmZpZ1Jlc3VsdCkpIHx8IHZvaWQgMDtcbiAgICByZXR1cm4gdG9UaGVuYWJsZShzdG9yYWdlLmdldEl0ZW0uYmluZChzdG9yYWdlKSkob3B0aW9ucy5uYW1lKS50aGVuKChkZXNlcmlhbGl6ZWRTdG9yYWdlVmFsdWUpID0+IHtcbiAgICAgIGlmIChkZXNlcmlhbGl6ZWRTdG9yYWdlVmFsdWUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBkZXNlcmlhbGl6ZWRTdG9yYWdlVmFsdWUudmVyc2lvbiA9PT0gXCJudW1iZXJcIiAmJiBkZXNlcmlhbGl6ZWRTdG9yYWdlVmFsdWUudmVyc2lvbiAhPT0gb3B0aW9ucy52ZXJzaW9uKSB7XG4gICAgICAgICAgaWYgKG9wdGlvbnMubWlncmF0ZSkge1xuICAgICAgICAgICAgcmV0dXJuIG9wdGlvbnMubWlncmF0ZShcbiAgICAgICAgICAgICAgZGVzZXJpYWxpemVkU3RvcmFnZVZhbHVlLnN0YXRlLFxuICAgICAgICAgICAgICBkZXNlcmlhbGl6ZWRTdG9yYWdlVmFsdWUudmVyc2lvblxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgIGBTdGF0ZSBsb2FkZWQgZnJvbSBzdG9yYWdlIGNvdWxkbid0IGJlIG1pZ3JhdGVkIHNpbmNlIG5vIG1pZ3JhdGUgZnVuY3Rpb24gd2FzIHByb3ZpZGVkYFxuICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGRlc2VyaWFsaXplZFN0b3JhZ2VWYWx1ZS5zdGF0ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pLnRoZW4oKG1pZ3JhdGVkU3RhdGUpID0+IHtcbiAgICAgIHZhciBfYTI7XG4gICAgICBzdGF0ZUZyb21TdG9yYWdlID0gb3B0aW9ucy5tZXJnZShcbiAgICAgICAgbWlncmF0ZWRTdGF0ZSxcbiAgICAgICAgKF9hMiA9IGdldCgpKSAhPSBudWxsID8gX2EyIDogY29uZmlnUmVzdWx0XG4gICAgICApO1xuICAgICAgc2V0KHN0YXRlRnJvbVN0b3JhZ2UsIHRydWUpO1xuICAgICAgcmV0dXJuIHNldEl0ZW0oKTtcbiAgICB9KS50aGVuKCgpID0+IHtcbiAgICAgIHBvc3RSZWh5ZHJhdGlvbkNhbGxiYWNrID09IG51bGwgPyB2b2lkIDAgOiBwb3N0UmVoeWRyYXRpb25DYWxsYmFjayhzdGF0ZUZyb21TdG9yYWdlLCB2b2lkIDApO1xuICAgICAgc3RhdGVGcm9tU3RvcmFnZSA9IGdldCgpO1xuICAgICAgaGFzSHlkcmF0ZWQgPSB0cnVlO1xuICAgICAgZmluaXNoSHlkcmF0aW9uTGlzdGVuZXJzLmZvckVhY2goKGNiKSA9PiBjYihzdGF0ZUZyb21TdG9yYWdlKSk7XG4gICAgfSkuY2F0Y2goKGUpID0+IHtcbiAgICAgIHBvc3RSZWh5ZHJhdGlvbkNhbGxiYWNrID09IG51bGwgPyB2b2lkIDAgOiBwb3N0UmVoeWRyYXRpb25DYWxsYmFjayh2b2lkIDAsIGUpO1xuICAgIH0pO1xuICB9O1xuICBhcGkucGVyc2lzdCA9IHtcbiAgICBzZXRPcHRpb25zOiAobmV3T3B0aW9ucykgPT4ge1xuICAgICAgb3B0aW9ucyA9IHtcbiAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgLi4ubmV3T3B0aW9uc1xuICAgICAgfTtcbiAgICAgIGlmIChuZXdPcHRpb25zLnN0b3JhZ2UpIHtcbiAgICAgICAgc3RvcmFnZSA9IG5ld09wdGlvbnMuc3RvcmFnZTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGNsZWFyU3RvcmFnZTogKCkgPT4ge1xuICAgICAgc3RvcmFnZSA9PSBudWxsID8gdm9pZCAwIDogc3RvcmFnZS5yZW1vdmVJdGVtKG9wdGlvbnMubmFtZSk7XG4gICAgfSxcbiAgICBnZXRPcHRpb25zOiAoKSA9PiBvcHRpb25zLFxuICAgIHJlaHlkcmF0ZTogKCkgPT4gaHlkcmF0ZSgpLFxuICAgIGhhc0h5ZHJhdGVkOiAoKSA9PiBoYXNIeWRyYXRlZCxcbiAgICBvbkh5ZHJhdGU6IChjYikgPT4ge1xuICAgICAgaHlkcmF0aW9uTGlzdGVuZXJzLmFkZChjYik7XG4gICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICBoeWRyYXRpb25MaXN0ZW5lcnMuZGVsZXRlKGNiKTtcbiAgICAgIH07XG4gICAgfSxcbiAgICBvbkZpbmlzaEh5ZHJhdGlvbjogKGNiKSA9PiB7XG4gICAgICBmaW5pc2hIeWRyYXRpb25MaXN0ZW5lcnMuYWRkKGNiKTtcbiAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIGZpbmlzaEh5ZHJhdGlvbkxpc3RlbmVycy5kZWxldGUoY2IpO1xuICAgICAgfTtcbiAgICB9XG4gIH07XG4gIGlmICghb3B0aW9ucy5za2lwSHlkcmF0aW9uKSB7XG4gICAgaHlkcmF0ZSgpO1xuICB9XG4gIHJldHVybiBzdGF0ZUZyb21TdG9yYWdlIHx8IGNvbmZpZ1Jlc3VsdDtcbn07XG5jb25zdCBwZXJzaXN0SW1wbCA9IChjb25maWcsIGJhc2VPcHRpb25zKSA9PiB7XG4gIGlmIChcImdldFN0b3JhZ2VcIiBpbiBiYXNlT3B0aW9ucyB8fCBcInNlcmlhbGl6ZVwiIGluIGJhc2VPcHRpb25zIHx8IFwiZGVzZXJpYWxpemVcIiBpbiBiYXNlT3B0aW9ucykge1xuICAgIGlmICgoaW1wb3J0Lm1ldGEuZW52ID8gaW1wb3J0Lm1ldGEuZW52Lk1PREUgOiB2b2lkIDApICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICBcIltERVBSRUNBVEVEXSBgZ2V0U3RvcmFnZWAsIGBzZXJpYWxpemVgIGFuZCBgZGVzZXJpYWxpemVgIG9wdGlvbnMgYXJlIGRlcHJlY2F0ZWQuIFVzZSBgc3RvcmFnZWAgb3B0aW9uIGluc3RlYWQuXCJcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiBvbGRJbXBsKGNvbmZpZywgYmFzZU9wdGlvbnMpO1xuICB9XG4gIHJldHVybiBuZXdJbXBsKGNvbmZpZywgYmFzZU9wdGlvbnMpO1xufTtcbmNvbnN0IHBlcnNpc3QgPSBwZXJzaXN0SW1wbDtcblxuZXhwb3J0IHsgY29tYmluZSwgY3JlYXRlSlNPTlN0b3JhZ2UsIGRldnRvb2xzLCBwZXJzaXN0LCByZWR1eCwgc3Vic2NyaWJlV2l0aFNlbGVjdG9yIH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/zustand/esm/middleware.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/zustand/esm/traditional.mjs":
/*!**************************************************!*\
  !*** ./node_modules/zustand/esm/traditional.mjs ***!
  \**************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createWithEqualityFn: function() { return /* binding */ createWithEqualityFn; },\n/* harmony export */   useStoreWithEqualityFn: function() { return /* binding */ useStoreWithEqualityFn; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var use_sync_external_store_shim_with_selector_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! use-sync-external-store/shim/with-selector.js */ \"(app-pages-browser)/./node_modules/use-sync-external-store/shim/with-selector.js\");\n/* harmony import */ var zustand_vanilla__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! zustand/vanilla */ \"(app-pages-browser)/./node_modules/zustand/esm/vanilla.mjs\");\n\n\n\n\nconst { useDebugValue } = react__WEBPACK_IMPORTED_MODULE_0__;\nconst { useSyncExternalStoreWithSelector } = use_sync_external_store_shim_with_selector_js__WEBPACK_IMPORTED_MODULE_1__;\nconst identity = (arg) => arg;\nfunction useStoreWithEqualityFn(api, selector = identity, equalityFn) {\n  const slice = useSyncExternalStoreWithSelector(\n    api.subscribe,\n    api.getState,\n    api.getServerState || api.getInitialState,\n    selector,\n    equalityFn\n  );\n  useDebugValue(slice);\n  return slice;\n}\nconst createWithEqualityFnImpl = (createState, defaultEqualityFn) => {\n  const api = (0,zustand_vanilla__WEBPACK_IMPORTED_MODULE_2__.createStore)(createState);\n  const useBoundStoreWithEqualityFn = (selector, equalityFn = defaultEqualityFn) => useStoreWithEqualityFn(api, selector, equalityFn);\n  Object.assign(useBoundStoreWithEqualityFn, api);\n  return useBoundStoreWithEqualityFn;\n};\nconst createWithEqualityFn = (createState, defaultEqualityFn) => createState ? createWithEqualityFnImpl(createState, defaultEqualityFn) : createWithEqualityFnImpl;\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy96dXN0YW5kL2VzbS90cmFkaXRpb25hbC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBaUM7QUFDdUQ7QUFDMUM7O0FBRTlDLFFBQVEsZ0JBQWdCLEVBQUUsa0NBQVk7QUFDdEMsUUFBUSxtQ0FBbUMsRUFBRSwwRUFBMkI7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLDREQUFXO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRXdEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy96dXN0YW5kL2VzbS90cmFkaXRpb25hbC5tanM/ZGRhMiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUmVhY3RFeHBvcnRzIGZyb20gJ3JlYWN0JztcbmltcG9ydCB1c2VTeW5jRXh0ZXJuYWxTdG9yZUV4cG9ydHMgZnJvbSAndXNlLXN5bmMtZXh0ZXJuYWwtc3RvcmUvc2hpbS93aXRoLXNlbGVjdG9yLmpzJztcbmltcG9ydCB7IGNyZWF0ZVN0b3JlIH0gZnJvbSAnenVzdGFuZC92YW5pbGxhJztcblxuY29uc3QgeyB1c2VEZWJ1Z1ZhbHVlIH0gPSBSZWFjdEV4cG9ydHM7XG5jb25zdCB7IHVzZVN5bmNFeHRlcm5hbFN0b3JlV2l0aFNlbGVjdG9yIH0gPSB1c2VTeW5jRXh0ZXJuYWxTdG9yZUV4cG9ydHM7XG5jb25zdCBpZGVudGl0eSA9IChhcmcpID0+IGFyZztcbmZ1bmN0aW9uIHVzZVN0b3JlV2l0aEVxdWFsaXR5Rm4oYXBpLCBzZWxlY3RvciA9IGlkZW50aXR5LCBlcXVhbGl0eUZuKSB7XG4gIGNvbnN0IHNsaWNlID0gdXNlU3luY0V4dGVybmFsU3RvcmVXaXRoU2VsZWN0b3IoXG4gICAgYXBpLnN1YnNjcmliZSxcbiAgICBhcGkuZ2V0U3RhdGUsXG4gICAgYXBpLmdldFNlcnZlclN0YXRlIHx8IGFwaS5nZXRJbml0aWFsU3RhdGUsXG4gICAgc2VsZWN0b3IsXG4gICAgZXF1YWxpdHlGblxuICApO1xuICB1c2VEZWJ1Z1ZhbHVlKHNsaWNlKTtcbiAgcmV0dXJuIHNsaWNlO1xufVxuY29uc3QgY3JlYXRlV2l0aEVxdWFsaXR5Rm5JbXBsID0gKGNyZWF0ZVN0YXRlLCBkZWZhdWx0RXF1YWxpdHlGbikgPT4ge1xuICBjb25zdCBhcGkgPSBjcmVhdGVTdG9yZShjcmVhdGVTdGF0ZSk7XG4gIGNvbnN0IHVzZUJvdW5kU3RvcmVXaXRoRXF1YWxpdHlGbiA9IChzZWxlY3RvciwgZXF1YWxpdHlGbiA9IGRlZmF1bHRFcXVhbGl0eUZuKSA9PiB1c2VTdG9yZVdpdGhFcXVhbGl0eUZuKGFwaSwgc2VsZWN0b3IsIGVxdWFsaXR5Rm4pO1xuICBPYmplY3QuYXNzaWduKHVzZUJvdW5kU3RvcmVXaXRoRXF1YWxpdHlGbiwgYXBpKTtcbiAgcmV0dXJuIHVzZUJvdW5kU3RvcmVXaXRoRXF1YWxpdHlGbjtcbn07XG5jb25zdCBjcmVhdGVXaXRoRXF1YWxpdHlGbiA9IChjcmVhdGVTdGF0ZSwgZGVmYXVsdEVxdWFsaXR5Rm4pID0+IGNyZWF0ZVN0YXRlID8gY3JlYXRlV2l0aEVxdWFsaXR5Rm5JbXBsKGNyZWF0ZVN0YXRlLCBkZWZhdWx0RXF1YWxpdHlGbikgOiBjcmVhdGVXaXRoRXF1YWxpdHlGbkltcGw7XG5cbmV4cG9ydCB7IGNyZWF0ZVdpdGhFcXVhbGl0eUZuLCB1c2VTdG9yZVdpdGhFcXVhbGl0eUZuIH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/zustand/esm/traditional.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/zustand/esm/vanilla.mjs":
/*!**********************************************!*\
  !*** ./node_modules/zustand/esm/vanilla.mjs ***!
  \**********************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createStore: function() { return /* binding */ createStore; },\n/* harmony export */   \"default\": function() { return /* binding */ vanilla; }\n/* harmony export */ });\nconst createStoreImpl = (createState) => {\n  let state;\n  const listeners = /* @__PURE__ */ new Set();\n  const setState = (partial, replace) => {\n    const nextState = typeof partial === \"function\" ? partial(state) : partial;\n    if (!Object.is(nextState, state)) {\n      const previousState = state;\n      state = (replace != null ? replace : typeof nextState !== \"object\" || nextState === null) ? nextState : Object.assign({}, state, nextState);\n      listeners.forEach((listener) => listener(state, previousState));\n    }\n  };\n  const getState = () => state;\n  const getInitialState = () => initialState;\n  const subscribe = (listener) => {\n    listeners.add(listener);\n    return () => listeners.delete(listener);\n  };\n  const destroy = () => {\n    if (( false ? 0 : void 0) !== \"production\") {\n      console.warn(\n        \"[DEPRECATED] The `destroy` method will be unsupported in a future version. Instead use unsubscribe function returned by subscribe. Everything will be garbage-collected if store is garbage-collected.\"\n      );\n    }\n    listeners.clear();\n  };\n  const api = { setState, getState, getInitialState, subscribe, destroy };\n  const initialState = state = createState(setState, getState, api);\n  return api;\n};\nconst createStore = (createState) => createState ? createStoreImpl(createState) : createStoreImpl;\nvar vanilla = (createState) => {\n  if (( false ? 0 : void 0) !== \"production\") {\n    console.warn(\n      \"[DEPRECATED] Default export is deprecated. Instead use import { createStore } from 'zustand/vanilla'.\"\n    );\n  }\n  return createStore(createState);\n};\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy96dXN0YW5kL2VzbS92YW5pbGxhLm1qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEhBQThIO0FBQzlIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxNQUFlLEdBQUcsQ0FBb0I7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPLE1BQWUsR0FBRyxDQUFvQjtBQUM3QztBQUNBLHVFQUF1RSxjQUFjO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBOztBQUUyQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvenVzdGFuZC9lc20vdmFuaWxsYS5tanM/ZjFiMSJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBjcmVhdGVTdG9yZUltcGwgPSAoY3JlYXRlU3RhdGUpID0+IHtcbiAgbGV0IHN0YXRlO1xuICBjb25zdCBsaXN0ZW5lcnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICBjb25zdCBzZXRTdGF0ZSA9IChwYXJ0aWFsLCByZXBsYWNlKSA9PiB7XG4gICAgY29uc3QgbmV4dFN0YXRlID0gdHlwZW9mIHBhcnRpYWwgPT09IFwiZnVuY3Rpb25cIiA/IHBhcnRpYWwoc3RhdGUpIDogcGFydGlhbDtcbiAgICBpZiAoIU9iamVjdC5pcyhuZXh0U3RhdGUsIHN0YXRlKSkge1xuICAgICAgY29uc3QgcHJldmlvdXNTdGF0ZSA9IHN0YXRlO1xuICAgICAgc3RhdGUgPSAocmVwbGFjZSAhPSBudWxsID8gcmVwbGFjZSA6IHR5cGVvZiBuZXh0U3RhdGUgIT09IFwib2JqZWN0XCIgfHwgbmV4dFN0YXRlID09PSBudWxsKSA/IG5leHRTdGF0ZSA6IE9iamVjdC5hc3NpZ24oe30sIHN0YXRlLCBuZXh0U3RhdGUpO1xuICAgICAgbGlzdGVuZXJzLmZvckVhY2goKGxpc3RlbmVyKSA9PiBsaXN0ZW5lcihzdGF0ZSwgcHJldmlvdXNTdGF0ZSkpO1xuICAgIH1cbiAgfTtcbiAgY29uc3QgZ2V0U3RhdGUgPSAoKSA9PiBzdGF0ZTtcbiAgY29uc3QgZ2V0SW5pdGlhbFN0YXRlID0gKCkgPT4gaW5pdGlhbFN0YXRlO1xuICBjb25zdCBzdWJzY3JpYmUgPSAobGlzdGVuZXIpID0+IHtcbiAgICBsaXN0ZW5lcnMuYWRkKGxpc3RlbmVyKTtcbiAgICByZXR1cm4gKCkgPT4gbGlzdGVuZXJzLmRlbGV0ZShsaXN0ZW5lcik7XG4gIH07XG4gIGNvbnN0IGRlc3Ryb3kgPSAoKSA9PiB7XG4gICAgaWYgKChpbXBvcnQubWV0YS5lbnYgPyBpbXBvcnQubWV0YS5lbnYuTU9ERSA6IHZvaWQgMCkgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgIFwiW0RFUFJFQ0FURURdIFRoZSBgZGVzdHJveWAgbWV0aG9kIHdpbGwgYmUgdW5zdXBwb3J0ZWQgaW4gYSBmdXR1cmUgdmVyc2lvbi4gSW5zdGVhZCB1c2UgdW5zdWJzY3JpYmUgZnVuY3Rpb24gcmV0dXJuZWQgYnkgc3Vic2NyaWJlLiBFdmVyeXRoaW5nIHdpbGwgYmUgZ2FyYmFnZS1jb2xsZWN0ZWQgaWYgc3RvcmUgaXMgZ2FyYmFnZS1jb2xsZWN0ZWQuXCJcbiAgICAgICk7XG4gICAgfVxuICAgIGxpc3RlbmVycy5jbGVhcigpO1xuICB9O1xuICBjb25zdCBhcGkgPSB7IHNldFN0YXRlLCBnZXRTdGF0ZSwgZ2V0SW5pdGlhbFN0YXRlLCBzdWJzY3JpYmUsIGRlc3Ryb3kgfTtcbiAgY29uc3QgaW5pdGlhbFN0YXRlID0gc3RhdGUgPSBjcmVhdGVTdGF0ZShzZXRTdGF0ZSwgZ2V0U3RhdGUsIGFwaSk7XG4gIHJldHVybiBhcGk7XG59O1xuY29uc3QgY3JlYXRlU3RvcmUgPSAoY3JlYXRlU3RhdGUpID0+IGNyZWF0ZVN0YXRlID8gY3JlYXRlU3RvcmVJbXBsKGNyZWF0ZVN0YXRlKSA6IGNyZWF0ZVN0b3JlSW1wbDtcbnZhciB2YW5pbGxhID0gKGNyZWF0ZVN0YXRlKSA9PiB7XG4gIGlmICgoaW1wb3J0Lm1ldGEuZW52ID8gaW1wb3J0Lm1ldGEuZW52Lk1PREUgOiB2b2lkIDApICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgIGNvbnNvbGUud2FybihcbiAgICAgIFwiW0RFUFJFQ0FURURdIERlZmF1bHQgZXhwb3J0IGlzIGRlcHJlY2F0ZWQuIEluc3RlYWQgdXNlIGltcG9ydCB7IGNyZWF0ZVN0b3JlIH0gZnJvbSAnenVzdGFuZC92YW5pbGxhJy5cIlxuICAgICk7XG4gIH1cbiAgcmV0dXJuIGNyZWF0ZVN0b3JlKGNyZWF0ZVN0YXRlKTtcbn07XG5cbmV4cG9ydCB7IGNyZWF0ZVN0b3JlLCB2YW5pbGxhIGFzIGRlZmF1bHQgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/zustand/esm/vanilla.mjs\n"));

/***/ })

},
/******/ function(__webpack_require__) { // webpackRuntimeModules
/******/ var __webpack_exec__ = function(moduleId) { return __webpack_require__(__webpack_require__.s = moduleId); }
/******/ __webpack_require__.O(0, ["main-app"], function() { return __webpack_exec__("(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22C%3A%5C%5CUsers%5C%5CUSUARIO%5C%5CDesktop%5C%5Ctransactions-app-manager%5C%5Csrc%5C%5Capp%5C%5Cdashboard%5C%5Cpage.tsx%22%2C%22ids%22%3A%5B%5D%7D&server=false!"); });
/******/ var __webpack_exports__ = __webpack_require__.O();
/******/ _N_E = __webpack_exports__;
/******/ }
]);